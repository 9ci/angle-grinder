(function(factory) {
    "use strict";
    if (typeof define === "function" && define.amd) {
        define([ "jquery", "./jqdnr", "./jqmodal" ], factory);
    } else if (typeof exports === "object") {
        factory(require("jquery"));
    } else {
        factory(jQuery);
    }
})(function($) {
    $.widget("ui.multiselect", {
        "options": {
            "sortable": true,
            "searchable": true,
            "doubleClickable": true,
            "animated": "fast",
            "show": "slideDown",
            "hide": "slideUp",
            "dividerLocation": .6,
            "availableFirst": false,
            "nodeComparator": function(node1, node2) {
                var text1 = node1.text(), text2 = node2.text();
                return text1 == text2 ? 0 : text1 < text2 ? -1 : 1;
            }
        },
        "_create": function() {
            this.element.hide();
            this.id = this.element.attr("id");
            this.container = $('<div class="ui-multiselect ui-helper-clearfix ui-widget"></div>').insertAfter(this.element);
            this.count = 0;
            this.selectedContainer = $('<div class="selected"></div>').appendTo(this.container);
            this.availableContainer = $('<div class="available"></div>')[this.options.availableFirst ? "prependTo" : "appendTo"](this.container);
            this.selectedActions = $('<div class="actions ui-widget-header ui-helper-clearfix"><span class="count">0 ' + $.ui.multiselect.locale.itemsCount + '</span><a href="#" class="remove-all">' + $.ui.multiselect.locale.removeAll + "</a></div>").appendTo(this.selectedContainer);
            this.availableActions = $('<div class="actions ui-widget-header ui-helper-clearfix"><input type="text" class="search empty ui-widget-content ui-corner-all"/><a href="#" class="add-all">' + $.ui.multiselect.locale.addAll + "</a></div>").appendTo(this.availableContainer);
            this.selectedList = $('<ul class="selected connected-list"><li class="ui-helper-hidden-accessible"></li></ul>').bind("selectstart", function() {
                return false;
            }).appendTo(this.selectedContainer);
            this.availableList = $('<ul class="available connected-list"><li class="ui-helper-hidden-accessible"></li></ul>').bind("selectstart", function() {
                return false;
            }).appendTo(this.availableContainer);
            var that = this;
            this.container.width(this.element.width() + 1);
            this.selectedContainer.width(Math.floor(this.element.width() * this.options.dividerLocation));
            this.availableContainer.width(Math.floor(this.element.width() * (1 - this.options.dividerLocation)));
            this.selectedList.height(Math.max(this.element.height() - this.selectedActions.height(), 1));
            this.availableList.height(Math.max(this.element.height() - this.availableActions.height(), 1));
            if (!this.options.animated) {
                this.options.show = "show";
                this.options.hide = "hide";
            }
            this._populateLists(this.element.find("option"));
            if (this.options.sortable) {
                this.selectedList.sortable({
                    "placeholder": "ui-state-highlight",
                    "axis": "y",
                    "update": function(event, ui) {
                        that.selectedList.find("li").each(function() {
                            if ($(this).data("optionLink")) $(this).data("optionLink").remove().appendTo(that.element);
                        });
                    },
                    "receive": function(event, ui) {
                        ui.item.data("optionLink").attr("selected", true);
                        that.count += 1;
                        that._updateCount();
                        that.selectedList.children(".ui-draggable").each(function() {
                            $(this).removeClass("ui-draggable");
                            $(this).data("optionLink", ui.item.data("optionLink"));
                            $(this).data("idx", ui.item.data("idx"));
                            that._applyItemState($(this), true);
                        });
                        setTimeout(function() {
                            ui.item.remove();
                        }, 1);
                    }
                });
            }
            if (this.options.searchable) {
                this._registerSearchEvents(this.availableContainer.find("input.search"));
            } else {
                $(".search").hide();
            }
            this.container.find(".remove-all").click(function() {
                that._populateLists(that.element.find("option").removeAttr("selected"));
                return false;
            });
            this.container.find(".add-all").click(function() {
                var options = that.element.find("option").not("[selected]");
                if (that.availableList.children("li:hidden").length > 1) {
                    that.availableList.children("li").each(function(i) {
                        if ($(this).is(":visible")) $(options[i - 1]).attr("selected", "selected");
                    });
                } else {
                    options.attr("selected", "selected");
                }
                that._populateLists(that.element.find("option"));
                return false;
            });
        },
        "destroy": function() {
            this.element.show();
            this.container.remove();
            $.Widget.prototype.destroy.apply(this, arguments);
        },
        "_populateLists": function(options) {
            this.selectedList.children(".ui-element").remove();
            this.availableList.children(".ui-element").remove();
            this.count = 0;
            var that = this;
            var items = $(options.map(function(i) {
                var isSelected = $(this).is("[selected]"), item = that._getOptionNode(this).appendTo(isSelected ? that.selectedList : that.availableList).show();
                if (isSelected) that.count += 1;
                that._applyItemState(item, isSelected);
                item.data("idx", i);
                return item[0];
            }));
            this._updateCount();
            that._filter.apply(this.availableContainer.find("input.search"), [ that.availableList ]);
        },
        "_updateCount": function() {
            this.element.trigger("change");
            this.selectedContainer.find("span.count").text(this.count + " " + $.ui.multiselect.locale.itemsCount);
        },
        "_getOptionNode": function(option) {
            option = $(option);
            var node = $('<li class="ui-state-default ui-element" title="' + (option.attr("title") || option.text()) + '"><span class="ui-icon"/>' + option.text() + '<a href="#" class="action"><span class="ui-corner-all ui-icon"/></a></li>').hide();
            node.data("optionLink", option);
            return node;
        },
        "_cloneWithData": function(clonee) {
            var clone = clonee.clone(false, false);
            clone.data("optionLink", clonee.data("optionLink"));
            clone.data("idx", clonee.data("idx"));
            return clone;
        },
        "_setSelected": function(item, selected) {
            item.data("optionLink").attr("selected", selected);
            if (selected) {
                var selectedItem = this._cloneWithData(item);
                item[this.options.hide](this.options.animated, function() {
                    $(this).remove();
                });
                selectedItem.appendTo(this.selectedList).hide()[this.options.show](this.options.animated);
                this._applyItemState(selectedItem, true);
                return selectedItem;
            } else {
                var items = this.availableList.find("li"), comparator = this.options.nodeComparator;
                var succ = null, i = item.data("idx"), direction = comparator(item, $(items[i]));
                if (direction) {
                    while (i >= 0 && i < items.length) {
                        direction > 0 ? i++ : i--;
                        if (direction != comparator(item, $(items[i]))) {
                            succ = items[direction > 0 ? i : i + 1];
                            break;
                        }
                    }
                } else {
                    succ = items[i];
                }
                var availableItem = this._cloneWithData(item);
                succ ? availableItem.insertBefore($(succ)) : availableItem.appendTo(this.availableList);
                item[this.options.hide](this.options.animated, function() {
                    $(this).remove();
                });
                availableItem.hide()[this.options.show](this.options.animated);
                this._applyItemState(availableItem, false);
                return availableItem;
            }
        },
        "_applyItemState": function(item, selected) {
            if (selected) {
                if (this.options.sortable) item.children("span").addClass("ui-icon-arrowthick-2-n-s").removeClass("ui-helper-hidden").addClass("ui-icon"); else item.children("span").removeClass("ui-icon-arrowthick-2-n-s").addClass("ui-helper-hidden").removeClass("ui-icon");
                item.find("a.action span").addClass("ui-icon-minus").removeClass("ui-icon-plus");
                this._registerRemoveEvents(item.find("a.action"));
            } else {
                item.children("span").removeClass("ui-icon-arrowthick-2-n-s").addClass("ui-helper-hidden").removeClass("ui-icon");
                item.find("a.action span").addClass("ui-icon-plus").removeClass("ui-icon-minus");
                this._registerAddEvents(item.find("a.action"));
            }
            this._registerDoubleClickEvents(item);
            this._registerHoverEvents(item);
        },
        "_filter": function(list) {
            var input = $(this);
            var rows = list.children("li"), cache = rows.map(function() {
                return $(this).text().toLowerCase();
            });
            var term = $.trim(input.val().toLowerCase()), scores = [];
            if (!term) {
                rows.show();
            } else {
                rows.hide();
                cache.each(function(i) {
                    if (this.indexOf(term) > -1) {
                        scores.push(i);
                    }
                });
                $.each(scores, function() {
                    $(rows[this]).show();
                });
            }
        },
        "_registerDoubleClickEvents": function(elements) {
            if (!this.options.doubleClickable) return;
            elements.dblclick(function(ev) {
                if ($(ev.target).closest(".action").length === 0) {
                    elements.find("a.action").click();
                }
            });
        },
        "_registerHoverEvents": function(elements) {
            elements.removeClass("ui-state-hover");
            elements.mouseover(function() {
                $(this).addClass("ui-state-hover");
            });
            elements.mouseout(function() {
                $(this).removeClass("ui-state-hover");
            });
        },
        "_registerAddEvents": function(elements) {
            var that = this;
            elements.click(function() {
                var item = that._setSelected($(this).parent(), true);
                that.count += 1;
                that._updateCount();
                return false;
            });
            if (this.options.sortable) {
                elements.each(function() {
                    $(this).parent().draggable({
                        "connectToSortable": that.selectedList,
                        "helper": function() {
                            var selectedItem = that._cloneWithData($(this)).width($(this).width() - 50);
                            selectedItem.width($(this).width());
                            return selectedItem;
                        },
                        "appendTo": that.container,
                        "containment": that.container,
                        "revert": "invalid"
                    });
                });
            }
        },
        "_registerRemoveEvents": function(elements) {
            var that = this;
            elements.click(function() {
                that._setSelected($(this).parent(), false);
                that.count -= 1;
                that._updateCount();
                return false;
            });
        },
        "_registerSearchEvents": function(input) {
            var that = this;
            input.focus(function() {
                $(this).addClass("ui-state-active");
            }).blur(function() {
                $(this).removeClass("ui-state-active");
            }).keypress(function(e) {
                if (e.keyCode == 13) return false;
            }).keyup(function() {
                that._filter.apply(this, [ that.availableList ]);
            });
        }
    });
    $.extend($.ui.multiselect, {
        "locale": {
            "addAll": "Add all",
            "removeAll": "Remove all",
            "itemsCount": "items selected"
        }
    });
});

(function(factory) {
    "use strict";
    if (typeof define === "function" && define.amd) {
        define([ "jquery" ], factory);
    } else if (typeof exports === "object") {
        factory(require("jquery"));
    } else {
        factory(jQuery);
    }
})(function($) {
    "use strict";
    var locInfo = {
        "name": "English (United States)",
        "nameEnglish": "English (United States)",
        "isRTL": false,
        "defaults": {
            "recordtext": "View {0} - {1} of {2}",
            "emptyrecords": "No records to view",
            "loadtext": "Loading...",
            "pgtext": "Page {0} of {1}",
            "pgfirst": "First Page",
            "pglast": "Last Page",
            "pgnext": "Next Page",
            "pgprev": "Previous Page",
            "pgrecs": "Records per Page",
            "showhide": "Toggle Expand Collapse Grid",
            "savetext": "Saving..."
        },
        "search": {
            "caption": "Search...",
            "Find": "Find",
            "Reset": "Reset",
            "odata": [ {
                "oper": "eq",
                "text": "equal"
            }, {
                "oper": "ne",
                "text": "not equal"
            }, {
                "oper": "lt",
                "text": "less"
            }, {
                "oper": "le",
                "text": "less or equal"
            }, {
                "oper": "gt",
                "text": "greater"
            }, {
                "oper": "ge",
                "text": "greater or equal"
            }, {
                "oper": "bw",
                "text": "begins with"
            }, {
                "oper": "bn",
                "text": "does not begin with"
            }, {
                "oper": "in",
                "text": "is in"
            }, {
                "oper": "ni",
                "text": "is not in"
            }, {
                "oper": "ew",
                "text": "ends with"
            }, {
                "oper": "en",
                "text": "does not end with"
            }, {
                "oper": "cn",
                "text": "contains"
            }, {
                "oper": "nc",
                "text": "does not contain"
            }, {
                "oper": "nu",
                "text": "is null"
            }, {
                "oper": "nn",
                "text": "is not null"
            } ],
            "groupOps": [ {
                "op": "AND",
                "text": "all"
            }, {
                "op": "OR",
                "text": "any"
            } ],
            "addGroupTitle": "Add subgroup",
            "deleteGroupTitle": "Delete group",
            "addRuleTitle": "Add rule",
            "deleteRuleTitle": "Delete rule",
            "operandTitle": "Click to select search operation.",
            "resetTitle": "Reset Search Value"
        },
        "edit": {
            "addCaption": "Add Record",
            "editCaption": "Edit Record",
            "bSubmit": "Submit",
            "bCancel": "Cancel",
            "bClose": "Close",
            "saveData": "Data has been changed! Save changes?",
            "bYes": "Yes",
            "bNo": "No",
            "bExit": "Cancel",
            "msg": {
                "required": "Field is required",
                "number": "Please, enter valid number",
                "minValue": "value must be greater than or equal to ",
                "maxValue": "value must be less than or equal to",
                "email": "is not a valid e-mail",
                "integer": "Please, enter valid integer value",
                "date": "Please, enter valid date value",
                "url": "is not a valid URL. Prefix required ('http://' or 'https://')",
                "nodefined": " is not defined!",
                "novalue": " return value is required!",
                "customarray": "Custom function should return array!",
                "customfcheck": "Custom function should be present in case of custom checking!"
            }
        },
        "view": {
            "caption": "View Record",
            "bClose": "Close"
        },
        "del": {
            "caption": "Delete",
            "msg": "Delete selected record(s)?",
            "bSubmit": "Delete",
            "bCancel": "Cancel"
        },
        "nav": {
            "edittext": "",
            "edittitle": "Edit selected row",
            "addtext": "",
            "addtitle": "Add new row",
            "deltext": "",
            "deltitle": "Delete selected row",
            "searchtext": "",
            "searchtitle": "Find records",
            "refreshtext": "",
            "refreshtitle": "Reload Grid",
            "alertcap": "Warning",
            "alerttext": "Please, select row",
            "viewtext": "",
            "viewtitle": "View selected row",
            "savetext": "",
            "savetitle": "Save row",
            "canceltext": "",
            "canceltitle": "Cancel row editing"
        },
        "col": {
            "caption": "Select columns",
            "bSubmit": "Ok",
            "bCancel": "Cancel"
        },
        "errors": {
            "errcap": "Error",
            "nourl": "No url is set",
            "norecords": "No records to process",
            "model": "Length of colNames <> colModel!"
        },
        "formatter": {
            "integer": {
                "thousandsSeparator": ",",
                "defaultValue": "0"
            },
            "number": {
                "decimalSeparator": ".",
                "thousandsSeparator": ",",
                "decimalPlaces": 2,
                "defaultValue": "0.00"
            },
            "currency": {
                "decimalSeparator": ".",
                "thousandsSeparator": ",",
                "decimalPlaces": 2,
                "prefix": "",
                "suffix": "",
                "defaultValue": "0.00"
            },
            "date": {
                "dayNames": [ "Sun", "Mon", "Tue", "Wed", "Thr", "Fri", "Sat", "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ],
                "monthNames": [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec", "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ],
                "AmPm": [ "am", "pm", "AM", "PM" ],
                "S": function(j) {
                    var ending = [ "st", "nd", "rd", "th" ];
                    return j < 11 || j > 13 ? ending[Math.min((j - 1) % 10, 3)] : "th";
                },
                "srcformat": "Y-m-d",
                "newformat": "n/j/Y",
                "masks": {
                    "ShortDate": "n/j/Y",
                    "LongDate": "l, F d, Y",
                    "FullDateTime": "l, F d, Y g:i:s A",
                    "MonthDay": "F d",
                    "ShortTime": "g:i A",
                    "LongTime": "g:i:s A",
                    "YearMonth": "F, Y"
                }
            }
        }
    };
    $.jgrid = $.jgrid || {};
    $.extend(true, $.jgrid, {
        "defaults": {
            "locale": "en-US"
        },
        "locales": {
            "en-US": locInfo
        }
    });
});

(function(factory) {
    "use strict";
    if (typeof define === "function" && define.amd) {
        define([ "jquery" ], factory);
    } else if (typeof exports === "object") {
        factory(require("jquery"));
    } else {
        factory(jQuery);
    }
})(function($) {
    "use strict";
    var englishLanguageDefaults = {
        "name": "English (United States)",
        "nameEnglish": "English (United States)",
        "isRTL": false,
        "defaults": {
            "recordtext": "View {0} - {1} of {2}",
            "emptyrecords": "No records to view",
            "loadtext": "Loading...",
            "pgtext": "Page {0} of {1}",
            "pgfirst": "First Page",
            "pglast": "Last Page",
            "pgnext": "Next Page",
            "pgprev": "Previous Page",
            "pgrecs": "Records per Page",
            "showhide": "Toggle Expand Collapse Grid",
            "savetext": "Saving..."
        },
        "search": {
            "caption": "Search...",
            "Find": "Find",
            "Reset": "Reset",
            "odata": [ {
                "oper": "eq",
                "text": "equal"
            }, {
                "oper": "ne",
                "text": "not equal"
            }, {
                "oper": "lt",
                "text": "less"
            }, {
                "oper": "le",
                "text": "less or equal"
            }, {
                "oper": "gt",
                "text": "greater"
            }, {
                "oper": "ge",
                "text": "greater or equal"
            }, {
                "oper": "bw",
                "text": "begins with"
            }, {
                "oper": "bn",
                "text": "does not begin with"
            }, {
                "oper": "in",
                "text": "is in"
            }, {
                "oper": "ni",
                "text": "is not in"
            }, {
                "oper": "ew",
                "text": "ends with"
            }, {
                "oper": "en",
                "text": "does not end with"
            }, {
                "oper": "cn",
                "text": "contains"
            }, {
                "oper": "nc",
                "text": "does not contain"
            }, {
                "oper": "nu",
                "text": "is null"
            }, {
                "oper": "nn",
                "text": "is not null"
            } ],
            "groupOps": [ {
                "op": "AND",
                "text": "all"
            }, {
                "op": "OR",
                "text": "any"
            } ],
            "addGroupTitle": "Add subgroup",
            "deleteGroupTitle": "Delete group",
            "addRuleTitle": "Add rule",
            "deleteRuleTitle": "Delete rule",
            "operandTitle": "Click to select search operation.",
            "resetTitle": "Reset Search Value"
        },
        "edit": {
            "addCaption": "Add Record",
            "editCaption": "Edit Record",
            "bSubmit": "Submit",
            "bCancel": "Cancel",
            "bClose": "Close",
            "saveData": "Data has been changed! Save changes?",
            "bYes": "Yes",
            "bNo": "No",
            "bExit": "Cancel",
            "msg": {
                "required": "Field is required",
                "number": "Please, enter valid number",
                "minValue": "value must be greater than or equal to ",
                "maxValue": "value must be less than or equal to",
                "email": "is not a valid e-mail",
                "integer": "Please, enter valid integer value",
                "date": "Please, enter valid date value",
                "url": "is not a valid URL. Prefix required ('http://' or 'https://')",
                "nodefined": " is not defined!",
                "novalue": " return value is required!",
                "customarray": "Custom function should return array!",
                "customfcheck": "Custom function should be present in case of custom checking!"
            }
        },
        "view": {
            "caption": "View Record",
            "bClose": "Close"
        },
        "del": {
            "caption": "Delete",
            "msg": "Delete selected record(s)?",
            "bSubmit": "Delete",
            "bCancel": "Cancel"
        },
        "nav": {
            "edittext": "",
            "edittitle": "Edit selected row",
            "addtext": "",
            "addtitle": "Add new row",
            "deltext": "",
            "deltitle": "Delete selected row",
            "searchtext": "",
            "searchtitle": "Find records",
            "refreshtext": "",
            "refreshtitle": "Reload Grid",
            "alertcap": "Warning",
            "alerttext": "Please, select row",
            "viewtext": "",
            "viewtitle": "View selected row",
            "savetext": "",
            "savetitle": "Save row",
            "canceltext": "",
            "canceltitle": "Cancel row editing"
        },
        "col": {
            "caption": "Select columns",
            "bSubmit": "Ok",
            "bCancel": "Cancel"
        },
        "errors": {
            "errcap": "Error",
            "nourl": "No url is set",
            "norecords": "No records to process",
            "model": "Length of colNames <> colModel!"
        },
        "formatter": {
            "integer": {
                "thousandsSeparator": ",",
                "defaultValue": "0"
            },
            "number": {
                "decimalSeparator": ".",
                "thousandsSeparator": ",",
                "decimalPlaces": 2,
                "defaultValue": "0.00"
            },
            "currency": {
                "decimalSeparator": ".",
                "thousandsSeparator": ",",
                "decimalPlaces": 2,
                "prefix": "",
                "suffix": "",
                "defaultValue": "0.00"
            },
            "date": {
                "dayNames": [ "Sun", "Mon", "Tue", "Wed", "Thr", "Fri", "Sat", "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ],
                "monthNames": [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec", "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ],
                "AmPm": [ "am", "pm", "AM", "PM" ],
                "S": function(j) {
                    var ending = [ "st", "nd", "rd", "th" ];
                    return j < 11 || j > 13 ? ending[Math.min((j - 1) % 10, 3)] : "th";
                },
                "srcformat": "Y-m-d",
                "newformat": "n/j/Y",
                "masks": {
                    "ShortDate": "n/j/Y",
                    "LongDate": "l, F d, Y",
                    "FullDateTime": "l, F d, Y g:i:s A",
                    "MonthDay": "F d",
                    "ShortTime": "g:i A",
                    "LongTime": "g:i:s A",
                    "YearMonth": "F, Y"
                }
            }
        }
    };
    $.jgrid = $.jgrid || {};
    var jgrid = $.jgrid;
    jgrid.locales = jgrid.locales || {};
    var locales = jgrid.locales;
    var COMPONENT_NAMES = {
        "GRID_BOX_DIV": 0,
        "GRID_OVERLAY_DIV": 1,
        "LOADING_DIV": 2,
        "DIALOG_ALERT_DIV": 3,
        "DIALOG_SEARCH_DIV": 4,
        "DIALOG_VIEW_DIV": 5,
        "DIALOG_EDIT_DIV": 6,
        "DIALOG_DELETE_DIV": 7,
        "GRID_VIEW_DIV": 8,
        "TITLE_BAR_DIV": 9,
        "UPPER_TOOLBAR_DIV": 10,
        "TOP_PAGER_DIV": 11,
        "HEADER_DIV": 12,
        "HEADER_BOX_DIV": 13,
        "HEADER_TABLE": 14,
        "HEADER_COLS_ROW": 15,
        "HEADER_COLS": 16,
        "HEADER_ROWS": 47,
        "HEADER_TH": 48,
        "HEADER_SORTABLE_DIV": 49,
        "HEADER_RESIZABLE_SPAN": 50,
        "HEADER_SELECT_ALL_ROWS_CHECKBOX": 45,
        "SEARCH_TOOLBAR": 17,
        "BODY_DIV": 18,
        "BODY_SCROLL_FULL_DIV": 19,
        "BODY_SCROLL_TOP_DIV": 20,
        "BODY_TABLE": 21,
        "GRID": 21,
        "BODY_COLS_ROW": 22,
        "BODY_COLS": 23,
        "BODY_DATA_ROWS": 24,
        "FOOTER_DIV": 25,
        "FOOTER_BOX_DIV": 26,
        "FOOTER_TABLE": 27,
        "FOOTER_DATA_ROWS": 28,
        "BOTTOM_TOOLBAR_DIV": 29,
        "FROZEN_HEADER_DIV": 30,
        "FROZEN_HEADER_TABLE": 31,
        "FROZEN_HEADER_COLS_ROW": 32,
        "FROZEN_HEADER_COLS": 33,
        "FROZEN_SEARCH_TOOLBAR": 34,
        "FROZEN_FOOTER_DIV": 35,
        "FROZEN_FOOTER_TABLE": 36,
        "FROZEN_FOOTER_DATA_ROWS": 37,
        "FROZEN_BODY_DIV": 38,
        "FROZEN_BODY_TABLE": 39,
        "FROZEN_BODY_COLS_ROW": 40,
        "FROZEN_BODY_COLS": 41,
        "FROZEN_BODY_DATA_ROWS": 42,
        "COLUMN_RESIZER_DIV": 43,
        "BOTTOM_PAGER_DIV": 44,
        "SEARCH_OPERATION_MENU_UL": 46
    };
    if (jgrid.defaults == null || $.isEmptyObject(locales) || locales["en-US"] === undefined) {
        if (locales["en-US"] === undefined) {
            $.extend(true, jgrid, {
                "locales": {
                    "en-US": englishLanguageDefaults
                }
            });
        }
        jgrid.defaults = jgrid.defaults || {};
        if (jgrid.defaults.locale === undefined) {
            jgrid.defaults.locale = "en-US";
        }
    }
    jgrid.defaults = jgrid.defaults || {};
    var defaults = jgrid.defaults;
    $.extend(true, jgrid, {
        "version": "4.13.3",
        "productName": "free jqGrid",
        "defaults": {},
        "search": {},
        "edit": {},
        "view": {},
        "del": {},
        "nav": {},
        "col": {},
        "errors": {},
        "formatter": {
            "unused": ""
        },
        "icons": {
            "jQueryUI": {
                "common": "ui-icon",
                "pager": {
                    "first": "ui-icon-seek-first",
                    "prev": "ui-icon-seek-prev",
                    "next": "ui-icon-seek-next",
                    "last": "ui-icon-seek-end"
                },
                "sort": {
                    "asc": "ui-icon-triangle-1-n",
                    "desc": "ui-icon-triangle-1-s"
                },
                "gridMinimize": {
                    "visible": "ui-icon-circle-triangle-n",
                    "hidden": "ui-icon-circle-triangle-s"
                },
                "nav": {
                    "edit": "ui-icon-pencil",
                    "add": "ui-icon-plus",
                    "del": "ui-icon-trash",
                    "search": "ui-icon-search",
                    "refresh": "ui-icon-refresh",
                    "view": "ui-icon-document",
                    "save": "ui-icon-disk",
                    "cancel": "ui-icon-cancel",
                    "newbutton": "ui-icon-newwin"
                },
                "actions": {
                    "edit": "ui-icon-pencil",
                    "del": "ui-icon-trash",
                    "save": "ui-icon-disk",
                    "cancel": "ui-icon-cancel"
                },
                "form": {
                    "close": "ui-icon-closethick",
                    "prev": "ui-icon-triangle-1-w",
                    "next": "ui-icon-triangle-1-e",
                    "save": "ui-icon-disk",
                    "undo": "ui-icon-close",
                    "del": "ui-icon-scissors",
                    "cancel": "ui-icon-cancel",
                    "resizableLtr": "ui-resizable-se ui-icon ui-icon-gripsmall-diagonal-se"
                },
                "search": {
                    "search": "ui-icon-search",
                    "reset": "ui-icon-arrowreturnthick-1-w",
                    "query": "ui-icon-comment"
                },
                "subgrid": {
                    "plus": "ui-icon-plus",
                    "minus": "ui-icon-minus",
                    "openLtr": "ui-icon-carat-1-sw",
                    "openRtl": "ui-icon-carat-1-se"
                },
                "grouping": {
                    "plus": "ui-icon-circlesmall-plus",
                    "minus": "ui-icon-circlesmall-minus"
                },
                "treeGrid": {
                    "minus": "ui-icon-triangle-1-s",
                    "leaf": "ui-icon-radio-off",
                    "plusLtr": "ui-icon-triangle-1-e",
                    "plusRtl": "ui-icon-triangle-1-w"
                }
            },
            "fontAwesome": {
                "common": "fa",
                "pager": {
                    "common": "fa-fw",
                    "first": "fa-step-backward",
                    "prev": "fa-backward",
                    "next": "fa-forward",
                    "last": "fa-step-forward"
                },
                "sort": {
                    "common": "fa-lg",
                    "asc": "fa-sort-asc",
                    "desc": "fa-sort-desc"
                },
                "gridMinimize": {
                    "visible": "fa-chevron-circle-up",
                    "hidden": "fa-chevron-circle-down"
                },
                "nav": {
                    "common": "fa-lg fa-fw",
                    "edit": "fa-pencil",
                    "add": "fa-plus",
                    "del": "fa-trash-o",
                    "search": "fa-search",
                    "refresh": "fa-refresh",
                    "view": "fa-file-o",
                    "save": "fa-floppy-o",
                    "cancel": "fa-ban",
                    "newbutton": "fa-external-link"
                },
                "actions": {
                    "common": "fa-fw",
                    "edit": "fa-pencil",
                    "del": "fa-trash-o",
                    "save": "fa-floppy-o",
                    "cancel": "fa-ban"
                },
                "form": {
                    "close": "fa-times",
                    "prev": "fa-caret-left",
                    "next": "fa-caret-right",
                    "save": "fa-floppy-o",
                    "undo": "fa-undo",
                    "del": "fa-trash-o",
                    "cancel": "fa-ban",
                    "resizableLtr": "fa-rss fa-rotate-270"
                },
                "search": {
                    "search": "fa-search",
                    "reset": "fa-undo",
                    "query": "fa-comments-o"
                },
                "subgrid": {
                    "common": "fa-fw",
                    "plus": "fa-plus",
                    "minus": "fa-minus",
                    "openLtr": "fa-reply fa-rotate-180",
                    "openRtl": "fa-share fa-rotate-180"
                },
                "grouping": {
                    "common": "fa-fw",
                    "plus": "fa-plus-square-o",
                    "minus": "fa-minus-square-o"
                },
                "treeGrid": {
                    "common": "fa-fw",
                    "minus": "fa-lg fa-sort-desc",
                    "leaf": "fa-dot-circle-o",
                    "plusLtr": "fa-lg fa-caret-right",
                    "plusRtl": "fa-lg fa-caret-left"
                }
            },
            "glyph": {
                "common": "glyphicon",
                "pager": {
                    "common": "",
                    "first": "glyphicon-step-backward",
                    "prev": "glyphicon-backward",
                    "next": "glyphicon-forward",
                    "last": "glyphicon-step-forward"
                },
                "sort": {
                    "common": "",
                    "asc": "glyphicon-triangle-top",
                    "desc": "glyphicon-triangle-bottom"
                },
                "gridMinimize": {
                    "visible": "glyphicon-circle-arrow-up",
                    "hidden": "glyphicon-circle-arrow-down"
                },
                "nav": {
                    "common": "",
                    "edit": "glyphicon-edit",
                    "add": "glyphicon-plus",
                    "del": "glyphicon-trash",
                    "search": "glyphicon-search",
                    "refresh": "glyphicon-refresh",
                    "view": "glyphicon-file",
                    "save": "glyphicon-save",
                    "cancel": "glyphicon-ban-circle",
                    "newbutton": "glyphicon-new-window"
                },
                "actions": {
                    "common": "",
                    "edit": "glyphicon-edit",
                    "del": "glyphicon-trash",
                    "save": "glyphicon-save",
                    "cancel": "glyphicon-ban-circle"
                },
                "form": {
                    "close": "glyphicon-remove-circle",
                    "prev": "glyphicon-step-backward",
                    "next": "glyphicon-step-forward",
                    "save": "glyphicon-save",
                    "undo": "glyphicon-repeat",
                    "del": "glyphicon-trash",
                    "cancel": "glyphicon-ban-circle",
                    "resizableLtr": "glyphicon-import"
                },
                "search": {
                    "search": "glyphicon-search",
                    "reset": "glyphicon-repeat",
                    "query": "glyphicon-cog"
                },
                "subgrid": {
                    "common": "",
                    "plus": "glyphicon-zoom-in",
                    "minus": "glyphicon-zoom-out",
                    "openLtr": "glyphicon-indent-left",
                    "openRtl": "glyphicon-indent-left"
                },
                "grouping": {
                    "common": "",
                    "plus": "glyphicon-expand",
                    "minus": "glyphicon-collapse-down"
                },
                "treeGrid": {
                    "common": "",
                    "minus": "glyphicon-triangle-bottom",
                    "leaf": "glyphicon-record",
                    "plusLtr": "glyphicon-triangle-right",
                    "plusRtl": "glyphicon-triangle-left"
                }
            }
        },
        "guiStyles": {
            "jQueryUI": {
                "gBox": "ui-jqgrid-jquery-ui ui-widget ui-widget-content ui-corner-all",
                "gView": "",
                "overlay": "ui-widget-overlay",
                "loading": "ui-state-default ui-state-active",
                "hDiv": "ui-state-default ui-corner-top",
                "hTable": "",
                "colHeaders": "ui-state-default",
                "states": {
                    "select": "ui-state-highlight",
                    "disabled": "ui-state-disabled ui-jqgrid-disablePointerEvents",
                    "hover": "ui-state-hover",
                    "error": "ui-state-error",
                    "active": "ui-state-active",
                    "textOfClickable": "ui-state-default"
                },
                "dialog": {
                    "header": "ui-widget-header ui-dialog-titlebar ui-corner-all ui-helper-clearfix",
                    "window": "ui-jqgrid-jquery-ui ui-widget ui-widget-content ui-corner-all ui-front",
                    "document": "",
                    "subdocument": "",
                    "body": "",
                    "footer": "",
                    "content": "ui-widget-content",
                    "hr": "ui-widget-content",
                    "closeButton": "ui-corner-all",
                    "fmButton": "ui-state-default",
                    "dataField": "ui-widget-content ui-corner-all",
                    "viewLabel": "ui-widget-content",
                    "viewData": "ui-widget-content",
                    "leftCorner": "ui-corner-left",
                    "rightCorner": "ui-corner-right",
                    "defaultCorner": "ui-corner-all"
                },
                "filterToolbar": {
                    "dataField": "ui-widget-content"
                },
                "subgrid": {
                    "thSubgrid": "ui-state-default",
                    "rowSubTable": "ui-widget-content",
                    "row": "ui-widget-content",
                    "tdStart": "",
                    "tdWithIcon": "ui-widget-content",
                    "buttonDiv": "",
                    "button": "",
                    "tdData": "ui-widget-content",
                    "legacyTable": ""
                },
                "grid": "",
                "gridRow": "ui-widget-content",
                "rowNum": "ui-state-default",
                "gridFooter": "",
                "rowFooter": "ui-widget-content",
                "gridTitle": "ui-widget-header ui-corner-top",
                "gridError": "ui-state-error",
                "gridErrorText": "",
                "titleButton": "ui-corner-all",
                "toolbarUpper": "ui-state-default",
                "toolbarBottom": "ui-state-default",
                "actionsDiv": "ui-widget-content",
                "actionsButton": "ui-corner-all",
                "pager": {
                    "pager": "ui-state-default",
                    "pagerButton": "ui-corner-all",
                    "pagerInput": "ui-widget-content",
                    "pagerSelect": "ui-widget-content"
                },
                "navButton": "ui-corner-all",
                "searchDialog": {
                    "operator": "ui-corner-all",
                    "label": "ui-corner-all",
                    "elem": "ui-corner-all",
                    "operationGroup": "",
                    "addRuleButton": "ui-corner-all",
                    "deleteRuleButton": "ui-corner-all",
                    "operationSelect": "ui-corner-all",
                    "addGroupButton": "ui-corner-all",
                    "deleteGroupButton": "ui-corner-all"
                },
                "searchToolbar": {
                    "menu": "ui-menu-jqueryui",
                    "operButton": "ui-corner-all",
                    "clearButton": "ui-corner-all"
                },
                "top": "ui-corner-top",
                "bottom": "ui-corner-bottom",
                "resizer": "ui-widget-header"
            },
            "bootstrap": {
                "gBox": "ui-jqgrid-bootstrap",
                "gView": "panel-info",
                "overlay": "modal-backdrop",
                "loading": "alert alert-info",
                "hDiv": "",
                "hTable": "table table-hover table-condensed table-bordered",
                "colHeaders": "",
                "states": {
                    "select": "success",
                    "disabled": "disabled ui-jqgrid-disablePointerEvents",
                    "hover": "active",
                    "error": "danger",
                    "active": "active",
                    "textOfClickable": ""
                },
                "dialog": {
                    "header": "modal-header",
                    "window": "modal ui-jqgrid-bootstrap",
                    "document": "modal-dialog",
                    "subdocument": "modal-content",
                    "body": "modal-body",
                    "footer": "modal-footer",
                    "content": "modal-content",
                    "hr": "hidden",
                    "closeButton": "btn btn-xs btn-default",
                    "fmButton": "btn btn-default",
                    "dataField": "form-control",
                    "viewLabel": "",
                    "viewData": "form-control",
                    "leftCorner": "",
                    "rightCorner": "",
                    "defaultCorner": ""
                },
                "filterToolbar": {
                    "dataField": "form-control"
                },
                "subgrid": {
                    "thSubgrid": "",
                    "rowSubTable": "",
                    "row": "",
                    "tdStart": "",
                    "tdWithIcon": "",
                    "buttonDiv": "",
                    "button": "btn btn-xs",
                    "tdData": "",
                    "legacyTable": "table table-condensed table-hover table-bordered"
                },
                "grid": "table table-condensed table-hover table-bordered",
                "gridRow": "",
                "rowNum": "",
                "gridFooter": "table table-hover table-condensed table-bordered",
                "rowFooter": "",
                "gridTitle": "",
                "gridError": "alert alert-danger",
                "gridErrorText": "sr-only",
                "titleButton": "btn btn-xs btn-default",
                "actionsDiv": "",
                "actionsButton": "btn btn-xs btn-default",
                "toolbarUpper": "",
                "toolbarBottom": "",
                "pager": {
                    "pager": "panel-footer",
                    "pagerButton": "btn btn-xs",
                    "pagerInput": "form-control",
                    "pagerSelect": "form-control"
                },
                "navButton": "btn btn-xs",
                "searchDialog": {
                    "operator": "form-control",
                    "label": "form-control",
                    "elem": "form-control",
                    "operationGroup": "form-inline",
                    "addRuleButton": "btn btn-xs btn-default",
                    "deleteRuleButton": "btn btn-xs btn-default",
                    "operationSelect": "form-control",
                    "addGroupButton": "btn btn-xs btn-default",
                    "deleteGroupButton": "btn btn-xs btn-default"
                },
                "searchToolbar": {
                    "menu": "dropdown-menu",
                    "operButton": "btn btn-xs btn-default",
                    "clearButton": "btn btn-xs btn-default"
                },
                "top": "ui-jqgrid-bootstrap-corner-top",
                "bottom": "ui-jqgrid-bootstrap-corner-bottom",
                "resizer": "ui-jqgrid-bootstrap"
            },
            "bootstrapPrimary": {
                "baseGuiStyle": "bootstrap",
                "dialog": {
                    "closeButton": "btn btn-xs close",
                    "fmButton": "btn btn-primary"
                },
                "searchDialog": {
                    "addRuleButton": "btn btn-xs btn-primary",
                    "deleteRuleButton": "btn btn-xs btn-primary",
                    "addGroupButton": "btn btn-xs btn-primary",
                    "deleteGroupButton": "btn btn-xs btn-primary"
                }
            }
        },
        "htmlDecode": function(value) {
            if (value && (value === "&nbsp;" || value === "&#160;" || value.length === 1 && value.charCodeAt(0) === 160)) {
                return "";
            }
            return !value ? value : String(value).replace(/&gt;/g, ">").replace(/&lt;/g, "<").replace(/&#x27;/g, "'").replace(/&#x2F;/g, "/").replace(/&#39;/g, "'").replace(/&#47;/g, "/").replace(/&quot;/g, '"').replace(/&amp;/g, "&");
        },
        "htmlEncode": function(value) {
            return !value ? value : String(value).replace(/&/g, "&amp;").replace(/\"/g, "&quot;").replace(/\'/g, "&#39;").replace(/\//g, "&#47;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
        },
        "oldEncodePostedData": function(value) {
            return !value ? value : String(value).replace(/&/g, "&amp;").replace(/\"/g, "&quot;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
        },
        "oldDecodePostedData": function(value) {
            if (value && (value === "&nbsp;" || value === "&#160;" || value.length === 1 && value.charCodeAt(0) === 160)) {
                return "";
            }
            return !value ? value : String(value).replace(/&gt;/g, ">").replace(/&lt;/g, "<").replace(/&quot;/g, '"').replace(/&amp;/g, "&");
        },
        "clearArray": function(ar) {
            while (ar.length > 0) {
                ar.pop();
            }
        },
        "format": function(format) {
            var args = $.makeArray(arguments).slice(1);
            if (format == null) {
                format = "";
            }
            return format.replace(/\{(\d+)\}/g, function(m, i) {
                return args[i];
            });
        },
        "template": function(format) {
            var args = $.makeArray(arguments).slice(1), j, al = args.length;
            if (format == null) {
                format = "";
            }
            return format.replace(/\{([\w\-]+)(?:\:([\w\.]*)(?:\((\.*?)?\))?)?\}/g, function(m, i) {
                var nmarr, k;
                if (!isNaN(parseInt(i, 10))) {
                    return args[parseInt(i, 10)];
                }
                for (j = 0; j < al; j++) {
                    if ($.isArray(args[j])) {
                        nmarr = args[j];
                        k = nmarr.length;
                        while (k--) {
                            if (i === nmarr[k].nm) {
                                return nmarr[k].v;
                            }
                        }
                    }
                }
            });
        },
        "msie": navigator.appName === "Microsoft Internet Explorer",
        "msiever": function() {
            var rv = -1, match = /(MSIE) ([0-9]{1,}[.0-9]{0,})/.exec(navigator.userAgent);
            if (match != null && match.length === 3) {
                rv = parseFloat(match[2] || -1);
            }
            return rv;
        },
        "fixMaxHeightOfDiv": function(height) {
            if (navigator.appName === "Microsoft Internet Explorer") {
                return Math.min(height, 1533917);
            }
            if (/(Firefox)/.exec(navigator.userAgent) != null) {
                return Math.min(height, 17895696);
            }
            return height;
        },
        "getCellIndex": function(cell) {
            var c = $(cell);
            if (c.is("tr")) {
                return -1;
            }
            c = (!c.is("td") && !c.is("th") ? c.closest("td,th") : c)[0];
            if (c == null) {
                return -1;
            }
            if (jgrid.msie) {
                return $.inArray(c, c.parentNode.cells);
            }
            return c.cellIndex;
        },
        "stripHtml": function(v) {
            v = String(v);
            if (v) {
                v = v.replace(/<("[^"]*"|'[^']*'|[^'">])*>/gi, "");
                return v && v !== "&nbsp;" && v !== "&#160;" ? v.replace(/\"/g, "'") : "";
            }
            return v;
        },
        "stripPref": function(pref, id) {
            var obj = $.type(pref);
            if (obj === "string" || obj === "number") {
                pref = String(pref);
                id = pref !== "" ? String(id).replace(String(pref), "") : id;
            }
            return id;
        },
        "getRes": function(basePath, path) {
            var pathParts = path.split("."), n = pathParts.length, i;
            if (basePath == null) {
                return undefined;
            }
            for (i = 0; i < n; i++) {
                if (!pathParts[i]) {
                    return null;
                }
                basePath = basePath[pathParts[i]];
                if (basePath === undefined) {
                    break;
                }
                if (typeof basePath === "string") {
                    return basePath;
                }
            }
            return basePath;
        },
        "parseDate": function(format, date, newformat, opts) {
            var token = /\\.|[dDjlNSwzWFmMntLoYyaABgGhHisueIOPTZcrU]/g, dM, k, hl, timestamp = 0, offset = 0, timezone = /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[\-+]\d{4})?)\b/g, timezoneClip = /[^\-+\dA-Z]/g, msMatch = typeof date === "string" ? date.match(/^\/Date\((([\-+])?[0-9]+)(([\-+])([0-9]{2})([0-9]{2}))?\)\/$/) : null, pad = function(value, length) {
                value = String(value);
                length = parseInt(length, 10) || 2;
                while (value.length < length) {
                    value = "0" + value;
                }
                return value;
            }, ts = {
                "m": 1,
                "d": 1,
                "y": 1970,
                "h": 0,
                "i": 0,
                "s": 0,
                "u": 0
            }, h12To24 = function(ampm, h) {
                if (ampm === 0) {
                    if (h === 12) {
                        h = 0;
                    }
                } else {
                    if (h !== 12) {
                        h += 12;
                    }
                }
                return h;
            }, getDefOptions = function(p, options) {
                var props = [ "AmPm", "dayNames", "masks", "monthNames", "userLocalTime", "parseRe", "S", "srcformat" ], root1 = options || {}, root2 = (jgrid.formatter || {}).date || {}, root3 = p == null || p.locale == null ? {} : ((locales[p.locale] || {}).formatter || {}).date, iProp, nProps = props.length, result = {}, prop;
                for (iProp = 0; iProp < nProps; iProp++) {
                    prop = props[iProp];
                    if (root1[prop] !== undefined) {
                        result[prop] = root1[prop];
                    } else if (root2[prop] !== undefined) {
                        result[prop] = root2[prop];
                    } else if (root3[prop] !== undefined) {
                        result[prop] = root3[prop];
                    }
                }
                return result;
            };
            opts = getDefOptions(this.p, opts);
            if (opts.parseRe === undefined) {
                opts.parseRe = /[#%\\\/:_;.,\t\s\-]/;
            }
            if (opts.masks.hasOwnProperty(format)) {
                format = opts.masks[format];
            }
            if (date && date != null) {
                if (!isNaN(date) && String(format).toLowerCase() === "u") {
                    timestamp = new Date(parseFloat(date) * 1e3);
                } else if (!isNaN(date) && String(format).toLowerCase() === "u1000") {
                    timestamp = new Date(parseFloat(date));
                } else if (date.constructor === Date) {
                    timestamp = date;
                } else if (msMatch !== null) {
                    timestamp = new Date(parseInt(msMatch[1], 10));
                    if (msMatch[3]) {
                        offset = Number(msMatch[5]) * 60 + Number(msMatch[6]);
                        offset *= msMatch[4] === "-" ? 1 : -1;
                        offset -= timestamp.getTimezoneOffset();
                        timestamp.setTime(Number(Number(timestamp) + offset * 60 * 1e3));
                    }
                } else {
                    if (opts.srcformat === "ISO8601Long" && date.charAt(date.length - 1) === "Z") {
                        offset -= new Date().getTimezoneOffset();
                    }
                    date = String(date).replace(/\T/g, "#").replace(/\t/, "%").split(opts.parseRe);
                    format = format.replace(/\T/g, "#").replace(/\t/, "%").split(opts.parseRe);
                    for (k = 0, hl = Math.min(format.length, date.length); k < hl; k++) {
                        switch (format[k]) {
                          case "M":
                            dM = $.inArray(date[k], opts.monthNames);
                            if (dM !== -1 && dM < 12) {
                                date[k] = dM + 1;
                                ts.m = date[k];
                            }
                            break;

                          case "F":
                            dM = $.inArray(date[k], opts.monthNames, 12);
                            if (dM !== -1 && dM > 11) {
                                date[k] = dM + 1 - 12;
                                ts.m = date[k];
                            }
                            break;

                          case "n":
                            ts.m = parseInt(date[k], 10);
                            break;

                          case "j":
                            ts.d = parseInt(date[k], 10);
                            break;

                          case "g":
                            ts.h = parseInt(date[k], 10);
                            break;

                          case "a":
                            dM = $.inArray(date[k], opts.AmPm);
                            if (dM !== -1 && dM < 2 && date[k] === opts.AmPm[dM]) {
                                date[k] = dM;
                                ts.h = h12To24(date[k], ts.h);
                            }
                            break;

                          case "A":
                            dM = $.inArray(date[k], opts.AmPm);
                            if (dM !== -1 && dM > 1 && date[k] === opts.AmPm[dM]) {
                                date[k] = dM - 2;
                                ts.h = h12To24(date[k], ts.h);
                            }
                            break;
                        }
                        if (date[k] !== undefined) {
                            ts[format[k].toLowerCase()] = parseInt(date[k], 10);
                        }
                    }
                    if (ts.f) {
                        ts.m = ts.f;
                    }
                    if (ts.m === 0 && ts.y === 0 && ts.d === 0) {
                        return "&#160;";
                    }
                    ts.m = parseInt(ts.m, 10) - 1;
                    var ty = ts.y;
                    if (ty >= 70 && ty <= 99) {
                        ts.y = 1900 + ts.y;
                    } else if (ty >= 0 && ty <= 69) {
                        ts.y = 2e3 + ts.y;
                    }
                    timestamp = new Date(ts.y, ts.m, ts.d, ts.h, ts.i, ts.s, ts.u);
                    if (offset > 0) {
                        timestamp.setTime(Number(Number(timestamp) + offset * 60 * 1e3));
                    }
                }
            } else {
                timestamp = new Date(ts.y, ts.m, ts.d, ts.h, ts.i, ts.s, ts.u);
            }
            if (opts.userLocalTime && offset === 0) {
                offset -= new Date().getTimezoneOffset();
                if (offset > 0) {
                    timestamp.setTime(Number(Number(timestamp) + offset * 60 * 1e3));
                }
            }
            if (newformat === undefined) {
                return timestamp;
            }
            if (opts.masks.hasOwnProperty(newformat)) {
                newformat = opts.masks[newformat];
            } else if (!newformat) {
                newformat = "Y-m-d";
            }
            var hours = timestamp.getHours(), i = timestamp.getMinutes(), j = timestamp.getDate(), n = timestamp.getMonth() + 1, o = timestamp.getTimezoneOffset(), s = timestamp.getSeconds(), u = timestamp.getMilliseconds(), w = timestamp.getDay(), year = timestamp.getFullYear(), dayOfWeek = (w + 6) % 7 + 1, z = (new Date(year, n - 1, j) - new Date(year, 0, 1)) / 864e5, weekNumberOfYear = dayOfWeek < 5 ? Math.floor((z + dayOfWeek - 1) / 7) + 1 : Math.floor((z + dayOfWeek - 1) / 7) || ((new Date(year - 1, 0, 1).getDay() + 6) % 7 < 4 ? 53 : 52), flags = {
                "d": pad(j),
                "D": opts.dayNames[w],
                "j": j,
                "l": opts.dayNames[w + 7],
                "N": dayOfWeek,
                "S": opts.S(j),
                "w": w,
                "z": z,
                "W": weekNumberOfYear,
                "F": opts.monthNames[n - 1 + 12],
                "m": pad(n),
                "M": opts.monthNames[n - 1],
                "n": n,
                "t": "?",
                "L": "?",
                "o": "?",
                "Y": year,
                "y": String(year).substring(2),
                "a": hours < 12 ? opts.AmPm[0] : opts.AmPm[1],
                "A": hours < 12 ? opts.AmPm[2] : opts.AmPm[3],
                "B": "?",
                "g": hours % 12 || 12,
                "G": hours,
                "h": pad(hours % 12 || 12),
                "H": pad(hours),
                "i": pad(i),
                "s": pad(s),
                "u": u,
                "e": "?",
                "I": "?",
                "O": (o > 0 ? "-" : "+") + pad(Math.floor(Math.abs(o) / 60) * 100 + Math.abs(o) % 60, 4),
                "P": "?",
                "T": (String(timestamp).match(timezone) || [ "" ]).pop().replace(timezoneClip, ""),
                "Z": "?",
                "c": "?",
                "r": "?",
                "U": Math.floor(timestamp / 1e3)
            };
            return newformat.replace(token, function($0) {
                return flags.hasOwnProperty($0) ? flags[$0] : $0.substring(1);
            });
        },
        "parseDateToNumber": function(format, date) {
            var datetime = jgrid.parseDate.call(this, format, date);
            return datetime instanceof Date ? datetime.getTime() : 0;
        },
        "jqID": function(sid) {
            return String(sid).replace(/[!"#$%&'()*+,.\/:; <=>?@\[\\\]\^`{|}~]/g, "\\$&");
        },
        "getGridComponentId": function(componentName) {
            var self = this;
            if (self.p == null || !self.p.id) {
                return "";
            }
            var id = self.p.id;
            switch (componentName) {
              case COMPONENT_NAMES.GRID:
                return id;

              case COMPONENT_NAMES.GRID_BOX_DIV:
                return "gbox_" + id;

              case COMPONENT_NAMES.GRID_VIEW_DIV:
                return "gview_" + id;

              case COMPONENT_NAMES.DIALOG_ALERT_DIV:
                return "alertmod_" + id;

              case COMPONENT_NAMES.COLUMN_RESIZER_DIV:
                return "rs_m" + id;

              case COMPONENT_NAMES.HEADER_SELECT_ALL_ROWS_CHECKBOX:
                return "cb_" + id;

              case COMPONENT_NAMES.SEARCH_OPERATION_MENU_UL:
                return "sopt_menu";

              default:
                return "";
            }
        },
        "getGridComponentIdSelector": function(componentName) {
            var id = jgrid.getGridComponentId.call(this, componentName);
            return id ? "#" + jgrid.jqID(id) : "";
        },
        "isHTMLElement": function(elem) {
            return typeof HTMLElement === "object" || typeof HTMLElement === "function" ? elem instanceof HTMLElement : elem != null && typeof elem === "object" && elem.nodeType === 1 && typeof elem.nodeName === "string";
        },
        "getGridComponent": function(componentName, $p) {
            var p;
            if ($p instanceof $ || $p.length > 0) {
                p = $p[0];
            } else if (jgrid.isHTMLElement($p)) {
                p = $p;
                $p = $(p);
            } else {
                return $();
            }
            switch (componentName) {
              case COMPONENT_NAMES.BODY_TABLE:
                return $p.hasClass("ui-jqgrid-bdiv") ? $p.find(">div>.ui-jqgrid-btable") : $();

              case COMPONENT_NAMES.HEADER_TABLE:
                return $p.hasClass("ui-jqgrid-hdiv") ? $p.find(">div>.ui-jqgrid-htable") : $();

              case COMPONENT_NAMES.FOOTER_TABLE:
                return $p.hasClass("ui-jqgrid-sdiv") ? $p.find(">div>.ui-jqgrid-ftable") : $();

              case COMPONENT_NAMES.FROZEN_HEADER_TABLE:
                return $p.hasClass("ui-jqgrid-hdiv") ? $p.children(".ui-jqgrid-htable") : $();

              case COMPONENT_NAMES.FROZEN_FOOTER_TABLE:
                return $p.hasClass("ui-jqgrid-sdiv") ? $p.children(".ui-jqgrid-ftable") : $();

              case COMPONENT_NAMES.BODY_DIV:
                return $p.hasClass("ui-jqgrid-btable") && p.grid != null ? $(p.grid.bDiv) : $();

              case COMPONENT_NAMES.HEADER_DIV:
                return $p.hasClass("ui-jqgrid-btable") && p.grid != null ? $(p.grid.hDiv) : $();

              case COMPONENT_NAMES.FOOTER_DIV:
                return $p.hasClass("ui-jqgrid-btable") && p.grid != null ? $(p.grid.sDiv) : $();

              default:
                return $();
            }
        },
        "fixScrollOffsetAndhBoxPadding": function() {
            var self = this, grid = self.grid;
            if (!grid) {
                return;
            }
            var p = self.p, bDiv = grid.bDiv, fixhBox = function(hDiv) {
                var $hDivhBox = $(hDiv).children("div").first();
                $hDivhBox.css($hDivhBox.hasClass("ui-jqgrid-hbox-rtl") ? "padding-left" : "padding-right", p.scrollOffset);
                hDiv.scrollLeft = bDiv.scrollLeft;
            };
            if ($(bDiv).width() > 0) {
                p.scrollOffset = bDiv.offsetWidth - bDiv.clientWidth;
                fixhBox(grid.hDiv);
                if (grid.sDiv) {
                    fixhBox(grid.sDiv);
                }
            }
        },
        "mergeCssClasses": function() {
            var args = $.makeArray(arguments), map = {}, i, j, ar, cssClass, classes = [];
            for (i = 0; i < args.length; i++) {
                ar = String(args[i]).replace(/[\t\r\n\f]/g, " ").split(" ");
                for (j = 0; j < ar.length; j++) {
                    cssClass = ar[j];
                    if (cssClass !== "" && !map.hasOwnProperty(cssClass)) {
                        map[cssClass] = true;
                        classes.push(cssClass);
                    }
                }
            }
            return classes.join(" ");
        },
        "hasOneFromClasses": function(elem, classes) {
            var $elem = $(elem), arClasses = String(classes).replace(/[\t\r\n\f]/g, " ").split(" "), n = arClasses.length, i;
            for (i = 0; i < n; i++) {
                if ($elem.hasClass(arClasses[i])) {
                    return true;
                }
            }
            return false;
        },
        "hasAllClasses": function(elem, classes) {
            var $elem = $(elem), arClasses = String(classes).replace(/[\t\r\n\f]/g, " ").split(" "), n = arClasses.length, i;
            for (i = 0; i < n; i++) {
                if (!$elem.hasClass(arClasses[i])) {
                    return false;
                }
            }
            return true;
        },
        "detectRowEditing": function(rowid) {
            var i, savedRowInfo, tr, self = this, rows = self.rows, p = self.p, isFunction = $.isFunction;
            if (!self.grid || rows == null || p == null) {
                return null;
            }
            if (p.savedRow === undefined || p.savedRow.length === 0) {
                return null;
            }
            for (i = 0; i < p.savedRow.length; i++) {
                savedRowInfo = p.savedRow[i];
                if (typeof savedRowInfo.id === "number" && typeof savedRowInfo.ic === "number" && savedRowInfo.name !== undefined && savedRowInfo.v !== undefined && rows[savedRowInfo.id] != null && rows[savedRowInfo.id].id === rowid && isFunction($.fn.jqGrid.restoreCell)) {
                    tr = rows[savedRowInfo.id];
                    if (tr != null && tr.id === rowid) {
                        return {
                            "mode": "cellEditing",
                            "savedRow": savedRowInfo
                        };
                    }
                } else if (savedRowInfo.id === rowid && isFunction($.fn.jqGrid.restoreRow)) {
                    return {
                        "mode": "inlineEditing",
                        "savedRow": savedRowInfo
                    };
                }
            }
            return null;
        },
        "getCell": function(tr, iCol) {
            var grid = this.grid, p = this.p, frozenRows, $td;
            if (!grid || !p) {
                return $();
            }
            if (tr instanceof $ || tr.length > 0) {
                tr = tr[0];
            }
            if (!((typeof HTMLTableRowElement === "object" || typeof HTMLTableRowElement === "function") && tr instanceof HTMLTableRowElement) || tr.cells == null) {
                return $();
            }
            $td = $(tr.cells[iCol]);
            frozenRows = grid.fbRows;
            return frozenRows != null && iCol < frozenRows[0].cells.length ? $td.add(frozenRows[tr.rowIndex].cells[iCol]) : $td;
        },
        "getDataFieldOfCell": function(tr, iCol) {
            var p = this.p, $td = jgrid.getCell.call(this, tr, iCol);
            if (p.treeGrid && $td.children("div.tree-wrap").length > 0) {
                $td = $td.children("span.cell-wrapperleaf,span.cell-wrapper");
            }
            return p.colModel[iCol].autoResizable ? $td.children("span." + p.autoResizing.wrapperClassName) : $td;
        },
        "enumEditableCells": function(tr, mode, callback) {
            var self = this, grid = self.grid, rows = self.rows, p = self.p;
            if (grid == null || rows == null || p == null || tr == null || tr.rowIndex == null || !tr.id || !$.isFunction(callback)) {
                return null;
            }
            var iCol, colModel = p.colModel, nCol = colModel.length, cm, nm, options, isEditable, iRow = tr.rowIndex, td, $dataElement, dataWidth, frozenRows = grid.fbRows, frozen = frozenRows != null, trFrozen = frozen ? frozenRows[iRow] : null;
            if (frozen) {
                tr = self.rows[iRow];
            }
            for (iCol = 0; iCol < nCol; iCol++) {
                cm = colModel[iCol];
                nm = cm.name;
                if (nm !== "cb" && nm !== "subgrid" && nm !== "rn") {
                    if (frozen && !cm.frozen) {
                        frozen = false;
                    }
                    td = (frozen ? trFrozen : tr).cells[iCol];
                    $dataElement = $(td);
                    if (!$dataElement.hasClass("not-editable-cell")) {
                        dataWidth = $dataElement.width();
                        if (p.treeGrid === true && nm === p.ExpandColumn) {
                            dataWidth -= $dataElement.children("div.tree-wrap").outerWidth();
                            $dataElement = $dataElement.children("span.cell-wrapperleaf,span.cell-wrapper").first();
                        } else {
                            dataWidth = 0;
                        }
                        options = {
                            "rowid": tr.id,
                            "iCol": iCol,
                            "iRow": iRow,
                            "cmName": nm,
                            "cm": cm,
                            "mode": mode,
                            "td": td,
                            "tr": tr,
                            "trFrozen": trFrozen,
                            "dataElement": $dataElement[0],
                            "dataWidth": dataWidth
                        };
                        if (!cm.edittype) {
                            cm.edittype = "text";
                        }
                        isEditable = cm.editable;
                        isEditable = $.isFunction(isEditable) ? isEditable.call(self, options) : isEditable;
                        if (isEditable === true || isEditable === "hidden") {
                            options.editable = isEditable;
                            if (callback.call(self, options) === false) {
                                break;
                            }
                        }
                    }
                }
            }
        },
        "getEditedValue": function($dataFiled, cm, valueText, editable) {
            var result, checkBoxValues, newformat, $field, values, texts, formatoptions = cm.formatoptions || {}, editoptions = cm.editoptions || {}, customValue = editoptions.custom_value, nameSelector = "[name=" + jgrid.jqID(cm.name) + "]", $t = this, $self = $($t);
            if (editable === "hidden" || editable === "readonly") {
                return $($t).jqGrid("getCell", $dataFiled.closest("tr.jqgrow").attr("id"), cm.name);
            }
            switch (cm.edittype) {
              case "checkbox":
                checkBoxValues = [ "Yes", "No" ];
                if (typeof editoptions.value === "string") {
                    checkBoxValues = editoptions.value.split(":");
                }
                result = $dataFiled.find("input[type=checkbox]").is(":checked") ? checkBoxValues[0] : checkBoxValues[1];
                break;

              case "text":
              case "password":
              case "textarea":
              case "button":
                $field = $dataFiled.find("input" + nameSelector + ",textarea" + nameSelector);
                result = $field.val();
                if ($field.prop("type") === "date" && String(result).split("-").length === 3) {
                    newformat = formatoptions.newformat || $self.jqGrid("getGridRes", "formatter.date.newformat");
                    result = jgrid.parseDate.call($t, "Y-m-d", result, newformat);
                }
                break;

              case "select":
                $field = $dataFiled.find("select option:selected");
                if (editoptions.multiple) {
                    values = [];
                    texts = [];
                    $field.each(function() {
                        values.push($(this).val());
                        texts.push($(this).text());
                    });
                    result = values.join(",");
                    valueText.text = texts.join(",");
                } else {
                    result = $field.val();
                    valueText.text = $field.text();
                }
                valueText.value = result;
                break;

              case "custom":
                try {
                    if ($.isFunction(customValue)) {
                        result = customValue.call($t, $dataFiled.find(".customelement"), "get");
                        if (result === undefined) {
                            throw "e2";
                        }
                    } else {
                        throw "e1";
                    }
                } catch (e) {
                    var errorText, infoDialog = jgrid.info_dialog, getRes = function(path) {
                        $self.jqGrid("getGridRes", path);
                    };
                    switch (String(e)) {
                      case "e1":
                        errorText = "function 'custom_value' " + getRes("edit.msg.nodefined");
                        break;

                      case "e2":
                        break;

                      default:
                        errorText = e.message;
                        break;
                    }
                    if (infoDialog && $.isFunction(infoDialog)) {
                        infoDialog.call($t, getRes("errors.errcap"), errorText, getRes("edit.bClose"));
                    } else {
                        alert(errorText);
                    }
                }
                break;

              default:
                result = $dataFiled.find("*" + nameSelector).text();
                break;
            }
            return result;
        },
        "guid": 1,
        "uidPref": "jqg",
        "randId": function(prefix) {
            return (prefix || jgrid.uidPref) + jgrid.guid++;
        },
        "getAccessor": function(obj, expr) {
            var ret, p, prm = [], i;
            if ($.isFunction(expr)) {
                return expr(obj);
            }
            ret = obj[expr];
            if (ret === undefined) {
                try {
                    if (typeof expr === "string") {
                        prm = expr.split(".");
                    }
                    i = prm.length;
                    if (i) {
                        ret = obj;
                        while (ret && i--) {
                            p = prm.shift();
                            ret = ret[p];
                        }
                    }
                } catch (ignore) {}
            }
            return ret;
        },
        "getXmlData": function(obj, expr, returnObj) {
            var m = typeof expr === "string" ? expr.match(/^(.*)\[(\w+)\]$/) : null;
            if ($.isFunction(expr)) {
                return expr(obj);
            }
            if (m && m[2]) {
                return m[1] ? $(m[1], obj).attr(m[2]) : $(obj).attr(m[2]);
            }
            if (obj === undefined) {
                alert("expr");
            }
            var ret = $(obj).find(expr);
            if (returnObj) {
                return ret;
            }
            return ret.length > 0 ? $(ret).text() : undefined;
        },
        "cellWidth": function() {
            var $testDiv = $("<div class='ui-jqgrid' style='left:10000px'><div class='ui-jqgrid-view'><div class='ui-jqgrid-bdiv'><table class='ui-jqgrid-btable' style='width:5px;'><tr class='jqgrow'><td style='width:5px;display:block;'></td></tr></table></div></div></div>"), testCell = $testDiv.appendTo("body").find("td").width();
            $testDiv.remove();
            return Math.abs(testCell - 5) > .1;
        },
        "isCellClassHidden": function(className) {
            var $testDiv = $("<div class='ui-jqgrid' style='left:10000px'><div class='ui-jqgrid-view'><div class='ui-jqgrid-bdiv'><table class='ui-jqgrid-btable' style='width:5px;'><tr class='jqgrow'><td style='width:5px;' class='" + (className || "") + "'></td></tr></table></div></div></div>"), isHidden = $testDiv.appendTo("body").find("td").is(":hidden");
            $testDiv.remove();
            return isHidden;
        },
        "cell_width": true,
        "ajaxOptions": {},
        "from": function(source) {
            var context = this, QueryObject = function(d, q) {
                var self = this, _data = d, _usecase = true, _trim = false, _query = q, _stripNum = /[\$,%]/g, _lastCommand = null, _lastField = null, _orDepth = 0, _negate = false, _queuedOperator = "", _sorting = [], toString = Object.prototype.toString, _useProperties = true;
                if (typeof d === "object" && d.push) {
                    if (d.length > 0) {
                        if (typeof d[0] !== "object") {
                            _useProperties = false;
                        } else {
                            _useProperties = true;
                        }
                    }
                } else {
                    throw "data provides is not an array";
                }
                this._hasData = function() {
                    return _data === null ? false : _data.length === 0 ? false : true;
                };
                this._getStr = function(s) {
                    var phrase = [];
                    if (_trim) {
                        phrase.push("jQuery.trim(");
                    }
                    phrase.push("String(" + s + ")");
                    if (_trim) {
                        phrase.push(")");
                    }
                    if (!_usecase) {
                        phrase.push(".toUpperCase()");
                    }
                    return phrase.join("");
                };
                this._strComp = function(val) {
                    if (typeof val === "string") {
                        return ".toString()";
                    }
                    return "";
                };
                this._group = function(f, u) {
                    return {
                        "field": f.toString(),
                        "unique": u,
                        "items": []
                    };
                };
                this._toStr = function(phrase) {
                    if (_trim) {
                        phrase = $.trim(phrase);
                    }
                    phrase = phrase.toString().replace(/\\/g, "\\\\").replace(/\"/g, '\\"');
                    return _usecase ? phrase : phrase.toUpperCase();
                };
                this._funcLoop = function(func) {
                    var results = [];
                    $.each(_data, function(i, v) {
                        results.push(func(v));
                    });
                    return results;
                };
                this._append = function(s) {
                    var i;
                    if (_query === null) {
                        _query = "";
                    } else {
                        _query += _queuedOperator === "" ? " && " : _queuedOperator;
                    }
                    for (i = 0; i < _orDepth; i++) {
                        _query += "(";
                    }
                    if (_negate) {
                        _query += "!";
                    }
                    _query += "(" + s + ")";
                    _negate = false;
                    _queuedOperator = "";
                    _orDepth = 0;
                };
                this._setCommand = function(f, c) {
                    _lastCommand = f;
                    _lastField = c;
                };
                this._resetNegate = function() {
                    _negate = false;
                };
                this._repeatCommand = function(f, v) {
                    if (_lastCommand === null) {
                        return self;
                    }
                    if (f !== null && v !== null) {
                        return _lastCommand(f, v);
                    }
                    if (_lastField === null) {
                        return _lastCommand(f);
                    }
                    if (!_useProperties) {
                        return _lastCommand(f);
                    }
                    return _lastCommand(_lastField, f);
                };
                this._equals = function(a, b) {
                    return self._compare(a, b, 1) === 0;
                };
                this._compare = function(a, b, dir) {
                    if (dir === undefined) {
                        dir = 1;
                    }
                    if (a === undefined) {
                        a = null;
                    }
                    if (b === undefined) {
                        b = null;
                    }
                    if (a === null && b === null) {
                        return 0;
                    }
                    if (a === null && b !== null) {
                        return 1;
                    }
                    if (a !== null && b === null) {
                        return -1;
                    }
                    if (toString.call(a) === "[object Date]" && toString.call(b) === "[object Date]") {
                        if (a < b) {
                            return -dir;
                        }
                        if (a > b) {
                            return dir;
                        }
                        return 0;
                    }
                    if (!_usecase && typeof a !== "number" && typeof b !== "number") {
                        a = String(a);
                        b = String(b);
                    }
                    if (a < b) {
                        return -dir;
                    }
                    if (a > b) {
                        return dir;
                    }
                    return 0;
                };
                this._performSort = function() {
                    if (_sorting.length === 0) {
                        return;
                    }
                    _data = self._doSort(_data, 0);
                };
                this._doSort = function(data, iSort) {
                    var by = _sorting[iSort].by, dir = _sorting[iSort].dir, type = _sorting[iSort].type, dfmt = _sorting[iSort].datefmt, sfunc = _sorting[iSort].sfunc;
                    if (iSort === _sorting.length - 1) {
                        return self._getOrder(data, by, dir, type, dfmt, sfunc);
                    }
                    iSort++;
                    var values = self._getGroup(data, by, dir, type, dfmt), results = [], i, j, sorted;
                    for (i = 0; i < values.length; i++) {
                        sorted = self._doSort(values[i].items, iSort);
                        for (j = 0; j < sorted.length; j++) {
                            results.push(sorted[j]);
                        }
                    }
                    return results;
                };
                this._getOrder = function(data, by, dir, type, dfmt, sfunc) {
                    var sortData = [], _sortData = [], newDir = dir === "a" ? 1 : -1, i, ab, findSortKey;
                    if (type === undefined) {
                        type = "text";
                    }
                    if (type === "float" || type === "number" || type === "currency" || type === "numeric") {
                        findSortKey = function($cell) {
                            var key = parseFloat(String($cell).replace(_stripNum, ""));
                            return isNaN(key) ? Number.NEGATIVE_INFINITY : key;
                        };
                    } else if (type === "int" || type === "integer") {
                        findSortKey = function($cell) {
                            return $cell ? parseFloat(String($cell).replace(_stripNum, "")) : Number.NEGATIVE_INFINITY;
                        };
                    } else if (type === "date" || type === "datetime") {
                        findSortKey = function($cell) {
                            return jgrid.parseDateToNumber.call(context, dfmt, $cell);
                        };
                    } else if ($.isFunction(type)) {
                        findSortKey = type;
                    } else {
                        findSortKey = function($cell) {
                            $cell = $cell != null ? $.trim(String($cell)) : "";
                            return _usecase ? $cell : $cell.toUpperCase();
                        };
                    }
                    $.each(data, function(index, v) {
                        ab = by !== "" ? jgrid.getAccessor(v, by) : v;
                        if (ab === undefined) {
                            ab = "";
                        }
                        ab = findSortKey(ab, v);
                        _sortData.push({
                            "vSort": ab,
                            "data": v,
                            "index": index
                        });
                    });
                    if ($.isFunction(sfunc)) {
                        _sortData.sort(function(a, b) {
                            return sfunc.call(context, a.vSort, b.vSort, newDir, a.data, b.data);
                        });
                    } else {
                        _sortData.sort(function(a, b) {
                            return self._compare(a.vSort, b.vSort, newDir);
                        });
                    }
                    var j = 0, nrec = data.length;
                    while (j < nrec) {
                        i = _sortData[j].index;
                        sortData.push(data[i]);
                        j++;
                    }
                    return sortData;
                };
                this._getGroup = function(data, by, dir, type, dfmt) {
                    var results = [], group = null, last = null;
                    $.each(self._getOrder(data, by, dir, type, dfmt), function(i, v) {
                        var val = jgrid.getAccessor(v, by);
                        if (val == null) {
                            val = "";
                        }
                        if (!self._equals(last, val)) {
                            last = val;
                            if (group !== null) {
                                results.push(group);
                            }
                            group = self._group(by, val);
                        }
                        group.items.push(v);
                    });
                    if (group !== null) {
                        results.push(group);
                    }
                    return results;
                };
                this.ignoreCase = function() {
                    _usecase = false;
                    return self;
                };
                this.useCase = function() {
                    _usecase = true;
                    return self;
                };
                this.trim = function() {
                    _trim = true;
                    return self;
                };
                this.noTrim = function() {
                    _trim = false;
                    return self;
                };
                this.execute = function() {
                    var match = _query, results = [];
                    if (match === null) {
                        return self;
                    }
                    $.each(_data, function() {
                        (function() {
                            var localMath = "(function (context) { var intFunc = function (jQuery, self) { return " + match + "; }; return intFunc.call(context.item, context.jQuery, context.context); }(this))";
                            if (eval(localMath)) {
                                results.push(this.item);
                            }
                        }).call({
                            "item": this,
                            "jQuery": $,
                            "context": context
                        });
                    });
                    _data = results;
                    return self;
                };
                this.data = function() {
                    return _data;
                };
                this.select = function(f) {
                    self.execute();
                    if ($.isFunction(f)) {
                        var results = [];
                        $.each(_data, function(i, v) {
                            results.push(f(v));
                        });
                        return results;
                    }
                    if (!self._hasData()) {
                        return [];
                    }
                    self._performSort();
                    return _data;
                };
                this.hasMatch = function() {
                    if (!self._hasData()) {
                        return false;
                    }
                    self.execute();
                    return _data.length > 0;
                };
                this.andNot = function(f, v, x) {
                    _negate = !_negate;
                    return self.and(f, v, x);
                };
                this.orNot = function(f, v, x) {
                    _negate = !_negate;
                    return self.or(f, v, x);
                };
                this.not = function(f, v, x) {
                    return self.andNot(f, v, x);
                };
                this.and = function(f, v, x) {
                    _queuedOperator = " && ";
                    if (f === undefined) {
                        return self;
                    }
                    return self._repeatCommand(f, v, x);
                };
                this.or = function(f, v, x) {
                    _queuedOperator = " || ";
                    if (f === undefined) {
                        return self;
                    }
                    return self._repeatCommand(f, v, x);
                };
                this.orBegin = function() {
                    _orDepth++;
                    return self;
                };
                this.orEnd = function() {
                    if (_query !== null) {
                        _query += ")";
                    }
                    return self;
                };
                this.isNot = function(f) {
                    _negate = !_negate;
                    return self.is(f);
                };
                this.is = function(f) {
                    self._append("this." + f);
                    self._resetNegate();
                    return self;
                };
                this._compareValues = function(func, f, v, how, t) {
                    var fld;
                    if (_useProperties) {
                        fld = f;
                    } else {
                        fld = "this";
                    }
                    if (v === undefined) {
                        v = null;
                    }
                    var val = v, swst = t.stype === undefined ? "text" : t.stype;
                    if (v !== null) {
                        switch (swst) {
                          case "int":
                          case "integer":
                            val = String(val).replace(_stripNum, "");
                            val = isNaN(Number(val)) || val === "" ? "0" : Number(val);
                            fld = "parseInt(" + fld + "||0,10)";
                            val = String(parseInt(val, 10));
                            break;

                          case "float":
                          case "number":
                          case "currency":
                          case "numeric":
                            val = String(val).replace(_stripNum, "");
                            val = isNaN(Number(val)) || val === "" ? "0" : Number(val);
                            fld = "parseFloat(" + fld + "||0)";
                            val = String(val);
                            break;

                          case "date":
                          case "datetime":
                            val = String(jgrid.parseDateToNumber.call(context, t.newfmt || "Y-m-d", val));
                            fld = 'jQuery.jgrid.parseDateToNumber.call(self,"' + t.srcfmt + '",' + fld + ")";
                            break;

                          default:
                            fld = self._getStr(fld);
                            val = self._getStr('"' + self._toStr(val) + '"');
                        }
                    }
                    self._append(fld + " " + how + " " + val);
                    self._setCommand(func, f);
                    self._resetNegate();
                    return self;
                };
                this.equals = function(f, v, t) {
                    return self._compareValues(self.equals, f, v, "==", t);
                };
                this.notEquals = function(f, v, t) {
                    return self._compareValues(self.equals, f, v, "!==", t);
                };
                this.isNull = function(f, v, t) {
                    return self._compareValues(self.equals, f, null, "===", t);
                };
                this.greater = function(f, v, t) {
                    return self._compareValues(self.greater, f, v, ">", t);
                };
                this.less = function(f, v, t) {
                    return self._compareValues(self.less, f, v, "<", t);
                };
                this.greaterOrEquals = function(f, v, t) {
                    return self._compareValues(self.greaterOrEquals, f, v, ">=", t);
                };
                this.lessOrEquals = function(f, v, t) {
                    return self._compareValues(self.lessOrEquals, f, v, "<=", t);
                };
                this.startsWith = function(f, v) {
                    var val = v == null ? f : v, length = _trim ? $.trim(val.toString()).length : val.toString().length;
                    if (_useProperties) {
                        self._append(self._getStr(f) + ".substr(0," + length + ") == " + self._getStr('"' + self._toStr(v) + '"'));
                    } else {
                        if (v != null) {
                            length = _trim ? $.trim(v.toString()).length : v.toString().length;
                        }
                        self._append(self._getStr("this") + ".substr(0," + length + ") == " + self._getStr('"' + self._toStr(f) + '"'));
                    }
                    self._setCommand(self.startsWith, f);
                    self._resetNegate();
                    return self;
                };
                this.endsWith = function(f, v) {
                    var val = v == null ? f : v, length = _trim ? $.trim(val.toString()).length : val.toString().length;
                    if (_useProperties) {
                        self._append(self._getStr(f) + ".substr(" + self._getStr(f) + ".length-" + length + "," + length + ') == "' + self._toStr(v) + '"');
                    } else {
                        self._append(self._getStr("this") + ".substr(" + self._getStr("this") + '.length-"' + self._toStr(f) + '".length,"' + self._toStr(f) + '".length) == "' + self._toStr(f) + '"');
                    }
                    self._setCommand(self.endsWith, f);
                    self._resetNegate();
                    return self;
                };
                this.contains = function(f, v) {
                    if (_useProperties) {
                        self._append(self._getStr(f) + '.indexOf("' + self._toStr(v) + '",0) > -1');
                    } else {
                        self._append(self._getStr("this") + '.indexOf("' + self._toStr(f) + '",0) > -1');
                    }
                    self._setCommand(self.contains, f);
                    self._resetNegate();
                    return self;
                };
                this.groupBy = function(by, dir, type, datefmt) {
                    if (!self._hasData()) {
                        return null;
                    }
                    return self._getGroup(_data, by, dir, type, datefmt);
                };
                this.orderBy = function(by, dir, stype, dfmt, sfunc) {
                    dir = dir == null ? "a" : $.trim(dir.toString().toLowerCase());
                    if (stype == null) {
                        stype = "text";
                    }
                    if (dfmt == null) {
                        dfmt = "Y-m-d";
                    }
                    if (sfunc == null) {
                        sfunc = false;
                    }
                    if (dir === "desc" || dir === "descending") {
                        dir = "d";
                    }
                    if (dir === "asc" || dir === "ascending") {
                        dir = "a";
                    }
                    _sorting.push({
                        "by": by,
                        "dir": dir,
                        "type": stype,
                        "datefmt": dfmt,
                        "sfunc": sfunc
                    });
                    return self;
                };
                this.custom = function(ruleOp, field, data) {
                    self._append("self.p.customSortOperations." + ruleOp + '.filter.call(self,{item:this,cmName:"' + field + '",searchValue:"' + data + '"})');
                    self._setCommand(self.custom, field);
                    self._resetNegate();
                    return self;
                };
                return self;
            };
            return new QueryObject(typeof source === "string" ? $.data(source) : source, null);
        },
        "serializeFeedback": function(callback, eventName, postData) {
            var self = this, eventResult;
            if (self instanceof $ && self.length > 0) {
                self = self[0];
            }
            if (typeof postData === "string") {
                return postData;
            }
            eventResult = $(self).triggerHandler(eventName, postData);
            if (typeof eventResult === "string") {
                return eventResult;
            }
            if (eventResult == null || typeof eventResult !== "object") {
                eventResult = postData;
            }
            return $.isFunction(callback) ? callback.call(self, eventResult) : eventResult;
        },
        "fullBoolFeedback": function(callback, eventName) {
            var self = this, args = $.makeArray(arguments).slice(2), result = $(self).triggerHandler(eventName, args);
            result = result === false || result === "stop" ? false : true;
            if ($.isFunction(callback)) {
                var callbackResult = callback.apply(self, args);
                if (callbackResult === false || callbackResult === "stop") {
                    result = false;
                }
            }
            return result;
        },
        "feedback": function(p, eventPrefix, callbackSuffix, callbackName) {
            var self = this;
            if (self instanceof $ && self.length > 0) {
                self = self[0];
            }
            if (p == null || typeof callbackName !== "string" || callbackName.length < 2) {
                return null;
            }
            var eventName = callbackName.substring(0, 2) === "on" ? "jqGrid" + eventPrefix + callbackName.charAt(2).toUpperCase() + callbackName.substring(3) : "jqGrid" + eventPrefix + callbackName.charAt(0).toUpperCase() + callbackName.substring(1), args = $.makeArray(arguments).slice(4), callback = p[callbackName + callbackSuffix];
            args.unshift(eventName);
            args.unshift(callback);
            return jgrid.fullBoolFeedback.apply(self, args);
        },
        "builderSortIcons": function() {
            var ts = this, p = ts.p, disabledStateClasses = $(this).jqGrid("getGuiStyles", "states.disabled"), getClasses = function(ascOrDesc) {
                return jgrid.mergeCssClasses("ui-grid-ico-sort", "ui-icon-" + ascOrDesc, p.viewsortcols[1] === "horizontal" ? "ui-i-" + ascOrDesc : "", disabledStateClasses, $(ts).jqGrid("getIconRes", "sort." + ascOrDesc), "ui-sort-" + p.direction);
            };
            return "<span class='s-ico" + (p.sortIconsBeforeText ? " jqgrid-icons-first" : "") + "' style='display:none'><span class='" + getClasses("asc") + "'></span><span class='" + getClasses("desc") + "'></span></span>";
        },
        "builderFmButon": function(id, text, icon, iconOnLeftOrRight, conner) {
            var p = this.p, $self = $(this), getDialogGuiStyles = function(name) {
                return $self.jqGrid("getGuiStyles", "dialog." + name);
            };
            if (p == null) {
                return "";
            }
            return "<a id='" + id + "' class='" + jgrid.mergeCssClasses("fm-button", getDialogGuiStyles("fmButton"), getDialogGuiStyles(conner === "right" ? "rightCorner" : conner === "left" ? "leftCorner" : "defaultCorner"), iconOnLeftOrRight === "right" ? "fm-button-icon-right" : iconOnLeftOrRight === "left" ? "fm-button-icon-left" : "") + "' role='button' tabindex='0'>" + (icon ? "<span class='fm-button-icon " + ($self.jqGrid("getIconRes", icon) || icon) + "'></span>" : "") + (text ? "<span class='fm-button-text'>" + text + "</span>" : "") + "</a>";
        },
        "convertOnSaveLocally": function(nData, cm, oData, rowid, item, iCol) {
            var self = this, p = self.p;
            if (p == null) {
                return nData;
            }
            if ($.isFunction(cm.convertOnSave)) {
                return cm.convertOnSave.call(this, {
                    "newValue": nData,
                    "cm": cm,
                    "oldValue": oData,
                    "id": rowid,
                    "item": item,
                    "iCol": iCol
                });
            }
            if (typeof oData !== "boolean" && typeof oData !== "number") {
                return nData;
            }
            if (typeof oData === "boolean" && (cm.edittype === "checkbox" || cm.formatter === "checkbox")) {
                var lnData = String(nData).toLowerCase(), cbv = cm.editoptions != null && typeof cm.editoptions.value === "string" ? cm.editoptions.value.split(":") : [ "yes", "no" ];
                if ($.inArray(lnData, [ "1", "true", cbv[0].toLowerCase() ]) >= 0) {
                    nData = true;
                } else if ($.inArray(lnData, [ "0", "false", cbv[1].toLowerCase() ]) >= 0) {
                    nData = false;
                }
            } else if (typeof oData === "number" && !isNaN(nData)) {
                if (cm.formatter === "number" || cm.formatter === "currency") {
                    nData = parseFloat(nData);
                } else if (cm.formatter === "integer") {
                    nData = parseInt(nData, 10);
                }
            }
            return nData;
        },
        "parseDataToHtml": function(len, ids, items, cellsToDisplay, rcnt, adjust, readAllInputData) {
            var self = this, p = self.p, $self = $(self), i, j, altr, cn1, selr, idr, rd, cells, iStartTrTag, selected = false, rowData = [], grpdata = [], cn = p.altRows === true && !$self.jqGrid("isBootstrapGuiStyle") ? p.altclass : "", hiderow = p.grouping ? p.groupingView.groupCollapse === true : false, rn = parseInt(p.rowNum, 10), cmName, $j = $.fn.jqGrid, rowIndex = p.treeGrid === true && p.treeANode > -1 ? self.rows[p.treeANode].rowIndex + 1 : self.rows.length, formatCol = self.formatCol, addCell = function(rowId, cell, pos, irow, srvr, rdata) {
                var v = self.formatter(rowId, cell, pos, srvr, "add", rdata);
                return "<td role='gridcell' " + formatCol(pos, irow, v, srvr, rowId, rdata) + ">" + v + "</td>";
            }, addMulti = function(rowid, pos, irow, checked, item) {
                var checkboxHtml = "&nbsp;", hasCbox = true;
                if ($.isFunction(p.hasMultiselectCheckBox)) {
                    hasCbox = p.hasMultiselectCheckBox.call(self, {
                        "rowid": rowid,
                        "iRow": irow,
                        "iCol": pos,
                        "data": item
                    });
                }
                if (hasCbox) {
                    checkboxHtml = "<input type='checkbox'" + " id='jqg_" + p.id + "_" + rowid + "' class='cbox' name='jqg_" + p.id + "_" + rowid + "'" + (checked ? " checked='checked' aria-checked='true'" : " aria-checked='false'") + "/>";
                }
                return "<td role='gridcell' " + formatCol(pos, irow, "", null, rowid, true) + ">" + checkboxHtml + "</td>";
            }, addRowNum = function(pos, irow, pG, rN) {
                var v = (parseInt(pG, 10) - 1) * parseInt(rN, 10) + 1 + irow;
                return "<td role='gridcell' class='" + $j.getGuiStyles.call($self, "rowNum", "jqgrid-rownum") + "' " + formatCol(pos, irow, v, null, irow, true) + ">" + v + "</td>";
            };
            if (rowIndex <= 1) {
                p.rowIndexes = {};
            }
            if (p.datatype === "local" && !p.deselectAfterSort || p.multiPageSelection) {
                selected = true;
            }
            if (adjust) {
                rn *= adjust + 1;
            }
            for (i = 0; i < Math.min(len, rn); i++) {
                idr = ids[i];
                rd = items[i];
                cells = cellsToDisplay != null ? cellsToDisplay[i] : rd;
                altr = rcnt === 1 ? 0 : rcnt;
                cn1 = (altr + i) % 2 === 1 ? cn : "";
                if (selected) {
                    if (p.multiselect) {
                        selr = $.inArray(idr, p.selarrrow) !== -1;
                        if (selr && p.selrow === null) {
                            p.selrow = idr;
                        }
                    } else {
                        selr = idr === p.selrow;
                    }
                }
                iStartTrTag = rowData.length;
                rowData.push("");
                for (j = 0; j < p.colModel.length; j++) {
                    cmName = p.colModel[j].name;
                    switch (cmName) {
                      case "rn":
                        rowData.push(addRowNum(j, i, p.page, p.rowNum));
                        break;

                      case "cb":
                        rowData.push(addMulti(idr, j, i, selr, rd));
                        break;

                      case "subgrid":
                        rowData.push($j.addSubGridCell.call($self, j, i + rcnt, idr, rd));
                        break;

                      default:
                        rowData.push(addCell(idr, rd[cmName], j, i + rcnt, cells, rd));
                    }
                }
                rowData[iStartTrTag] = self.constructTr(idr, hiderow, cn1, rd, cells, selr);
                rowData.push("</tr>");
                p.rowIndexes[idr] = rowIndex;
                rowIndex++;
                if (p.grouping && $j.groupingPrepare) {
                    grpdata.push(rowData);
                    if (!p.groupingView._locgr) {
                        $j.groupingPrepare.call($self, rd, i);
                    }
                    rowData = [];
                }
                if (rowData.length > p.maxItemsToJoin) {
                    rowData = [ rowData.join("") ];
                }
            }
            if (p.grouping && $j.groupingRender) {
                if (readAllInputData) {
                    p.groupingView._locgr = true;
                }
                rowData = [ $j.groupingRender.call($self, grpdata, rn) ];
                jgrid.clearArray(grpdata);
            }
            return rowData;
        },
        "getMethod": function(name) {
            return this.getAccessor($.fn.jqGrid, name);
        },
        "extend": function(methods) {
            $.extend($.fn.jqGrid, methods);
            if (!this.no_legacy_api) {
                $.fn.extend(methods);
            }
        }
    });
    var clearArray = jgrid.clearArray, jqID = jgrid.jqID, getGridComponentIdSelector = jgrid.getGridComponentIdSelector, getGridComponentId = jgrid.getGridComponentId, getGridComponent = jgrid.getGridComponent, stripPref = jgrid.stripPref, randId = jgrid.randId, getAccessor = jgrid.getAccessor, convertOnSaveLocally = jgrid.convertOnSaveLocally, stripHtml = jgrid.stripHtml, htmlEncode = jgrid.htmlEncode, htmlDecode = jgrid.htmlDecode, mergeCssClasses = jgrid.mergeCssClasses, hasOneFromClasses = jgrid.hasOneFromClasses, feedback = function() {
        var args = $.makeArray(arguments);
        args.unshift("");
        args.unshift("");
        args.unshift(this.p);
        return jgrid.feedback.apply(this, args);
    };
    $.fn.jqGrid = function(pin) {
        var $j = $.fn.jqGrid, fn;
        if (typeof pin === "string") {
            fn = $j[pin];
            if (!fn) {
                throw "jqGrid - No such method: " + pin;
            }
            return fn.apply(this, $.makeArray(arguments).slice(1));
        }
        return this.each(function() {
            if (this.grid) {
                return;
            }
            var ts = this, localData, localDataStr, $self0 = $(ts), isFunction = $.isFunction, isArray = $.isArray, extend = $.extend, inArray = $.inArray, trim = $.trim, each = $.each, setSelection = $j.setSelection, getGridRes = $j.getGridRes, fatalErrorFunction = isFunction(defaults.fatalError) ? defaults.fatalError : alert, locale = pin.locale || defaults.locale || "en-US", direction = locales[locale] != null && typeof locales[locale].isRTL === "boolean" ? locales[locale].isRTL ? "rtl" : "ltr" : "ltr", iconSet = pin.iconSet || defaults.iconSet || ((pin.guiStyle || defaults.guiStyle) === "bootstrap" || (pin.guiStyle || defaults.guiStyle) === "bootstrapPrimary" ? "glyph" : "jQueryUI"), guiStyle = pin.guiStyle || defaults.guiStyle || "jQueryUI", getIcon = function(path) {
                return $j.getIconRes.call(ts, path);
            }, getGuiStyles = function(path, jqClasses) {
                return $self0.jqGrid("getGuiStyles", path, jqClasses);
            }, stdLoadError = function(jqXHR, textStatus, errorThrown) {
                if (textStatus !== "abort" && errorThrown !== "abort") {
                    var contentType = jqXHR.getResponseHeader("Content-Type"), message = jqXHR.responseText || "", processHtmlError = function(msg) {
                        var div = document.createElement("div"), scripts, i, bodyMatch;
                        bodyMatch = /<body[^>]*>([\s\S]*)<\/body\s*>/gim.exec(msg);
                        div.innerHTML = bodyMatch != null && bodyMatch.length === 2 ? bodyMatch[1] : msg;
                        scripts = div.getElementsByTagName("script");
                        i = scripts.length;
                        while (i--) {
                            scripts[i].parentNode.removeChild(scripts[i]);
                        }
                        msg = div.innerHTML;
                        try {
                            if ($.trim($(msg).text()) === "") {
                                msg = "";
                            }
                        } catch (ignore) {}
                        return msg;
                    }, processJsonError = function(msg) {
                        try {
                            var errorInfo = $.parseJSON(msg), errorMessages = [], errorProp;
                            for (errorProp in errorInfo) {
                                if (errorInfo.hasOwnProperty(errorProp) && errorProp !== "StackTrace") {
                                    errorMessages.push(errorProp + ": " + errorInfo[errorProp]);
                                }
                            }
                            msg = errorMessages.join("<br />");
                        } catch (ignore) {}
                        return msg;
                    };
                    if (contentType === "text/html") {
                        message = processHtmlError(message);
                    } else if (contentType === "application/json") {
                        message = processJsonError(message);
                    } else if (contentType === "text/plain") {
                        message = processJsonError(message);
                    }
                    if (jqXHR.status !== 500 && jqXHR.status !== 0) {
                        message = (textStatus || errorThrown) + (errorThrown && errorThrown !== textStatus ? ": " + errorThrown : "") + " " + jqXHR.status + " " + jqXHR.statusText + (message !== "" ? "<hr />" : "") + message;
                    }
                    $self0.jqGrid("displayErrorMessage", message || textStatus || errorThrown);
                }
            };
            if (pin == null) {
                pin = {
                    "datatype": "local"
                };
            }
            if (pin.datastr !== undefined && isArray(pin.datastr)) {
                localDataStr = pin.datastr;
                pin.datastr = [];
            }
            if (pin.data !== undefined) {
                localData = pin.data;
                pin.data = [];
            }
            if (jgrid.formatter == null || jgrid.formatter.unused == null) {
                fatalErrorFunction("CRITICAL ERROR!!!\n\n\nOne uses probably\n\n\t$.extend($.jgrid.defaults, {...});\n\nto set default settings of jqGrid instead of the usage the DEEP version of jQuery.extend (with true as the first parameter):\n\n\t$.extend(true, $.jgrid.defaults, {...});\n\nOne other possible reason:\n\nyou included some OLD version of language file (grid.locale-en.js for example) AFTER jquery.jqGrid.min.js. For example all language files of jqGrid 4.7.0 uses non-deep call of jQuery.extend.\n\n\nSome options of jqGrid could still work, but another one will be broken.");
            }
            if (pin.datatype === undefined && pin.dataType !== undefined) {
                pin.datatype = pin.dataType;
                delete pin.dataType;
            }
            if (pin.mtype === undefined && pin.type !== undefined) {
                pin.mtype = pin.type;
                delete pin.type;
            }
            ts.p = {
                "iconSet": iconSet
            };
            var p = extend(true, {
                "height": "auto",
                "page": 1,
                "rowNum": 20,
                "maxRowNum": 1e4,
                "autoresizeOnLoad": false,
                "columnsToReResizing": [],
                "autoResizing": {
                    "wrapperClassName": "ui-jqgrid-cell-wrapper",
                    "minColWidth": 33,
                    "maxColWidth": 300,
                    "adjustGridWidth": true,
                    "compact": false,
                    "fixWidthOnShrink": false
                },
                "doubleClickSensitivity": 250,
                "minResizingWidth": 10,
                "rowTotal": null,
                "records": 0,
                "pager": "",
                "pgbuttons": true,
                "pginput": true,
                "colModel": [],
                "additionalProperties": [],
                "arrayReader": [],
                "rowList": [],
                "colNames": [],
                "sortorder": "asc",
                "threeStateSort": false,
                "sortname": "",
                "mtype": "GET",
                "altRows": false,
                "selarrrow": [],
                "savedRow": [],
                "shrinkToFit": true,
                "xmlReader": {},
                "subGrid": false,
                "subGridModel": [],
                "reccount": 0,
                "lastpage": 0,
                "lastsort": 0,
                "selrow": null,
                "singleSelectClickMode": "toggle",
                "beforeSelectRow": null,
                "onSelectRow": null,
                "onSortCol": null,
                "ondblClickRow": null,
                "onRightClickRow": null,
                "onPaging": null,
                "onSelectAll": null,
                "onInitGrid": null,
                "loadComplete": null,
                "gridComplete": null,
                "loadError": stdLoadError,
                "loadBeforeSend": null,
                "afterInsertRow": null,
                "beforeRequest": null,
                "beforeProcessing": null,
                "onHeaderClick": null,
                "viewrecords": false,
                "loadonce": false,
                "forceClientSorting": false,
                "multiselect": false,
                "multikey": false,
                "editurl": "clientArray",
                "search": false,
                "caption": "",
                "hidegrid": true,
                "hiddengrid": false,
                "useUnformattedDataForCellAttr": true,
                "postData": {},
                "userData": {},
                "treeGrid": false,
                "treeGridModel": "nested",
                "treeReader": {},
                "treeANode": -1,
                "ExpandColumn": null,
                "tree_root_level": 0,
                "prmNames": {
                    "page": "page",
                    "rows": "rows",
                    "sort": "sidx",
                    "order": "sord",
                    "search": "_search",
                    "nd": "nd",
                    "id": "id",
                    "oper": "oper",
                    "editoper": "edit",
                    "addoper": "add",
                    "deloper": "del",
                    "subgridid": "id",
                    "npage": null,
                    "totalrows": "totalrows"
                },
                "forceFit": false,
                "gridstate": "visible",
                "cellEdit": false,
                "iCol": -1,
                "iRow": -1,
                "nv": 0,
                "loadui": "enable",
                "toolbar": [ false, "" ],
                "scroll": false,
                "multiboxonly": false,
                "deselectAfterSort": true,
                "multiPageSelection": false,
                "scrollrows": false,
                "autowidth": false,
                "scrollOffset": 18,
                "cellLayout": 5,
                "subGridWidth": 16,
                "multiselectWidth": 16,
                "multiselectPosition": "left",
                "gridview": true,
                "rownumWidth": 25,
                "rownumbers": false,
                "pagerpos": "center",
                "footerrow": false,
                "userDataOnFooter": false,
                "hoverrows": true,
                "altclass": "ui-priority-secondary",
                "viewsortcols": [ false, "vertical", true ],
                "resizeclass": "",
                "autoencode": false,
                "autoEncodeOnEdit": false,
                "remapColumns": [],
                "cmNamesInputOrder": [],
                "ajaxGridOptions": {},
                "direction": direction,
                "toppager": false,
                "headertitles": false,
                "scrollTimeout": 40,
                "maxItemsToJoin": 32768,
                "data": [],
                "lastSelectedData": [],
                "quickEmpty": "quickest",
                "_index": {},
                "iColByName": {},
                "iPropByName": {},
                "reservedColumnNames": [ "rn", "cb", "subgrid" ],
                "grouping": false,
                "groupingView": {
                    "groupField": [],
                    "groupOrder": [],
                    "groupText": [],
                    "groupColumnShow": [],
                    "groupSummary": [],
                    "showSummaryOnHide": false,
                    "sortitems": [],
                    "sortnames": [],
                    "summary": [],
                    "summaryval": [],
                    "displayField": [],
                    "groupSummaryPos": [],
                    "formatDisplayField": [],
                    "_locgr": false,
                    "commonIconClass": getIcon("grouping.common"),
                    "plusicon": getIcon("grouping.plus"),
                    "minusicon": getIcon("grouping.minus")
                },
                "ignoreCase": true,
                "cmTemplate": {},
                "idPrefix": "",
                "iconSet": iconSet,
                "guiStyle": guiStyle,
                "locale": locale,
                "multiSort": false,
                "treeIcons": {
                    "commonIconClass": getIcon("treeGrid.common"),
                    "plusLtr": getIcon("treeGrid.plusLtr"),
                    "plusRtl": getIcon("treeGrid.plusRtl"),
                    "minus": getIcon("treeGrid.minus"),
                    "leaf": getIcon("treeGrid.leaf")
                },
                "subGridOptions": {
                    "commonIconClass": getIcon("subgrid.common"),
                    "plusicon": getIcon("subgrid.plus"),
                    "minusicon": getIcon("subgrid.minus")
                }
            }, defaults, {
                "navOptions": extend(true, {
                    "commonIconClass": getIcon("nav.common"),
                    "editicon": getIcon("nav.edit"),
                    "addicon": getIcon("nav.add"),
                    "delicon": getIcon("nav.del"),
                    "searchicon": getIcon("nav.search"),
                    "refreshicon": getIcon("nav.refresh"),
                    "viewicon": getIcon("nav.view"),
                    "saveicon": getIcon("nav.save"),
                    "cancelicon": getIcon("nav.cancel"),
                    "buttonicon": getIcon("nav.newbutton")
                }, jgrid.nav || {}),
                "actionsNavOptions": extend(true, {
                    "commonIconClass": getIcon("actions.common"),
                    "editicon": getIcon("actions.edit"),
                    "delicon": getIcon("actions.del"),
                    "saveicon": getIcon("actions.save"),
                    "cancelicon": getIcon("actions.cancel")
                }, jgrid.actionsNav || {}),
                "formEditing": extend(true, {
                    "commonIconClass": getIcon("form.common"),
                    "prevIcon": getIcon("form.prev"),
                    "nextIcon": getIcon("form.next"),
                    "saveicon": [ true, "left", getIcon("form.save") ],
                    "closeicon": [ true, "left", getIcon("form.undo") ]
                }, jgrid.edit || {}),
                "searching": extend(true, {
                    "commonIconClass": getIcon("search.common"),
                    "findDialogIcon": getIcon("search.search"),
                    "resetDialogIcon": getIcon("search.reset"),
                    "queryDialogIcon": getIcon("search.query")
                }, jgrid.search || {}),
                "formViewing": extend(true, {
                    "commonIconClass": getIcon("form.common"),
                    "prevIcon": getIcon("form.prev"),
                    "nextIcon": getIcon("form.next"),
                    "closeicon": [ true, "left", getIcon("form.cancel") ]
                }, jgrid.view || {}),
                "formDeleting": extend(true, {
                    "commonIconClass": getIcon("form.common"),
                    "delicon": [ true, "left", getIcon("form.del") ],
                    "cancelicon": [ true, "left", getIcon("form.cancel") ]
                }, jgrid.del || {})
            }, pin || {}), getRes = function(path) {
                return getGridRes.call($self0, path);
            }, getDef = function(path) {
                var gridParam = jgrid.getRes(p, path);
                return gridParam !== undefined ? gridParam : getGridRes.call($self0, "defaults." + path);
            };
            p.recordpos = p.recordpos || (p.direction === "rtl" ? "left" : "right");
            p.subGridOptions.openicon = p.direction === "rtl" ? getIcon("subgrid.openRtl") : getIcon("subgrid.openLtr");
            p.autoResizing.widthOfVisiblePartOfSortIcon = p.autoResizing.widthOfVisiblePartOfSortIcon !== undefined ? p.autoResizing.widthOfVisiblePartOfSortIcon : p.iconSet === "fontAwesome" ? 13 : 12;
            p.datatype = p.datatype !== undefined ? p.datatype : localData !== undefined || p.url == null ? "local" : p.jsonReader != null && typeof p.jsonReader === "object" ? "json" : "xml";
            p.jsonReader = p.jsonReader || {};
            p.url = p.url || "";
            p.cellsubmit = p.cellsubmit !== undefined ? p.cellsubmit : p.cellurl === undefined ? "clientArray" : "remote";
            p.gridview = p.gridview !== undefined ? p.gridview : p.afterInsertRow == null;
            if (localData !== undefined) {
                p.data = localData;
                pin.data = localData;
            }
            if (localDataStr !== undefined) {
                p.datastr = localDataStr;
                pin.datastr = localDataStr;
            }
            if (ts.tagName.toUpperCase() !== "TABLE") {
                fatalErrorFunction("Element is not a table!");
                return;
            }
            if (ts.id === "") {
                $self0.attr("id", randId());
            }
            if (document.documentMode !== undefined) {
                if (document.documentMode <= 5) {
                    fatalErrorFunction("Grid can not be used in this ('quirks') mode!");
                    return;
                }
            }
            $self0.empty().attr("tabindex", "0");
            ts.p = p;
            p.id = ts.id;
            p.idSel = "#" + jqID(ts.id);
            p.gBoxId = getGridComponentId.call(ts, COMPONENT_NAMES.GRID_BOX_DIV);
            p.gBox = getGridComponentIdSelector.call(ts, COMPONENT_NAMES.GRID_BOX_DIV);
            p.gViewId = getGridComponentId.call(ts, COMPONENT_NAMES.GRID_VIEW_DIV);
            p.gView = getGridComponentIdSelector.call(ts, COMPONENT_NAMES.GRID_VIEW_DIV);
            p.rsId = getGridComponentId.call(ts, COMPONENT_NAMES.COLUMN_RESIZER_DIV);
            p.rs = getGridComponentIdSelector.call(ts, COMPONENT_NAMES.COLUMN_RESIZER_DIV);
            p.cbId = getGridComponentId.call(ts, COMPONENT_NAMES.HEADER_SELECT_ALL_ROWS_CHECKBOX);
            p.cb = getGridComponentIdSelector.call(ts, COMPONENT_NAMES.HEADER_SELECT_ALL_ROWS_CHECKBOX);
            var fixScrollOffsetAndhBoxPadding = jgrid.fixScrollOffsetAndhBoxPadding, buildColNameMap = function(colModel) {
                var m = {}, i, n = colModel.length;
                for (i = 0; i < n; i++) {
                    m[colModel[i].name] = i;
                }
                return m;
            }, buildAddPropMap = function(additionalProperties) {
                var m = {}, i, n = additionalProperties.length, addPropInfo;
                for (i = 0; i < n; i++) {
                    addPropInfo = additionalProperties[i];
                    m[typeof addPropInfo === "string" ? addPropInfo : addPropInfo.name] = i;
                }
                return m;
            }, rebuildRowIndexes = function() {
                var rowIndexes = {}, row, i;
                this.p.rowIndexes = rowIndexes;
                for (i = 0; i < this.rows.length; i++) {
                    row = this.rows[i];
                    if ($(row).hasClass("jqgrow")) {
                        rowIndexes[row.id] = row.rowIndex;
                    }
                }
            }, buildArrayReader = function() {
                var i, colModel = p.colModel, cmNamesInputOrder = p.cmNamesInputOrder, additionalProperties = p.additionalProperties, n = cmNamesInputOrder.length, arrayReaderInfos, name, index, order;
                p.arrayReaderInfos = {};
                arrayReaderInfos = p.arrayReaderInfos;
                for (order = 0; order < n; order++) {
                    name = cmNamesInputOrder[order];
                    if (inArray(name, p.reservedColumnNames) < 0 && !arrayReaderInfos.hasOwnProperty(name)) {
                        index = p.iColByName[name];
                        if (index !== undefined) {
                            arrayReaderInfos[name] = {
                                "name": colModel[index].name,
                                "index": index,
                                "order": order,
                                "type": 0
                            };
                        } else {
                            index = p.iPropByName[name];
                            if (index !== undefined) {
                                arrayReaderInfos[name] = {
                                    "name": colModel[index].name,
                                    "index": index,
                                    "order": order,
                                    "type": 1
                                };
                            } else if (name === (p.prmNames.rowidName || "rowid")) {
                                arrayReaderInfos[name] = {
                                    "index": index,
                                    "type": 2
                                };
                            }
                        }
                    }
                }
                n = colModel.length;
                for (i = 0; i < n; i++) {
                    name = colModel[i].name;
                    if (inArray(name, p.reservedColumnNames) < 0 && !arrayReaderInfos.hasOwnProperty(name)) {
                        arrayReaderInfos[name] = {
                            "name": name,
                            "index": i,
                            "order": order,
                            "type": 0
                        };
                        order++;
                    }
                }
                n = additionalProperties.length;
                for (i = 0; i < n; i++) {
                    name = additionalProperties[i];
                    if (name != null && !arrayReaderInfos.hasOwnProperty(name)) {
                        if (typeof name === "object" && $.type(name.name) === "string") {
                            name = name.name;
                        }
                        arrayReaderInfos[name] = {
                            "name": name,
                            "index": i,
                            "order": order,
                            "type": 1
                        };
                        order++;
                    }
                }
            }, myResizerClickHandler = function(e) {
                var pageX = $(this).data("pageX");
                if (pageX) {
                    pageX = String(pageX).split(";");
                    pageX = pageX[pageX.length - 1];
                    $(this).data("pageX", pageX + ";" + e.pageX);
                } else {
                    $(this).data("pageX", e.pageX);
                }
            }, intNum = function(val, defval) {
                val = parseInt(val, 10);
                if (isNaN(val)) {
                    return defval || 0;
                }
                return val;
            }, grid = {
                "headers": [],
                "cols": [],
                "footers": [],
                "dragStart": function(i, x, y, $th) {
                    var self = this, $bDiv = $(self.bDiv), gridOffset = $bDiv.closest(p.gBox).offset(), startX = $th.offset().left + (p.direction === "rtl" ? 0 : self.headers[i].width + (jgrid.cell_width ? 0 : intNum(p.cellLayout, 0)) - 2);
                    self.resizing = {
                        "idx": i,
                        "startX": startX,
                        "sOL": startX,
                        "moved": false,
                        "delta": startX - x.pageX
                    };
                    self.curGbox = $(p.rs);
                    self.curGbox.prependTo("body");
                    self.curGbox.css({
                        "display": "block",
                        "left": startX,
                        "top": y[1] + gridOffset.top + 1,
                        "height": y[2]
                    });
                    self.curGbox.css("height", y[2] - (self.curGbox.outerHeight() - self.curGbox.height()) + "px");
                    self.curGbox.data("idx", i);
                    self.curGbox.data("delta", startX - x.pageX);
                    myResizerClickHandler.call(this.curGbox, x);
                    feedback.call(getGridComponent(COMPONENT_NAMES.BODY_TABLE, $bDiv)[0], "resizeStart", x, i);
                    document.onselectstart = function() {
                        return false;
                    };
                    $(document).bind("mousemove.jqGrid", function(e) {
                        if (grid.resizing) {
                            grid.dragMove(e);
                            return false;
                        }
                    }).bind("mouseup.jqGrid" + p.id, function() {
                        if (grid.resizing) {
                            grid.dragEnd();
                            return false;
                        }
                    });
                },
                "dragMove": function(x) {
                    var self = this, resizing = self.resizing;
                    if (resizing) {
                        var diff = x.pageX + resizing.delta - resizing.startX, headers = self.headers, h = headers[resizing.idx], newWidth = p.direction === "ltr" ? h.width + diff : h.width - diff, hn, nWn, minResizingWidth = ((p.colModel[resizing.idx] || {}).autoResizing || {}).minColWidth || p.minResizingWidth;
                        resizing.moved = true;
                        if (newWidth > minResizingWidth) {
                            if (self.curGbox == null) {
                                self.curGbox = $(p.rs);
                            }
                            self.curGbox.css({
                                "left": resizing.sOL + diff
                            });
                            if (p.forceFit === true) {
                                hn = headers[resizing.idx + p.nv];
                                nWn = p.direction === "ltr" ? hn.width - diff : hn.width + diff;
                                if (nWn > p.autoResizing.minColWidth) {
                                    h.newWidth = newWidth;
                                    hn.newWidth = nWn;
                                }
                            } else {
                                self.newWidth = p.direction === "ltr" ? p.tblwidth + diff : p.tblwidth - diff;
                                h.newWidth = newWidth;
                            }
                        }
                    }
                },
                "resizeColumn": function(idx, skipCallbacks, skipGridAdjustments) {
                    var self = this, headers = self.headers, footers = self.footers, h = headers[idx], hn, nw = h.newWidth || h.width, $bTable = getGridComponent(COMPONENT_NAMES.BODY_TABLE, self.bDiv), $hTable = getGridComponent(COMPONENT_NAMES.HEADER_TABLE, self.hDiv), hCols = $hTable.children("thead").children("tr").first()[0].cells;
                    nw = parseInt(nw, 10);
                    p.colModel[idx].width = nw;
                    h.width = nw;
                    hCols[idx].style.width = nw + "px";
                    self.cols[idx].style.width = nw + "px";
                    if (self.fbRows) {
                        $(self.fbRows[0].cells[idx]).css("width", nw);
                        $(getGridComponent(COMPONENT_NAMES.FROZEN_HEADER_TABLE, self.fhDiv)[0].rows[0].cells[idx]).css("width", nw);
                    }
                    if (footers.length > 0) {
                        footers[idx].style.width = nw + "px";
                    }
                    if (skipGridAdjustments !== true) {
                        fixScrollOffsetAndhBoxPadding.call($bTable[0]);
                    }
                    if (p.forceFit === true) {
                        hn = headers[idx + p.nv];
                        nw = hn.newWidth || hn.width;
                        hn.width = nw;
                        hCols[idx + p.nv].style.width = nw + "px";
                        self.cols[idx + p.nv].style.width = nw + "px";
                        if (footers.length > 0) {
                            footers[idx + p.nv].style.width = nw + "px";
                        }
                        p.colModel[idx + p.nv].width = nw;
                    } else {
                        p.tblwidth = self.newWidth || p.tblwidth;
                        if (skipGridAdjustments !== true) {
                            self.hDiv.scrollLeft = self.bDiv.scrollLeft;
                            if (p.footerrow) {
                                self.sDiv.scrollLeft = self.bDiv.scrollLeft;
                            }
                        }
                    }
                    if (!p.autowidth && (p.widthOrg === undefined || p.widthOrg === "auto" || p.widthOrg === "100%") && skipGridAdjustments !== true) {
                        $j.setGridWidth.call($bTable, self.newWidth + p.scrollOffset, false);
                    }
                    if (!skipCallbacks) {
                        feedback.call($bTable[0], "resizeStop", nw, idx);
                    }
                },
                "dragEnd": function() {
                    var self = this;
                    self.hDiv.style.cursor = "default";
                    if (self.resizing) {
                        if (self.resizing !== null && self.resizing.moved === true) {
                            $(self.headers[self.resizing.idx].el).removeData("autoResized");
                            self.resizeColumn(self.resizing.idx, false);
                        }
                        $(p.rs).removeData("pageX");
                        self.resizing = false;
                        setTimeout(function() {
                            $(p.rs).css("display", "none").prependTo(p.gBox);
                        }, p.doubleClickSensitivity);
                    }
                    self.curGbox = null;
                    document.onselectstart = function() {
                        return true;
                    };
                    $(document).unbind("mousemove.jqGrid").unbind("mouseup.jqGrid" + p.id);
                },
                "populateVisible": function() {
                    var self = this, $self = $(self), gridSelf = self.grid, bDiv = gridSelf.bDiv, $bDiv = $(bDiv);
                    if (gridSelf.timer) {
                        clearTimeout(gridSelf.timer);
                    }
                    gridSelf.timer = null;
                    var dh = $bDiv.height();
                    if (!dh) {
                        return;
                    }
                    var firstDataRow, rh;
                    if (self.rows.length) {
                        try {
                            firstDataRow = self.rows[1];
                            rh = firstDataRow ? $(firstDataRow).outerHeight() || gridSelf.prevRowHeight : gridSelf.prevRowHeight;
                        } catch (pv) {
                            rh = gridSelf.prevRowHeight;
                        }
                    }
                    if (!rh) {
                        return;
                    }
                    gridSelf.prevRowHeight = rh;
                    var rn = p.rowNum;
                    gridSelf.scrollTop = bDiv.scrollTop;
                    var scrollTop = gridSelf.scrollTop;
                    var ttop = Math.round($self.position().top) - scrollTop;
                    var tbot = ttop + $self.height();
                    var div = rh * rn;
                    var page, npage, empty;
                    if (tbot < dh && ttop <= 0 && (p.lastpage === undefined || (parseInt((tbot + scrollTop + div - 1) / div, 10) || 0) <= p.lastpage)) {
                        npage = parseInt((dh - tbot + div - 1) / div, 10) || 1;
                        if (tbot >= 0 || npage < 2 || p.scroll === true) {
                            page = (Math.round((tbot + scrollTop) / div) || 0) + 1;
                            ttop = -1;
                        } else {
                            ttop = 1;
                        }
                    }
                    if (ttop > 0) {
                        page = (parseInt(scrollTop / div, 10) || 0) + 1;
                        npage = (parseInt((scrollTop + dh) / div, 10) || 0) + 2 - page;
                        empty = true;
                    }
                    if (npage) {
                        if (p.lastpage && (page > p.lastpage || p.lastpage === 1 || page === p.page && page === p.lastpage)) {
                            return;
                        }
                        if (gridSelf.hDiv.loading) {
                            gridSelf.timer = setTimeout(function() {
                                gridSelf.populateVisible.call(self);
                            }, p.scrollTimeout);
                        } else {
                            p.page = page;
                            if (empty) {
                                gridSelf.selectionPreserver.call(self);
                                gridSelf.emptyRows.call(self, false, false);
                            }
                            gridSelf.populate.call(self, npage);
                        }
                    }
                },
                "scrollGrid": function() {
                    if (p.scroll) {
                        var scrollTop = this.scrollTop;
                        if (grid.scrollTop === undefined) {
                            grid.scrollTop = 0;
                        }
                        if (scrollTop !== grid.scrollTop) {
                            grid.scrollTop = scrollTop;
                            if (grid.timer) {
                                clearTimeout(grid.timer);
                            }
                            grid.timer = setTimeout(function() {
                                grid.populateVisible.call(ts);
                            }, p.scrollTimeout);
                        }
                    }
                    grid.hDiv.scrollLeft = this.scrollLeft;
                    if (p.footerrow) {
                        grid.sDiv.scrollLeft = this.scrollLeft;
                    }
                    return false;
                },
                "selectionPreserver": function() {
                    var self = this, $self = $(self), sr = p.selrow, sra = p.selarrrow ? $.makeArray(p.selarrrow) : null, bDiv = self.grid.bDiv, left = bDiv.scrollLeft, restoreSelection = function() {
                        var i;
                        p.selrow = null;
                        if (!p.multiPageSelection) {
                            clearArray(p.selarrrow);
                            if (p.multiselect && sra && sra.length > 0) {
                                for (i = 0; i < sra.length; i++) {
                                    if (sra[i] !== sr) {
                                        setSelection.call($self, sra[i], false, null);
                                    }
                                }
                            }
                            if (sr) {
                                setSelection.call($self, sr, false, null);
                            }
                        }
                        bDiv.scrollLeft = left;
                        $self.unbind(".selectionPreserver", restoreSelection);
                    };
                    $self.bind("jqGridGridComplete.selectionPreserver", restoreSelection);
                }
            };
            ts.grid = grid;
            feedback.call(ts, "beforeInitGrid");
            p.iColByName = buildColNameMap(p.colModel);
            p.iPropByName = buildAddPropMap(p.additionalProperties);
            var gv = $("<div class='" + getGuiStyles("gView", "ui-jqgrid-view") + "' role='grid' aria-multiselectable='" + !!p.multiselect + "'></div>"), isMSIE = jgrid.msie, dir;
            p.direction = trim(p.direction.toLowerCase());
            if (inArray(p.direction, [ "ltr", "rtl" ]) === -1) {
                p.direction = "ltr";
            }
            dir = p.direction;
            $(gv).insertBefore(ts);
            $self0.removeClass("scroll").appendTo(gv);
            var eg = $("<div class='" + getGuiStyles("gBox", "ui-jqgrid") + "'></div>");
            $(eg).attr({
                "id": p.gBoxId,
                "dir": dir
            }).insertBefore(gv);
            $(gv).attr("id", p.gViewId).appendTo(eg);
            $("<div class='" + getGuiStyles("overlay", "jqgrid-overlay") + "' id='lui_" + p.id + "'></div>").insertBefore(gv);
            $("<div class='" + getGuiStyles("loading", "loading") + "' id='load_" + p.id + "'>" + getDef("loadtext") + "</div>").insertBefore(gv);
            $self0.attr({
                "role": "presentation",
                "aria-labelledby": "gbox_" + ts.id
            });
            var sortkeys = [ "shiftKey", "altKey", "ctrlKey" ], normalizeRemapColumns = function() {
                var remapColumns = p.remapColumns, colModel = p.colModel, nCol = colModel.length, cmNames = [], i, remappedCmNames, name;
                for (i = 0; i < nCol; i++) {
                    name = colModel[i].name;
                    if (inArray(name, p.reservedColumnNames) < 0) {
                        cmNames.push(name);
                    }
                }
                if (remapColumns != null) {
                    remappedCmNames = cmNames.slice();
                    for (i = 0; i < remapColumns.length; i++) {
                        cmNames[i] = remappedCmNames[remapColumns[i]];
                    }
                }
                p.cmNamesInputOrder = cmNames;
            }, stripGridPrefix = function(rowId) {
                return stripPref(p.idPrefix, rowId);
            }, formatCol = function(pos, rowInd, tv, rawObject, rowId, rdata) {
                var cm = p.colModel[pos], cellAttrFunc, cellValue = tv, rPrefix, result, classes = cm.classes, styleValue = cm.align ? "text-align:" + cm.align + ";" : "", attrStr, matches, value, tilteValue, encodeAttr = function(v) {
                    return typeof v === "string" ? v.replace(/\'/g, "&#39;") : v;
                }, rest = " aria-describedby='" + p.id + "_" + cm.name + "'";
                if (cm.hidden === true) {
                    styleValue += "display:none;";
                }
                if (rowInd === 0) {
                    styleValue += "width: " + grid.headers[pos].width + "px;";
                } else if (isFunction(cm.cellattr) || typeof cm.cellattr === "string" && jgrid.cellattr != null && isFunction(jgrid.cellattr[cm.cellattr])) {
                    cellAttrFunc = isFunction(cm.cellattr) ? cm.cellattr : jgrid.cellattr[cm.cellattr];
                    if (p.useUnformattedDataForCellAttr && rdata != null) {
                        cellValue = rdata[cm.name];
                    } else if (cm.autoResizable) {
                        rPrefix = "<span class='" + p.autoResizing.wrapperClassName + "'>";
                        cellValue = tv.substring(rPrefix.length, tv.length - "</span>".length);
                    }
                    attrStr = cellAttrFunc.call(ts, rowId, cellValue, rawObject, cm, rdata);
                    if (typeof attrStr === "string") {
                        attrStr = attrStr.replace(/\n/g, "&#xA;");
                        while (true) {
                            matches = /^\s*(\w+[\w|\-]*)\s*=\s*([\"|\'])(.*?)\2(.*)/.exec(attrStr);
                            if (matches === null || matches.length < 5) {
                                if (!tilteValue && cm.title) {
                                    tilteValue = cellValue;
                                }
                                return rest + " style='" + encodeAttr(styleValue) + "'" + (classes ? " class='" + encodeAttr(classes) + "'" : "") + (tilteValue ? " title='" + encodeAttr(tilteValue) + "'" : "");
                            }
                            value = matches[3];
                            attrStr = matches[4];
                            switch (matches[1].toLowerCase()) {
                              case "class":
                                if (classes) {
                                    classes += " " + value;
                                } else {
                                    classes = value;
                                }
                                break;

                              case "title":
                                tilteValue = value;
                                break;

                              case "style":
                                styleValue += value;
                                break;

                              default:
                                rest += " " + matches[1] + "=" + matches[2] + value + matches[2];
                                break;
                            }
                        }
                    }
                }
                result = styleValue !== "" ? "style='" + styleValue + "'" : "";
                result += (classes !== undefined ? " class='" + classes + "'" : "") + (cm.title && cellValue ? " title='" + stripHtml(tv).replace(/\'/g, "&apos;") + "'" : "");
                result += rest;
                return result;
            }, cellVal = function(val) {
                return val == null || val === "" ? "&#160;" : p.autoencode ? htmlEncode(val) : String(val);
            }, normalizeTreeGridProperties = function(ldat) {
                var treeReader = p.treeReader, loaded = treeReader.loaded, isLeaf = treeReader.leaf_field, expanded = treeReader.expanded_field, getBool = function(val) {
                    return val === true || val === "true" || val === "1";
                };
                if (p.treeGridModel === "nested" && !ldat[isLeaf]) {
                    var lft = parseInt(ldat[treeReader.left_field], 10), rgt = parseInt(ldat[treeReader.right_field], 10);
                    ldat[isLeaf] = rgt === lft + 1 ? true : false;
                }
                if (ldat[loaded] !== undefined) {
                    ldat[loaded] = getBool(ldat[loaded]);
                }
                ldat[isLeaf] = getBool(ldat[isLeaf]);
                ldat[expanded] = getBool(ldat[expanded]);
            }, formatter = function(rowId, cellval, colpos, rwdat, act, rdata) {
                var cm = p.colModel[colpos], v;
                if (cm.formatter !== undefined) {
                    rowId = String(p.idPrefix) !== "" ? stripGridPrefix(rowId) : rowId;
                    var opts = {
                        "rowId": rowId,
                        "colModel": cm,
                        "gid": p.id,
                        "pos": colpos,
                        "rowData": rdata || rwdat
                    };
                    if (isFunction(cm.cellBuilder)) {
                        v = cm.cellBuilder.call(ts, cellval, opts, rwdat, act);
                    } else if (isFunction(cm.formatter)) {
                        v = cm.formatter.call(ts, cellval, opts, rwdat, act);
                    } else if ($.fmatter) {
                        v = $.fn.fmatter.call(ts, cm.formatter, cellval, opts, rwdat, act);
                    } else {
                        v = cellVal(cellval);
                    }
                } else {
                    v = cellVal(cellval);
                }
                v = cm.autoResizable && cm.formatter !== "actions" ? "<span class='" + p.autoResizing.wrapperClassName + "'>" + v + "</span>" : v;
                if (p.treeGrid && act !== "edit" && (p.ExpandColumn === undefined && colpos === 0 || p.ExpandColumn === cm.name)) {
                    if (rdata == null) {
                        rdata = p.data[p._index[rowId]];
                    }
                    var curLevel = parseInt(rdata[p.treeReader.level_field] || 0, 10), levelOffset = 18, rootLevel = parseInt(p.tree_root_level, 10), lftpos = rootLevel === 0 ? curLevel : curLevel - 1, isLeaf = rdata[p.treeReader.leaf_field], isExpanded = rdata[p.treeReader.expanded_field], icon = rdata[p.treeReader.icon_field], iconClass = isLeaf ? (icon != null && icon !== "" ? icon : p.treeIcons.leaf) + " tree-leaf" : isExpanded ? p.treeIcons.minus + " tree-minus" : p.treeIcons.plus + " tree-plus";
                    v = "<div class='tree-wrap' style='width:" + (lftpos + 1) * levelOffset + "px;'><div class='" + mergeCssClasses(p.treeIcons.commonIconClass, iconClass, "treeclick") + "' style='" + (p.ExpandColClick === true ? "cursor:pointer;" : "") + (p.direction === "rtl" ? "margin-right:" : "margin-left:") + lftpos * levelOffset + "px;'></div></div>" + "<span class='cell-wrapper" + (isLeaf ? "leaf" : "") + "'" + (p.ExpandColClick ? " style='cursor:pointer;'" : "") + ">" + v + "</span>";
                }
                return v;
            }, emptyRows = function(scroll, locdata) {
                var self = this, bDiv = grid.bDiv, frozenTable = grid.fbDiv != null ? grid.fbDiv.children(".ui-jqgrid-btable")[0] : null, removeRows = function(table) {
                    if (!table) {
                        return;
                    }
                    var tableRows = table.rows, firstrow = tableRows[0];
                    if (p.deepempty) {
                        if (tableRows) {
                            $(tableRows).slice(1).remove();
                        }
                    } else if (p.quickEmpty) {
                        if (p.quickEmpty === "quickest") {
                            table.replaceChild(document.createElement("tbody"), table.tBodies[0]);
                            table.firstChild.appendChild(firstrow);
                        } else {
                            while (tableRows.length > 1) {
                                table.deleteRow(tableRows.length - 1);
                            }
                        }
                    } else {
                        $(table.firstChild).empty().append(firstrow);
                    }
                };
                $(self).unbind(".jqGridFormatter");
                removeRows(self);
                removeRows(frozenTable);
                if (scroll && p.scroll) {
                    $(bDiv.firstChild).css({
                        "height": "auto"
                    });
                    $(bDiv.firstChild.firstChild).css({
                        "height": 0,
                        "display": "none"
                    });
                    if (bDiv.scrollTop !== 0) {
                        bDiv.scrollTop = 0;
                    }
                }
                if (locdata === true && p.treeGrid) {
                    clearArray(p.data);
                    clearArray(p.lastSelectedData);
                    p._index = {};
                }
                p.rowIndexes = {};
                p.iRow = -1;
                p.iCol = -1;
            }, normalizeData = function() {
                var data = p.data, dataLength = data.length, i, cur, cells, idName, idIndex, v, rd, id, localReader = p.localReader, additionalProperties = p.additionalProperties, cellName = localReader.cell, cmName, isArrayCells, addProp, info, arrayReaderInfos = p.arrayReaderInfos;
                if (p.datatype !== "local" || localReader.repeatitems !== true) {
                    if (p.treeGrid) {
                        for (i = 0; i < dataLength; i++) {
                            normalizeTreeGridProperties(data[i]);
                        }
                    }
                    return;
                }
                idName = p.keyName === false ? isFunction(localReader.id) ? localReader.id.call(ts, data) : localReader.id : p.keyName;
                if (!isNaN(idName)) {
                    idIndex = Number(idName);
                } else if (!isFunction(idName)) {
                    if (p.arrayReaderInfos[idName] != null) {
                        idIndex = p.arrayReaderInfos[idName].order;
                    }
                }
                for (i = 0; i < dataLength; i++) {
                    cur = data[i];
                    cells = cellName ? getAccessor(cur, cellName) || cur : cur;
                    isArrayCells = isArray(cells);
                    rd = {};
                    for (cmName in arrayReaderInfos) {
                        if (arrayReaderInfos.hasOwnProperty(cmName)) {
                            info = arrayReaderInfos[cmName];
                            v = getAccessor(cells, isArrayCells ? info.order : info.name);
                            if (info.type === 1) {
                                addProp = additionalProperties[info.index];
                                if (addProp != null && isFunction(addProp.convert)) {
                                    v = addProp.convert(v, cells);
                                }
                            }
                            if (v !== undefined) {
                                rd[cmName] = v;
                            }
                        }
                    }
                    if (rd[idName] !== undefined) {
                        id = rd[idName] !== undefined ? rd[idName] : randId();
                    } else {
                        id = getAccessor(cur, isArray(cur) ? idIndex : idName);
                        if (id === undefined) {
                            id = getAccessor(cells, isArray(cells) ? idIndex : idName);
                        }
                        if (id === undefined) {
                            id = randId();
                        }
                    }
                    id = String(id);
                    rd[localReader.id] = id;
                    if (p.treeGrid) {
                        normalizeTreeGridProperties(rd);
                    }
                    extend(data[i], rd);
                }
            }, refreshIndex = function() {
                var datalen = p.data.length, idname, i, val, item;
                if (p.keyName === false || p.loadonce) {
                    idname = p.localReader.id;
                } else {
                    idname = p.keyName;
                }
                p._index = {};
                for (i = 0; i < datalen; i++) {
                    item = p.data[i];
                    val = getAccessor(item, idname);
                    if (val === undefined) {
                        val = String(randId());
                        if (item[idname] === undefined) {
                            item[idname] = val;
                        }
                    }
                    p._index[val] = i;
                }
            }, constructTr = function(id, hide, altClass, rd, cur, selected) {
                var tabindex = "-1", restAttr = "", attrName, style = hide ? "display:none;" : "", self = this, classes = getGuiStyles("gridRow", "jqgrow ui-row-" + p.direction) + (altClass ? " " + altClass : "") + (selected ? " " + getGuiStyles("states.select") : ""), rowAttrObj = $(self).triggerHandler("jqGridRowAttr", [ rd, cur, id ]);
                if (typeof rowAttrObj !== "object") {
                    rowAttrObj = isFunction(p.rowattr) ? p.rowattr.call(self, rd, cur, id) : typeof p.rowattr === "string" && jgrid.rowattr != null && isFunction(jgrid.rowattr[p.rowattr]) ? jgrid.rowattr[p.rowattr].call(self, rd, cur, id) : {};
                }
                if (rowAttrObj != null && !$.isEmptyObject(rowAttrObj)) {
                    if (rowAttrObj.hasOwnProperty("id")) {
                        id = rowAttrObj.id;
                        delete rowAttrObj.id;
                    }
                    if (rowAttrObj.hasOwnProperty("tabindex")) {
                        tabindex = rowAttrObj.tabindex;
                        delete rowAttrObj.tabindex;
                    }
                    if (rowAttrObj.hasOwnProperty("style")) {
                        style += rowAttrObj.style;
                        delete rowAttrObj.style;
                    }
                    if (rowAttrObj.hasOwnProperty("class")) {
                        classes += " " + rowAttrObj["class"];
                        delete rowAttrObj["class"];
                    }
                    try {
                        delete rowAttrObj.role;
                    } catch (ignore) {}
                    for (attrName in rowAttrObj) {
                        if (rowAttrObj.hasOwnProperty(attrName)) {
                            restAttr += " " + attrName + "=" + rowAttrObj[attrName];
                        }
                    }
                }
                if (p.treeGrid) {
                    if (parseInt(rd[p.treeReader.level_field], 10) !== parseInt(p.tree_root_level, 10)) {
                        var pn = $j.getNodeParent.call($(this), rd), expan = pn && pn.hasOwnProperty(p.treeReader.expanded_field) ? pn[p.treeReader.expanded_field] : true;
                        if (!expan && !hide) {
                            style += "display:none;";
                        }
                    }
                }
                return "<tr role='row' id='" + id + "' tabindex='" + tabindex + "' class='" + classes + "'" + (style === "" ? "" : " style='" + style + "'") + restAttr + ">";
            }, finalizationFormatters = function() {
                var i, formatName, fmatter = $.fn.fmatter;
                for (i = 0; i < p.colModel.length; i++) {
                    formatName = p.colModel[i].formatter;
                    if (typeof formatName === "string" && fmatter != null && isFunction(fmatter[formatName]) && isFunction(fmatter[formatName].pageFinalization)) {
                        fmatter[formatName].pageFinalization.call(this, i);
                    }
                }
            }, fillOrClearCellBuilder = function(clear, act) {
                var i, cm, colModel = p.colModel, n = colModel.length, opt, autoencodeCellBuilder = function(v) {
                    return v == null || v === "" ? "&#160;" : htmlEncode(v);
                }, simpleCellBuilder = function(v) {
                    return v == null || v === "" ? "&#160;" : String(v);
                };
                for (i = 0; i < n; i++) {
                    cm = colModel[i];
                    cm.cellBuilder = null;
                    if (!clear) {
                        opt = {
                            "colModel": cm,
                            "gid": p.id,
                            "pos": i
                        };
                        if (cm.formatter === undefined) {
                            cm.cellBuilder = p.autoencode ? autoencodeCellBuilder : simpleCellBuilder;
                        } else if (typeof cm.formatter === "string" && $.fn.fmatter != null && isFunction($.fn.fmatter.getCellBuilder)) {
                            cm.cellBuilder = $.fn.fmatter.getCellBuilder.call(ts, cm.formatter, opt, act || "add");
                        } else if (isFunction(cm.getCellBuilder)) {
                            cm.cellBuilder = cm.getCellBuilder.call(ts, opt, act || "add");
                        }
                    }
                }
            }, readInput = function(data, rcnt, more, adjust) {
                var self = this, $self = $(self), startReq = new Date(), datatype = p.datatype, readAllInputData = datatype !== "local" && p.loadonce || datatype === "xmlstring" || datatype === "jsonstring", isXML = (datatype === "xmlstring" || datatype === "xml") && $.isXMLDoc(data), locid = "_id_", dataReader = p.localReader, fieldReader = getAccessor;
                if (data) {
                    if (datatype === "xml" && !isXML) {
                        return;
                    }
                    if (p.treeANode === -1 && !p.scroll) {
                        grid.emptyRows.call(self, false, true);
                        rcnt = 1;
                    } else {
                        rcnt = rcnt > 1 ? rcnt : 1;
                    }
                } else {
                    return;
                }
                if (readAllInputData) {
                    clearArray(p.data);
                    clearArray(p.lastSelectedData);
                    p._index = {};
                    if (p.grouping && p.groupingView != null) {
                        p.groupingView.groups = [];
                        p.groupingView._locgr = false;
                    }
                    p.localReader.id = locid;
                }
                p.reccount = 0;
                switch (datatype) {
                  case "xml":
                  case "xmlstring":
                    dataReader = p.xmlReader;
                    fieldReader = jgrid.getXmlData;
                    break;

                  case "json":
                  case "jsonp":
                  case "jsonstring":
                    dataReader = p.jsonReader;
                    break;

                  default:
                    break;
                }
                var i, cells, len, drows, idName, idIndex, rd = {}, idr, colModel = p.colModel, nCol = colModel.length, cmName, iChild, children, nChildren, child, arrayReaderInfos = p.arrayReaderInfos, info, preloadedNodes = {}, attrReader = function(nodeName) {
                    return function(obj) {
                        var attrValue = obj != null && isFunction(obj.getAttribute) ? obj.getAttribute(nodeName) : null;
                        return attrValue !== null ? attrValue : undefined;
                    };
                }, nodeReader = function(nodeName) {
                    return function() {
                        var elem = preloadedNodes[nodeName], childNodes;
                        if (elem == null) {
                            return undefined;
                        }
                        childNodes = elem.childNodes;
                        return childNodes.length > 0 ? childNodes[0].nodeValue : undefined;
                    };
                };
                p.page = intNum(fieldReader(data, dataReader.page), p.page);
                p.lastpage = intNum(fieldReader(data, dataReader.total), 1);
                p.records = intNum(fieldReader(data, dataReader.records));
                if (isFunction(dataReader.userdata)) {
                    p.userData = dataReader.userdata.call(self, data) || {};
                } else if (isXML) {
                    fieldReader(data, dataReader.userdata, true).each(function() {
                        p.userData[this.getAttribute("name")] = $(this).text();
                    });
                } else {
                    p.userData = fieldReader(data, dataReader.userdata) || {};
                }
                fillOrClearCellBuilder();
                var colReader = {}, isArrayCells, v, addProp, items, additionalProperties = p.additionalProperties, setSimpleColReaderIfPossible = function(propName, nameReaderOrAddProp) {
                    if (isXML && typeof nameReaderOrAddProp === "string") {
                        if (/^\w+$/.test(nameReaderOrAddProp)) {
                            colReader[propName] = nodeReader(nameReaderOrAddProp);
                        } else if (/^\[\w+\]$/.test(nameReaderOrAddProp)) {
                            colReader[propName] = attrReader(nameReaderOrAddProp.substring(1, nameReaderOrAddProp.length - 1));
                        }
                    }
                }, colReaderFilling = function(colOrAddProp) {
                    var colOrAddPropName = colOrAddProp.name, nameReader = isXML ? colOrAddProp.xmlmap || colOrAddPropName : datatype === "local" && !p.dataTypeOrg || datatype === "jsonstring" || datatype === "json" || datatype === "jsonp" ? colOrAddProp.jsonmap || colOrAddPropName : colOrAddPropName;
                    if (p.keyName !== false && colOrAddProp.key === true) {
                        p.keyName = colOrAddPropName;
                    }
                    if (typeof nameReader === "string" || isFunction(nameReader)) {
                        colReader[colOrAddPropName] = nameReader;
                    }
                    if (!isFunction(nameReader)) {
                        setSimpleColReaderIfPossible(colOrAddPropName, nameReader);
                    }
                };
                for (i = 0; i < nCol; i++) {
                    colReaderFilling(colModel[i]);
                }
                nCol = additionalProperties.length;
                for (i = 0; i < nCol; i++) {
                    addProp = additionalProperties[i];
                    if (typeof addProp === "object" && addProp != null) {
                        colReaderFilling(addProp);
                    } else {
                        setSimpleColReaderIfPossible(addProp, addProp);
                    }
                }
                idName = p.keyName === false ? isFunction(dataReader.id) ? dataReader.id.call(self, data) : dataReader.id : p.keyName;
                if (!isNaN(idName)) {
                    idIndex = Number(idName);
                } else if (!isFunction(idName)) {
                    if (arrayReaderInfos[idName]) {
                        idIndex = arrayReaderInfos[idName].order;
                    }
                    if (isXML) {
                        if (typeof idName === "string" && /^\[\w+\]$/.test(idName)) {
                            idName = attrReader(idName.substring(1, idName.length - 1));
                        } else if (typeof idName === "string" && /^\w+$/.test(idName)) {
                            idName = nodeReader(idName);
                        }
                    }
                }
                drows = fieldReader(data, dataReader.root, true);
                if (dataReader.row) {
                    if (drows.length === 1 && typeof dataReader.row === "string" && /^\w+$/.test(dataReader.row)) {
                        items = [];
                        children = drows[0].childNodes;
                        nChildren = children.length;
                        for (iChild = 0; iChild < nChildren; iChild++) {
                            child = children[iChild];
                            if (child.nodeType === 1 && child.nodeName === dataReader.row) {
                                items.push(child);
                            }
                        }
                        drows = items;
                    } else {
                        drows = fieldReader(drows, dataReader.row, true);
                    }
                }
                if (drows == null && isArray(data)) {
                    drows = data;
                }
                if (!drows) {
                    drows = [];
                }
                len = drows.length;
                if (len > 0 && p.page <= 0) {
                    p.page = 1;
                }
                var rn = parseInt(p.rowNum, 10);
                if (adjust) {
                    rn *= adjust + 1;
                }
                var cellsToDisplay = [], ids = [], id, cur;
                items = [];
                for (i = 0; i < len; i++) {
                    cur = drows[i];
                    cells = dataReader.repeatitems && dataReader.cell ? fieldReader(cur, dataReader.cell, true) || cur : cur;
                    isArrayCells = dataReader.repeatitems && (isXML || isArray(cells));
                    rd = {};
                    preloadedNodes = {};
                    if (isXML && !isArrayCells && cells != null) {
                        children = cells.childNodes;
                        nChildren = children.length;
                        for (iChild = 0; iChild < nChildren; iChild++) {
                            child = children[iChild];
                            if (child.nodeType === 1) {
                                preloadedNodes[child.nodeName] = child;
                            }
                        }
                    }
                    for (cmName in arrayReaderInfos) {
                        if (arrayReaderInfos.hasOwnProperty(cmName)) {
                            info = arrayReaderInfos[cmName];
                            if (isArrayCells) {
                                v = cells[info.order];
                                if (isXML && v != null) {
                                    v = v.textContent || v.text;
                                }
                            } else if (colReader[cmName] != null && typeof colReader[cmName] !== "string") {
                                v = colReader[cmName](cells);
                            } else {
                                v = fieldReader(cells, typeof colReader[cmName] === "string" ? colReader[cmName] : info.name);
                            }
                            if (info.type === 1) {
                                addProp = additionalProperties[info.index];
                                if (addProp != null && isFunction(addProp.convert)) {
                                    v = addProp.convert(v, cells);
                                }
                            }
                            if (v !== undefined) {
                                rd[cmName] = v;
                            }
                        }
                    }
                    if (rd[idName] !== undefined) {
                        id = rd[idName] !== undefined ? rd[idName] : randId();
                    } else {
                        id = fieldReader(cur, isArray(cur) ? idIndex : idName);
                        if (id === undefined) {
                            id = fieldReader(cells, isArray(cells) ? idIndex : idName);
                        }
                        if (id === undefined) {
                            id = randId();
                        }
                    }
                    if (rd[idName] === undefined) {
                        rd[idName] = id;
                    }
                    id = String(id);
                    idr = p.idPrefix + id;
                    if (p.treeGrid) {
                        normalizeTreeGridProperties(rd);
                    }
                    if (i < rn) {
                        ids.push(idr);
                        cellsToDisplay.push(cells);
                        items.push(rd);
                    } else if (!readAllInputData) {
                        break;
                    }
                    if (readAllInputData || p.treeGrid === true) {
                        rd[locid] = id;
                        p.data.push(rd);
                        p._index[rd[locid]] = p.data.length - 1;
                    }
                }
                if (readAllInputData && p.forceClientSorting && p.treeGrid !== true) {
                    return;
                }
                var rowData = jgrid.parseDataToHtml.call(self, len, ids, items, cellsToDisplay, rcnt, adjust, readAllInputData);
                fillOrClearCellBuilder(true);
                var fpos = p.treeANode > -1 ? p.treeANode : 0;
                var $tbody = $(self.tBodies[0]);
                if (p.treeGrid === true && fpos > 0) {
                    $(self.rows[fpos]).after(rowData.join(""));
                } else if (p.scroll) {
                    $tbody.append(rowData.join(""));
                } else if (self.firstElementChild == null || document.documentMode !== undefined && document.documentMode <= 9) {
                    $tbody.html($tbody.html() + rowData.join(""));
                    self.grid.cols = self.rows[0].cells;
                } else {
                    self.firstElementChild.innerHTML += rowData.join("");
                    self.grid.cols = self.rows[0].cells;
                }
                if (p.grouping) {
                    rebuildRowIndexes.call(self);
                }
                if (p.subGrid === true) {
                    try {
                        $j.addSubGrid.call($self, p.iColByName.subgrid);
                    } catch (ignore) {}
                }
                if (p.gridview === false || isFunction(p.afterInsertRow)) {
                    for (i = 0; i < Math.min(len, rn); i++) {
                        feedback.call(self, "afterInsertRow", ids[i], items[i], cellsToDisplay[i]);
                    }
                }
                p.totaltime = new Date() - startReq;
                if (i > 0) {
                    if (p.records === 0) {
                        p.records = len;
                    }
                }
                clearArray(rowData);
                if (p.treeGrid === true) {
                    try {
                        $j.setTreeNode.call($self, fpos + 1, i + fpos + 1);
                    } catch (ignore) {}
                }
                p.reccount = Math.min(len, rn);
                p.treeANode = -1;
                if (p.userDataOnFooter) {
                    $j.footerData.call($self, "set", p.userData, true);
                }
                if (readAllInputData) {
                    p.records = len;
                    p.lastpage = Math.ceil(len / rn);
                }
                if (!more) {
                    self.updatepager(false, true);
                }
                finalizationFormatters.call(self);
            }, addLocalData = function() {
                var $self = $(this), st = p.multiSort ? [] : "", sto = {}, fndsort = false, cmtypes = {}, grtypes = [], grindexes = [], defSrcFormat = getRes("formatter.date.srcformat"), defNewFormat = getRes("formatter.date.newformat");
                if (!isArray(p.data)) {
                    return {};
                }
                if (p.multiSort) {
                    getSortNames(st, sto);
                }
                var grpview = p.grouping ? p.groupingView : false, lengrp, gin, processColModel = function(cm, iCol1, isAddProp) {
                    var srcformat, newformat, grindex = cm.index || cm.name, sorttype = cm.sorttype || "text";
                    cmtypes[cm.name] = {
                        "reader": !p.dataTypeOrg ? cm.jsonmap || cm.name : cm.name,
                        "iCol": iCol1,
                        "stype": sorttype,
                        "srcfmt": "",
                        "newfmt": "",
                        "sfunc": cm.sortfunc || null,
                        "isAddProp": isAddProp === true ? true : false
                    };
                    if (sorttype === "date" || sorttype === "datetime") {
                        if (cm.formatter && typeof cm.formatter === "string" && cm.formatter === "date") {
                            if (cm.formatoptions && cm.formatoptions.srcformat) {
                                srcformat = cm.formatoptions.srcformat;
                            } else {
                                srcformat = defSrcFormat;
                            }
                            if (cm.formatoptions && cm.formatoptions.newformat) {
                                newformat = cm.formatoptions.newformat;
                            } else {
                                newformat = defNewFormat;
                            }
                        } else {
                            srcformat = newformat = cm.datefmt || "Y-m-d";
                        }
                        cmtypes[cm.name].srcfmt = srcformat;
                        cmtypes[cm.name].newfmt = newformat;
                    }
                    if (p.grouping) {
                        for (gin = 0, lengrp = grpview.groupField.length; gin < lengrp; gin++) {
                            if (cm.name === grpview.groupField[gin]) {
                                grtypes[gin] = cmtypes[grindex];
                                grindexes[gin] = grindex;
                            }
                        }
                    }
                    if (!p.multiSort) {
                        if (!fndsort && (cm.index === p.sortname || cm.name === p.sortname)) {
                            st = cm.name;
                            fndsort = true;
                        }
                    }
                };
                each(p.colModel, function(iCol1) {
                    processColModel(this, iCol1);
                });
                each(p.additionalProperties, function(iCol1) {
                    processColModel(typeof this === "string" ? {
                        "name": this
                    } : this, iCol1, true);
                });
                if (p.treeGrid) {
                    $j.SortTree.call($self, st, p.sortorder, cmtypes[st] != null && cmtypes[st].stype ? cmtypes[st].stype : "text", cmtypes[st] != null && cmtypes[st].srcfmt ? cmtypes[st].srcfmt : "");
                    return false;
                }
                var compareFnMap = {
                    "eq": function(queryObj) {
                        return queryObj.equals;
                    },
                    "ne": function(queryObj) {
                        return queryObj.notEquals;
                    },
                    "lt": function(queryObj) {
                        return queryObj.less;
                    },
                    "le": function(queryObj) {
                        return queryObj.lessOrEquals;
                    },
                    "gt": function(queryObj) {
                        return queryObj.greater;
                    },
                    "ge": function(queryObj) {
                        return queryObj.greaterOrEquals;
                    },
                    "cn": function(queryObj) {
                        return queryObj.contains;
                    },
                    "nc": function(queryObj, op) {
                        return op === "OR" ? queryObj.orNot().contains : queryObj.andNot().contains;
                    },
                    "bw": function(queryObj) {
                        return queryObj.startsWith;
                    },
                    "bn": function(queryObj, op) {
                        return op === "OR" ? queryObj.orNot().startsWith : queryObj.andNot().startsWith;
                    },
                    "en": function(queryObj, op) {
                        return op === "OR" ? queryObj.orNot().endsWith : queryObj.andNot().endsWith;
                    },
                    "ew": function(queryObj) {
                        return queryObj.endsWith;
                    },
                    "ni": function(queryObj, op) {
                        return op === "OR" ? queryObj.orNot().equals : queryObj.andNot().equals;
                    },
                    "in": function(queryObj) {
                        return queryObj.equals;
                    },
                    "nu": function(queryObj) {
                        return queryObj.isNull;
                    },
                    "nn": function(queryObj, op) {
                        return op === "OR" ? queryObj.orNot().isNull : queryObj.andNot().isNull;
                    }
                }, query = jgrid.from.call(this, p.data);
                if (p.ignoreCase) {
                    query = query.ignoreCase();
                }
                function tojLinq(group) {
                    var s = 0, index, gor, ror, opr, rule, r, cmi1;
                    if (group.groups != null) {
                        gor = group.groups.length && group.groupOp.toString().toUpperCase() === "OR";
                        if (gor) {
                            query.orBegin();
                        }
                        for (index = 0; index < group.groups.length; index++) {
                            if (s > 0 && gor) {
                                query.or();
                            }
                            try {
                                tojLinq(group.groups[index]);
                            } catch (e) {
                                fatalErrorFunction(e);
                            }
                            s++;
                        }
                        if (gor) {
                            query.orEnd();
                        }
                    }
                    if (group.rules != null) {
                        try {
                            ror = group.rules.length && group.groupOp.toString().toUpperCase() === "OR";
                            if (ror) {
                                query.orBegin();
                            }
                            for (index = 0; index < group.rules.length; index++) {
                                rule = group.rules[index];
                                opr = group.groupOp.toString().toUpperCase();
                                if (compareFnMap[rule.op] && rule.field) {
                                    if (s > 0 && opr && opr === "OR") {
                                        query = query.or();
                                    }
                                    cmi1 = cmtypes[rule.field];
                                    if (cmi1 != null) {
                                        r = cmi1.reader;
                                        query = compareFnMap[rule.op](query, opr)(isFunction(r) ? 'jQuery.jgrid.getAccessor(this,jQuery("' + p.idSel + '")[0].p.colModel[' + cmi1.iCol + "].jsonmap)" : "jQuery.jgrid.getAccessor(this,'" + r + "')", rule.data, cmtypes[rule.field]);
                                    }
                                } else if (p.customSortOperations != null && p.customSortOperations[rule.op] != null && isFunction(p.customSortOperations[rule.op].filter)) {
                                    query = query.custom(rule.op, rule.field, rule.data);
                                }
                                s++;
                            }
                            if (ror) {
                                query.orEnd();
                            }
                        } catch (g) {
                            fatalErrorFunction(g);
                        }
                    }
                }
                if (p.search === true) {
                    var srules = p.postData.filters;
                    if (srules) {
                        if (typeof srules === "string") {
                            srules = $.parseJSON(srules);
                        }
                        tojLinq(srules);
                    } else {
                        try {
                            var cmtypes1 = cmtypes[p.postData.searchField];
                            query = compareFnMap[p.postData.searchOper](query)(isFunction(cmtypes1.reader) ? 'jQuery.jgrid.getAccessor(this,jQuery("' + p.idSel + '")[0].p.colModel[' + cmtypes1.iCol + "].jsonmap)" : "jQuery.jgrid.getAccessor(this,'" + cmtypes1.reader + "')", p.postData.searchString, cmtypes[p.postData.searchField]);
                        } catch (ignore) {}
                    }
                }
                if (p.grouping) {
                    for (gin = 0; gin < lengrp; gin++) {
                        query.orderBy(grindexes[gin], grpview.groupOrder[gin], grtypes[gin].stype, grtypes[gin].srcfmt);
                    }
                }
                if (p.multiSort) {
                    each(st, function() {
                        query.orderBy(this, sto[this], cmtypes[this].stype, cmtypes[this].srcfmt, cmtypes[this].sfunc);
                    });
                } else if (st && p.sortorder && fndsort) {
                    query.orderBy(p.sortname, p.sortorder.toUpperCase() === "DESC" ? "d" : "a", cmtypes[st].stype, cmtypes[st].srcfmt, cmtypes[st].sfunc);
                }
                p.lastSelectedData = query.select();
                var recordsperpage = parseInt(p.rowNum, 10), total = p.lastSelectedData.length, page = parseInt(p.page, 10), totalpages = Math.ceil(total / recordsperpage), retresult = {};
                if (p.grouping && p.groupingView._locgr) {
                    p.groupingView.groups = [];
                    var j, key, udc;
                    if (p.footerrow && p.userDataOnFooter) {
                        for (key in p.userData) {
                            if (p.userData.hasOwnProperty(key)) {
                                p.userData[key] = 0;
                            }
                        }
                        udc = true;
                    }
                    for (j = 0; j < total; j++) {
                        if (udc) {
                            for (key in p.userData) {
                                if (p.userData.hasOwnProperty(key)) {
                                    p.userData[key] += parseFloat(p.lastSelectedData[j][key] || 0);
                                }
                            }
                        }
                        $j.groupingPrepare.call($self, p.lastSelectedData[j], j, recordsperpage);
                    }
                }
                query = null;
                cmtypes = null;
                var localReader = p.localReader;
                retresult[localReader.total] = totalpages;
                retresult[localReader.page] = page;
                retresult[localReader.records] = total;
                retresult[localReader.root] = p.lastSelectedData.slice((page - 1) * recordsperpage, page * recordsperpage);
                retresult[localReader.userdata] = p.userData;
                return retresult;
            }, setWidthOfPagerTdWithPager = function($pgTable) {
                var self = this, width = $pgTable.outerWidth(), fontSize;
                if (width <= 0) {
                    fontSize = $(self).closest(".ui-jqgrid>.ui-jqgrid-view").css("font-size") || "11px";
                    $(document.body).append("<div id='testpg' class='" + getGuiStyles("gBox", "ui-jqgrid") + "' style='font-size:" + fontSize + ";visibility:hidden;margin:0;padding:0;' ></div>");
                    $($pgTable).clone().appendTo("#testpg");
                    width = $("#testpg>.ui-pg-table").width();
                    $("#testpg").remove();
                }
                if (width > 0) {
                    $pgTable.parent().width(width);
                }
                return width;
            }, updatepager = function(rn, dnd) {
                var self = this, $self = $(self), gridSelf = self.grid, cp, last, base1, from, to, tot, fmt, pgboxes = p.pager || "", sppg, tspg = p.pager ? "_" + p.pager.substr(1) : "", bDiv = gridSelf.bDiv, numberFormat = $.fmatter ? $.fmatter.NumberFormat : null, tspgTop = p.toppager ? "_" + p.toppager.substr(1) : "", hoverClasses = getGuiStyles("states.hover"), disabledClasses = getGuiStyles("states.disabled");
                base1 = parseInt(p.page, 10) - 1;
                if (base1 < 0) {
                    base1 = 0;
                }
                base1 = base1 * parseInt(p.rowNum, 10);
                to = base1 + p.reccount;
                if (p.scroll) {
                    var rows = $(getGridComponent(COMPONENT_NAMES.BODY_TABLE, bDiv)[0].rows).slice(1);
                    base1 = to - rows.length;
                    p.reccount = rows.length;
                    var rh = rows.outerHeight() || gridSelf.prevRowHeight;
                    if (rh) {
                        var top = base1 * rh;
                        var height = jgrid.fixMaxHeightOfDiv.call(self, parseInt(p.records, 10) * rh);
                        $(bDiv).children("div").first().css({
                            "height": height + "px"
                        }).children("div").first().css({
                            "height": top + "px",
                            "display": top + "px" ? "" : "none"
                        });
                        if (bDiv.scrollTop === 0 && p.page > 1) {
                            bDiv.scrollTop = p.rowNum * (p.page - 1) * rh;
                        }
                    }
                    bDiv.scrollLeft = gridSelf.hDiv.scrollLeft;
                }
                pgboxes += p.toppager ? (pgboxes ? "," : "") + p.toppager : "";
                if (pgboxes) {
                    fmt = getRes("formatter.integer") || {};
                    cp = intNum(p.page);
                    last = intNum(p.lastpage);
                    $(".selbox", pgboxes).prop("disabled", false);
                    if (p.pginput === true) {
                        $(".ui-pg-input", pgboxes).val(p.page);
                        sppg = p.toppager ? "#sp_1" + tspg + ",#sp_1" + tspgTop : "#sp_1" + tspg;
                        $(sppg).html($.fmatter ? numberFormat(p.lastpage, fmt) : p.lastpage).closest(".ui-pg-table").each(function() {
                            setWidthOfPagerTdWithPager.call(self, $(this));
                        });
                    }
                    if (p.viewrecords) {
                        if (p.reccount === 0) {
                            $(".ui-paging-info", pgboxes).html(getDef("emptyrecords"));
                        } else {
                            from = base1 + 1;
                            tot = p.records;
                            if ($.fmatter) {
                                from = numberFormat(from, fmt);
                                to = numberFormat(to, fmt);
                                tot = numberFormat(tot, fmt);
                            }
                            $(".ui-paging-info", pgboxes).html(jgrid.format(getDef("recordtext"), from, to, tot));
                        }
                    }
                    if (p.pgbuttons === true) {
                        if (last <= 0) {
                            cp = 0;
                        }
                        if (cp <= 0) {
                            cp = last = 0;
                        }
                        if (cp === 1 || cp === 0) {
                            $("#first" + tspg + ", #prev" + tspg).addClass(disabledClasses).removeClass(hoverClasses);
                            if (p.toppager) {
                                $("#first_t" + tspgTop + ", #prev_t" + tspgTop).addClass(disabledClasses).removeClass(hoverClasses);
                            }
                        } else {
                            $("#first" + tspg + ", #prev" + tspg).removeClass(disabledClasses);
                            if (p.toppager) {
                                $("#first_t" + tspgTop + ", #prev_t" + tspgTop).removeClass(disabledClasses);
                            }
                        }
                        if (cp === last || cp === 0) {
                            $("#next" + tspg + ", #last" + tspg).addClass(disabledClasses).removeClass(hoverClasses);
                            if (p.toppager) {
                                $("#next_t" + tspgTop + ", #last_t" + tspgTop).addClass(disabledClasses).removeClass(hoverClasses);
                            }
                        } else {
                            $("#next" + tspg + ", #last" + tspg).removeClass(disabledClasses);
                            if (p.toppager) {
                                $("#next_t" + tspgTop + ", #last_t" + tspgTop).removeClass(disabledClasses);
                            }
                        }
                    }
                }
                if (rn === true && p.rownumbers === true) {
                    $(">td.jqgrid-rownum", self.rows).each(function(i) {
                        $(this).html(base1 + 1 + i);
                    });
                }
                if (dnd && p.jqgdnd) {
                    $self.jqGrid("gridDnD", "updateDnD");
                }
                feedback.call(self, "gridComplete");
                $self.triggerHandler("jqGridAfterGridComplete");
            }, beginReq = function() {
                var self = this;
                self.grid.hDiv.loading = true;
                if (p.hiddengrid) {
                    return;
                }
                $j.progressBar.call($(self), {
                    "method": "show",
                    "loadtype": p.loadui,
                    "htmlcontent": getDef("loadtext")
                });
            }, endReq = function() {
                var self = this;
                self.grid.hDiv.loading = false;
                $j.progressBar.call($(self), {
                    "method": "hide",
                    "loadtype": p.loadui
                });
            }, populate = function(npage) {
                var self = this, $self = $(self), gridSelf = self.grid;
                if (!gridSelf.hDiv.loading) {
                    var pvis = p.scroll && npage === false, prm = {}, dt, dstr, pN = p.prmNames;
                    if (p.page <= 0) {
                        p.page = Math.min(1, p.lastpage);
                    }
                    if (pN.search !== null) {
                        prm[pN.search] = p.search;
                    }
                    if (pN.nd !== null) {
                        prm[pN.nd] = new Date().getTime();
                    }
                    if (isNaN(parseInt(p.rowNum, 10)) || parseInt(p.rowNum, 10) <= 0) {
                        p.rowNum = p.maxRowNum;
                    }
                    if (pN.rows !== null) {
                        prm[pN.rows] = p.rowNum;
                    }
                    if (pN.page !== null) {
                        prm[pN.page] = p.page;
                    }
                    if (pN.sort !== null) {
                        prm[pN.sort] = p.sortname;
                    }
                    if (pN.order !== null) {
                        prm[pN.order] = p.sortorder;
                    }
                    if (p.rowTotal !== null && pN.totalrows !== null) {
                        prm[pN.totalrows] = p.rowTotal;
                    }
                    var lcf = isFunction(p.loadComplete), lc = lcf ? p.loadComplete : null;
                    var adjust = 0;
                    npage = npage || 1;
                    if (npage > 1) {
                        if (pN.npage !== null) {
                            prm[pN.npage] = npage;
                            adjust = npage - 1;
                            npage = 1;
                        } else {
                            lc = function(data) {
                                p.page++;
                                gridSelf.hDiv.loading = false;
                                if (lcf) {
                                    p.loadComplete.call(self, data);
                                }
                                populate.call(self, npage - 1);
                            };
                        }
                    } else if (pN.npage !== null) {
                        delete p.postData[pN.npage];
                    }
                    if (p.grouping && $j.groupingSetup) {
                        $j.groupingSetup.call($self);
                        var grp = p.groupingView, gi, gs = "", index, iColumn, cmValue;
                        for (gi = 0; gi < grp.groupField.length; gi++) {
                            index = grp.groupField[gi];
                            for (iColumn = 0; iColumn < p.colModel.length; iColumn++) {
                                cmValue = p.colModel[iColumn];
                                if (cmValue.name === index && cmValue.index) {
                                    index = cmValue.index;
                                }
                            }
                            gs += index + " " + grp.groupOrder[gi] + ", ";
                        }
                        prm[pN.sort] = gs + prm[pN.sort];
                    }
                    extend(p.postData, prm);
                    var rcnt = !p.scroll ? 1 : self.rows.length - 1, fixDisplayingHorizontalScrollbar = function() {
                        fixScrollOffsetAndhBoxPadding.call(self);
                        var gBodyWidth = $self.width(), gViewWidth = $self.closest(".ui-jqgrid-view").width(), gridCssHeight = $self.css("height");
                        if (gViewWidth < gBodyWidth && p.reccount === 0) {
                            $self.css("height", "1px");
                        } else if (gridCssHeight !== "0" && gridCssHeight !== "0px") {
                            $self.css("height", "");
                        }
                        if (!p.autowidth && (p.widthOrg === undefined || p.widthOrg === "auto" || p.widthOrg === "100%")) {
                            $j.setGridWidth.call($self, p.tblwidth + p.scrollOffset, false);
                        }
                    }, resort = function() {
                        var iRes;
                        if (p.autoresizeOnLoad) {
                            $j.autoResizeAllColumns.call($self);
                            clearArray(p.columnsToReResizing);
                        } else {
                            for (iRes = 0; iRes < p.columnsToReResizing.length; iRes++) {
                                $j.autoResizeColumn.call($self, p.columnsToReResizing[iRes]);
                            }
                            clearArray(p.columnsToReResizing);
                        }
                    }, finalReportSteps = function() {
                        feedback.call(self, "loadComplete", dstr);
                        resort();
                        $self.triggerHandler("jqGridAfterLoadComplete", [ dstr ]);
                        endReq.call(self);
                        p.datatype = "local";
                        p.datastr = null;
                        fixDisplayingHorizontalScrollbar();
                    }, finalReportVirtual = function(data) {
                        $self.triggerHandler("jqGridLoadComplete", [ data ]);
                        if (lc) {
                            lc.call(self, data);
                        }
                        resort();
                        $self.triggerHandler("jqGridAfterLoadComplete", [ data ]);
                        if (pvis) {
                            gridSelf.populateVisible.call(self);
                        }
                        if (npage === 1) {
                            endReq.call(self);
                        }
                        fixDisplayingHorizontalScrollbar();
                    }, readLocal = function() {
                        var req = addLocalData.call(self);
                        readInput.call(self, req, rcnt, npage > 1, adjust);
                        finalReportVirtual(req);
                    };
                    if (!feedback.call(self, "beforeRequest")) {
                        return;
                    }
                    if (isFunction(p.datatype)) {
                        p.datatype.call(self, p.postData, "load_" + p.id, rcnt, npage, adjust);
                        return;
                    }
                    dt = p.datatype.toLowerCase();
                    $(grid.eDiv).hide();
                    switch (dt) {
                      case "json":
                      case "jsonp":
                      case "xml":
                      case "script":
                        $.ajax(extend({
                            "url": p.url,
                            "type": p.mtype,
                            "dataType": dt,
                            "data": jgrid.serializeFeedback.call(ts, p.serializeGridData, "jqGridSerializeGridData", p.postData),
                            "success": function(data, textStatus, jqXHR) {
                                p.jqXhr = null;
                                $(grid.eDiv).hide();
                                if (isFunction(p.beforeProcessing)) {
                                    if (p.beforeProcessing.call(self, data, textStatus, jqXHR) === false) {
                                        endReq.call(self);
                                        return;
                                    }
                                }
                                readInput.call(self, data, rcnt, npage > 1, adjust);
                                finalReportVirtual(data);
                                if (p.loadonce || p.treeGrid) {
                                    p.dataTypeOrg = p.datatype;
                                    p.datatype = "local";
                                    if (p.forceClientSorting) {
                                        readLocal();
                                    }
                                }
                            },
                            "error": function(jqXHR, textStatus, errorThrown) {
                                p.jqXhr = null;
                                if (isFunction(p.loadError)) {
                                    p.loadError.call(self, jqXHR, textStatus, errorThrown);
                                }
                                if (npage === 1) {
                                    endReq.call(self);
                                }
                            },
                            "beforeSend": function(jqXHR, settings) {
                                var gotoreq = true;
                                if (isFunction(p.loadBeforeSend)) {
                                    gotoreq = p.loadBeforeSend.call(self, jqXHR, settings);
                                }
                                if (gotoreq === undefined) {
                                    gotoreq = true;
                                }
                                if (gotoreq === false) {
                                    return false;
                                }
                                p.jqXhr = jqXHR;
                                beginReq.call(self);
                            }
                        }, jgrid.ajaxOptions, p.ajaxGridOptions));
                        break;

                      case "xmlstring":
                        beginReq.call(self);
                        dstr = typeof p.datastr === "string" ? $.parseXML(p.datastr) : p.datastr;
                        readInput.call(self, dstr);
                        finalReportSteps();
                        if (p.forceClientSorting) {
                            readLocal();
                        }
                        break;

                      case "jsonstring":
                        beginReq.call(self);
                        dstr = p.datastr && typeof p.datastr === "string" ? $.parseJSON(p.datastr) : p.datastr;
                        readInput.call(self, dstr);
                        finalReportSteps();
                        if (p.forceClientSorting) {
                            readLocal();
                        }
                        break;

                      case "local":
                      case "clientside":
                        beginReq.call(self);
                        p.datatype = "local";
                        readLocal();
                        break;
                    }
                }
            }, setHeadCheckBox = function(checked) {
                var self = this, gridSelf = self.grid;
                $(p.cb, gridSelf.hDiv).prop("checked", checked);
                if (p.frozenColumns) {
                    $(p.cb, gridSelf.fhDiv).prop("checked", checked);
                }
            }, setPager = function(pgid, tp) {
                var hoverClasses = getGuiStyles("states.hover"), disabledClasses = getGuiStyles("states.disabled"), sep = "<td class='ui-pg-button " + disabledClasses + "'><span class='ui-separator'></span></td>", pginp = "", blockAlign = p.pagerpos === "left" ? "margin-right:auto;" : p.pagerpos === "right" ? "margin-left:auto;" : "margin-left:auto;margin-right:auto;", pgl = "<table " + "style='table-layout:auto;white-space: pre;" + blockAlign + "' class='ui-pg-table'><tbody><tr>", str = "", pgcnt, lft, cent, rgt, twd, i, clearVals = function(onpaging, newPage, newRowNum) {
                    if (!feedback.call(ts, "onPaging", onpaging, {
                        "newPage": newPage,
                        "currentPage": intNum(p.page, 1),
                        "lastPage": intNum(p.lastpage, 1),
                        "currentRowNum": intNum(p.rowNum, 10),
                        "newRowNum": newRowNum
                    })) {
                        return false;
                    }
                    p.selrow = null;
                    if (p.multiselect) {
                        if (!p.multiPageSelection) {
                            clearArray(p.selarrrow);
                        }
                        setHeadCheckBox.call(ts, false);
                    }
                    clearArray(p.savedRow);
                    return true;
                };
                tp += "_" + pgid;
                pgcnt = "pg_" + pgid;
                lft = pgid + "_left";
                cent = pgid + "_center";
                rgt = pgid + "_right";
                $("#" + jqID(pgid)).append("<div id='" + pgcnt + "' class='ui-pager-control' role='group'><table class='ui-pg-table' style='width:100%;table-layout:fixed;height:100%;'><tbody><tr>" + "<td id='" + lft + "' style='text-align:left;" + (p.pagerLeftWidth !== undefined ? "width:" + p.pagerLeftWidth + "px;" : "") + "'></td>" + "<td id='" + cent + "' style='text-align:center;white-space:pre;" + (p.pagerCenterWidth !== undefined ? "width:" + p.pagerCenterWidth + "px;" : "") + "'></td>" + "<td id='" + rgt + "' style='text-align:right;" + (p.pagerRightWidth !== undefined ? "width:" + p.pagerRightWidth + "px;" : "") + "'></td></tr></tbody></table></div>").attr("dir", "ltr");
                pgcnt = "#" + jqID(pgcnt);
                if (p.rowList.length > 0) {
                    str = "<td dir='" + dir + "'>";
                    var pgrecs = getDef("pgrecs");
                    str += "<select class='" + getGuiStyles("pager.pagerSelect", "ui-pg-selbox") + "' " + (pgrecs ? "title='" + pgrecs + "'" : "") + ">";
                    var strnm;
                    for (i = 0; i < p.rowList.length; i++) {
                        strnm = p.rowList[i].toString().split(":");
                        if (strnm.length === 1) {
                            strnm[1] = strnm[0];
                        }
                        str += "<option value='" + strnm[0] + "'" + (intNum(p.rowNum, 0) === intNum(strnm[0], 0) ? " selected='selected'" : "") + ">" + strnm[1] + "</option>";
                    }
                    str += "</select></td>";
                }
                if (dir === "rtl") {
                    pgl += str;
                }
                if (p.pginput === true) {
                    pginp = "<td dir='" + dir + "'>" + jgrid.format(getDef("pgtext") || "", "<input class='" + getGuiStyles("pager.pagerInput", "ui-pg-input") + "' type='text' size='2' maxlength='7' value='0'/>", "<span id='sp_1_" + pgid + "'>0</span>") + "</td>";
                }
                pgid = "#" + jqID(pgid);
                if (p.pgbuttons === true) {
                    var po = [ "first", "prev", "next", "last" ], buttonClasses = getGuiStyles("pager.pagerButton", "ui-pg-button"), buildPagerButton = function(buttonName) {
                        var titleText = getDef("pg" + buttonName);
                        return "<td role='button' tabindex='0' id='" + buttonName + tp + "' class='" + buttonClasses + "' " + (titleText ? "title='" + titleText + "'" : "") + "><span class='" + getIcon("pager." + buttonName) + "'></span></td>";
                    };
                    if (dir === "rtl") {
                        po.reverse();
                    }
                    for (i = 0; i < po.length; i++) {
                        pgl += buildPagerButton(po[i]);
                        if (i === 1) {
                            pgl += pginp !== "" ? sep + pginp + sep : "";
                        }
                    }
                } else if (pginp !== "") {
                    pgl += pginp;
                }
                if (dir === "ltr") {
                    pgl += str;
                }
                pgl += "</tr></tbody></table>";
                if (p.viewrecords === true) {
                    $("td" + pgid + "_" + p.recordpos, pgcnt).append("<span dir='" + dir + "' style='text-align:" + p.recordpos + "' class='ui-paging-info'></span>");
                }
                var $pagerIn = $("td" + pgid + "_" + p.pagerpos, pgcnt);
                $pagerIn.append(pgl);
                twd = setWidthOfPagerTdWithPager.call(this, $pagerIn.children(".ui-pg-table"));
                p._nvtd = [];
                p._nvtd[0] = twd ? Math.floor((p.width - twd) / 2) : Math.floor(p.width / 3);
                p._nvtd[1] = 0;
                pgl = null;
                $(".ui-pg-selbox", pgcnt).bind("change", function() {
                    var newRowNum = intNum(this.value, 10), newPage = Math.round(p.rowNum * (p.page - 1) / newRowNum - .5) + 1;
                    if (!clearVals("records", newPage, newRowNum)) {
                        return false;
                    }
                    p.page = newPage;
                    p.rowNum = newRowNum;
                    if (p.pager) {
                        $(".ui-pg-selbox", p.pager).val(newRowNum);
                    }
                    if (p.toppager) {
                        $(".ui-pg-selbox", p.toppager).val(newRowNum);
                    }
                    populate.call(ts);
                    return false;
                });
                if (p.pgbuttons === true) {
                    $(".ui-pg-button", pgcnt).hover(function() {
                        if (hasOneFromClasses(this, disabledClasses)) {
                            this.style.cursor = "default";
                        } else {
                            $(this).addClass(hoverClasses);
                            this.style.cursor = "pointer";
                        }
                    }, function() {
                        if (!hasOneFromClasses(this, disabledClasses)) {
                            $(this).removeClass(hoverClasses);
                            this.style.cursor = "default";
                        }
                    });
                    $("#first" + jqID(tp) + ", #prev" + jqID(tp) + ", #next" + jqID(tp) + ", #last" + jqID(tp)).click(function() {
                        if (hasOneFromClasses(this, disabledClasses)) {
                            return false;
                        }
                        var cp = intNum(p.page, 1), newPage = cp, onpaging = this.id, last = intNum(p.lastpage, 1), selclick = false, fp = true, pp = true, np = true, lp = true;
                        if (last === 0 || last === 1) {
                            if (cp <= 1) {
                                fp = false;
                                pp = false;
                            }
                            np = false;
                            lp = false;
                        } else if (last > 1 && cp >= 1) {
                            if (cp === 1) {
                                fp = false;
                                pp = false;
                            } else if (cp === last) {
                                np = false;
                                lp = false;
                            }
                        } else if (last > 1 && cp === 0) {
                            np = false;
                            lp = false;
                            cp = last - 1;
                        }
                        if (this.id === "first" + tp && fp) {
                            onpaging = "first";
                            newPage = 1;
                            selclick = true;
                        }
                        if (this.id === "prev" + tp && pp) {
                            onpaging = "prev";
                            newPage = cp - 1;
                            selclick = true;
                        }
                        if (this.id === "next" + tp && np) {
                            onpaging = "next";
                            newPage = cp + 1;
                            selclick = true;
                        }
                        if (this.id === "last" + tp && lp) {
                            onpaging = "last";
                            newPage = last;
                            selclick = true;
                        }
                        if (!clearVals(onpaging, newPage, intNum(p.rowNum, 10))) {
                            return false;
                        }
                        p.page = newPage;
                        if (selclick) {
                            populate.call(ts);
                        }
                        return false;
                    });
                }
                if (p.pginput === true) {
                    $("input.ui-pg-input", pgcnt).bind("keypress.jqGrid", function(e) {
                        var key = e.charCode || e.keyCode || 0, newPage = intNum($(this).val(), 1);
                        if (key === 13) {
                            if (!clearVals("user", newPage, intNum(p.rowNum, 10))) {
                                return false;
                            }
                            $(this).val(newPage);
                            p.page = $(this).val() > 0 ? $(this).val() : p.page;
                            populate.call(ts);
                            return false;
                        }
                        return this;
                    });
                }
                $pagerIn.children(".ui-pg-table").bind("keydown.jqGrid", function(e) {
                    var $focused;
                    if (e.which === 13) {
                        $focused = $pagerIn.find(":focus");
                        if ($focused.length > 0) {
                            $focused.trigger("click");
                        }
                    }
                });
            }, getSortNames = function(sortNames, sortDirs, cm) {
                each((p.sortname + " " + p.sortorder).split(","), function() {
                    var s = $.trim(this).split(" ");
                    if (s.length === 2) {
                        sortNames.push(s[0]);
                    }
                });
                if (cm != null) {
                    var i = $.inArray(cm.index || cm.name, sortNames);
                    if (cm.lso !== "" && i < 0) {
                        sortNames.push(cm.index || cm.name);
                    } else if (cm.lso === "" && i >= 0) {
                        sortNames.splice(i, 1);
                    }
                }
                each(p.colModel, function() {
                    var sortName = this.index || this.name, splas;
                    if (this.lso) {
                        splas = this.lso.split("-");
                        if ($.inArray(sortName, sortNames) < 0) {
                            sortNames.push(sortName);
                        }
                        sortDirs[sortName] = splas[splas.length - 1];
                    }
                });
            }, multiSort = function(iCol1, obj) {
                var sort1 = "", cm = p.colModel[iCol1], so, disabledClasses = getGuiStyles("states.disabled"), $selTh = p.frozenColumns ? $(obj) : $(ts.grid.headers[iCol1].el), $iconsSpan = $selTh.find("span.s-ico"), $iconAsc = $iconsSpan.children("span.ui-icon-asc"), $iconDesc = $iconsSpan.children("span.ui-icon-desc"), $iconsActive = $iconAsc, $iconsInictive = $iconDesc, sortNames = [], sortDirs = {};
                $selTh.find("span.ui-grid-ico-sort").addClass(disabledClasses);
                $selTh.attr("aria-selected", "false");
                if (cm.lso) {
                    $iconsSpan.show();
                    so = cm.lso.split("-");
                    so = so[so.length - 1];
                    if (so === "desc") {
                        $iconsActive = $iconDesc;
                        $iconsInictive = $iconAsc;
                    }
                    $iconsActive.removeClass(disabledClasses).css("display", "");
                    if (p.showOneSortIcon) {
                        $iconsInictive.hide();
                    }
                    $selTh.attr("aria-selected", "true");
                } else if (!p.viewsortcols[0]) {
                    $iconsSpan.hide();
                }
                getSortNames(sortNames, sortDirs, cm);
                each(sortNames, function() {
                    if (sort1.length > 0) {
                        sort1 += ", ";
                    }
                    sort1 += this + " " + sortDirs[this];
                    p.sortorder = sortDirs[this];
                });
                p.sortname = sort1.substring(0, sort1.length - p.sortorder.length - 1);
            }, sortData = function(index, idxcol, reload, sor, obj) {
                var self = this, mygrid = self.grid, cm = p.colModel[idxcol], disabledClasses = getGuiStyles("states.disabled");
                if (cm == null || !cm.sortable) {
                    return;
                }
                if (p.savedRow.length > 0) {
                    return;
                }
                if (!reload) {
                    if (p.lastsort === idxcol && p.sortname !== "") {
                        if (p.sortorder === "asc") {
                            p.sortorder = "desc";
                        } else if (p.sortorder === "desc") {
                            p.sortorder = "asc";
                        } else {
                            p.sortorder = cm.firstsortorder || "asc";
                        }
                        if (cm.lso) {
                            if (cm.lso === "asc") {
                                cm.lso += "-desc";
                            } else if (cm.lso === "desc") {
                                cm.lso += "-asc";
                            } else if ((cm.lso === "asc-desc" || cm.lso === "desc-asc") && (p.threeStateSort || p.multiSort)) {
                                cm.lso = "";
                            }
                        } else {
                            cm.lso = cm.firstsortorder || "asc";
                        }
                    } else {
                        cm.lso = p.sortorder = cm.firstsortorder || "asc";
                    }
                    p.page = 1;
                }
                if (p.multiSort) {
                    multiSort(idxcol, obj);
                } else {
                    if (sor) {
                        if (p.lastsort === idxcol && p.sortorder === sor && !reload) {
                            return;
                        }
                        p.sortorder = sor;
                    }
                    var headers = mygrid.headers, fhDiv = mygrid.fhDiv, $previousSelectedTh = headers[p.lastsort] ? $(headers[p.lastsort].el) : $(), $newSelectedTh = p.frozenColumns ? $(obj) : $(headers[idxcol].el), $iconsSpan = $newSelectedTh.find("span.s-ico"), $iconsActive = $iconsSpan.children("span.ui-icon-" + p.sortorder), $iconsInictive = $iconsSpan.children("span.ui-icon-" + (p.sortorder === "asc" ? "desc" : "asc"));
                    cm = p.colModel[p.lastsort];
                    $previousSelectedTh.find("span.ui-grid-ico-sort").addClass(disabledClasses);
                    $previousSelectedTh.attr("aria-selected", "false");
                    if (p.frozenColumns) {
                        fhDiv.find("span.ui-grid-ico-sort").addClass(disabledClasses);
                        fhDiv.find("th").attr("aria-selected", "false");
                    }
                    if (!p.viewsortcols[0]) {
                        if (p.lastsort !== idxcol) {
                            if (p.frozenColumns) {
                                fhDiv.find("span.s-ico").hide();
                            }
                            $previousSelectedTh.find("span.s-ico").hide();
                            $iconsSpan.show();
                        } else if (p.sortname === "") {
                            $iconsSpan.show();
                        }
                    }
                    if (p.lastsort !== idxcol) {
                        if ($previousSelectedTh.data("autoResized") === "true" && (cm != null && cm.autoResizing != null && cm.autoResizing.compact || p.autoResizing.compact)) {
                            p.columnsToReResizing.push(p.lastsort);
                        }
                    }
                    cm = p.colModel[idxcol];
                    $iconsSpan.css("display", "");
                    if (cm.lso !== "") {
                        $iconsActive.removeClass(disabledClasses).css("display", "");
                        if (p.showOneSortIcon) {
                            $iconsInictive.removeClass(disabledClasses).hide();
                        }
                        $newSelectedTh.attr("aria-selected", "true");
                    } else {
                        $newSelectedTh.attr("aria-selected", "false");
                        if (p.threeStateSort) {
                            p.sortorder = "";
                            if (!p.viewsortcols[0]) {
                                $iconsSpan.hide();
                            }
                        }
                    }
                    if (p.lastsort !== idxcol && $newSelectedTh.data("autoResized") === "true") {
                        if (cm != null && cm.autoResizing != null && cm.autoResizing.compact || p.autoResizing.compact) {
                            p.columnsToReResizing.push(idxcol);
                        }
                    }
                    index = index.substring(5 + p.id.length + 1);
                    p.sortname = cm.index || index;
                }
                if (!feedback.call(self, "onSortCol", p.sortname, idxcol, p.sortorder)) {
                    p.lastsort = idxcol;
                    return;
                }
                if (p.datatype === "local") {
                    if (p.deselectAfterSort && !p.multiPageSelection) {
                        $j.resetSelection.call($(self));
                    }
                } else if (!p.multiPageSelection) {
                    p.selrow = null;
                    if (p.multiselect) {
                        setHeadCheckBox.call(self, false);
                        clearArray(p.selarrrow);
                    }
                }
                clearArray(p.savedRow);
                if (p.scroll) {
                    var sscroll = mygrid.bDiv.scrollLeft;
                    grid.emptyRows.call(self, true, false);
                    mygrid.hDiv.scrollLeft = sscroll;
                }
                if (p.subGrid && p.datatype === "local") {
                    $("td.sgexpanded", "#" + jqID(p.id)).each(function() {
                        $(this).trigger("click");
                    });
                }
                populate.call(self);
                p.lastsort = idxcol;
                if (p.sortname !== index && idxcol) {
                    p.lastsort = idxcol;
                }
            }, setInitialColWidth = function() {
                var initialWidth = 0, borderAndPaddingWidth = jgrid.cell_width ? 0 : intNum(p.cellLayout, 0), numberOfVariableColumns = 0, iLastVariableColumn, scrollbarWidth = intNum(p.scrollOffset, 0), columnWidth, hasScrollbar = false, totalVariableWidth, fixedColumnsWidth = 0, correctur, isCellClassHidden = jgrid.isCellClassHidden;
                each(p.colModel, function() {
                    if (this.hidden === undefined) {
                        this.hidden = false;
                    }
                    if (p.grouping && p.autowidth) {
                        var ind = inArray(this.name, p.groupingView.groupField);
                        if (ind >= 0 && p.groupingView.groupColumnShow.length > ind) {
                            this.hidden = !p.groupingView.groupColumnShow[ind];
                        }
                    }
                    this.widthOrg = columnWidth = intNum(this.width, 0);
                    if (this.hidden === false && !isCellClassHidden(this.classes)) {
                        initialWidth += columnWidth + borderAndPaddingWidth;
                        if (this.fixed) {
                            fixedColumnsWidth += columnWidth + borderAndPaddingWidth;
                        } else {
                            numberOfVariableColumns++;
                        }
                    }
                });
                if (isNaN(p.width)) {
                    p.width = initialWidth + (p.shrinkToFit === false && !isNaN(p.height) ? scrollbarWidth : 0);
                }
                grid.width = p.width;
                p.tblwidth = initialWidth;
                if (p.shrinkToFit === false && p.forceFit === true) {
                    p.forceFit = false;
                }
                if (p.shrinkToFit === true && numberOfVariableColumns > 0) {
                    totalVariableWidth = grid.width - borderAndPaddingWidth * numberOfVariableColumns - fixedColumnsWidth;
                    if (!isNaN(p.height)) {
                        totalVariableWidth -= scrollbarWidth;
                        hasScrollbar = true;
                    }
                    initialWidth = 0;
                    each(p.colModel, function(i) {
                        if (this.hidden === false && !isCellClassHidden(this.classes) && !this.fixed) {
                            columnWidth = Math.round(totalVariableWidth * this.width / (p.tblwidth - borderAndPaddingWidth * numberOfVariableColumns - fixedColumnsWidth));
                            this.width = columnWidth;
                            initialWidth += columnWidth;
                            iLastVariableColumn = i;
                        }
                    });
                    correctur = 0;
                    if (hasScrollbar) {
                        if (grid.width - fixedColumnsWidth - (initialWidth + borderAndPaddingWidth * numberOfVariableColumns) !== scrollbarWidth) {
                            correctur = grid.width - fixedColumnsWidth - (initialWidth + borderAndPaddingWidth * numberOfVariableColumns) - scrollbarWidth;
                        }
                    } else if (!hasScrollbar && Math.abs(grid.width - fixedColumnsWidth - (initialWidth + borderAndPaddingWidth * numberOfVariableColumns)) !== 1) {
                        correctur = grid.width - fixedColumnsWidth - (initialWidth + borderAndPaddingWidth * numberOfVariableColumns);
                    }
                    p.colModel[iLastVariableColumn].width += correctur;
                    p.tblwidth = initialWidth + correctur + borderAndPaddingWidth * numberOfVariableColumns + fixedColumnsWidth;
                    if (p.tblwidth > p.width) {
                        p.colModel[iLastVariableColumn].width -= p.tblwidth - parseInt(p.width, 10);
                        p.tblwidth = p.width;
                    }
                }
            }, nextVisible = function(iCol1) {
                var ret = iCol1, j = iCol1, i;
                for (i = iCol1 + 1; i < p.colModel.length; i++) {
                    if (p.colModel[i].hidden !== true) {
                        j = i;
                        break;
                    }
                }
                return j - ret;
            }, getColumnHeaderIndex = function(th) {
                return p.iColByName[(th.id || "").substring(p.id.length + 1)];
            }, colTemplate;
            if (inArray(p.multikey, sortkeys) === -1) {
                p.multikey = false;
            }
            p.keyName = false;
            p.sortorder = p.sortorder.toLowerCase();
            jgrid.cell_width = jgrid.cellWidth();
            var jgridCmTemplate = jgrid.cmTemplate, iCol, cmi;
            for (iCol = 0; iCol < p.colModel.length; iCol++) {
                cmi = p.colModel[iCol];
                colTemplate = typeof cmi.template === "string" ? jgridCmTemplate != null && (typeof jgridCmTemplate[cmi.template] === "object" || $.isFunction(jgridCmTemplate[cmi.template])) ? jgridCmTemplate[cmi.template] : {} : cmi.template;
                if (isFunction(colTemplate)) {
                    colTemplate = colTemplate.call(ts, {
                        "cm": cmi,
                        "iCol": iCol
                    });
                }
                cmi = extend(true, {}, p.cmTemplate, colTemplate || {}, cmi);
                if (p.keyName === false && cmi.key === true) {
                    p.keyName = cmi.name;
                }
                p.colModel[iCol] = cmi;
            }
            for (iCol = 0; iCol < p.additionalProperties.length; iCol++) {
                cmi = p.additionalProperties[iCol];
                if (p.keyName === false && cmi.key === true) {
                    p.keyName = cmi.name;
                }
            }
            if (p.colNames.length === 0) {
                for (iCol = 0; iCol < p.colModel.length; iCol++) {
                    p.colNames[iCol] = p.colModel[iCol].label !== undefined ? p.colModel[iCol].label : p.colModel[iCol].name;
                }
            }
            if (p.colNames.length !== p.colModel.length) {
                fatalErrorFunction(getRes("errors.model"));
                return;
            }
            if (p.grouping === true) {
                p.scroll = false;
                p.rownumbers = false;
                p.treeGrid = false;
                p.gridview = true;
            }
            if (p.subGrid) {
                try {
                    $j.setSubGrid.call($self0);
                } catch (ignore1) {}
            }
            if (p.multiselect && (p.multiselectPosition === "left" || p.multiselectPosition === "right")) {
                var insertMethod = p.multiselectPosition === "left" ? "unshift" : "push";
                p.colNames[insertMethod]("<input id='" + p.cbId + "' class='cbox' type='checkbox' aria-checked='false'/>");
                p.colModel[insertMethod]({
                    "name": "cb",
                    "width": jgrid.cell_width ? p.multiselectWidth + p.cellLayout : p.multiselectWidth,
                    "labelClasses": "jqgh_cbox",
                    "classes": "td_cbox",
                    "sortable": false,
                    "resizable": false,
                    "hidedlg": true,
                    "search": false,
                    "align": "center",
                    "fixed": true,
                    "frozen": true
                });
            }
            if (p.rownumbers) {
                p.colNames.unshift("");
                p.colModel.unshift({
                    "name": "rn",
                    "width": jgrid.cell_width ? p.rownumWidth + p.cellLayout : p.rownumWidth,
                    "labelClasses": "jqgh_rn",
                    "sortable": false,
                    "resizable": false,
                    "hidedlg": true,
                    "search": false,
                    "align": "center",
                    "fixed": true,
                    "frozen": true
                });
            }
            p.iColByName = buildColNameMap(p.colModel);
            p.xmlReader = extend(true, {
                "root": "rows",
                "row": "row",
                "page": "rows>page",
                "total": "rows>total",
                "records": "rows>records",
                "repeatitems": true,
                "cell": "cell",
                "id": "[id]",
                "userdata": "userdata",
                "subgrid": {
                    "root": "rows",
                    "row": "row",
                    "repeatitems": true,
                    "cell": "cell"
                }
            }, p.xmlReader);
            p.jsonReader = extend(true, {
                "root": "rows",
                "page": "page",
                "total": "total",
                "records": "records",
                "repeatitems": true,
                "cell": "cell",
                "id": "id",
                "userdata": "userdata",
                "subgrid": {
                    "root": "rows",
                    "repeatitems": true,
                    "cell": "cell"
                }
            }, p.jsonReader);
            p.localReader = extend(true, {
                "root": "rows",
                "page": "page",
                "total": "total",
                "records": "records",
                "repeatitems": false,
                "cell": "cell",
                "id": "id",
                "userdata": "userdata",
                "subgrid": {
                    "root": "rows",
                    "repeatitems": true,
                    "cell": "cell"
                }
            }, p.localReader);
            if (p.scroll) {
                p.pgbuttons = false;
                p.pginput = false;
                p.rowList = [];
            }
            if (p.treeGrid === true) {
                try {
                    $j.setTreeGrid.call($self0);
                } catch (ignore1) {}
                if (p.datatype !== "local") {
                    p.localReader = {
                        "id": "_id_"
                    };
                }
                p.iPropByName = buildAddPropMap(p.additionalProperties);
            }
            normalizeRemapColumns();
            buildArrayReader();
            if (p.data.length) {
                normalizeData.call(ts);
                refreshIndex();
            }
            if (p.shrinkToFit === true && p.forceFit === true) {
                for (iCol = p.colModel.length - 1; iCol >= 0; iCol--) {
                    if (p.colModel[iCol].hidden !== true) {
                        p.colModel[iCol].resizable = false;
                        break;
                    }
                }
            }
            var idn, w, res, sort, tooltip, labelStyle, ptr, sortarr = [], sortord = [], sotmp = [], thead = "<thead><tr class='ui-jqgrid-labels' role='row'>", headerText, tbody = "<tbody><tr style='display:none;'>", hoverStateClasses = getGuiStyles("states.hover"), disabledStateClasses = getGuiStyles("states.disabled");
            if (p.multiSort) {
                sortarr = p.sortname.split(",");
                var iSort;
                for (iSort = 0; iSort < sortarr.length; iSort++) {
                    sotmp = trim(sortarr[iSort]).split(" ");
                    sortarr[iSort] = trim(sotmp[0]);
                    sortord[iSort] = sotmp[1] ? trim(sotmp[1]) : p.sortorder || "asc";
                }
            }
            for (iCol = 0; iCol < p.colNames.length; iCol++) {
                cmi = p.colModel[iCol];
                tooltip = p.headertitles || cmi.headerTitle ? " title='" + stripHtml(typeof cmi.headerTitle === "string" ? cmi.headerTitle : p.colNames[iCol]) + "'" : "";
                thead += "<th id='" + p.id + "_" + cmi.name + "' class='" + getGuiStyles("colHeaders", "ui-th-column ui-th-" + dir + " " + (cmi.labelClasses || "")) + "'" + tooltip + ">";
                idn = cmi.index || cmi.name;
                switch (cmi.labelAlign) {
                  case "left":
                    labelStyle = "text-align:left;";
                    break;

                  case "right":
                    labelStyle = "text-align:right;" + (cmi.sortable === false ? "" : "padding-right:" + p.autoResizing.widthOfVisiblePartOfSortIcon + "px;");
                    break;

                  case "likeData":
                    labelStyle = cmi.align === undefined || cmi.align === "left" ? "text-align:left;" : cmi.align === "right" ? "text-align:right;" + (cmi.sortable === false ? "" : "padding-right:" + p.autoResizing.widthOfVisiblePartOfSortIcon + "px;") : "";
                    break;

                  default:
                    labelStyle = "";
                }
                thead += "<div id='jqgh_" + p.id + "_" + cmi.name + "'" + (isMSIE ? " class='ui-th-div-ie'" : "") + (labelStyle === "" ? "" : " style='" + labelStyle + "'") + ">";
                headerText = cmi.autoResizable && cmi.formatter !== "actions" ? "<span class='" + p.autoResizing.wrapperClassName + "'>" + p.colNames[iCol] + "</span>" : p.colNames[iCol];
                if (p.sortIconsBeforeText) {
                    thead += (p.builderSortIcons || jgrid.builderSortIcons).call(ts, iCol);
                    thead += headerText;
                } else {
                    thead += headerText;
                    thead += (p.builderSortIcons || jgrid.builderSortIcons).call(ts, iCol);
                }
                thead += "</div></th>";
                tbody += "<td></td>";
                cmi.width = cmi.width ? parseInt(cmi.width, 10) : 150;
                if (typeof cmi.title !== "boolean") {
                    cmi.title = true;
                }
                cmi.lso = "";
                if (idn === p.sortname) {
                    p.lastsort = iCol;
                    cmi.lso = p.sortorder || cmi.firstsortorder || "asc";
                }
                if (p.multiSort) {
                    sotmp = inArray(idn, sortarr);
                    if (sotmp !== -1) {
                        cmi.lso = sortord[sotmp];
                    }
                }
            }
            thead += "</tr></thead>";
            tbody += "</tr></tbody>";
            var hTable = $("<table class='" + getGuiStyles("hTable", "ui-jqgrid-htable") + "' style='width:1px' role='presentation' aria-labelledby='gbox_" + p.id + "'>" + thead + tbody + "</table>");
            $(hTable[0].tHead).children("tr").children("th").hover(function() {
                $(this).addClass(hoverStateClasses);
            }, function() {
                $(this).removeClass(hoverStateClasses);
            });
            if (p.multiselect) {
                $(p.cb, hTable).bind("click", function() {
                    var highlightClass = getGuiStyles("states.select"), toCheck, emp = [], iColCb = p.iColByName.cb, selectUnselectRow = function(tr, toSelect) {
                        $(tr)[toSelect ? "addClass" : "removeClass"](highlightClass).attr(toSelect ? {
                            "aria-selected": "true",
                            "tabindex": "0"
                        } : {
                            "aria-selected": "false",
                            "tabindex": "-1"
                        });
                        if (iColCb !== undefined) {
                            $(tr.cells[iColCb]).children("input.cbox").prop("checked", toSelect);
                        }
                    }, frozenRows = grid.fbRows, skipClasses = disabledStateClasses + " ui-subgrid jqgroup jqfoot jqgfirstrow jqgskipselect", id, ids = p._index;
                    clearArray(p.selarrrow);
                    if (this.checked) {
                        toCheck = true;
                        p.selrow = ts.rows.length > 1 ? ts.rows[ts.rows.length - 1].id : null;
                        if (p.multiPageSelection && (p.datatype === "local" || p.treeGrid)) {
                            if (p.data != null && p.data.length > 0 && ids != null) {
                                for (id in ids) {
                                    if (ids.hasOwnProperty(id)) {
                                        p.selarrrow.push(p.idPrefix + id);
                                    }
                                }
                            }
                        }
                    } else {
                        toCheck = false;
                        p.selrow = null;
                    }
                    var selArr = toCheck ? p.selarrrow : emp;
                    $(ts.rows).each(function(i) {
                        if (!hasOneFromClasses(this, skipClasses)) {
                            selectUnselectRow(this, toCheck);
                            if ($.inArray(this.id, selArr) < 0) {
                                selArr.push(this.id);
                            }
                            if (frozenRows) {
                                selectUnselectRow(frozenRows[i], toCheck);
                            }
                        }
                    });
                    feedback.call(ts, "onSelectAll", toCheck ? p.selarrrow : emp, toCheck);
                });
            }
            if (p.autowidth === true) {
                var pw = Math.floor($(eg).innerWidth());
                p.width = pw > 0 ? pw : "nw";
            }
            if (!isNaN(p.width)) {
                p.width = Number(p.width);
            } else if (!isNaN(parseFloat(p.width))) {
                p.width = parseFloat(p.width);
            }
            p.widthOrg = p.width;
            setInitialColWidth();
            $(eg).css("width", grid.width + "px").append("<div class='" + getGuiStyles("resizer", "ui-jqgrid-resize-mark") + "' id='" + p.rsId + "'>&#160;</div>");
            $(p.rs).bind("selectstart", function() {
                return false;
            }).click(myResizerClickHandler).dblclick(function(e) {
                var iColIndex = $(this).data("idx"), pageX = $(this).data("pageX"), cm = p.colModel[iColIndex];
                if (pageX == null || cm == null) {
                    return false;
                }
                var arPageX = String(pageX).split(";"), pageX1 = parseFloat(arPageX[0]), pageX2 = parseFloat(arPageX[1]);
                if (arPageX.length === 2 && (Math.abs(pageX1 - pageX2) > 5 || Math.abs(e.pageX - pageX1) > 5 || Math.abs(e.pageX - pageX2) > 5)) {
                    return false;
                }
                if (feedback.call(ts, "resizeDblClick", iColIndex, cm, e) && cm.autoResizable) {
                    $j.autoResizeColumn.call($self0, iColIndex);
                }
                feedback.call(ts, "afterResizeDblClick", {
                    "iCol": iColIndex,
                    "cm": cm,
                    "cmName": cm.name
                });
                return false;
            });
            $(gv).css("width", grid.width + "px");
            var tfoot = "";
            if (p.footerrow) {
                tfoot += "<table role='presentation' style='width:1px' class='" + getGuiStyles("gridFooter", "ui-jqgrid-ftable") + "'><tbody><tr role='row' class='" + getGuiStyles("rowFooter", "footrow footrow-" + dir) + "'>";
            }
            var firstr = "<tr class='jqgfirstrow' role='row' style='height:auto'>";
            p.disableClick = false;
            $("th", hTable[0].tHead.rows[0]).each(function(j) {
                var cm = p.colModel[j], nm = cm.name, $th = $(this), $sortableDiv = $th.children("div"), $iconsSpan = $sortableDiv.children("span.s-ico"), showOneSortIcon = p.showOneSortIcon;
                w = cm.width;
                if (cm.resizable === undefined) {
                    cm.resizable = true;
                }
                if (cm.resizable) {
                    res = document.createElement("span");
                    $(res).html("&#160;").addClass("ui-jqgrid-resize ui-jqgrid-resize-" + dir).bind("selectstart", function() {
                        return false;
                    });
                    $th.addClass(p.resizeclass);
                } else {
                    res = "";
                }
                $th.css("width", w + "px").prepend(res);
                res = null;
                var hdcol = "";
                if (cm.hidden === true) {
                    $th.css("display", "none");
                    hdcol = "display:none;";
                }
                firstr += "<td role='gridcell' " + (cm.classes ? "class='" + cm.classes + "' " : "") + "style='height:0;width:" + w + "px;" + hdcol + "'></td>";
                grid.headers[j] = {
                    "width": w,
                    "el": this
                };
                sort = cm.sortable;
                if (typeof sort !== "boolean") {
                    cm.sortable = true;
                    sort = true;
                }
                if (!(nm === "cb" || nm === "subgrid" || nm === "rn") && sort) {
                    if (p.viewsortcols[2]) {
                        $sortableDiv.addClass("ui-jqgrid-sortable");
                    }
                }
                if (sort) {
                    if (p.multiSort) {
                        var notLso = cm.lso === "desc" ? "asc" : "desc";
                        if (p.viewsortcols[0]) {
                            $iconsSpan.css("display", "");
                            if (cm.lso) {
                                $iconsSpan.children("span.ui-icon-" + cm.lso).removeClass(disabledStateClasses);
                                if (showOneSortIcon) {
                                    $iconsSpan.children("span.ui-icon-" + notLso).hide();
                                }
                            }
                        } else if (cm.lso) {
                            $iconsSpan.css("display", "");
                            $iconsSpan.children("span.ui-icon-" + cm.lso).removeClass(disabledStateClasses);
                            if (showOneSortIcon) {
                                $iconsSpan.children("span.ui-icon-" + notLso).hide();
                            }
                        }
                    } else {
                        var notSortOrder = p.sortorder === "desc" ? "asc" : "desc";
                        if (p.viewsortcols[0]) {
                            $iconsSpan.css("display", "");
                            if (j === p.lastsort) {
                                $iconsSpan.children("span.ui-icon-" + p.sortorder).removeClass(disabledStateClasses);
                                if (showOneSortIcon) {
                                    $iconsSpan.children("span.ui-icon-" + notSortOrder).hide();
                                }
                            }
                        } else if (j === p.lastsort && cm.lso !== "") {
                            $iconsSpan.css("display", "");
                            $iconsSpan.children("span.ui-icon-" + p.sortorder).removeClass(disabledStateClasses);
                            if (showOneSortIcon) {
                                $iconsSpan.children("span.ui-icon-" + notSortOrder).hide();
                            }
                        }
                    }
                }
                if (p.footerrow) {
                    tfoot += "<td role='gridcell' " + formatCol(j, 0, "", null, "", false) + ">&#160;</td>";
                }
            }).mousedown(function(e) {
                var $th = $(this), isFrozen = $th.closest(".ui-jqgrid-hdiv").hasClass("frozen-div"), getOffset = function() {
                    var ret = [ $th.position().left + $th.outerWidth() ];
                    if (p.direction === "rtl") {
                        ret[0] = p.width - ret[0];
                    }
                    ret[0] -= isFrozen ? 0 : grid.bDiv.scrollLeft;
                    ret.push($(grid.hDiv).position().top);
                    ret.push($(grid.bDiv).offset().top - $(grid.hDiv).offset().top + $(grid.bDiv).height() + (grid.sDiv ? $(grid.sDiv).height() : 0));
                    return ret;
                }, iCol1;
                if ($(e.target).closest("th>span.ui-jqgrid-resize").length !== 1) {
                    return;
                }
                iCol1 = getColumnHeaderIndex(this);
                if (iCol1 != null) {
                    if (p.forceFit === true) {
                        p.nv = nextVisible(iCol1);
                    }
                    grid.dragStart(iCol1, e, getOffset(), $th);
                }
                return false;
            }).click(function(e) {
                if (p.disableClick) {
                    p.disableClick = false;
                    return false;
                }
                var s = "th.ui-th-column>div", r, d;
                if (!p.viewsortcols[2]) {
                    s += ">span.s-ico>span.ui-grid-ico-sort";
                } else {
                    s += ".ui-jqgrid-sortable";
                }
                var t = $(e.target).closest(s);
                if (t.length !== 1) {
                    return;
                }
                if (!p.viewsortcols[2]) {
                    r = true;
                    d = t.hasClass("ui-icon-desc") ? "desc" : "asc";
                }
                var iColByName = getColumnHeaderIndex(this);
                if (iColByName != null) {
                    sortData.call(ts, $("div", this)[0].id, iColByName, r, d, this);
                }
                return false;
            });
            if (p.sortable && $.fn.sortable) {
                try {
                    $j.sortableColumns.call($self0, $(hTable[0].tHead.rows[0]));
                } catch (ignore1) {}
            }
            if (p.footerrow) {
                tfoot += "</tr></tbody></table>";
            }
            firstr += "</tr>";
            $self0.html("<tbody>" + firstr + "</tbody>");
            $self0.addClass(getGuiStyles("grid", "ui-jqgrid-btable" + (p.altRows === true && $self0.jqGrid("isBootstrapGuiStyle") ? " table-striped" : "")));
            var hg = p.caption && p.hiddengrid === true ? true : false, hb = $("<div class='ui-jqgrid-hbox" + (dir === "rtl" ? "-rtl" : "") + "'></div>"), topClasses = getGuiStyles("top"), bottomClasses = getGuiStyles("bottom");
            grid.hDiv = document.createElement("div");
            $(grid.hDiv).css({
                "width": grid.width + "px"
            }).addClass(getGuiStyles("hDiv", "ui-jqgrid-hdiv")).append(hb).scroll(function() {
                var bDiv = $(this).next(".ui-jqgrid-bdiv")[0];
                if (bDiv) {
                    bDiv.scrollLeft = this.scrollLeft;
                }
                return false;
            });
            $(hb).append(hTable);
            hTable = null;
            if (hg) {
                $(grid.hDiv).hide();
            }
            p.rowNum = parseInt(p.rowNum, 10);
            if (isNaN(p.rowNum) || p.rowNum <= 0) {
                p.rowNum = p.maxRowNum;
            }
            if (p.pager) {
                var $pager, pagerId;
                if (typeof p.pager === "string" && p.pager.substr(0, 1) !== "#") {
                    pagerId = p.pager;
                    $pager = $("#" + jqID(p.pager));
                } else if (p.pager === true) {
                    pagerId = randId();
                    $pager = $("<div id='" + pagerId + "'></div>");
                    $pager.appendTo("body");
                    p.pager = "#" + jqID(pagerId);
                } else {
                    $pager = $(p.pager);
                    pagerId = $pager.attr("id");
                }
                if ($pager.length > 0) {
                    $pager.css({
                        "width": grid.width + "px"
                    }).addClass(getGuiStyles("pager.pager", "ui-jqgrid-pager " + bottomClasses)).appendTo(eg);
                    if (hg) {
                        $pager.hide();
                    }
                    setPager.call(ts, pagerId, "");
                    p.pager = "#" + jqID(pagerId);
                } else {
                    p.pager = "";
                }
            }
            if (p.cellEdit === false && p.hoverrows === true) {
                $self0.bind("mouseover", function(e) {
                    ptr = $(e.target).closest("tr.jqgrow");
                    if ($(ptr).attr("class") !== "ui-subgrid") {
                        $(ptr).addClass(hoverStateClasses);
                    }
                }).bind("mouseout", function(e) {
                    ptr = $(e.target).closest("tr.jqgrow");
                    $(ptr).removeClass(hoverStateClasses);
                });
            }
            var ri, ci, tdHtml, getTdFromTarget = function(target) {
                var $td, $tr, $table;
                do {
                    $td = $(target).closest("td");
                    if ($td.length > 0) {
                        $tr = $td.parent();
                        $table = $tr.parent().parent();
                        if ($tr.is(".jqgrow") && ($table[0] === this || $table.is("table.ui-jqgrid-btable") && ($table[0].id || "").replace("_frozen", "") === this.id)) {
                            break;
                        }
                        target = $td.parent();
                    }
                } while ($td.length > 0);
                return $td;
            };
            $self0.before(grid.hDiv).click(function(e) {
                var highlightClass = getGuiStyles("states.select"), target = e.target, $td = getTdFromTarget.call(this, target), $tr = $td.parent();
                if ($tr.length === 0 || hasOneFromClasses($tr, disabledStateClasses)) {
                    return;
                }
                ri = $tr[0].id;
                var scb = $(target).hasClass("cbox") && $(target).is(":enabled") && !hasOneFromClasses(target, disabledStateClasses), cSel = feedback.call(ts, "beforeSelectRow", ri, e), editingInfo = jgrid.detectRowEditing.call(ts, ri), locked = editingInfo != null && editingInfo.mode !== "cellEditing";
                if (target.tagName === "A" || locked && !scb) {
                    return;
                }
                ci = $td[0].cellIndex;
                tdHtml = $td.html();
                feedback.call(ts, "onCellSelect", ri, ci, tdHtml, e);
                if (p.cellEdit === true) {
                    if (p.multiselect && scb && cSel) {
                        setSelection.call($self0, ri, true, e);
                    } else {
                        ri = $tr[0].rowIndex;
                        try {
                            $j.editCell.call($self0, ri, ci, true);
                        } catch (ignore) {}
                    }
                    return;
                }
                if (!cSel) {
                    if (scb) {
                        $(target).prop("checked", false);
                    }
                    return;
                }
                if (!p.multikey) {
                    if (p.multiselect && p.multiboxonly) {
                        if (scb) {
                            setSelection.call($self0, ri, true, e);
                        } else {
                            var frz = p.frozenColumns ? p.id + "_frozen" : "";
                            $(p.selarrrow).each(function(i, n) {
                                var trid = $j.getGridRowById.call($self0, n);
                                if (trid) {
                                    $(trid).removeClass(highlightClass);
                                }
                                $("#jqg_" + jqID(p.id) + "_" + jqID(n)).prop("checked", false);
                                if (frz) {
                                    $("#" + jqID(n), "#" + jqID(frz)).removeClass(highlightClass);
                                    $("#jqg_" + jqID(p.id) + "_" + jqID(n), "#" + jqID(frz)).prop("checked", false);
                                }
                            });
                            clearArray(p.selarrrow);
                            setSelection.call($self0, ri, true, e);
                        }
                    } else {
                        var oldSelRow = p.selrow;
                        setSelection.call($self0, ri, true, e);
                        if (p.singleSelectClickMode === "toggle" && !p.multiselect && oldSelRow === ri) {
                            if (this.grid.fbRows) {
                                $tr = $tr.add(this.grid.fbRows[ri]);
                            }
                            $tr.removeClass(highlightClass).attr({
                                "aria-selected": "false",
                                "tabindex": "-1"
                            });
                            p.selrow = null;
                        }
                    }
                } else {
                    if (e[p.multikey]) {
                        setSelection.call($self0, ri, true, e);
                    } else if (p.multiselect && scb) {
                        scb = $("#jqg_" + jqID(p.id) + "_" + ri).is(":checked");
                        $("#jqg_" + jqID(p.id) + "_" + ri).prop("checked", !scb);
                    }
                }
            }).bind("reloadGrid", function(e, opts) {
                var self = this, gridSelf = self.grid, $self = $(this);
                if (p.treeGrid === true) {
                    p.datatype = p.treedatatype;
                }
                opts = extend({}, defaults.reloadGridOptions || {}, p.reloadGridOptions || {}, opts || {});
                if (p.datatype === "local" && p.dataTypeOrg && p.loadonce && opts.fromServer) {
                    p.datatype = p.dataTypeOrg;
                    delete p.dataTypeOrg;
                }
                if (opts.current) {
                    gridSelf.selectionPreserver.call(self);
                }
                if (p.datatype === "local") {
                    if (!p.multiPageSelection) {
                        $j.resetSelection.call($self);
                    }
                    if (p.data.length) {
                        normalizeData.call(self);
                        refreshIndex();
                    }
                } else if (!p.treeGrid && !p.multiPageSelection) {
                    p.selrow = null;
                    if (p.multiselect) {
                        clearArray(p.selarrrow);
                        setHeadCheckBox.call(self, false);
                    }
                    clearArray(p.savedRow);
                }
                p.iRow = -1;
                p.iCol = -1;
                if (p.scroll) {
                    grid.emptyRows.call(self, true, false);
                }
                if (opts.page) {
                    var page = parseInt(opts.page, 10);
                    if (page > p.lastpage) {
                        page = p.lastpage;
                    }
                    if (page < 1) {
                        page = 1;
                    }
                    p.page = page;
                    if (gridSelf.prevRowHeight) {
                        gridSelf.bDiv.scrollTop = (page - 1) * gridSelf.prevRowHeight * p.rowNum;
                    } else {
                        gridSelf.bDiv.scrollTop = 0;
                    }
                }
                if (gridSelf.prevRowHeight && p.scroll && opts.page === undefined) {
                    delete p.lastpage;
                    gridSelf.populateVisible.call(self);
                } else {
                    gridSelf.populate.call(self);
                }
                if (p._inlinenav === true) {
                    $self.jqGrid("showAddEditButtons", false);
                }
                return false;
            }).dblclick(function(e) {
                var $td = getTdFromTarget.call(this, e.target), $tr = $td.parent();
                if ($td.length > 0 && !feedback.call(ts, "ondblClickRow", $tr.attr("id"), $tr[0].rowIndex, $td[0].cellIndex, e)) {
                    return false;
                }
            }).bind("contextmenu", function(e) {
                var $td = getTdFromTarget.call(this, e.target), $tr = $td.parent(), rowid = $tr.attr("id");
                if ($td.length === 0) {
                    return;
                }
                if (!p.multiselect) {
                    setSelection.call($self0, rowid, true, e);
                }
                if (!feedback.call(ts, "onRightClickRow", rowid, $tr[0].rowIndex, $td[0].cellIndex, e)) {
                    return false;
                }
            });
            grid.bDiv = document.createElement("div");
            if (isMSIE) {
                if (String(p.height).toLowerCase() === "auto") {
                    p.height = "100%";
                }
            }
            $(grid.bDiv).append($("<div style='position:relative;'></div>").append("<div></div>").append(ts)).addClass("ui-jqgrid-bdiv").css({
                "height": p.height + (isNaN(p.height) ? "" : "px"),
                "width": grid.width + "px"
            }).scroll(grid.scrollGrid);
            if (p.maxHeight) {
                $(grid.bDiv).css("max-height", p.maxHeight + (isNaN(p.maxHeight) ? "" : "px"));
            }
            $self0.css({
                "width": "1px"
            });
            if (!$.support.tbody) {
                if ($(">tbody", ts).length === 2) {
                    $(">tbody:gt(0)", ts).remove();
                }
            }
            if (p.multikey) {
                $(grid.bDiv).bind(jgrid.msie ? "selectstart" : "mousedown", function() {
                    return false;
                });
            }
            if (hg) {
                $(grid.bDiv).hide();
            }
            grid.cDiv = document.createElement("div");
            var visibleGridIcon = getIcon("gridMinimize.visible"), hiddenGridIcon = getIcon("gridMinimize.hidden"), showhide = getDef("showhide"), arf = p.hidegrid === true ? $("<a role='link' class='" + getGuiStyles("titleButton", "ui-jqgrid-titlebar-close") + "'" + (showhide ? " title='" + showhide + "'" : "") + "/>").hover(function() {
                arf.addClass(hoverStateClasses);
            }, function() {
                arf.removeClass(hoverStateClasses);
            }).append("<span class='" + visibleGridIcon + "'></span>") : "";
            $(grid.cDiv).append("<span class='ui-jqgrid-title'>" + p.caption + "</span>").append(arf).addClass(getGuiStyles("gridTitle", "ui-jqgrid-titlebar ui-jqgrid-caption" + (dir === "rtl" ? "-rtl " : " ") + topClasses));
            $(grid.cDiv).insertBefore(grid.hDiv);
            if (p.toolbar[0]) {
                grid.uDiv = document.createElement("div");
                if (p.toolbar[1] === "top") {
                    $(grid.uDiv).insertBefore(grid.hDiv);
                } else if (p.toolbar[1] === "bottom") {
                    $(grid.uDiv).insertAfter(grid.hDiv);
                }
                var toolbarUpperClasses = getGuiStyles("toolbarUpper", "ui-userdata");
                if (p.toolbar[1] === "both") {
                    grid.ubDiv = document.createElement("div");
                    $(grid.uDiv).addClass(toolbarUpperClasses).attr("id", "t_" + p.id).insertBefore(grid.hDiv);
                    $(grid.ubDiv).addClass(getGuiStyles("toolbarBottom", "ui-userdata")).attr("id", "tb_" + p.id).insertAfter(grid.hDiv);
                    if (hg) {
                        $(grid.ubDiv).hide();
                    }
                } else {
                    $(grid.uDiv).width(grid.width).addClass(toolbarUpperClasses).attr("id", "t_" + p.id);
                }
                if (hg) {
                    $(grid.uDiv).hide();
                }
            }
            if (typeof p.datatype === "string") {
                p.datatype = p.datatype.toLowerCase();
            }
            if (p.toppager) {
                p.toppager = p.id + "_toppager";
                grid.topDiv = $("<div id='" + p.toppager + "'></div>")[0];
                $(grid.topDiv).addClass(getGuiStyles("pager.pager", "ui-jqgrid-toppager" + (p.caption ? "" : " " + topClasses))).css({
                    "width": grid.width + "px"
                }).insertBefore(grid.hDiv);
                setPager.call(ts, p.toppager, "_t");
                p.toppager = "#" + jqID(p.toppager);
            } else if (p.pager === "" && !p.scroll) {
                p.rowNum = p.maxRowNum;
            }
            if (p.footerrow) {
                grid.sDiv = $("<div class='ui-jqgrid-sdiv'></div>")[0];
                hb = $("<div class='ui-jqgrid-hbox" + (dir === "rtl" ? "-rtl" : "") + "'></div>");
                $(grid.sDiv).append(hb).width(grid.width).insertAfter(grid.hDiv);
                $(hb).append(tfoot);
                grid.footers = $(".ui-jqgrid-ftable", grid.sDiv)[0].rows[0].cells;
                if (p.rownumbers) {
                    grid.footers[0].className = getGuiStyles("rowNum", "jqgrid-rownum");
                }
                if (hg) {
                    $(grid.sDiv).hide();
                }
            }
            hb = null;
            if (p.caption) {
                var tdt = p.datatype;
                if (p.hidegrid === true) {
                    $(".ui-jqgrid-titlebar-close", grid.cDiv).click(function(e) {
                        var elems = ".ui-jqgrid-bdiv,.ui-jqgrid-hdiv,.ui-jqgrid-pager,.ui-jqgrid-sdiv", self = this;
                        if (p.toolbar[0] === true) {
                            if (p.toolbar[1] === "both") {
                                elems += ",#" + jqID($(grid.ubDiv).attr("id"));
                            }
                            elems += ",#" + jqID($(grid.uDiv).attr("id"));
                        }
                        var counter = $(elems, p.gView).length;
                        if (p.toppager) {
                            elems += "," + p.toppager;
                        }
                        if (p.gridstate === "visible") {
                            $(elems, p.gBox).slideUp("fast", function() {
                                counter--;
                                if (counter === 0) {
                                    $("span", self).removeClass(visibleGridIcon).addClass(hiddenGridIcon);
                                    p.gridstate = "hidden";
                                    if ($(p.gBox).hasClass("ui-resizable")) {
                                        $(".ui-resizable-handle", p.gBox).hide();
                                    }
                                    $(grid.cDiv).addClass(bottomClasses);
                                    if (!hg) {
                                        feedback.call(ts, "onHeaderClick", p.gridstate, e);
                                    }
                                }
                            });
                        } else if (p.gridstate === "hidden") {
                            $(grid.cDiv).removeClass(bottomClasses);
                            $(elems, p.gBox).slideDown("fast", function() {
                                counter--;
                                if (counter === 0) {
                                    $("span", self).removeClass(hiddenGridIcon).addClass(visibleGridIcon);
                                    if (hg) {
                                        p.datatype = tdt;
                                        populate.call(ts);
                                        hg = false;
                                    }
                                    p.gridstate = "visible";
                                    if ($(p.gBox).hasClass("ui-resizable")) {
                                        $(".ui-resizable-handle", p.gBox).show();
                                    }
                                    if (!hg) {
                                        feedback.call(ts, "onHeaderClick", p.gridstate, e);
                                    }
                                }
                            });
                        }
                        return false;
                    });
                    if (hg) {
                        p.datatype = "local";
                        $(".ui-jqgrid-titlebar-close", grid.cDiv).trigger("click");
                    }
                }
            } else {
                $(grid.cDiv).hide();
                $(grid.cDiv).nextAll("div:visible").first().addClass("ui-corner-top");
            }
            $(grid.hDiv).after(grid.bDiv);
            grid.eDiv = $("<div class='" + getGuiStyles("gridError", "ui-jqgrid-errorbar ui-jqgrid-errorbar-" + dir) + "' style='display:none;'>" + "<span class='" + getGuiStyles("gridErrorText", "ui-jqgrid-error") + "'></span></div>")[0];
            $(grid.hDiv).after(grid.eDiv);
            $(eg).click(myResizerClickHandler).dblclick(function(e) {
                var $resizer = $(p.rs), resizerOffset = $resizer.offset(), iColIndex = $resizer.data("idx"), delta = $resizer.data("delta"), cm = p.colModel[iColIndex], pageX = $(this).data("pageX") || $resizer.data("pageX");
                if (pageX == null || cm == null) {
                    return false;
                }
                var arPageX = String(pageX).split(";"), pageX1 = parseFloat(arPageX[0]), pageX2 = parseFloat(arPageX[1]);
                if (arPageX.length === 2 && (Math.abs(pageX1 - pageX2) > 5 || Math.abs(e.pageX - pageX1) > 5 || Math.abs(e.pageX - pageX2) > 5)) {
                    return false;
                }
                if (feedback.call(ts, "resizeDblClick", iColIndex, cm) && (resizerOffset.left - 1 <= e.pageX + delta && e.pageX + delta <= resizerOffset.left + $resizer.outerWidth() + 1) && cm.autoResizable) {
                    $j.autoResizeColumn.call($self0, iColIndex);
                }
                feedback.call(ts, "afterResizeDblClick", {
                    "iCol": iColIndex,
                    "cm": cm,
                    "cmName": cm.name
                });
                return false;
            });
            if (!p.pager) {
                $(grid.cDiv).nextAll("div:visible").filter(":last").addClass(bottomClasses);
            }
            $(".ui-jqgrid-labels", grid.hDiv).bind("selectstart", function() {
                return false;
            });
            ts.formatCol = formatCol;
            ts.sortData = sortData;
            ts.updatepager = updatepager;
            ts.refreshIndex = refreshIndex;
            ts.setHeadCheckBox = setHeadCheckBox;
            ts.fixScrollOffsetAndhBoxPadding = fixScrollOffsetAndhBoxPadding;
            ts.constructTr = constructTr;
            ts.formatter = formatter;
            extend(grid, {
                "populate": populate,
                "emptyRows": emptyRows,
                "beginReq": beginReq,
                "endReq": endReq
            });
            ts.addXmlData = readInput;
            ts.addJSONData = readInput;
            ts.rebuildRowIndexes = rebuildRowIndexes;
            ts.grid.cols = ts.rows[0].cells;
            feedback.call(ts, "onInitGrid");
            if (p.treeGrid && p.datatype === "local" && p.data != null && p.data.length > 0) {
                p.datatype = "jsonstring";
                p.datastr = p.data;
                p.data = [];
            }
            populate.call(ts);
            p.hiddengrid = false;
        });
    };
    var base = $.fn.jqGrid;
    jgrid.extend({
        "getGridRes": function(defaultPropName) {
            var $t = this[0];
            if (!$t || !$t.grid || !$t.p) {
                return null;
            }
            var res = jgrid.getRes(locales[$t.p.locale], defaultPropName) || jgrid.getRes(locales["en-US"], defaultPropName), resDef = jgrid.getRes(jgrid, defaultPropName);
            return typeof res === "object" && res !== null && !$.isArray(res) ? $.extend(true, {}, res, resDef || {}) : resDef !== undefined ? resDef : res;
        },
        "getGuiStyles": function(path, jqClasses) {
            var $t = this instanceof $ && this.length > 0 ? this[0] : this;
            if (!$t || !$t.grid || !$t.p) {
                return "";
            }
            var p = $t.p, guiStyle = p.guiStyle || jgrid.defaults.guiStyle || "jQueryUI", guiClasses = jgrid.getRes(jgrid.guiStyles[guiStyle], path), baseGuiStyle;
            if (guiClasses === undefined) {
                baseGuiStyle = jgrid.getRes(jgrid.guiStyles[guiStyle], "baseGuiStyle");
                if (typeof baseGuiStyle === "string") {
                    guiClasses = jgrid.getRes(jgrid.guiStyles[baseGuiStyle], path);
                }
            }
            return jgrid.mergeCssClasses(guiClasses || "", jqClasses || "");
        },
        "isBootstrapGuiStyle": function() {
            return $.inArray("ui-jqgrid-bootstrap", $(this).jqGrid("getGuiStyles", "gBox").split(" ")) >= 0;
        },
        "displayErrorMessage": function(message) {
            var $t = this instanceof $ && this.length > 0 ? this[0] : this;
            if (!$t || !$t.grid || !$t.p || !message) {
                return;
            }
            var $errorDiv = $($t.grid.eDiv), $errorSpan = $errorDiv.children(".ui-jqgrid-error");
            $errorSpan.html(message);
            $errorDiv.show();
            if ($t.p.errorDisplayTimeout) {
                setTimeout(function() {
                    $errorSpan.empty();
                    $errorDiv.hide();
                }, $t.p.errorDisplayTimeout);
            }
        },
        "getIconRes": function(path) {
            var $t = this instanceof $ && this.length > 0 ? this[0] : this;
            if (!$t || !$t.p) {
                return "";
            }
            var p = $t.p, iconSet = jgrid.icons[p.iconSet], getIcon = function(basePath, path) {
                var pathParts = path.split("."), root, n = pathParts.length, part, i, classes = [];
                basePath = typeof basePath === "string" ? jgrid.icons[basePath] : basePath;
                if (basePath == null) {
                    return "";
                }
                root = basePath;
                if (root.common) {
                    classes.push(root.common);
                }
                for (i = 0; i < n; i++) {
                    part = pathParts[i];
                    if (!part) {
                        break;
                    }
                    root = root[part];
                    if (root === undefined) {
                        if (part === "common") {
                            break;
                        }
                        return "";
                    }
                    if (typeof root === "string") {
                        classes.push(root);
                        break;
                    }
                    if (root != null && root.common) {
                        classes.push(root.common);
                    }
                }
                return jgrid.mergeCssClasses.apply(this, classes);
            };
            if (iconSet == null) {
                return "";
            }
            var classes = getIcon(p.iconSet, path);
            if (classes === "" && iconSet.baseIconSet != null) {
                classes = getIcon(iconSet.baseIconSet, path);
            }
            return classes || "";
        },
        "isInCommonIconClass": function(testClass) {
            var $t = this instanceof $ && this.length > 0 ? this[0] : this;
            if (!$t || !$t.p) {
                return "";
            }
            var p = $t.p, iconSet = jgrid.icons[p.iconSet];
            if (iconSet == null) {
                return false;
            }
            var commonClasses = iconSet.common;
            if (commonClasses === undefined) {
                if (iconSet.baseIconSet == null) {
                    return false;
                }
                iconSet = jgrid.icons[iconSet.baseIconSet];
                if (iconSet == null) {
                    return false;
                }
                commonClasses = iconSet.common;
            }
            return typeof commonClasses === "string" && $.inArray(testClass, commonClasses.split(" ")) >= 0;
        },
        "getGridParam": function(pName) {
            var $t = this[0];
            if (!$t || !$t.grid) {
                return null;
            }
            if (!pName) {
                return $t.p;
            }
            return $t.p[pName] !== undefined ? $t.p[pName] : null;
        },
        "setGridParam": function(newParams, overwrite) {
            return this.each(function() {
                var self = this;
                if (overwrite == null) {
                    overwrite = false;
                }
                if (self.grid && typeof newParams === "object") {
                    if (overwrite === true) {
                        var params = $.extend({}, self.p, newParams);
                        self.p = params;
                    } else {
                        $.extend(true, self.p, newParams);
                    }
                }
            });
        },
        "abortAjaxRequest": function() {
            return this.each(function() {
                var self = this;
                if (self.p.jqXhr != null) {
                    self.p.jqXhr.abort();
                }
                self.grid.endReq.call(self);
            });
        },
        "getGridRowById": function(rowid) {
            if (rowid == null) {
                return null;
            }
            var row, rowId = rowid.toString();
            this.each(function() {
                var i, rows = this.rows, tr, rowIndex;
                if (this.p.rowIndexes != null) {
                    rowIndex = this.p.rowIndexes[rowId];
                    tr = rows[rowIndex];
                    if (tr && tr.id === rowId) {
                        row = tr;
                    }
                }
                if (!row) {
                    try {
                        i = rows.length;
                        while (i--) {
                            tr = rows[i];
                            if (rowId === tr.id) {
                                row = tr;
                                break;
                            }
                        }
                    } catch (e) {
                        row = $(this.grid.bDiv).find("#" + jqID(rowid));
                        row = row.length > 0 ? row[0] : null;
                    }
                }
            });
            return row;
        },
        "getDataIDs": function() {
            var ids = [];
            this.each(function() {
                var rows = this.rows, len = rows.length, i, tr;
                if (len && len > 0) {
                    for (i = 0; i < len; i++) {
                        tr = rows[i];
                        if ($(tr).hasClass("jqgrow")) {
                            ids.push(tr.id);
                        }
                    }
                }
            });
            return ids;
        },
        "setSelection": function(selection, onsr, e) {
            return this.each(function() {
                var $t = this, $self = $($t), p = $t.p, stat, pt, ner, ia, tpsr, csr, $tr, getGuiStyles = base.getGuiStyles, getGridRowById = base.getGridRowById, highlightClass = getGuiStyles.call($self, "states.select"), disabledClasses = getGuiStyles.call($self, "states.disabled"), frozenRows = $t.grid.fbRows, selectUnselectRow = function(tr1, toSelect) {
                    var method = toSelect ? "addClass" : "removeClass", iColCb = p.iColByName.cb, attributes = toSelect ? {
                        "aria-selected": "true",
                        "tabindex": "0"
                    } : {
                        "aria-selected": "false",
                        "tabindex": "-1"
                    }, selectUnselectRowInTable = function(tr) {
                        $(tr)[method](highlightClass).attr(attributes);
                        if (iColCb !== undefined) {
                            $(tr.cells[iColCb]).children("input.cbox").prop("checked", toSelect);
                        }
                    };
                    selectUnselectRowInTable(tr1);
                    if (frozenRows) {
                        selectUnselectRowInTable(frozenRows[tr1.rowIndex]);
                    }
                };
                if (selection === undefined) {
                    return;
                }
                onsr = onsr === false ? false : true;
                if (e != null) {
                    $tr = $(e.target).closest("tr.jqgrow");
                    if ($tr.length > 0) {
                        pt = $tr[0];
                        if (frozenRows) {
                            pt = $t.rows[pt.rowIndex];
                        }
                    }
                }
                if (pt == null) {
                    pt = getGridRowById.call($self, selection);
                }
                if (!pt || !pt.className || pt.className.indexOf(disabledClasses) > -1) {
                    return;
                }
                function scrGrid(tr, bDiv) {
                    var ch = bDiv.clientHeight, st = bDiv.scrollTop, rpos = $(tr).position().top, rh = tr.clientHeight;
                    if (rpos + rh >= ch + st) {
                        bDiv.scrollTop = rpos - (ch + st) + rh + st;
                    } else if (rpos < ch + st) {
                        if (rpos < st) {
                            bDiv.scrollTop = rpos;
                        }
                    }
                }
                if (p.scrollrows === true) {
                    ner = getGridRowById.call($self, selection);
                    if (ner != null) {
                        ner = ner.rowIndex;
                        if (ner >= 0) {
                            scrGrid($t.rows[ner], $t.grid.bDiv);
                        }
                    }
                }
                if (!p.multiselect) {
                    if (pt.className !== "ui-subgrid") {
                        if (p.selrow !== pt.id) {
                            if (p.selrow !== null) {
                                csr = getGridRowById.call($self, p.selrow);
                                if (csr) {
                                    selectUnselectRow(csr, false);
                                }
                            }
                            selectUnselectRow(pt, true);
                            stat = true;
                        } else {
                            stat = false;
                        }
                        p.selrow = pt.id;
                        if (onsr) {
                            feedback.call($t, "onSelectRow", pt.id, stat, e);
                        }
                    }
                } else {
                    $t.setHeadCheckBox(false);
                    p.selrow = pt.id;
                    ia = $.inArray(p.selrow, p.selarrrow);
                    if (ia === -1) {
                        stat = true;
                        p.selarrrow.push(p.selrow);
                    } else if (jgrid.detectRowEditing.call($t, pt.id) !== null) {
                        stat = true;
                    } else {
                        stat = false;
                        p.selarrrow.splice(ia, 1);
                        tpsr = p.selarrrow[0];
                        p.selrow = tpsr === undefined ? null : tpsr;
                    }
                    if (pt.className !== "ui-subgrid") {
                        selectUnselectRow(pt, stat);
                    }
                    if (onsr) {
                        feedback.call($t, "onSelectRow", pt.id, stat, e);
                    }
                }
            });
        },
        "resetSelection": function(rowid) {
            return this.each(function() {
                var $t = this, $self = $(this), p = $t.p, row, getGuiStyles = base.getGuiStyles, getGridRowById = base.getGridRowById, highlightClass = getGuiStyles.call($self, "states.select"), cellEditCellHighlightClasses = "edit-cell " + highlightClass, cellEditRowHighlightClasses = "selected-row " + getGuiStyles.call($self, "states.hover"), iColCb = p.iColByName.cb, multiselectChechboxes = iColCb !== undefined, frozenRows = $t.grid.fbRows, deselectRow = function(tr) {
                    var method = "removeClass", frozenRow, attributes = {
                        "aria-selected": "false",
                        "tabindex": "-1"
                    };
                    $(tr)[method](highlightClass).attr(attributes);
                    if (multiselectChechboxes) {
                        $(tr.cells[iColCb]).children("input.cbox").prop("checked", false);
                    }
                    if (frozenRows) {
                        frozenRow = frozenRows[tr.rowIndex];
                        $(frozenRow)[method](highlightClass).attr(attributes);
                        if (multiselectChechboxes) {
                            $(frozenRow.cells[iColCb]).children("input.cbox").prop("checked", false);
                        }
                    }
                };
                if (rowid !== undefined) {
                    row = getGridRowById.call($self, rowid);
                    deselectRow(row);
                    if (multiselectChechboxes) {
                        $t.setHeadCheckBox(false);
                        var ia = $.inArray(rowid, p.selarrrow);
                        if (ia !== -1) {
                            p.selarrrow.splice(ia, 1);
                        }
                    }
                } else if (!p.multiselect) {
                    if (p.selrow) {
                        row = getGridRowById.call($self, p.selrow);
                        deselectRow(row);
                        p.selrow = null;
                    }
                } else {
                    $($t.rows).each(function() {
                        var iSel = $.inArray(this.id, p.selarrrow);
                        if (iSel !== -1) {
                            deselectRow(this);
                            p.selarrrow.splice(iSel, 1);
                        }
                    });
                    $t.setHeadCheckBox(false);
                    if (!p.multiPageSelection) {
                        clearArray(p.selarrrow);
                    }
                    p.selrow = null;
                }
                if (p.cellEdit === true) {
                    if (parseInt(p.iCol, 10) >= 0 && parseInt(p.iRow, 10) >= 0) {
                        row = $t.rows[p.iRow];
                        if (row != null) {
                            $(row.cells[p.iCol]).removeClass(cellEditCellHighlightClasses);
                            $(row).removeClass(cellEditRowHighlightClasses);
                        }
                        if (frozenRows) {
                            row = frozenRows[p.iRow];
                            if (row != null) {
                                $(row.cells[p.iCol]).removeClass(cellEditCellHighlightClasses);
                                $(row).removeClass(cellEditRowHighlightClasses);
                            }
                        }
                    }
                }
                clearArray(p.savedRow);
            });
        },
        "getRowData": function(rowid, options) {
            var res = {}, resall;
            if (typeof rowid === "object") {
                options = rowid;
                rowid = undefined;
            }
            options = options || {};
            this.each(function() {
                var $t = this, p = $t.p, getall = false, ind, len = 2, j = 0, rows = $t.rows, i, $td, cm, nm, td;
                if (rowid === undefined) {
                    getall = true;
                    resall = [];
                    len = rows.length;
                } else {
                    ind = base.getGridRowById.call($($t), rowid);
                    if (!ind) {
                        return res;
                    }
                }
                while (j < len) {
                    if (getall) {
                        ind = rows[j];
                    }
                    if ($(ind).hasClass("jqgrow")) {
                        $td = $("td[role=gridcell]", ind);
                        for (i = 0; i < $td.length; i++) {
                            cm = p.colModel[i];
                            nm = cm.name;
                            if (nm !== "cb" && nm !== "subgrid" && nm !== "rn" && cm.formatter !== "actions" && (!options.skipHidden || !cm.hidden)) {
                                td = $td[i];
                                if (p.treeGrid === true && nm === p.ExpandColumn) {
                                    res[nm] = htmlDecode($("span", td).first().html());
                                } else {
                                    try {
                                        res[nm] = $.unformat.call($t, td, {
                                            "rowId": ind.id,
                                            "colModel": cm
                                        }, i);
                                    } catch (exception) {
                                        res[nm] = htmlDecode($(td).html());
                                    }
                                }
                            }
                        }
                        if (options.includeId && (p.keyName === false || res[p.keyName] == null)) {
                            res[p.prmNames.id] = stripPref(p.idPrefix, ind.id);
                        }
                        if (getall) {
                            resall.push(res);
                            res = {};
                        }
                    }
                    j++;
                }
            });
            return resall || res;
        },
        "delRowData": function(rowid) {
            var success = false, rowInd, ia, nextRow;
            this.each(function() {
                var $t = this, p = $t.p;
                rowInd = base.getGridRowById.call($($t), rowid);
                if (!rowInd) {
                    return false;
                }
                if (p.subGrid) {
                    nextRow = $(rowInd).next();
                    if (nextRow.hasClass("ui-subgrid")) {
                        nextRow.remove();
                    }
                }
                $(rowInd).remove();
                p.records--;
                p.reccount--;
                $t.updatepager(true, false);
                success = true;
                if (p.multiselect) {
                    ia = $.inArray(rowid, p.selarrrow);
                    if (ia !== -1) {
                        p.selarrrow.splice(ia, 1);
                    }
                }
                if (p.multiselect && p.selarrrow.length > 0) {
                    p.selrow = p.selarrrow[p.selarrrow.length - 1];
                } else if (p.selrow === rowid) {
                    p.selrow = null;
                }
                if (p.datatype === "local") {
                    var id = stripPref(p.idPrefix, rowid), pos = p._index[id];
                    if (pos !== undefined) {
                        p.data.splice(pos, 1);
                        $t.refreshIndex();
                    }
                }
                $t.rebuildRowIndexes();
                if (p.altRows === true && success && !$($t).jqGrid("isBootstrapGuiStyle")) {
                    var cn = p.altclass, frozenRows = $t.grid.fbRows;
                    $($t.rows).each(function(i) {
                        var $row = $(this);
                        if (frozenRows) {
                            $row = $row.add(frozenRows[this.rowIndex]);
                        }
                        $row[i % 2 === 0 ? "addClass" : "removeClass"](cn);
                    });
                }
                feedback.call($t, "afterDelRow", rowid);
            });
            return success;
        },
        "setRowData": function(rowid, data, cssp) {
            var success = true;
            this.each(function() {
                var t = this, p = t.p, ind, cp = typeof cssp, lcdata = {};
                if (!t.grid) {
                    return false;
                }
                ind = base.getGridRowById.call($(t), rowid);
                if (!ind) {
                    return false;
                }
                if (data) {
                    try {
                        var id = stripPref(p.idPrefix, rowid), key, pos = p._index[id], newData = {}, oData = pos != null ? p.data[pos] : undefined;
                        $(p.colModel).each(function(i) {
                            var cm = this, nm = cm.name, vl = getAccessor(data, nm);
                            if (vl !== undefined) {
                                if (p.datatype === "local" && oData != null) {
                                    vl = convertOnSaveLocally.call(t, vl, cm, oData[nm], id, oData, i);
                                    if ($.isFunction(cm.saveLocally)) {
                                        cm.saveLocally.call(t, {
                                            "newValue": vl,
                                            "newItem": lcdata,
                                            "oldItem": oData,
                                            "id": id,
                                            "cm": cm,
                                            "cmName": nm,
                                            "iCol": i
                                        });
                                    } else {
                                        lcdata[nm] = vl;
                                    }
                                }
                                newData[nm] = vl;
                            }
                        });
                        $(p.colModel).each(function(i) {
                            var cm = this, nm = cm.name, title, vl = getAccessor(data, nm), $td = $(ind.cells[i]);
                            if (vl !== undefined) {
                                if (p.datatype === "local" && oData != null) {
                                    vl = lcdata[nm];
                                }
                                title = cm.title ? {
                                    "title": vl
                                } : {};
                                vl = t.formatter(rowid, vl, i, data, "edit", newData);
                                var $dataFiled = $td;
                                if (p.treeGrid === true && nm === p.ExpandColumn) {
                                    $dataFiled = $dataFiled.children("span.cell-wrapperleaf,span.cell-wrapper").first();
                                }
                                $dataFiled.html(vl);
                                $td.attr(title);
                                if (p.frozenColumns) {
                                    $dataFiled = $(t.grid.fbRows[ind.rowIndex].cells[i]);
                                    if (p.treeGrid === true && nm === p.ExpandColumn) {
                                        $dataFiled = $dataFiled.children("span.cell-wrapperleaf,span.cell-wrapper").first();
                                    }
                                    $dataFiled.html(vl).attr(title);
                                }
                            }
                        });
                        if (p.datatype === "local") {
                            if (p.treeGrid) {
                                for (key in p.treeReader) {
                                    if (p.treeReader.hasOwnProperty(key)) {
                                        delete lcdata[p.treeReader[key]];
                                    }
                                }
                            }
                            if (oData !== undefined) {
                                p.data[pos] = $.extend(true, oData, lcdata);
                            }
                        }
                        feedback.call(t, "afterSetRow", {
                            "rowid": rowid,
                            "inputData": data,
                            "iData": pos,
                            "iRow": ind.rowIndex,
                            "tr": ind,
                            "localData": lcdata,
                            "cssProp": cssp
                        });
                    } catch (exception) {
                        success = false;
                    }
                }
                if (success) {
                    if (cp === "string") {
                        $(ind).addClass(cssp);
                    } else if (cssp !== null && cp === "object") {
                        $(ind).css(cssp);
                    }
                }
            });
            return success;
        },
        "addRowData": function(rowid, rdata, pos, src) {
            if ($.inArray(pos, [ "first", "last", "before", "after", "afterSelected", "beforeSelected" ]) < 0) {
                pos = "last";
            }
            var success = false, nm, row, sind, i, v, aradd, cnm, cn, data, cm, id;
            if (rdata) {
                if ($.isArray(rdata)) {
                    aradd = true;
                    cnm = rowid;
                } else {
                    rdata = [ rdata ];
                    aradd = false;
                }
                this.each(function() {
                    var t = this, p = t.p, datalen = rdata.length, $self = $(t), rows = t.rows, k = 0, getGridRowById = base.getGridRowById, colModel = p.colModel, lcdata, additionalProperties = p.additionalProperties;
                    if (!aradd) {
                        if (rowid !== undefined) {
                            rowid = String(rowid);
                        } else {
                            rowid = randId();
                            if (p.keyName !== false) {
                                cnm = p.keyName;
                                if (rdata[0][cnm] !== undefined) {
                                    rowid = rdata[0][cnm];
                                }
                            }
                        }
                    }
                    cn = p.altclass;
                    while (k < datalen) {
                        data = rdata[k];
                        row = [];
                        if (aradd) {
                            try {
                                rowid = data[cnm];
                                if (rowid === undefined) {
                                    rowid = randId();
                                }
                            } catch (exception) {
                                rowid = randId();
                            }
                        }
                        id = rowid;
                        lcdata = {};
                        for (i = 0; i < colModel.length; i++) {
                            cm = colModel[i];
                            nm = cm.name;
                            if (nm !== "rn" && nm !== "cb" && nm !== "subgrid") {
                                v = convertOnSaveLocally.call(t, data[nm], cm, undefined, id, {}, i);
                                if ($.isFunction(cm.saveLocally)) {
                                    cm.saveLocally.call(t, {
                                        "newValue": v,
                                        "newItem": lcdata,
                                        "oldItem": {},
                                        "id": id,
                                        "cm": cm,
                                        "cmName": nm,
                                        "iCol": i
                                    });
                                } else if (v !== undefined) {
                                    lcdata[nm] = v;
                                }
                            }
                        }
                        for (i = 0; i < additionalProperties.length; i++) {
                            nm = additionalProperties[i];
                            if (typeof nm === "object" && nm.hasOwnProperty("name")) {
                                nm = nm.name;
                            }
                            v = getAccessor(data, nm);
                            if (v !== undefined) {
                                lcdata[nm] = v;
                            }
                        }
                        if (p.datatype === "local") {
                            lcdata[p.localReader.id] = id;
                            p._index[id] = p.data.length;
                            p.data.push(lcdata);
                        }
                        row = jgrid.parseDataToHtml.call(t, 1, [ rowid ], [ data ]);
                        row = row.join("");
                        if (rows.length === 0) {
                            $(t.tBodies[0]).append(row);
                        } else {
                            if (pos === "afterSelected" || pos === "beforeSelected") {
                                if (src === undefined && p.selrow !== null) {
                                    src = p.selrow;
                                    pos = pos === "afterSelected" ? "after" : "before";
                                } else {
                                    pos = pos === "afterSelected" ? "last" : "first";
                                }
                            }
                            switch (pos) {
                              case "last":
                                $(rows[rows.length - 1]).after(row);
                                sind = rows.length - 1;
                                break;

                              case "first":
                                $(rows[0]).after(row);
                                sind = 1;
                                break;

                              case "after":
                                sind = getGridRowById.call($self, src);
                                if (sind) {
                                    if ($(rows[sind.rowIndex + 1]).hasClass("ui-subgrid")) {
                                        $(rows[sind.rowIndex + 1]).after(row);
                                        sind = sind.rowIndex + 2;
                                    } else {
                                        $(sind).after(row);
                                        sind = sind.rowIndex + 1;
                                    }
                                }
                                break;

                              case "before":
                                sind = getGridRowById.call($self, src);
                                if (sind) {
                                    $(sind).before(row);
                                    sind = sind.rowIndex - 1;
                                }
                                break;
                            }
                        }
                        if (p.subGrid === true) {
                            base.addSubGrid.call($self, p.iColByName.subgrid, sind);
                        }
                        p.records++;
                        p.reccount++;
                        if (p.lastpage === 0) {
                            p.lastpage = 1;
                        }
                        feedback.call(t, "afterAddRow", {
                            "rowid": rowid,
                            "inputData": rdata,
                            "position": pos,
                            "srcRowid": src,
                            "iRow": sind,
                            "localData": lcdata,
                            "iData": p.data.length - 1
                        });
                        k++;
                    }
                    if (p.altRows === true && !aradd && !$self.jqGrid("isBootstrapGuiStyle")) {
                        if (pos === "last") {
                            if ((rows.length - 1) % 2 === 0) {
                                $(rows[rows.length - 1]).addClass(cn);
                            }
                        } else {
                            $(rows).each(function(iRow) {
                                if (iRow % 2 === 1) {
                                    $(this).addClass(cn);
                                } else {
                                    $(this).removeClass(cn);
                                }
                            });
                        }
                    }
                    t.rebuildRowIndexes();
                    t.updatepager(true, true);
                    success = true;
                });
            }
            return success;
        },
        "footerData": function(action, data, format) {
            var success = false, res = {};
            function isEmpty(obj) {
                var i;
                for (i in obj) {
                    if (obj.hasOwnProperty(i)) {
                        return false;
                    }
                }
                return true;
            }
            if (action == null) {
                action = "get";
            }
            if (typeof format !== "boolean") {
                format = true;
            }
            action = action.toLowerCase();
            this.each(function() {
                var t = this, p = t.p, vl, $td, nm, iCol;
                if (!t.grid || !p.footerrow) {
                    return false;
                }
                if (action === "set" && isEmpty(data)) {
                    return false;
                }
                success = true;
                var ftable = $(t.grid.sDiv).children(".ui-jqgrid-hbox").children(".ui-jqgrid-ftable")[0];
                if (ftable == null || ftable.rows == null) {
                    return false;
                }
                var cells = ftable.rows[0].cells, fcells = t.grid.fsDiv == null ? {} : t.grid.fsDiv.children(".ui-jqgrid-ftable")[0].rows[0].cells;
                for (nm in data) {
                    iCol = p.iColByName[nm];
                    if (data.hasOwnProperty(nm) && iCol !== undefined) {
                        if (action === "get") {
                            res[nm] = $(cells[iCol]).html();
                        } else if (action === "set") {
                            vl = format ? t.formatter("", data[nm], iCol, data, "edit") : data[nm];
                            $td = $(cells[iCol]).add(fcells[iCol]);
                            $td.html(vl);
                            if (p.colModel[iCol].title) {
                                $td.attr({
                                    "title": stripHtml(vl)
                                });
                            }
                        }
                    }
                }
            });
            return action === "get" ? res : success;
        },
        "showHideCol": function(colname, show, options) {
            return this.each(function() {
                var $t = this, $self = $($t), grid = $t.grid, fndh = false, p = $t.p, brd = jgrid.cell_width ? 0 : p.cellLayout, cw;
                if (!grid) {
                    return;
                }
                if (typeof colname === "string") {
                    colname = [ colname ];
                }
                show = show !== "none" && show !== false ? "" : "none";
                options = options || {};
                var sw = show === "" ? true : false, groupHeader = p.groupHeader, gh = groupHeader && (typeof groupHeader === "object" || $.isFunction(groupHeader));
                if (gh && !options.skipSetGroupHeaders) {
                    base.destroyGroupHeader.call($self, false);
                }
                $(p.colModel).each(function(iCol) {
                    if ($.inArray(this.name, colname) !== -1 && this.hidden === sw) {
                        if (p.frozenColumns === true && this.frozen === true && !options.notSkipFrozen) {
                            return true;
                        }
                        var $rows = $(grid.hDiv).find("tr[role=row]");
                        if (p.frozenColumns === true && grid.fhDiv != null) {
                            $rows = $rows.add($(grid.fhDiv).find("tr[role=row]"));
                        }
                        $rows.each(function() {
                            $(this.cells[iCol]).css("display", show);
                        });
                        $rows = $($t.rows);
                        if (p.frozenColumns === true && grid.fbRows != null) {
                            $rows = $rows.add(grid.fbRows);
                        }
                        $rows.each(function() {
                            var cell = this.cells[iCol];
                            if (!$(this).hasClass("jqgroup") || cell != null && cell.colSpan === 1) {
                                $(cell).css("display", show);
                            }
                        });
                        if (p.footerrow) {
                            $rows = $(grid.sDiv).find("tr.footrow");
                            if (p.frozenColumns === true && grid.fsDiv != null) {
                                $rows = $rows.add($(grid.fsDiv).find("tr.footrow"));
                            }
                            $rows.each(function() {
                                $(this.cells[iCol]).css("display", show);
                            });
                        }
                        cw = parseInt(this.width, 10);
                        if (show === "none") {
                            p.tblwidth -= cw + brd;
                        } else {
                            p.tblwidth += cw + brd;
                        }
                        this.hidden = !sw;
                        fndh = true;
                        if (!options.skipFeedback) {
                            feedback.call($t, "onShowHideCol", sw, this.name, iCol);
                        } else {
                            options.toReport = options.toReport || {};
                            options.toReport[this.name] = sw;
                        }
                    }
                });
                if (fndh === true) {
                    var newGridWidth = !p.autowidth && (p.widthOrg === undefined || p.widthOrg === "auto" || p.widthOrg === "100%") ? p.tblwidth + parseInt(p.scrollOffset, 10) : p.width;
                    if (!options.skipSetGridWidth) {
                        base.setGridWidth.call($self, newGridWidth);
                    } else {
                        options.newGridWidth = newGridWidth;
                    }
                }
                if (gh && !options.skipSetGroupHeaders) {
                    if (p.pivotOptions != null && p.pivotOptions.colHeaders != null && p.pivotOptions.colHeaders.length > 1) {
                        var i, gHead = p.pivotOptions.colHeaders;
                        for (i = 0; i < gHead.length; i++) {
                            if (gHead[i] && gHead[i].groupHeaders.length) {
                                base.setGroupHeaders.call($self, gHead[i]);
                            }
                        }
                    } else {
                        base.setGroupHeaders.call($self, p.groupHeader);
                    }
                }
            });
        },
        "hideCol": function(colname, options) {
            return this.each(function() {
                base.showHideCol.call($(this), colname, "none", options);
            });
        },
        "showCol": function(colname, options) {
            return this.each(function() {
                base.showHideCol.call($(this), colname, "", options);
            });
        },
        "remapColumns": function(permutation, updateCells, keepHeader) {
            var ts = this[0], p = ts.p, grid = ts.grid, iCol, n, makeArray = $.makeArray, isFrozenColumns = p.frozenColumns === true, $toResort, nFrozenColumns = this.jqGrid("getNumberOfFrozenColumns"), permutationNormalized;
            function normalizePermutation() {
                var frozen = [], nonFrozen = [], i, l = permutation.length;
                for (i = 0; i < l; i++) {
                    if (isFrozenColumns && permutation[i] < nFrozenColumns) {
                        frozen.push(permutation[i]);
                    } else {
                        nonFrozen.push(permutation[i]);
                    }
                }
                return frozen.concat(nonFrozen);
            }
            function resortArray(a) {
                var ac = a.length ? makeArray(a) : $.extend({}, a);
                $.each(permutationNormalized, function(i) {
                    a[i] = ac[this];
                });
            }
            function resortRows($parent, selector) {
                var $rows = selector ? $parent.children(selector) : $parent.children();
                $rows.each(function() {
                    var row = this, elems = makeArray(row.cells);
                    $.each(permutationNormalized, function(i) {
                        var e = elems[this], oldElem = row.cells[i];
                        if (e != null && oldElem != null && e.cellIndex !== i) {
                            e.parentNode.insertBefore(e, oldElem);
                        }
                    });
                });
            }
            if (grid == null || p == null) {
                return;
            }
            permutationNormalized = normalizePermutation();
            resortArray(p.colModel);
            resortArray(p.colNames);
            resortArray(grid.headers);
            $toResort = $(grid.hDiv).children("div").children("table.ui-jqgrid-htable").children("thead");
            if (isFrozenColumns && grid.fhDiv != null) {
                $toResort = $toResort.add(grid.fhDiv.children("table.ui-jqgrid-htable").children("thead"));
            }
            resortRows($toResort, keepHeader && ":not(.ui-jqgrid-labels)");
            if (updateCells) {
                $toResort = $(ts.tBodies[0]);
                if (isFrozenColumns && grid.fbDiv != null) {
                    $toResort = $toResort.add(grid.fbDiv.children("table.ui-jqgrid-btable").children("tbody").first());
                }
                resortRows($toResort, "tr.jqgfirstrow,tr.jqgrow,tr.jqfoot");
            }
            if (p.footerrow) {
                $toResort = $(grid.sDiv).children("div").children("table.ui-jqgrid-ftable").children("tbody").first();
                if (isFrozenColumns && grid.fsDiv != null) {
                    $toResort = $toResort.add(grid.fsDiv.children("table.ui-jqgrid-ftable").children("tbody").first());
                }
                resortRows($toResort);
            }
            if (p.remapColumns) {
                if (!p.remapColumns.length) {
                    p.remapColumns = makeArray(permutationNormalized);
                } else {
                    resortArray(p.remapColumns);
                }
            }
            p.lastsort = $.inArray(p.lastsort, permutationNormalized);
            p.iColByName = {};
            for (iCol = 0, n = p.colModel.length; iCol < n; iCol++) {
                p.iColByName[p.colModel[iCol].name] = iCol;
            }
            feedback.call(ts, "onRemapColumns", permutationNormalized, updateCells, keepHeader);
        },
        "remapColumnsByName": function(permutationByName, updateCells, keepHeader) {
            var ts = this[0], p = ts.p, permutation = [], i, n, cmNames = permutationByName.slice(), inArray = $.inArray;
            if (p.subGrid && inArray("subgrid", cmNames) < 0) {
                cmNames.unshift("subgrid");
            }
            if (p.multiselect && inArray("cb", cmNames) < 0) {
                cmNames.unshift("cb");
            }
            if (p.rownumbers && inArray("rn", cmNames) < 0) {
                cmNames.unshift("rn");
            }
            for (i = 0, n = cmNames.length; i < n; i++) {
                permutation.push(p.iColByName[cmNames[i]]);
            }
            base.remapColumns.call(this, permutation, updateCells, keepHeader);
            return this;
        },
        "setGridWidth": function(newWidth, shrink) {
            return this.each(function() {
                var $t = this, p = $t.p, columnWidth, grid = $t.grid, initialWidth = 0, iLastVariableColumn, numberOfVariableColumns = 0, hasScrollbar = false, totalVariableWidth, fixedColumnsWidth = 0, correctur, isCellClassHidden = jgrid.isCellClassHidden, newGridWidth = newWidth;
                if (!grid || p == null) {
                    return;
                }
                $t.fixScrollOffsetAndhBoxPadding();
                var colModel = p.colModel, cm, scrollbarWidth = p.scrollOffset, borderAndPaddingWidth = jgrid.cell_width ? 0 : p.cellLayout, thInfo, headers = grid.headers, footers = grid.footers, bDiv = grid.bDiv, hDiv = grid.hDiv, sDiv = grid.sDiv, cols = grid.cols, delta, colsExist, shrinkFactor, hCols = $(hDiv).find(">div>.ui-jqgrid-htable>thead>tr").first()[0].cells, setWidthOfAllDivs = function(width) {
                    grid.width = p.width = width;
                    $(p.gBox).css("width", width + "px");
                    $(p.gView).css("width", width + "px");
                    $(bDiv).css("width", width + "px");
                    $(hDiv).css("width", width + "px");
                    if (p.pager) {
                        $(p.pager).css("width", width + "px");
                    }
                    if (p.toppager) {
                        $(p.toppager).css("width", width + "px");
                    }
                    if (p.toolbar[0] === true) {
                        $(grid.uDiv).css("width", width + "px");
                        if (p.toolbar[1] === "both") {
                            $(grid.ubDiv).css("width", width + "px");
                        }
                    }
                    if (p.footerrow) {
                        $(sDiv).css("width", width + "px");
                    }
                };
                if (typeof shrink !== "boolean") {
                    shrink = p.shrinkToFit;
                }
                if (isNaN(newGridWidth)) {
                    return;
                }
                newGridWidth = parseInt(newGridWidth, 10);
                setWidthOfAllDivs(newGridWidth);
                if (shrink === false && p.forceFit === true) {
                    p.forceFit = false;
                }
                if (shrink === true) {
                    $.each(colModel, function() {
                        if (this.hidden === false && !isCellClassHidden(this.classes)) {
                            columnWidth = this.widthOrg;
                            initialWidth += columnWidth + borderAndPaddingWidth;
                            if (this.fixed) {
                                fixedColumnsWidth += this.width + borderAndPaddingWidth;
                            } else {
                                numberOfVariableColumns++;
                            }
                        }
                    });
                    if (numberOfVariableColumns === 0) {
                        return;
                    }
                    p.tblwidth = parseInt(initialWidth, 10);
                    totalVariableWidth = newGridWidth - borderAndPaddingWidth * numberOfVariableColumns - fixedColumnsWidth;
                    if (!isNaN(p.height)) {
                        if (bDiv.clientHeight < bDiv.scrollHeight || $t.rows.length === 1) {
                            hasScrollbar = true;
                            totalVariableWidth -= scrollbarWidth;
                        }
                    }
                    shrinkFactor = totalVariableWidth / (p.tblwidth - borderAndPaddingWidth * numberOfVariableColumns - fixedColumnsWidth);
                    if (shrinkFactor < 0) {
                        return;
                    }
                    initialWidth = 0;
                    colsExist = cols.length > 0;
                    $.each(colModel, function(i) {
                        if (this.hidden === false && !isCellClassHidden(this.classes) && !this.fixed) {
                            columnWidth = Math.round(this.widthOrg * shrinkFactor);
                            this.width = columnWidth;
                            initialWidth += columnWidth;
                            headers[i].width = columnWidth;
                            hCols[i].style.width = columnWidth + "px";
                            if (p.footerrow) {
                                footers[i].style.width = columnWidth + "px";
                            }
                            if (colsExist) {
                                cols[i].style.width = columnWidth + "px";
                            }
                            iLastVariableColumn = i;
                        }
                    });
                    if (!iLastVariableColumn) {
                        return;
                    }
                    correctur = 0;
                    if (hasScrollbar) {
                        if (newGridWidth - fixedColumnsWidth - (initialWidth + borderAndPaddingWidth * numberOfVariableColumns) !== scrollbarWidth) {
                            correctur = newGridWidth - fixedColumnsWidth - (initialWidth + borderAndPaddingWidth * numberOfVariableColumns) - scrollbarWidth;
                        }
                    } else if (Math.abs(newGridWidth - fixedColumnsWidth - (initialWidth + borderAndPaddingWidth * numberOfVariableColumns)) !== 1) {
                        correctur = newGridWidth - fixedColumnsWidth - (initialWidth + borderAndPaddingWidth * numberOfVariableColumns);
                    }
                    cm = colModel[iLastVariableColumn];
                    cm.width += correctur;
                    p.tblwidth = parseInt(initialWidth + correctur + borderAndPaddingWidth * numberOfVariableColumns + fixedColumnsWidth, 10);
                    if (p.tblwidth > newGridWidth) {
                        delta = p.tblwidth - parseInt(newGridWidth, 10);
                        p.tblwidth = newGridWidth;
                        cm.width = cm.width - delta;
                    }
                    columnWidth = cm.width;
                    thInfo = headers[iLastVariableColumn];
                    thInfo.width = columnWidth;
                    hCols[iLastVariableColumn].style.width = columnWidth + "px";
                    if (colsExist) {
                        cols[iLastVariableColumn].style.width = columnWidth + "px";
                    }
                    if (p.footerrow) {
                        footers[iLastVariableColumn].style.width = columnWidth + "px";
                    }
                    if (p.tblwidth + (hasScrollbar ? scrollbarWidth : 0) < p.width) {
                        setWidthOfAllDivs(p.tblwidth + (hasScrollbar ? scrollbarWidth : 0));
                    }
                    if (bDiv.offsetWidth > bDiv.clientWidth) {
                        if (!p.autowidth && (p.widthOrg === undefined || p.widthOrg === "auto" || p.widthOrg === "100%")) {
                            setWidthOfAllDivs(bDiv.offsetWidth);
                        }
                    }
                }
                if (p.tblwidth) {
                    p.tblwidth = parseInt(p.tblwidth, 10);
                    newGridWidth = p.tblwidth;
                    hDiv.scrollLeft = bDiv.scrollLeft;
                    delta = Math.abs(newGridWidth - p.width);
                    if (p.shrinkToFit && !shrink && delta < 3 && delta > 0) {
                        if (newGridWidth < p.width) {
                            setWidthOfAllDivs(newGridWidth);
                        }
                        if (bDiv.offsetWidth > bDiv.clientWidth) {
                            if (!p.autowidth && (p.widthOrg === undefined || p.widthOrg === "auto" || p.widthOrg === "100%")) {
                                setWidthOfAllDivs(bDiv.offsetWidth);
                            }
                        }
                    }
                }
                $t.fixScrollOffsetAndhBoxPadding();
                var whichHeigthToRecalculate = {
                    "resizeDiv": true,
                    "resizedRows": {
                        "iRowStart": shrink ? 0 : -1,
                        "iRowEnd": -1
                    }
                };
                $($t).triggerHandler("jqGridResetFrozenHeights", [ {
                    "header": whichHeigthToRecalculate,
                    "resizeFooter": true,
                    "body": whichHeigthToRecalculate
                } ]);
            });
        },
        "setGridHeight": function(nh) {
            return this.each(function() {
                var $t = this, grid = $t.grid, p = $t.p;
                if (!grid) {
                    return;
                }
                var bDiv = $(grid.bDiv);
                bDiv.css({
                    "height": nh + (isNaN(nh) ? "" : "px")
                });
                if (p.frozenColumns === true) {
                    $(p.idSel + "_frozen").parent().height(bDiv.height() - 16);
                }
                p.height = nh;
                if (p.scroll) {
                    grid.populateVisible.call($t);
                }
                $t.fixScrollOffsetAndhBoxPadding();
                $($t).triggerHandler("jqGridResetFrozenHeights");
            });
        },
        "setCaption": function(newcap) {
            return this.each(function() {
                var self = this, cDiv = self.grid.cDiv;
                self.p.caption = newcap;
                $("span.ui-jqgrid-title, span.ui-jqgrid-title-rtl", cDiv).html(newcap);
                $(cDiv).show();
                $(cDiv).nextAll("div").removeClass(base.getGuiStyles.call(self, "top"));
                $(this).triggerHandler("jqGridResetFrozenHeights");
            });
        },
        "setLabel": function(colname, nData, prop, attrp) {
            return this.each(function() {
                var $t = this, iCol, p = $t.p, $th;
                if (!$t.grid) {
                    return;
                }
                if (isNaN(colname)) {
                    iCol = p.iColByName[colname];
                    if (iCol === undefined) {
                        return;
                    }
                } else {
                    iCol = parseInt(colname, 10);
                }
                if (iCol >= 0) {
                    $th = $($t.grid.headers[iCol].el);
                    if (p.frozenColumns) {
                        $th = $th.add($t.grid.fhDiv.find(".ui-jqgrid-htable tr.ui-jqgrid-labels th.ui-th-column").eq(iCol));
                    }
                    if (nData) {
                        $th.each(function() {
                            var $div = $("[id^=jqgh_]", this), $textWrapper = $div.children("span.ui-jqgrid-cell-wrapper");
                            if ($textWrapper.length > 0) {
                                $textWrapper.html(nData);
                            } else {
                                var $ico = $(".s-ico", this);
                                $div.empty().html(nData)[p.sortIconsBeforeText ? "prepend" : "append"]($ico);
                            }
                        });
                        p.colNames[iCol] = nData;
                    }
                    if (prop) {
                        if (typeof prop === "string") {
                            $th.addClass(prop);
                        } else {
                            $th.css(prop);
                        }
                    }
                    if (typeof attrp === "object") {
                        $th.attr(attrp);
                    }
                }
            });
        },
        "setCell": function(rowid, colName, nData, cssp, attrp, forceUpdate) {
            return this.each(function() {
                var $t = this, p = $t.p, iCol = -1, colModel = p.colModel, v, i, cm, item, tr, $td, $tdi, val, rawdat = {}, id, index;
                if (!$t.grid) {
                    return;
                }
                iCol = isNaN(colName) ? p.iColByName[colName] : parseInt(colName, 10);
                if (iCol >= 0) {
                    tr = base.getGridRowById.call($($t), rowid);
                    if (tr) {
                        $td = jgrid.getCell.call($t, tr, iCol);
                        if (nData !== "" || forceUpdate === true) {
                            cm = colModel[iCol];
                            if (p.datatype === "local") {
                                id = stripPref(p.idPrefix, rowid);
                                index = p._index[id];
                                if (index !== undefined) {
                                    item = p.data[index];
                                }
                            }
                            if (item == null) {
                                for (i = 0; i < tr.cells.length; i++) {
                                    if (i !== iCol) {
                                        $tdi = jgrid.getDataFieldOfCell.call($t, tr, i);
                                        if ($tdi.length > 0) {
                                            try {
                                                val = $.unformat.call($t, $tdi, {
                                                    "rowId": rowid,
                                                    "colModel": colModel[i]
                                                }, i);
                                            } catch (exception) {
                                                val = htmlDecode($tdi[0].innerHTML);
                                            }
                                            rawdat[colModel[i].name] = val;
                                        }
                                    }
                                }
                            } else {
                                rawdat = item;
                            }
                            rawdat[cm.name] = nData;
                            v = $t.formatter(rowid, nData, iCol, rawdat, "edit");
                            var $dataFiled = $td;
                            if (p.treeGrid === true && cm.name === p.ExpandColumn) {
                                $dataFiled = $dataFiled.children("span.cell-wrapperleaf,span.cell-wrapper").first();
                            }
                            $dataFiled.html(v);
                            if (cm.title) {
                                $td.attr({
                                    "title": nData
                                });
                            }
                            if (item != null) {
                                v = convertOnSaveLocally.call($t, nData, cm, item[cm.name], id, item, iCol);
                                if ($.isFunction(cm.saveLocally)) {
                                    cm.saveLocally.call($t, {
                                        "newValue": v,
                                        "newItem": item,
                                        "oldItem": item,
                                        "id": id,
                                        "cm": cm,
                                        "cmName": cm.name,
                                        "iCol": iCol
                                    });
                                } else {
                                    item[cm.name] = v;
                                }
                            }
                        }
                        if (cssp || attrp) {
                            $td = jgrid.getCell.call($t, tr, iCol);
                            if (cssp) {
                                $td[typeof cssp === "string" ? "addClass" : "css"](cssp);
                            }
                            if (typeof attrp === "object") {
                                $td.attr(attrp);
                            }
                        }
                    }
                }
            });
        },
        "getCell": function(rowid, colName) {
            var ret = false;
            this.each(function() {
                var $t = this, iCol, p = $t.p, tr, $td;
                if (!$t.grid) {
                    return;
                }
                iCol = isNaN(colName) ? p.iColByName[colName] : parseInt(colName, 10);
                if (iCol >= 0) {
                    tr = base.getGridRowById.call($($t), rowid);
                    if (tr) {
                        $td = jgrid.getDataFieldOfCell.call($t, tr, iCol).first();
                        try {
                            ret = $.unformat.call($t, $td, {
                                "rowId": tr.id,
                                "colModel": p.colModel[iCol]
                            }, iCol);
                        } catch (exception) {
                            ret = htmlDecode($td.html());
                        }
                    }
                }
            });
            return ret;
        },
        "getCol": function(colName, obj, mathopr) {
            var ret = [], val, sum = 0, min, max, v;
            obj = typeof obj !== "boolean" ? false : obj;
            if (mathopr === undefined) {
                mathopr = false;
            }
            this.each(function() {
                var $t = this, iCol, p = $t.p, $td;
                if (!$t.grid) {
                    return;
                }
                iCol = isNaN(colName) ? p.iColByName[colName] : parseInt(colName, 10);
                if (iCol >= 0) {
                    var rows = $t.rows, ln = rows.length, i = 0, dlen = 0, tr;
                    if (ln && ln > 0) {
                        while (i < ln) {
                            tr = rows[i];
                            if ($(tr).hasClass("jqgrow")) {
                                $td = jgrid.getDataFieldOfCell.call($t, tr, iCol).first();
                                try {
                                    val = $.unformat.call($t, $td, {
                                        "rowId": tr.id,
                                        "colModel": p.colModel[iCol]
                                    }, iCol);
                                } catch (exception) {
                                    val = htmlDecode($td.html());
                                }
                                if (mathopr) {
                                    v = parseFloat(val);
                                    if (!isNaN(v)) {
                                        sum += v;
                                        if (max === undefined) {
                                            max = min = v;
                                        }
                                        min = Math.min(min, v);
                                        max = Math.max(max, v);
                                        dlen++;
                                    }
                                } else if (obj) {
                                    ret.push({
                                        "id": tr.id,
                                        "value": val
                                    });
                                } else {
                                    ret.push(val);
                                }
                            }
                            i++;
                        }
                        if (mathopr) {
                            switch (mathopr.toLowerCase()) {
                              case "sum":
                                ret = sum;
                                break;

                              case "avg":
                                ret = sum / dlen;
                                break;

                              case "count":
                                ret = ln - 1;
                                break;

                              case "min":
                                ret = min;
                                break;

                              case "max":
                                ret = max;
                                break;
                            }
                        }
                    }
                }
            });
            return ret;
        },
        "clearGridData": function(clearfooter) {
            return this.each(function() {
                var $t = this, p = $t.p, rows = $t.rows, grid = $t.grid;
                if (!grid || !p || !rows) {
                    return;
                }
                if (typeof clearfooter !== "boolean") {
                    clearfooter = false;
                }
                $($t).unbind(".jqGridFormatter");
                grid.emptyRows.call($t, false, true);
                if (p.footerrow && clearfooter) {
                    $(".ui-jqgrid-ftable td", grid.sDiv).html("&#160;");
                }
                p.selrow = null;
                clearArray(p.selarrrow);
                clearArray(p.savedRow);
                clearArray(p.data);
                clearArray(p.lastSelectedData);
                p._index = {};
                p.rowIndexes = {};
                p.records = 0;
                p.page = 1;
                p.lastpage = 0;
                p.reccount = 0;
                $t.updatepager(true, false);
            });
        },
        "getInd": function(rowid, rc) {
            var tr = base.getGridRowById.call($(this), rowid);
            return tr ? rc === true ? tr : tr.rowIndex : false;
        },
        "bindKeys": function(settings) {
            var o = $.extend({
                "onEnter": null,
                "onSpace": null,
                "onLeftKey": null,
                "onRightKey": null,
                "scrollingRows": true
            }, settings || {});
            return this.each(function() {
                var $t = this, p = $t.p, $self = $($t);
                p.scrollrows = o.scrollingRows;
                $self.bind("keydown.jqGrid", function(event) {
                    var tr = $(this).find("tr[tabindex=0]")[0], editingInfo = jgrid.detectRowEditing.call($t, $(event.target).closest("tr.jqgrow").attr("id")), moveVerical = function(siblingProperty) {
                        do {
                            tr = tr[siblingProperty];
                            if (tr === null) {
                                return;
                            }
                        } while ($(tr).is(":hidden") || !$(tr).hasClass("jqgrow"));
                        base.setSelection.call($self, tr.id, true);
                        event.preventDefault();
                    }, feedbackKey = function(name, callbackSuffix) {
                        var callback = o["on" + name + (callbackSuffix || "")];
                        $self.triggerHandler("jqGridKey" + name, [ p.selrow ]);
                        if ($.isFunction(callback)) {
                            callback.call($t, p.selrow);
                        }
                    }, moveHorizontal = function(stringLeftOrRight) {
                        if (p.treeGrid) {
                            var expanded = p.data[p._index[stripPref(p.idPrefix, tr.id)]][p.treeReader.expanded_field];
                            if (stringLeftOrRight === "Right") {
                                expanded = !expanded;
                            }
                            if (expanded) {
                                $(tr).find("div.treeclick").trigger("click");
                            }
                        }
                        feedbackKey(stringLeftOrRight, "Key");
                    };
                    if (tr && editingInfo === null) {
                        switch (event.keyCode) {
                          case 38:
                            moveVerical("previousSibling");
                            break;

                          case 40:
                            moveVerical("nextSibling");
                            break;

                          case 37:
                            moveHorizontal("Left");
                            break;

                          case 39:
                            moveHorizontal("Right");
                            break;

                          case 13:
                            feedbackKey("Enter");
                            break;

                          case 32:
                            feedbackKey("Space");
                            break;

                          default:
                            break;
                        }
                    }
                });
            });
        },
        "unbindKeys": function() {
            return this.each(function() {
                $(this).unbind("keydown.jqGrid");
            });
        },
        "getLocalRow": function(rowid) {
            var ret = false, ind;
            this.each(function() {
                if (rowid !== undefined) {
                    ind = this.p._index[stripPref(this.p.idPrefix, rowid)];
                    if (ind >= 0) {
                        ret = this.p.data[ind];
                    }
                }
            });
            return ret;
        },
        "progressBar": function(p) {
            p = $.extend({
                "htmlcontent": "",
                "method": "hide",
                "loadtype": "disable"
            }, p || {});
            return this.each(function() {
                var sh = p.method === "show" ? true : false, gridIdEscaped = jqID(this.p.id), $loading = $("#load_" + gridIdEscaped);
                if (p.htmlcontent !== "") {
                    $loading.html(p.htmlcontent);
                }
                switch (p.loadtype) {
                  case "disable":
                    break;

                  case "enable":
                    $loading.toggle(sh);
                    break;

                  case "block":
                    $("#lui_" + gridIdEscaped).toggle(sh);
                    $loading.toggle(sh);
                    break;
                }
            });
        },
        "setColWidth": function(iCol, newWidth, adjustGridWidth, skipGridAdjustments) {
            return this.each(function() {
                var self = this, $self = $(self), grid = self.grid, p = self.p, h;
                if (typeof iCol === "string") {
                    iCol = p.iColByName[iCol];
                    if (iCol === undefined) {
                        return;
                    }
                } else if (typeof iCol !== "number") {
                    return;
                }
                h = grid.headers[iCol];
                if (h != null) {
                    h.newWidth = newWidth;
                    grid.newWidth = p.tblwidth + newWidth - h.width;
                    grid.resizeColumn(iCol, !p.frozenColumns, skipGridAdjustments);
                    if (adjustGridWidth !== false && !skipGridAdjustments) {
                        self.fixScrollOffsetAndhBoxPadding();
                        base.setGridWidth.call($self, grid.newWidth + p.scrollOffset, false);
                    }
                }
            });
        },
        "getAutoResizableWidth": function(iCol) {
            var self = this;
            if (self.length === 0) {
                return -1;
            }
            self = self[0];
            var rows = self.rows, row, cell, iRow, $cell, $cellFirstChild, p = self.p, cm = p.colModel[iCol], $th = $(self.grid.headers[iCol].el), $thDiv = $th.find(">div"), thPaddingLeft = parseFloat($th.css("padding-left") || 0), thPaddingRight = parseFloat($th.css("padding-right") || 0), $incosDiv = $thDiv.find("span.s-ico"), $wrapper = $thDiv.find(">." + p.autoResizing.wrapperClassName), wrapperOuterWidth = $wrapper.outerWidth(), wrapperCssWidth = parseFloat($wrapper.css("width") || 0), widthOuter = 0, colWidth = 0, compact = cm.autoResizing != null && cm.autoResizable.compact !== undefined ? cm.autoResizable.compact : p.autoResizing.compact, wrapperClassName = p.autoResizing.wrapperClassName;
            if (cm == null || !cm.autoResizable || $wrapper.length === 0 || cm.hidden || jgrid.isCellClassHidden(cm.classes) || cm.fixed) {
                return -1;
            }
            if (!compact || $incosDiv.is(":visible") || $incosDiv.css("display") !== "none") {
                colWidth = $incosDiv.outerWidth(true);
                if (!p.sortIconsBeforeText) {
                    colWidth -= p.direction === "rtl" ? parseFloat($incosDiv.css("padding-left") || 0) + parseFloat($incosDiv.css("margin-left") || 0) : parseFloat($incosDiv.css("padding-right") || 0) + parseFloat($incosDiv.css("margin-right") || 0);
                }
            }
            colWidth += wrapperOuterWidth + thPaddingLeft + (wrapperCssWidth === wrapperOuterWidth ? thPaddingLeft + thPaddingRight : 0) + parseFloat($thDiv.css("margin-left") || 0) + parseFloat($thDiv.css("margin-right") || 0);
            for (iRow = 0, rows = self.rows; iRow < rows.length; iRow++) {
                row = rows[iRow];
                cell = row.cells[iCol];
                $cell = $(row.cells[iCol]);
                if (cell != null && ($(row).hasClass("jqgrow") || $(row).hasClass("jqgroup") && cell.colSpan === 1)) {
                    $cellFirstChild = $(cell.firstChild);
                    if ($cellFirstChild.hasClass(wrapperClassName)) {
                        colWidth = Math.max(colWidth, $cellFirstChild.outerWidth() + widthOuter);
                    } else if (p.treeGrid && p.ExpandColumn === cm.name) {
                        $cellFirstChild = $cell.children(".cell-wrapper,.cell-wrapperleaf");
                        colWidth = Math.max(colWidth, $cellFirstChild.outerWidth() + widthOuter + $cell.children(".tree-wrap").outerWidth());
                    }
                } else if ($(row).hasClass("jqgfirstrow")) {
                    widthOuter = (jgrid.cell_width ? parseFloat($cell.css("padding-left") || 0) + parseFloat($cell.css("padding-right") || 0) : 0) + parseFloat($cell.css("border-right") || 0) + parseFloat($cell.css("border-left") || 0);
                }
            }
            colWidth = Math.max(colWidth, cm.autoResizing != null && cm.autoResizing.minColWidth !== undefined ? cm.autoResizing.minColWidth : p.autoResizing.minColWidth);
            return Math.min(colWidth, cm.autoResizing != null && cm.autoResizing.maxColWidth !== undefined ? cm.autoResizing.maxColWidth : p.autoResizing.maxColWidth);
        },
        "autoResizeColumn": function(iCol, skipGridAdjustments) {
            return this.each(function() {
                var self = this, $self = $(this), p = self.p, cm = p.colModel[iCol], widthOrg, $th = $(self.grid.headers[iCol].el), newWidth = base.getAutoResizableWidth.call($self, iCol);
                if (cm == null || newWidth < 0 || newWidth === cm.width) {
                    return;
                }
                base.setColWidth.call($self, iCol, newWidth, p.autoResizing.adjustGridWidth && !p.autoResizing.fixWidthOnShrink && !skipGridAdjustments, skipGridAdjustments);
                if (p.autoResizing.fixWidthOnShrink && p.shrinkToFit && !skipGridAdjustments) {
                    cm.fixed = true;
                    widthOrg = cm.widthOrg;
                    cm.widthOrg = cm.width;
                    base.setGridWidth.call($self, p.width, true);
                    cm.widthOrg = widthOrg;
                    cm.fixed = false;
                }
                $th.data("autoResized", "true");
            });
        },
        "autoResizeAllColumns": function() {
            return this.each(function() {
                var self = this, $self = $(self), p = self.p, colModel = p.colModel, nCol = colModel.length, iCol, cm, shrinkToFit = p.shrinkToFit, adjustGridWidth = p.autoResizing.adjustGridWidth, fixWidthOnShrink = p.autoResizing.fixWidthOnShrink, width = parseInt(p.widthOrg, 10), grid = self.grid, autoResizeColumn = base.autoResizeColumn;
                p.shrinkToFit = false;
                p.autoResizing.adjustGridWidth = true;
                p.autoResizing.fixWidthOnShrink = false;
                for (iCol = 0; iCol < nCol; iCol++) {
                    cm = colModel[iCol];
                    if (cm.autoResizable && cm.formatter !== "actions") {
                        autoResizeColumn.call($self, iCol, true);
                    }
                }
                grid.hDiv.scrollLeft = grid.bDiv.scrollLeft;
                if (p.footerrow) {
                    grid.sDiv.scrollLeft = grid.bDiv.scrollLeft;
                }
                self.fixScrollOffsetAndhBoxPadding();
                if (!isNaN(width)) {
                    base.setGridWidth.call($self, width, false);
                } else if (adjustGridWidth) {
                    base.setGridWidth.call($self, grid.newWidth + p.scrollOffset, false);
                }
                p.autoResizing.fixWidthOnShrink = fixWidthOnShrink;
                p.autoResizing.adjustGridWidth = adjustGridWidth;
                p.shrinkToFit = shrinkToFit;
            });
        }
    });
});

(function(factory) {
    "use strict";
    if (typeof define === "function" && define.amd) {
        define([ "jquery", "./grid.base", "./jquery.fmatter", "./grid.common" ], factory);
    } else if (typeof exports === "object") {
        factory(require("jquery"));
    } else {
        factory(jQuery);
    }
})(function($) {
    "use strict";
    var jgrid = $.jgrid, jqID = jgrid.jqID, base = $.fn.jqGrid, getGuiStyles = base.getGuiStyles, getGridRes = base.getGridRes;
    jgrid.extend({
        "getColProp": function(colname) {
            var ret = {}, t = this[0], iCol;
            if (t != null && t.grid) {
                iCol = t.p.iColByName[colname];
                if (iCol !== undefined) {
                    return t.p.colModel[iCol];
                }
            }
            return ret;
        },
        "setColProp": function(colname, obj) {
            return this.each(function() {
                var self = this, p = self.p, iCol;
                if (self.grid && p != null && obj) {
                    iCol = p.iColByName[colname];
                    if (iCol !== undefined) {
                        $.extend(true, p.colModel[iCol], obj);
                    }
                }
            });
        },
        "sortGrid": function(colname, reload, sor) {
            return this.each(function() {
                var self = this, grid = self.grid, p = self.p, colModel = p.colModel, l = colModel.length, cm, i, sobj = false, sort;
                if (!grid) {
                    return;
                }
                if (!colname) {
                    colname = p.sortname;
                }
                if (typeof reload !== "boolean") {
                    reload = false;
                }
                for (i = 0; i < l; i++) {
                    cm = colModel[i];
                    if (cm.index === colname || cm.name === colname) {
                        if (p.frozenColumns === true && cm.frozen === true) {
                            sobj = grid.fhDiv.find("#" + p.id + "_" + colname);
                        }
                        if (!sobj || sobj.length === 0) {
                            sobj = grid.headers[i].el;
                        }
                        sort = cm.sortable;
                        if (typeof sort !== "boolean" || sort) {
                            self.sortData("jqgh_" + p.id + "_" + colname, i, reload, sor, sobj);
                        }
                        break;
                    }
                }
            });
        },
        "clearBeforeUnload": function() {
            return this.each(function() {
                var self = this, p = self.p, grid = self.grid, propOrMethod, clearArray = jgrid.clearArray, hasOwnProperty = Object.prototype.hasOwnProperty;
                if ($.isFunction(grid.emptyRows)) {
                    grid.emptyRows.call(self, true, true);
                }
                $(document).unbind("mouseup.jqGrid" + p.id);
                $(grid.hDiv).unbind("mousemove");
                $(self).unbind();
                var i, l = grid.headers.length;
                for (i = 0; i < l; i++) {
                    grid.headers[i].el = null;
                }
                for (propOrMethod in grid) {
                    if (grid.hasOwnProperty(propOrMethod)) {
                        grid.propOrMethod = null;
                    }
                }
                var propOrMethods = [ "formatCol", "sortData", "updatepager", "refreshIndex", "setHeadCheckBox", "constructTr", "clearToolbar", "fixScrollOffsetAndhBoxPadding", "rebuildRowIndexes", "modalAlert", "toggleToolbar", "triggerToolbar", "formatter", "addXmlData", "addJSONData", "ftoolbar", "_inlinenav", "nav", "grid", "p" ];
                l = propOrMethods.length;
                for (i = 0; i < l; i++) {
                    if (hasOwnProperty.call(self, propOrMethods[i])) {
                        self[propOrMethods[i]] = null;
                    }
                }
                self._index = {};
                clearArray(p.data);
                clearArray(p.lastSelectedData);
                clearArray(p.selarrrow);
                clearArray(p.savedRow);
            });
        },
        "GridDestroy": function() {
            return this.each(function() {
                var self = this, p = self.p;
                if (self.grid && p != null) {
                    if (p.pager) {
                        $(p.pager).remove();
                    }
                    try {
                        $("#alertmod_" + p.idSel).remove();
                        $(self).jqGrid("clearBeforeUnload");
                        $(p.gBox).remove();
                    } catch (ignore) {}
                }
            });
        },
        "GridUnload": function() {
            return this.each(function() {
                var self = this, $self = $(self), p = self.p, $j = $.fn.jqGrid;
                if (!self.grid) {
                    return;
                }
                $self.removeClass($j.getGuiStyles.call($self, "grid", "ui-jqgrid-btable"));
                if (p.pager) {
                    $(p.pager).empty().removeClass($j.getGuiStyles.call($self, "pagerBottom", "ui-jqgrid-pager")).removeAttr("style").removeAttr("dir");
                }
                $self.jqGrid("clearBeforeUnload");
                $self.removeAttr("style").removeAttr("tabindex").removeAttr("role").removeAttr("aria-labelledby").removeAttr("style");
                $self.empty();
                $self.insertBefore(p.gBox).show();
                $(p.pager).insertBefore(p.gBox).show();
                $(p.gBox).remove();
            });
        },
        "setGridState": function(state) {
            return this.each(function() {
                var $t = this, p = $t.p, grid = $t.grid, cDiv = grid.cDiv, $uDiv = $(grid.uDiv), $ubDiv = $(grid.ubDiv);
                if (!grid || p == null) {
                    return;
                }
                var getMinimizeIcon = function(path) {
                    return base.getIconRes.call($t, "gridMinimize." + path);
                }, visibleGridIcon = getMinimizeIcon("visible"), hiddenGridIcon = getMinimizeIcon("hidden");
                if (state === "hidden") {
                    $(".ui-jqgrid-bdiv, .ui-jqgrid-hdiv", p.gView).slideUp("fast");
                    if (p.pager) {
                        $(p.pager).slideUp("fast");
                    }
                    if (p.toppager) {
                        $(p.toppager).slideUp("fast");
                    }
                    if (p.toolbar[0] === true) {
                        if (p.toolbar[1] === "both") {
                            $ubDiv.slideUp("fast");
                        }
                        $uDiv.slideUp("fast");
                    }
                    if (p.footerrow) {
                        $(".ui-jqgrid-sdiv", p.gBox).slideUp("fast");
                    }
                    $(".ui-jqgrid-titlebar-close span", cDiv).removeClass(visibleGridIcon).addClass(hiddenGridIcon);
                    p.gridstate = "hidden";
                } else if (state === "visible") {
                    $(".ui-jqgrid-hdiv, .ui-jqgrid-bdiv", p.gView).slideDown("fast");
                    if (p.pager) {
                        $(p.pager).slideDown("fast");
                    }
                    if (p.toppager) {
                        $(p.toppager).slideDown("fast");
                    }
                    if (p.toolbar[0] === true) {
                        if (p.toolbar[1] === "both") {
                            $ubDiv.slideDown("fast");
                        }
                        $uDiv.slideDown("fast");
                    }
                    if (p.footerrow) {
                        $(".ui-jqgrid-sdiv", p.gBox).slideDown("fast");
                    }
                    $(".ui-jqgrid-titlebar-close span", cDiv).removeClass(hiddenGridIcon).addClass(visibleGridIcon);
                    p.gridstate = "visible";
                }
            });
        },
        "filterToolbar": function(oMuligrid) {
            return this.each(function() {
                var $t = this, grid = $t.grid, $self = $($t), p = $t.p, bindEv = jgrid.bindEv, infoDialog = jgrid.info_dialog, htmlEncode = jgrid.htmlEncode;
                if (this.ftoolbar) {
                    return;
                }
                var o = $.extend(true, {
                    "autosearch": true,
                    "autosearchDelay": 500,
                    "searchOnEnter": true,
                    "beforeSearch": null,
                    "afterSearch": null,
                    "beforeClear": null,
                    "afterClear": null,
                    "searchurl": "",
                    "stringResult": false,
                    "groupOp": "AND",
                    "defaultSearch": "bw",
                    "idMode": "new",
                    "searchOperators": false,
                    "resetIcon": "&times;",
                    "applyLabelClasses": true,
                    "loadFilterDefaults": true,
                    "operands": {
                        "eq": "==",
                        "ne": "!",
                        "lt": "<",
                        "le": "<=",
                        "gt": ">",
                        "ge": ">=",
                        "bw": "^",
                        "bn": "!^",
                        "in": "=",
                        "ni": "!=",
                        "ew": "|",
                        "en": "!@",
                        "cn": "~",
                        "nc": "!~",
                        "nu": "#",
                        "nn": "!#"
                    }
                }, jgrid.search, p.searching || {}, oMuligrid || {}), colModel = p.colModel, getRes = function(path) {
                    return getGridRes.call($self, path);
                }, errcap = getRes("errors.errcap"), bClose = getRes("edit.bClose"), editMsg = getRes("edit.msg"), hoverClasses = getGuiStyles.call($t, "states.hover"), highlightClass = getGuiStyles.call($t, "states.select"), dataFieldClass = getGuiStyles.call($t, "filterToolbar.dataField"), currentFilters, getId = function(cmName) {
                    var prefix = "gs_";
                    switch (o.idMode) {
                      case "compatibility":
                        prefix += p.idPrefix;
                        break;

                      case "new":
                        prefix += p.id + "_";
                        break;

                      default:
                        break;
                    }
                    return prefix + cmName;
                }, getIdSel = function(cmName) {
                    return "#" + jqID(getId(cmName));
                }, parseFilter = function(fillAll) {
                    var i, j, filters = p.postData.filters, filter = {}, rules, rule, iColByName = p.iColByName, cm, soptions;
                    if (fillAll) {
                        for (j = 0; j < colModel.length; j++) {
                            cm = colModel[j];
                            if (cm.search !== false) {
                                soptions = cm.searchoptions || {};
                                filter[cm.name] = {
                                    "op": soptions.sopt ? soptions.sopt[0] : cm.stype === "select" ? "eq" : o.defaultSearch,
                                    "data": soptions.defaultValue !== undefined ? soptions.defaultValue : ""
                                };
                            }
                        }
                    }
                    if (!filters || !p.search) {
                        return filter;
                    }
                    if (typeof filters === "string") {
                        try {
                            filters = $.parseJSON(filters);
                        } catch (ignore) {
                            filters = {};
                        }
                    } else {
                        filters = filters || {};
                    }
                    rules = filters.rules || {};
                    if (filters == null || filters.groupOp != null && o.groupOp != null && filters.groupOp.toUpperCase() !== o.groupOp.toUpperCase() || rules == null || rules.length === 0 || filters.groups != null && filters.groups.length > 0) {
                        return filter;
                    }
                    for (j = 0; j < rules.length; j++) {
                        rule = rules[j];
                        cm = colModel[iColByName[rule.field]];
                        for (i = 0; i < colModel.length; i++) {
                            cm = colModel[i];
                            if ((cm.index || cm.name) !== rule.field || cm.search === false) {
                                continue;
                            }
                            soptions = cm.searchoptions || {};
                            if (soptions.sopt) {
                                if ($.inArray(rule.op, soptions.sopt) < 0) {
                                    continue;
                                }
                            } else if (cm.stype === "select") {
                                if (rule.op !== "eq") {
                                    continue;
                                }
                            } else if (rule.op !== o.defaultSearch) {
                                continue;
                            }
                            filter[cm.name] = {
                                "op": rule.op,
                                "data": rule.data
                            };
                        }
                    }
                    return filter;
                }, triggerToolbar = function() {
                    var sdata = {}, j = 0, sopt = {};
                    $.each(colModel, function() {
                        var cm = this, nm = cm.index || cm.name, v, so, searchoptions = cm.searchoptions || {}, $elem = $(getIdSel(cm.name), cm.frozen === true && p.frozenColumns === true ? grid.fhDiv : grid.hDiv), getFormaterOption = function(optionName, formatter) {
                            var formatoptions = cm.formatoptions || {};
                            return formatoptions[optionName] !== undefined ? formatoptions[optionName] : getRes("formatter." + (formatter || cm.formatter) + "." + optionName);
                        }, cutThousandsSeparator = function(val) {
                            var separator = getFormaterOption("thousandsSeparator").replace(/([\.\*\_\'\(\)\{\}\+\?\\])/g, "\\$1");
                            return val.replace(new RegExp(separator, "g"), "");
                        };
                        if (o.searchOperators) {
                            so = $elem.parent().prev().children("a").data("soper") || o.defaultSearch;
                        } else {
                            so = searchoptions.sopt ? searchoptions.sopt[0] : cm.stype === "select" ? "eq" : o.defaultSearch;
                        }
                        if (cm.stype === "custom" && $.isFunction(searchoptions.custom_value) && $elem.length > 0 && $elem[0].nodeName.toUpperCase() === "SPAN") {
                            v = searchoptions.custom_value.call($t, $elem.children(".customelement").first(), "get");
                        } else if (cm.stype === "select") {
                            v = $elem.val();
                        } else {
                            v = $.trim($elem.val());
                            switch (cm.formatter) {
                              case "integer":
                                v = cutThousandsSeparator(v).replace(getFormaterOption("decimalSeparator", "number"), ".");
                                if (v !== "") {
                                    v = String(parseInt(v, 10));
                                }
                                break;

                              case "number":
                                v = cutThousandsSeparator(v).replace(getFormaterOption("decimalSeparator"), ".");
                                if (v !== "" && String(v).charAt(0) === "0") {
                                    v = String(parseFloat(v));
                                }
                                break;

                              case "currency":
                                var prefix = getFormaterOption("prefix"), suffix = getFormaterOption("suffix");
                                if (prefix && prefix.length) {
                                    v = v.substr(prefix.length);
                                }
                                if (suffix && suffix.length) {
                                    v = v.substr(0, v.length - suffix.length);
                                }
                                v = cutThousandsSeparator(v).replace(getFormaterOption("decimalSeparator"), ".");
                                if (v !== "") {
                                    v = String(parseFloat(v));
                                }
                                break;

                              default:
                                break;
                            }
                        }
                        if (v || so === "nu" || so === "nn") {
                            sdata[nm] = v;
                            sopt[nm] = so;
                            j++;
                        } else {
                            if (sdata.hasOwnProperty(nm)) {
                                delete sdata[nm];
                            }
                            if (!(o.stringResult || o.searchOperators || p.datatype === "local")) {
                                try {
                                    if (p.postData != null && p.postData.hasOwnProperty(nm)) {
                                        delete p.postData[nm];
                                    }
                                } catch (ignore) {}
                            }
                        }
                    });
                    var sd = j > 0 ? true : false;
                    if (o.stringResult || o.searchOperators || p.datatype === "local") {
                        var ruleGroup = '{"groupOp":"' + o.groupOp + '","rules":[';
                        var gi = 0;
                        $.each(sdata, function(cmName, n) {
                            if (gi > 0) {
                                ruleGroup += ",";
                            }
                            ruleGroup += '{"field":"' + cmName + '",';
                            ruleGroup += '"op":"' + sopt[cmName] + '",';
                            n += "";
                            ruleGroup += '"data":"' + n.replace(/\\/g, "\\\\").replace(/\"/g, '\\"') + '"}';
                            gi++;
                        });
                        ruleGroup += "]}";
                        $.extend(p.postData, {
                            "filters": ruleGroup
                        });
                        $.each([ "searchField", "searchString", "searchOper" ], function(i, n) {
                            if (p.postData.hasOwnProperty(n)) {
                                delete p.postData[n];
                            }
                        });
                    } else {
                        $.extend(p.postData, sdata);
                    }
                    var saveurl;
                    if (p.searchurl) {
                        saveurl = p.url;
                        $self.jqGrid("setGridParam", {
                            "url": p.searchurl
                        });
                    }
                    var bsr = $self.triggerHandler("jqGridToolbarBeforeSearch") === "stop" ? true : false;
                    if (!bsr && $.isFunction(o.beforeSearch)) {
                        bsr = o.beforeSearch.call($t);
                    }
                    if (!bsr) {
                        $self.jqGrid("setGridParam", {
                            "search": sd
                        }).trigger("reloadGrid", [ $.extend({
                            "page": 1
                        }, o.reloadGridSearchOptions || {}) ]);
                    }
                    if (saveurl) {
                        $self.jqGrid("setGridParam", {
                            "url": saveurl
                        });
                    }
                    $self.triggerHandler("jqGridToolbarAfterSearch");
                    if ($.isFunction(o.afterSearch)) {
                        o.afterSearch.call($t);
                    }
                }, clearToolbar = function(trigger) {
                    var sdata = {}, j = 0, nm;
                    trigger = typeof trigger !== "boolean" ? true : trigger;
                    $.each(colModel, function() {
                        var v, cm = this, $elem = $(getIdSel(cm.name), cm.frozen === true && p.frozenColumns === true ? grid.fhDiv : grid.hDiv), isSindleSelect, searchoptions = cm.searchoptions || {};
                        if (searchoptions.defaultValue !== undefined) {
                            v = searchoptions.defaultValue;
                        }
                        nm = cm.index || cm.name;
                        switch (cm.stype) {
                          case "select":
                            isSindleSelect = $elem.length > 0 ? !$elem[0].multiple : true;
                            $elem.find("option").each(function(i) {
                                this.selected = i === 0 && isSindleSelect;
                                if ($(this).val() === v) {
                                    this.selected = true;
                                    return false;
                                }
                            });
                            if (v !== undefined) {
                                sdata[nm] = v;
                                j++;
                            } else {
                                try {
                                    delete p.postData[nm];
                                } catch (ignore) {}
                            }
                            break;

                          case "text":
                            $elem.val(v || "");
                            if (v !== undefined) {
                                sdata[nm] = v;
                                j++;
                            } else {
                                try {
                                    delete p.postData[nm];
                                } catch (ignore) {}
                            }
                            break;

                          case "custom":
                            if ($.isFunction(searchoptions.custom_value) && $elem.length > 0 && $elem[0].nodeName.toUpperCase() === "SPAN") {
                                searchoptions.custom_value.call($t, $elem.children(".customelement").first(), "set", v || "");
                            }
                            break;
                        }
                    });
                    var sd = j > 0 ? true : false;
                    p.resetsearch = true;
                    if (o.stringResult || o.searchOperators || p.datatype === "local") {
                        var ruleGroup = '{"groupOp":"' + o.groupOp + '","rules":[';
                        var gi = 0;
                        $.each(sdata, function(i, n) {
                            if (gi > 0) {
                                ruleGroup += ",";
                            }
                            ruleGroup += '{"field":"' + i + '",';
                            ruleGroup += '"op":"' + "eq" + '",';
                            n += "";
                            ruleGroup += '"data":"' + n.replace(/\\/g, "\\\\").replace(/\"/g, '\\"') + '"}';
                            gi++;
                        });
                        ruleGroup += "]}";
                        $.extend(p.postData, {
                            "filters": ruleGroup
                        });
                        $.each([ "searchField", "searchString", "searchOper" ], function(i, n) {
                            if (p.postData.hasOwnProperty(n)) {
                                delete p.postData[n];
                            }
                        });
                    } else {
                        $.extend(p.postData, sdata);
                    }
                    var saveurl;
                    if (p.searchurl) {
                        saveurl = p.url;
                        $self.jqGrid("setGridParam", {
                            "url": p.searchurl
                        });
                    }
                    var bcv = $self.triggerHandler("jqGridToolbarBeforeClear") === "stop" ? true : false;
                    if (!bcv && $.isFunction(o.beforeClear)) {
                        bcv = o.beforeClear.call($t);
                    }
                    if (!bcv) {
                        if (trigger) {
                            $self.jqGrid("setGridParam", {
                                "search": sd
                            }).trigger("reloadGrid", [ $.extend({
                                "page": 1
                            }, o.reloadGridResetOptions || {}) ]);
                        }
                    }
                    if (saveurl) {
                        $self.jqGrid("setGridParam", {
                            "url": saveurl
                        });
                    }
                    $self.triggerHandler("jqGridToolbarAfterClear");
                    if ($.isFunction(o.afterClear)) {
                        o.afterClear();
                    }
                }, toggleToolbar = function() {
                    var trow = $("tr.ui-search-toolbar", grid.hDiv), trow2 = p.frozenColumns === true ? $("tr.ui-search-toolbar", grid.fhDiv) : false;
                    if (trow.css("display") === "none") {
                        trow.show();
                        if (trow2) {
                            trow2.show();
                        }
                    } else {
                        trow.hide();
                        if (trow2) {
                            trow2.hide();
                        }
                    }
                    if (p.frozenColumns === true) {
                        $self.jqGrid("destroyFrozenColumns");
                        $self.jqGrid("setFrozenColumns");
                    }
                }, odata = getRes("search.odata") || [], customSortOperations = p.customSortOperations, buildRuleMenu = function(elem, left, top) {
                    $("#sopt_menu").remove();
                    left = parseInt(left, 10);
                    top = parseInt(top, 10) + 18;
                    var selclass, ina, i = 0, aoprs = [], selected = $(elem).data("soper"), nm = $(elem).data("colname"), fs = $(".ui-jqgrid-view").css("font-size") || "11px", str = "<ul id='sopt_menu' class='" + getGuiStyles.call($t, "searchToolbar.menu", "ui-search-menu") + "' role='menu' tabindex='0' style='z-index:9999;display:block;font-size:" + fs + ";left:" + left + "px;top:" + top + "px;'>";
                    i = p.iColByName[nm];
                    if (i === undefined) {
                        return;
                    }
                    var cm = colModel[i], options = $.extend({}, cm.searchoptions), odataItem, item, itemOper, itemOperand, itemText;
                    if (!options.sopt) {
                        options.sopt = [];
                        options.sopt[0] = cm.stype === "select" ? "eq" : o.defaultSearch;
                    }
                    $.each(odata, function() {
                        aoprs.push(this.oper);
                    });
                    if (customSortOperations != null) {
                        $.each(customSortOperations, function(propertyName) {
                            aoprs.push(propertyName);
                        });
                    }
                    for (i = 0; i < options.sopt.length; i++) {
                        itemOper = options.sopt[i];
                        ina = $.inArray(itemOper, aoprs);
                        if (ina !== -1) {
                            odataItem = odata[ina];
                            if (odataItem !== undefined) {
                                itemOperand = o.operands[itemOper];
                                itemText = odataItem.text;
                            } else if (customSortOperations != null) {
                                item = customSortOperations[itemOper];
                                itemOperand = item.operand;
                                itemText = item.text;
                            }
                            selclass = selected === itemOper ? highlightClass : "";
                            str += '<li class="ui-menu-item ' + selclass + '" role="presentation"><a class="ui-corner-all g-menu-item" tabindex="0" role="menuitem" value="' + htmlEncode(itemOper) + '" data-oper="' + htmlEncode(itemOperand) + '"><table><tr><td style="width:25px">' + htmlEncode(itemOperand) + "</td><td>" + htmlEncode(itemText) + "</td></tr></table></a></li>";
                        }
                    }
                    str += "</ul>";
                    $("body").append(str);
                    $("#sopt_menu").addClass("ui-menu ui-widget ui-widget-content ui-corner-all");
                    $("#sopt_menu > li > a").hover(function() {
                        $(this).addClass(hoverClasses);
                    }, function() {
                        $(this).removeClass(hoverClasses);
                    }).click(function() {
                        var v = $(this).attr("value"), oper = $(this).data("oper");
                        $self.triggerHandler("jqGridToolbarSelectOper", [ v, oper, elem ]);
                        $("#sopt_menu").hide();
                        $(elem).text(oper).data("soper", v);
                        if (o.autosearch === true) {
                            var inpelm = $(elem).parent().next().children()[0];
                            if ($(inpelm).val() || v === "nu" || v === "nn") {
                                triggerToolbar();
                            }
                        }
                    });
                }, timeoutHnd, tr = $("<tr></tr>", {
                    "class": "ui-search-toolbar",
                    "role": "row"
                });
                if (o.loadFilterDefaults) {
                    currentFilters = parseFilter() || {};
                }
                $.each(colModel, function(ci) {
                    var cm = this, soptions, mode = "filter", surl, self, select = "", sot, so, i, searchoptions = cm.searchoptions || {}, editoptions = cm.editoptions || {}, th = $("<th></th>", {
                        "class": getGuiStyles.call($t, "colHeaders", "ui-th-column ui-th-" + p.direction + " " + (o.applyLabelClasses ? cm.labelClasses || "" : ""))
                    }), thd = $("<div></div>"), stbl = $("<table class='ui-search-table'><tr><td class='ui-search-oper'></td><td class='ui-search-input'></td><td class='ui-search-clear' style='width:1px'></td></tr></table>");
                    if (this.hidden === true) {
                        $(th).css("display", "none");
                    }
                    this.search = this.search === false ? false : true;
                    if (this.stype === undefined) {
                        this.stype = "text";
                    }
                    soptions = $.extend({
                        "mode": mode
                    }, searchoptions);
                    if (this.search) {
                        if (o.searchOperators) {
                            if (p.search && currentFilters[this.name] != null) {
                                so = currentFilters[this.name].op;
                            } else {
                                so = soptions.sopt ? soptions.sopt[0] : cm.stype === "select" ? "eq" : o.defaultSearch;
                            }
                            for (i = 0; i < odata.length; i++) {
                                if (odata[i].oper === so) {
                                    sot = o.operands[so] || "";
                                    break;
                                }
                            }
                            if (sot === undefined && customSortOperations != null) {
                                var customOp;
                                for (customOp in customSortOperations) {
                                    if (customSortOperations.hasOwnProperty(customOp) && customOp === so) {
                                        sot = customSortOperations[customOp].operand;
                                        break;
                                    }
                                }
                            }
                            if (sot === undefined) {
                                sot = "=";
                            }
                            var st = soptions.searchtitle != null ? soptions.searchtitle : getRes("search.operandTitle");
                            select = "<a title='" + st + "' data-soper='" + so + "' class='" + getGuiStyles.call($t, "searchToolbar.operButton", "soptclass") + "' data-colname='" + this.name + "'>" + sot + "</a>";
                        }
                        $("td", stbl).first().data("colindex", ci).append(select);
                        if (soptions.sopt == null || soptions.sopt.length === 1) {
                            $("td.ui-search-oper", stbl).hide();
                        }
                        if (p.search && currentFilters[this.name] != null) {
                            soptions.defaultValue = currentFilters[this.name].data;
                        }
                        if (soptions.clearSearch === undefined) {
                            soptions.clearSearch = this.stype === "text" ? true : false;
                        }
                        if (soptions.clearSearch) {
                            var csv = getRes("search.resetTitle") || "Clear Search Value";
                            $("td", stbl).eq(2).append("<a title='" + csv + "' class='" + getGuiStyles.call($t, "searchToolbar.clearButton", "clearsearchclass") + "'><span>" + o.resetIcon + "</span></a>");
                        } else {
                            $("td", stbl).eq(2).hide();
                        }
                        switch (this.stype) {
                          case "select":
                            surl = this.surl || soptions.dataUrl;
                            if (surl) {
                                self = thd;
                                $(self).append(stbl);
                                $.ajax($.extend({
                                    "url": surl,
                                    "context": {
                                        "stbl": stbl,
                                        "options": soptions,
                                        "cm": cm,
                                        "iCol": ci
                                    },
                                    "dataType": "html",
                                    "success": function(data, textStatus, jqXHR) {
                                        var cm1 = this.cm, iCol1 = this.iCol, soptions1 = this.options, d, $td = this.stbl.find(">tbody>tr>td.ui-search-input"), $select;
                                        if (soptions1.buildSelect !== undefined) {
                                            d = soptions1.buildSelect.call($t, data, jqXHR, cm1, iCol1);
                                            if (d) {
                                                $td.append(d);
                                            }
                                        } else {
                                            $td.append(data);
                                        }
                                        $select = $td.children("select");
                                        if ($select.find("option[value='']").length === 0 && typeof soptions.noFilterText === "string") {
                                            ov = document.createElement("option");
                                            ov.value = "";
                                            ov.innerHTML = soptions.noFilterText;
                                            $select.prepend(ov);
                                        }
                                        if (soptions1.defaultValue !== undefined) {
                                            $select.val(soptions1.defaultValue);
                                        }
                                        $select.attr({
                                            "name": cm1.index || cm1.name,
                                            "id": getId(cm1.name)
                                        });
                                        if (soptions1.attr) {
                                            $select.attr(soptions1.attr);
                                        }
                                        $select.addClass(dataFieldClass);
                                        $select.css({
                                            "width": "100%"
                                        });
                                        bindEv.call($t, $select[0], soptions1);
                                        jgrid.fullBoolFeedback.call($t, soptions1.selectFilled, "jqGridSelectFilled", {
                                            "elem": $select[0],
                                            "options": soptions1,
                                            "cm": cm1,
                                            "cmName": cm1.name,
                                            "iCol": iCol1,
                                            "mode": mode
                                        });
                                        if (o.autosearch === true) {
                                            $select.change(function() {
                                                triggerToolbar();
                                                return false;
                                            });
                                        }
                                    }
                                }, jgrid.ajaxOptions, p.ajaxSelectOptions || {}));
                            } else {
                                var oSv, sep, delim;
                                if (cm.searchoptions) {
                                    oSv = searchoptions.value === undefined ? editoptions.value || "" : searchoptions.value;
                                    sep = searchoptions.separator === undefined ? editoptions.separator || ":" : searchoptions.separator;
                                    delim = searchoptions.delimiter === undefined ? editoptions.delimiter || ";" : searchoptions.delimiter;
                                } else if (cm.editoptions) {
                                    oSv = editoptions.value === undefined ? "" : editoptions.value;
                                    sep = editoptions.separator === undefined ? ":" : editoptions.separator;
                                    delim = editoptions.delimiter === undefined ? ";" : editoptions.delimiter;
                                }
                                if (oSv) {
                                    var elem = document.createElement("select");
                                    elem.style.width = "100%";
                                    $(elem).attr({
                                        "name": cm.index || cm.name,
                                        "id": getId(cm.name)
                                    });
                                    var sv, ov, key, k, isNoFilterValueExist;
                                    if (typeof oSv === "string") {
                                        so = oSv.split(delim);
                                        for (k = 0; k < so.length; k++) {
                                            sv = so[k].split(sep);
                                            ov = document.createElement("option");
                                            ov.value = sv[0];
                                            if (sv[0] === "") {
                                                isNoFilterValueExist = true;
                                            }
                                            ov.innerHTML = sv[1];
                                            elem.appendChild(ov);
                                        }
                                    } else if (typeof oSv === "object") {
                                        for (key in oSv) {
                                            if (oSv.hasOwnProperty(key)) {
                                                ov = document.createElement("option");
                                                ov.value = key;
                                                if (key === "") {
                                                    isNoFilterValueExist = true;
                                                }
                                                ov.innerHTML = oSv[key];
                                                elem.appendChild(ov);
                                            }
                                        }
                                    }
                                    if (!isNoFilterValueExist && typeof soptions.noFilterText === "string") {
                                        ov = document.createElement("option");
                                        ov.value = "";
                                        ov.innerHTML = soptions.noFilterText;
                                        $(elem).prepend(ov);
                                    }
                                    if (soptions.defaultValue !== undefined) {
                                        $(elem).val(soptions.defaultValue);
                                    }
                                    if (soptions.attr) {
                                        $(elem).attr(soptions.attr);
                                    }
                                    $(elem).addClass(dataFieldClass);
                                    $(thd).append(stbl);
                                    bindEv.call($t, elem, soptions);
                                    $("td", stbl).eq(1).append(elem);
                                    jgrid.fullBoolFeedback.call($t, soptions.selectFilled, "jqGridSelectFilled", {
                                        "elem": elem,
                                        "options": cm.searchoptions || editoptions,
                                        "cm": cm,
                                        "cmName": cm.name,
                                        "iCol": ci,
                                        "mode": mode
                                    });
                                    if (o.autosearch === true) {
                                        $(elem).change(function() {
                                            triggerToolbar();
                                            return false;
                                        });
                                    }
                                }
                            }
                            break;

                          case "text":
                            var df = soptions.defaultValue !== undefined ? soptions.defaultValue : "";
                            $("td", stbl).eq(1).append("<input type='text' class='" + dataFieldClass + "' name='" + (cm.index || cm.name) + "' id='" + getId(cm.name) + "' value='" + df + "'/>");
                            $(thd).append(stbl);
                            if (soptions.attr) {
                                $("input", thd).attr(soptions.attr);
                            }
                            bindEv.call($t, $("input", thd)[0], soptions);
                            if (o.autosearch === true) {
                                if (o.searchOnEnter) {
                                    $("input", thd).keypress(function(e) {
                                        var key1 = e.charCode || e.keyCode || 0;
                                        if (key1 === 13) {
                                            triggerToolbar();
                                            return false;
                                        }
                                        return this;
                                    });
                                } else {
                                    $("input", thd).keydown(function(e) {
                                        var key1 = e.which;
                                        switch (key1) {
                                          case 13:
                                            return false;

                                          case 9:
                                          case 16:
                                          case 37:
                                          case 38:
                                          case 39:
                                          case 40:
                                          case 27:
                                            break;

                                          default:
                                            if (timeoutHnd) {
                                                clearTimeout(timeoutHnd);
                                            }
                                            timeoutHnd = setTimeout(function() {
                                                triggerToolbar();
                                            }, o.autosearchDelay);
                                        }
                                    });
                                }
                            }
                            break;

                          case "custom":
                            $("td", stbl).eq(1).append("<span style='width:100%;padding:0;box-sizing:border-box;' class='" + dataFieldClass + "' name='" + (cm.index || cm.name) + "' id='" + getId(cm.name) + "'/>");
                            $(thd).append(stbl);
                            try {
                                if ($.isFunction(soptions.custom_element)) {
                                    var celm = soptions.custom_element.call($t, soptions.defaultValue !== undefined ? soptions.defaultValue : "", soptions);
                                    if (celm) {
                                        celm = $(celm).addClass("customelement");
                                        $(thd).find("span[name='" + (cm.index || cm.name) + "']").append(celm);
                                    } else {
                                        throw "e2";
                                    }
                                } else {
                                    throw "e1";
                                }
                            } catch (ex) {
                                if (ex === "e1") {
                                    infoDialog.call($t, errcap, "function 'custom_element' " + editMsg.nodefined, bClose);
                                }
                                if (ex === "e2") {
                                    infoDialog.call($t, errcap, "function 'custom_element' " + editMsg.novalue, bClose);
                                } else {
                                    infoDialog.call($t, errcap, typeof ex === "string" ? ex : ex.message, bClose);
                                }
                            }
                            break;
                        }
                    }
                    $(th).append(thd);
                    $(th).find(".ui-search-oper .soptclass,.ui-search-clear .clearsearchclass").hover(function() {
                        $(this).addClass(hoverClasses);
                    }, function() {
                        $(this).removeClass(hoverClasses);
                    });
                    $(tr).append(th);
                    if (!o.searchOperators) {
                        $("td", stbl).eq(0).hide();
                    }
                });
                $(grid.hDiv).find(">div>.ui-jqgrid-htable>thead").append(tr);
                if (o.searchOperators) {
                    $(".soptclass", tr).click(function(e) {
                        var offset = $(this).offset(), left = offset.left, top = offset.top;
                        buildRuleMenu(this, left, top);
                        e.stopPropagation();
                    });
                    $("body").on("click", function(e) {
                        if (e.target.className !== "soptclass") {
                            $("#sopt_menu").hide();
                        }
                    });
                }
                $(".clearsearchclass", tr).click(function() {
                    var ptr = $(this).parents("tr").first(), coli = parseInt($("td.ui-search-oper", ptr).data("colindex"), 10), sval = $.extend({}, colModel[coli].searchoptions || {}), dval = sval.defaultValue || "";
                    if (colModel[coli].stype === "select") {
                        if (dval) {
                            $("td.ui-search-input select", ptr).val(dval);
                        } else {
                            $("td.ui-search-input select", ptr)[0].selectedIndex = 0;
                        }
                    } else {
                        $("td.ui-search-input input", ptr).val(dval);
                    }
                    if (o.autosearch === true) {
                        triggerToolbar();
                    }
                });
                $t.ftoolbar = true;
                $t.triggerToolbar = triggerToolbar;
                $t.clearToolbar = clearToolbar;
                $t.toggleToolbar = toggleToolbar;
                if (p.frozenColumns === true) {
                    $self.jqGrid("destroyFrozenColumns");
                    $self.jqGrid("setFrozenColumns");
                }
                $self.bind("jqGridRefreshFilterValues.filterToolbar" + (o.loadFilterDefaults ? " jqGridAfterLoadComplete.filterToolbar" : ""), function() {
                    var cmName, filter, newFilters = parseFilter(true) || {}, $input, $searchOper, i;
                    if (!o.stringResult && !o.searchOperators && p.datatype !== "local" && p.search) {
                        return;
                    }
                    for (cmName in newFilters) {
                        if (newFilters.hasOwnProperty(cmName)) {
                            filter = newFilters[cmName];
                            $input = $(getIdSel(cmName));
                            if ($.trim($input.val()) !== filter.data) {
                                $input.val(filter.data);
                            }
                            $searchOper = $input.closest(".ui-search-input").siblings(".ui-search-oper").children(".soptclass");
                            $searchOper.data("soper", filter.op);
                            $searchOper.text(o.operands[filter.op]);
                        }
                    }
                    for (i = 0; i < p.colModel.length; i++) {
                        cmName = p.colModel[i].name;
                        if (!newFilters.hasOwnProperty(cmName)) {
                            $(getIdSel(cmName)).val("");
                        }
                    }
                });
            });
        },
        "destroyFilterToolbar": function() {
            return this.each(function() {
                var self = this;
                if (!self.ftoolbar) {
                    return;
                }
                self.triggerToolbar = null;
                self.clearToolbar = null;
                self.toggleToolbar = null;
                self.ftoolbar = false;
                $(self.grid.hDiv).find("table thead tr.ui-search-toolbar").remove();
                if (self.p.frozenColumns === true) {
                    $(self).jqGrid("destroyFrozenColumns").jqGrid("setFrozenColumns");
                }
            });
        },
        "destroyGroupHeader": function(nullHeader) {
            if (nullHeader === undefined) {
                nullHeader = true;
            }
            return this.each(function() {
                var $t = this, i, l, $th, $resizing, grid = $t.grid, cm = $t.p.colModel, hc, thead = $("table.ui-jqgrid-htable thead", grid.hDiv);
                if (!grid) {
                    return;
                }
                $($t).unbind(".setGroupHeaders");
                var $tr = $("<tr>", {
                    "role": "row"
                }).addClass("ui-jqgrid-labels");
                var headers = grid.headers;
                for (i = 0, l = headers.length; i < l; i++) {
                    hc = cm[i].hidden ? "none" : "";
                    $th = $(headers[i].el).width(headers[i].width).css("display", hc);
                    try {
                        $th.removeAttr("rowSpan");
                    } catch (rs) {
                        $th.attr("rowSpan", 1);
                    }
                    $tr.append($th);
                    $resizing = $th.children("span.ui-jqgrid-resize");
                    if ($resizing.length > 0) {
                        $resizing[0].style.height = "";
                    }
                    $th.children("div")[0].style.top = "";
                }
                $(thead).children("tr.ui-jqgrid-labels").remove();
                $(thead).prepend($tr);
                if (nullHeader === true) {
                    $($t).jqGrid("setGridParam", {
                        "groupHeader": null
                    });
                }
            });
        },
        "setGroupHeaders": function(o) {
            o = $.extend({
                "useColSpanStyle": false,
                "applyLabelClasses": true,
                "groupHeaders": []
            }, o || {});
            return this.each(function() {
                this.p.groupHeader = o;
                var ts = this, i, cmi, skip = 0, $tr, $colHeader, th, $th, thStyle, iCol, cghi, numberOfColumns, titleText, cVisibleColumns, cColumns, p = ts.p, colModel = p.colModel, cml = colModel.length, ths = ts.grid.headers, $theadInTable, thClasses, $htable = $("table.ui-jqgrid-htable", ts.grid.hDiv), isCellClassHidden = jgrid.isCellClassHidden, $trLabels = $htable.children("thead").children("tr.ui-jqgrid-labels"), $trLastWithLabels = $trLabels.last().addClass("jqg-second-row-header"), $thead = $htable.children("thead"), $firstHeaderRow = $htable.find(".jqg-first-row-header");
                if ($firstHeaderRow[0] === undefined) {
                    $firstHeaderRow = $("<tr>", {
                        "role": "row",
                        "aria-hidden": "true"
                    }).addClass("jqg-first-row-header").css("height", "auto");
                } else {
                    $firstHeaderRow.empty();
                }
                var inColumnHeader = function(text, columnHeaders) {
                    var length = columnHeaders.length, j;
                    for (j = 0; j < length; j++) {
                        if (columnHeaders[j].startColumnName === text) {
                            return j;
                        }
                    }
                    return -1;
                };
                $(ts).prepend($thead);
                $tr = $("<tr>", {
                    "role": "row"
                }).addClass("ui-jqgrid-labels jqg-third-row-header");
                for (i = 0; i < cml; i++) {
                    th = ths[i].el;
                    $th = $(th);
                    cmi = colModel[i];
                    thStyle = {
                        "height": "0",
                        "width": ths[i].width + "px",
                        "display": cmi.hidden ? "none" : ""
                    };
                    $("<th>", {
                        "role": "gridcell"
                    }).css(thStyle).addClass("ui-first-th-" + p.direction + (o.applyLabelClasses ? " " + (cmi.labelClasses || "") : "")).appendTo($firstHeaderRow);
                    th.style.width = "";
                    thClasses = getGuiStyles.call(ts, "colHeaders", "ui-th-column-header ui-th-" + p.direction + " " + (o.applyLabelClasses ? cmi.labelClasses || "" : ""));
                    iCol = inColumnHeader(cmi.name, o.groupHeaders);
                    if (iCol >= 0) {
                        cghi = o.groupHeaders[iCol];
                        numberOfColumns = cghi.numberOfColumns;
                        titleText = cghi.titleText;
                        for (cVisibleColumns = 0, iCol = 0, cColumns = 0; iCol < numberOfColumns && i + iCol < cml; iCol++) {
                            cColumns++;
                            if (!colModel[i + iCol].hidden && !isCellClassHidden(colModel[i + iCol].classes)) {
                                cVisibleColumns++;
                            }
                        }
                        $colHeader = $("<th>").addClass(thClasses).css({
                            "height": "22px",
                            "border-top": "0 none"
                        }).html(titleText);
                        if (cColumns > 1) {
                            $colHeader.attr("colspan", String(cColumns));
                        }
                        if (p.headertitles) {
                            $colHeader.attr("title", $colHeader.text());
                        }
                        if (cVisibleColumns === 0) {
                            $colHeader.hide();
                        }
                        $th.before($colHeader);
                        $tr.append(th);
                        skip = numberOfColumns - 1;
                    } else {
                        if (skip === 0) {
                            if (o.useColSpanStyle) {
                                $th.attr("rowspan", $trLabels.length + 1);
                            } else {
                                $("<th>").addClass(thClasses).css({
                                    "display": cmi.hidden ? "none" : "",
                                    "border-top": "0 none"
                                }).insertBefore($th);
                                $tr.append(th);
                            }
                        } else {
                            $tr.append(th);
                            skip--;
                        }
                    }
                }
                $theadInTable = $(ts).children("thead");
                $theadInTable.prepend($firstHeaderRow);
                $tr.insertAfter($trLastWithLabels);
                $htable.prepend($theadInTable);
                if (o.useColSpanStyle) {
                    $htable.find("span.ui-jqgrid-resize").each(function() {
                        var $parent = $(this).parent();
                        if ($parent.is(":visible")) {
                            this.style.cssText = "height:" + $parent.height() + "px !important;cursor:col-resize;";
                        }
                    });
                    $htable.find(".ui-th-column>div").each(function() {
                        var $ts = $(this), $parent = $ts.parent();
                        if ($parent.is(":visible") && $parent.is(":has(span.ui-jqgrid-resize)") && !($ts.hasClass("ui-jqgrid-rotate") || $ts.hasClass("ui-jqgrid-rotateOldIE"))) {
                            $ts.css("top", ($parent.height() - $ts.outerHeight(true)) / 2 + "px");
                        }
                    });
                }
                $(ts).triggerHandler("jqGridAfterSetGroupHeaders");
            });
        },
        "getNumberOfFrozenColumns": function() {
            var $t = this;
            if ($t.length === 0) {
                return 0;
            }
            $t = $t[0];
            var colModel = $t.p.colModel, len = colModel.length, maxfrozen = -1, i;
            for (i = 0; i < len; i++) {
                if (colModel[i].frozen !== true) {
                    break;
                }
                maxfrozen = i;
            }
            return maxfrozen + 1;
        },
        "setFrozenColumns": function() {
            return this.each(function() {
                var $t = this, $self = $($t), p = $t.p, grid = $t.grid;
                if (!grid || p == null || p.frozenColumns === true) {
                    return;
                }
                var cm = p.colModel, i, len = cm.length, maxfrozen = -1, frozen = false, frozenIds = [], $colHeaderRow, tid = jqID(p.id), hoverClasses = getGuiStyles.call($t, "states.hover"), disabledClass = getGuiStyles.call($t, "states.disabled");
                if (p.subGrid === true || p.treeGrid === true || p.scroll) {
                    return;
                }
                for (i = 0; i < len; i++) {
                    if (cm[i].frozen !== true) {
                        break;
                    }
                    frozen = true;
                    maxfrozen = i;
                    frozenIds.push("#jqgh_" + tid + "_" + jqID(cm[i].name));
                }
                if (p.sortable) {
                    $colHeaderRow = $(grid.hDiv).find(".ui-jqgrid-htable .ui-jqgrid-labels");
                    $colHeaderRow.sortable("destroy");
                    $self.jqGrid("setGridParam", {
                        "sortable": {
                            "options": {
                                "items": frozenIds.length > 0 ? ">th:not(:has(" + frozenIds.join(",") + "),:hidden)" : ">th:not(:hidden)"
                            }
                        }
                    });
                    $self.jqGrid("sortableColumns", $colHeaderRow);
                }
                if (maxfrozen >= 0 && frozen) {
                    var top = p.caption ? $(grid.cDiv).outerHeight() : 0, hth = $(".ui-jqgrid-htable", p.gView).height();
                    if (p.toppager) {
                        top = top + $(grid.topDiv).outerHeight();
                    }
                    if (p.toolbar[0] === true) {
                        if (p.toolbar[1] !== "bottom") {
                            top = top + $(grid.uDiv).outerHeight();
                        }
                    }
                    grid.fhDiv = $("<div style='position:absolute;overflow:hidden;" + (p.direction === "rtl" ? "right:0;border-top-left-radius:0;" : "left:0;border-top-right-radius:0;") + "top:" + top + "px;height:" + hth + "px;' class='" + getGuiStyles.call($t, "hDiv", "frozen-div ui-jqgrid-hdiv") + "'></div>");
                    grid.fbDiv = $("<div style='position:absolute;overflow:hidden;" + (p.direction === "rtl" ? "right:0;" : "left:0;") + "top:" + (parseInt(top, 10) + parseInt(hth, 10) + 1) + "px;overflow:hidden;' class='frozen-bdiv ui-jqgrid-bdiv'></div>");
                    $(p.gView).append(grid.fhDiv);
                    var htbl = $(".ui-jqgrid-htable", p.gView).clone(true), tHeadRows = htbl[0].tHead.rows;
                    if (p.groupHeader) {
                        $(tHeadRows[0].cells).filter(":gt(" + maxfrozen + ")").remove();
                        $(tHeadRows).filter(".jqg-third-row-header").each(function() {
                            $(this).children("th[id]").each(function() {
                                var id = $(this).attr("id"), colName;
                                if (id && id.substr(0, $t.id.length + 1) === $t.id + "_") {
                                    colName = id.substr($t.id.length + 1);
                                    if (p.iColByName[colName] > maxfrozen) {
                                        $(this).remove();
                                    }
                                }
                            });
                        });
                        var swapfroz = -1, fdel = -1, cs, rs;
                        $(tHeadRows).filter(".jqg-second-row-header").children("th").each(function() {
                            cs = parseInt($(this).attr("colspan") || 1, 10);
                            rs = parseInt($(this).attr("rowspan") || 1, 10);
                            if (rs > 1) {
                                swapfroz++;
                                fdel++;
                            } else if (cs) {
                                swapfroz = swapfroz + cs;
                                fdel++;
                            }
                            if (swapfroz === maxfrozen) {
                                return false;
                            }
                        });
                        if (swapfroz !== maxfrozen) {
                            fdel = maxfrozen;
                        }
                        $(tHeadRows).filter(".jqg-second-row-header,.ui-search-toolbar").each(function() {
                            $(this).children(":gt(" + fdel + ")").remove();
                        });
                    } else {
                        $(tHeadRows).each(function() {
                            $(this).children(":gt(" + maxfrozen + ")").remove();
                        });
                    }
                    $(htbl).width(1);
                    $(grid.fhDiv).append(htbl).mousemove(function(e) {
                        if (grid.resizing) {
                            grid.dragMove(e);
                            return false;
                        }
                    }).scroll(function() {
                        this.scrollLeft = 0;
                    });
                    if (p.footerrow) {
                        var hbd = $(".ui-jqgrid-bdiv", p.gView).height();
                        grid.fsDiv = $("<div style='position:absolute;" + (p.direction === "rtl" ? "right:0;" : "left:0;") + "top:" + (parseInt(top, 10) + parseInt(hth, 10) + parseInt(hbd, 10) + 1) + "px;' class='frozen-sdiv ui-jqgrid-sdiv'></div>");
                        $(p.gView).append(grid.fsDiv);
                        var ftbl = $(".ui-jqgrid-ftable", p.gView).clone(true);
                        $("tr", ftbl).each(function() {
                            $("td:gt(" + maxfrozen + ")", this).remove();
                        });
                        $(ftbl).width(1);
                        $(grid.fsDiv).append(ftbl);
                    }
                    $self.bind("jqGridSortCol.setFrozenColumns", function(e, index, idxcol) {
                        var previousSelectedTh = $("tr.ui-jqgrid-labels:last th:eq(" + p.lastsort + ")", grid.fhDiv), newSelectedTh = $("tr.ui-jqgrid-labels:last th:eq(" + idxcol + ")", grid.fhDiv);
                        $("span.ui-grid-ico-sort", previousSelectedTh).addClass(disabledClass);
                        $(previousSelectedTh).attr("aria-selected", "false");
                        $("span.ui-icon-" + p.sortorder, newSelectedTh).removeClass(disabledClass);
                        $(newSelectedTh).attr("aria-selected", "true");
                        if (!p.viewsortcols[0]) {
                            if (p.lastsort !== idxcol) {
                                $("span.s-ico", previousSelectedTh).hide();
                                $("span.s-ico", newSelectedTh).show();
                            }
                        }
                    });
                    $(p.gView).append(grid.fbDiv);
                    $(grid.bDiv).scroll(function() {
                        $(grid.fbDiv).scrollTop($(this).scrollTop());
                    });
                    if (p.hoverrows === true) {
                        $(p.idSel).unbind("mouseover").unbind("mouseout");
                    }
                    var safeHeightSet = function($elem, newHeight) {
                        var height = $elem.height();
                        if (Math.abs(height - newHeight) >= 1 && newHeight > 0) {
                            $elem.height(newHeight);
                            height = $elem.height();
                            if (Math.abs(newHeight - height) >= 1) {
                                $elem.height(newHeight + Math.round(newHeight - height));
                            }
                        }
                    }, safeWidthSet = function($elem, newWidth) {
                        var width = $elem.width();
                        if (Math.abs(width - newWidth) >= 1) {
                            $elem.width(newWidth);
                            width = $elem.width();
                            if (Math.abs(newWidth - width) >= 1) {
                                $elem.width(newWidth + Math.round(newWidth - width));
                            }
                        }
                    }, fixDiv = function($hDiv, hDivBase, iRowStart, iRowEnd) {
                        var iRow, n, $frozenRows, $rows, $row, $frozenRow, posFrozenTop, height, newHeightFrozen, td, posTop = $(hDivBase).position().top, frozenTableTop, tableTop, cells;
                        if ($hDiv != null && $hDiv.length > 0) {
                            $hDiv[0].scrollTop = hDivBase.scrollTop;
                            $hDiv.css(p.direction === "rtl" ? {
                                "top": posTop,
                                "right": 0
                            } : {
                                "top": posTop,
                                "left": 0
                            });
                            $frozenRows = $hDiv.children("table").children("thead").children("tr");
                            $rows = $(hDivBase).children("div").children("table").children("thead").children("tr");
                            if ($rows.length === 0) {
                                $frozenRows = $($hDiv.children("table")[0].rows);
                                $rows = $($(hDivBase).children("div").children("table")[0].rows);
                            }
                            n = Math.min($frozenRows.length, $rows.length);
                            frozenTableTop = n > 0 ? $($frozenRows[0]).position().top : 0;
                            tableTop = n > 0 ? $($rows[0]).position().top : 0;
                            if (iRowStart >= 0) {
                                if (iRowEnd >= 0) {
                                    n = Math.min(iRowEnd + 1, n);
                                }
                                for (iRow = iRowStart; iRow < n; iRow++) {
                                    $row = $($rows[iRow]);
                                    if ($row.css("display") !== "none" && $row.is(":visible")) {
                                        posTop = $row.position().top;
                                        $frozenRow = $($frozenRows[iRow]);
                                        posFrozenTop = $frozenRow.position().top;
                                        height = $row.height();
                                        if (p.groupHeader != null && p.groupHeader.useColSpanStyle) {
                                            cells = $row[0].cells;
                                            for (i = 0; i < cells.length; i++) {
                                                td = cells[i];
                                                if (td != null && td.nodeName.toUpperCase() === "TH") {
                                                    height = Math.max(height, $(td).height());
                                                }
                                            }
                                        }
                                        newHeightFrozen = height + (posTop - tableTop) + (frozenTableTop - posFrozenTop);
                                        safeHeightSet($frozenRow, newHeightFrozen);
                                    }
                                }
                            }
                            safeHeightSet($hDiv, hDivBase.clientHeight);
                        }
                    }, resizeAll = {
                        "resizeDiv": true,
                        "resizedRows": {
                            "iRowStart": 0,
                            "iRowEnd": -1
                        }
                    }, fullResize = {
                        "header": resizeAll,
                        "resizeFooter": true,
                        "body": resizeAll
                    };
                    $self.bind("jqGridAfterGridComplete.setFrozenColumns", function() {
                        $(p.idSel + "_frozen").remove();
                        $(grid.fbDiv).height(grid.hDiv.clientHeight);
                        var $frozenBTable = $(this).clone(true), frozenRows = $frozenBTable[0].rows, rows = $self[0].rows;
                        $(frozenRows).filter("tr[role=row]").each(function() {
                            $(this.cells).filter("td[role=gridcell]:gt(" + maxfrozen + ")").remove();
                        });
                        grid.fbRows = frozenRows;
                        $frozenBTable.width(1).attr("id", p.id + "_frozen");
                        $frozenBTable.appendTo(grid.fbDiv);
                        if (p.hoverrows === true) {
                            var hoverRows = function(tr, method, additionalRows) {
                                $(tr)[method](hoverClasses);
                                $(additionalRows[tr.rowIndex])[method](hoverClasses);
                            };
                            $(frozenRows).filter(".jqgrow").hover(function() {
                                hoverRows(this, "addClass", rows);
                            }, function() {
                                hoverRows(this, "removeClass", rows);
                            });
                            $(rows).filter(".jqgrow").hover(function() {
                                hoverRows(this, "addClass", frozenRows);
                            }, function() {
                                hoverRows(this, "removeClass", frozenRows);
                            });
                        }
                        fixDiv(grid.fhDiv, grid.hDiv, 0, -1);
                        fixDiv(grid.fbDiv, grid.bDiv, 0, -1);
                        if (grid.sDiv) {
                            fixDiv(grid.fsDiv, grid.sDiv, 0, -1);
                        }
                    });
                    var myResize = function(resizeOptions) {
                        $(grid.fbDiv).scrollTop($(grid.bDiv).scrollTop());
                        if (resizeOptions.header.resizeDiv) {
                            fixDiv(grid.fhDiv, grid.hDiv, resizeOptions.header.iRowStart, resizeOptions.header.iRowEnd);
                        }
                        if (resizeOptions.body.resizeDiv) {
                            fixDiv(grid.fbDiv, grid.bDiv, resizeOptions.body.iRowStart, resizeOptions.body.iRowEnd);
                        }
                        if (resizeOptions.resizeFooter && grid.sDiv && resizeOptions.resizeFooter) {
                            fixDiv(grid.fsDiv, grid.sDiv, 0, -1);
                        }
                        var frozenWidth = grid.fhDiv[0].clientWidth;
                        if (resizeOptions.header.resizeDiv && grid.fhDiv != null && grid.fhDiv.length >= 1) {
                            safeHeightSet($(grid.fhDiv), grid.hDiv.clientHeight);
                        }
                        if (resizeOptions.body.resizeDiv && grid.fbDiv != null && grid.fbDiv.length > 0) {
                            safeWidthSet($(grid.fbDiv), frozenWidth);
                        }
                        if (resizeOptions.resizeFooter && grid.fsDiv != null && grid.fsDiv.length >= 0) {
                            safeWidthSet($(grid.fsDiv), frozenWidth);
                        }
                    };
                    $(p.gBox).bind("resizestop.setFrozenColumns", function() {
                        setTimeout(function() {
                            myResize(fullResize);
                        }, 50);
                    });
                    $self.bind("jqGridInlineEditRow.setFrozenColumns jqGridInlineAfterRestoreRow.setFrozenColumns jqGridInlineAfterSaveRow.setFrozenColumns jqGridAfterEditCell.setFrozenColumns jqGridAfterRestoreCell.setFrozenColumns jqGridAfterSaveCell.setFrozenColumns jqGridResizeStop.setFrozenColumns", function(e, rowid) {
                        var iRow = $self.jqGrid("getInd", rowid);
                        myResize({
                            "header": {
                                "resizeDiv": false,
                                "resizedRows": {
                                    "iRowStart": -1,
                                    "iRowEnd": -1
                                }
                            },
                            "resizeFooter": true,
                            "body": {
                                "resizeDiv": true,
                                "resizedRows": {
                                    "iRowStart": iRow,
                                    "iRowEnd": iRow
                                }
                            }
                        });
                    });
                    $self.bind("jqGridResizeStop.setFrozenColumns", function() {
                        myResize(fullResize);
                    });
                    $self.bind("jqGridResetFrozenHeights.setFrozenColumns", function(e, o) {
                        myResize(o || fullResize);
                    });
                    if (!grid.hDiv.loading) {
                        $self.triggerHandler("jqGridAfterGridComplete");
                    }
                    p.frozenColumns = true;
                }
            });
        },
        "destroyFrozenColumns": function() {
            return this.each(function() {
                var $t = this, $self = $($t), grid = $t.grid, p = $t.p, tid = jqID(p.id);
                if (!grid) {
                    return;
                }
                if (p.frozenColumns === true) {
                    $(grid.fhDiv).remove();
                    $(grid.fbDiv).remove();
                    grid.fhDiv = null;
                    grid.fbDiv = null;
                    grid.fbRows = null;
                    if (p.footerrow) {
                        $(grid.fsDiv).remove();
                        grid.fsDiv = null;
                    }
                    $self.unbind(".setFrozenColumns");
                    if (p.hoverrows === true) {
                        var ptr, hoverClasses = getGuiStyles.call($t, "states.hover");
                        $self.bind("mouseover", function(e) {
                            ptr = $(e.target).closest("tr.jqgrow");
                            if ($(ptr).attr("class") !== "ui-subgrid") {
                                $(ptr).addClass(hoverClasses);
                            }
                        }).bind("mouseout", function(e) {
                            ptr = $(e.target).closest("tr.jqgrow");
                            $(ptr).removeClass(hoverClasses);
                        });
                    }
                    p.frozenColumns = false;
                    if (p.sortable) {
                        var $colHeaderRow = $(grid.hDiv).find(".ui-jqgrid-htable .ui-jqgrid-labels");
                        $colHeaderRow.sortable("destroy");
                        $self.jqGrid("setGridParam", {
                            "sortable": {
                                "options": {
                                    "items": ">th:not(:has(#jqgh_" + tid + "_cb" + ",#jqgh_" + tid + "_rn" + ",#jqgh_" + tid + "_subgrid),:hidden)"
                                }
                            }
                        });
                        $self.jqGrid("sortableColumns", $colHeaderRow);
                    }
                }
            });
        }
    });
});

(function(factory) {
    "use strict";
    if (typeof define === "function" && define.amd) {
        define([ "jquery", "./grid.base", "./jqdnr", "./jqmodal" ], factory);
    } else if (typeof exports === "object") {
        factory(require("jquery"));
    } else {
        factory(jQuery);
    }
})(function($) {
    "use strict";
    var jgrid = $.jgrid, base = $.fn.jqGrid;
    var getGuiStyles = base.getGuiStyles, getGridRes = base.getGridRes;
    jgrid.jqModal = jgrid.jqModal || {};
    $.extend(true, jgrid.jqModal, {
        "toTop": true
    });
    $.extend(jgrid, {
        "showModal": function(h) {
            h.w.show();
        },
        "closeModal": function(h) {
            h.w.hide().attr("aria-hidden", "true");
            if (h.o) {
                h.o.remove();
            }
        },
        "hideModal": function(selector, o) {
            o = $.extend({
                "jqm": true,
                "gb": "",
                "removemodal": false
            }, o || {});
            var thisgrid = o.gb && typeof o.gb === "string" && o.gb.substr(0, 6) === "#gbox_" ? $("#" + o.gb.substr(6))[0] : false, $selector = $(selector);
            if (o.onClose) {
                var oncret = thisgrid ? o.onClose.call(thisgrid, selector) : o.onClose(selector);
                if (typeof oncret === "boolean" && !oncret) {
                    return;
                }
            }
            if ($.fn.jqm && o.jqm === true) {
                $selector.attr("aria-hidden", "true").jqmHide();
            } else {
                if (o.gb !== "") {
                    try {
                        $(">.jqgrid-overlay", o.gb).first().hide();
                    } catch (ignore) {}
                }
                $selector.hide().attr("aria-hidden", "true");
            }
            if (o.removemodal) {
                $selector.remove();
            }
        },
        "findPos": function(obj) {
            var curleft = 0, curtop = 0;
            if (obj.offsetParent) {
                do {
                    curleft += obj.offsetLeft;
                    curtop += obj.offsetTop;
                    obj = obj.offsetParent;
                } while (obj);
            }
            return [ curleft, curtop ];
        },
        "createModal": function(aIDs, content, o, insertSelector, posSelector, appendsel, css) {
            var jqID = jgrid.jqID, p = this.p, gridjqModal = p != null ? p.jqModal || {} : {};
            o = $.extend(true, {
                "resizingRightBottomIcon": base.getIconRes.call(this, "form.resizableLtr")
            }, jgrid.jqModal || {}, gridjqModal, o);
            var mw = document.createElement("div"), themodalSelector = "#" + jqID(aIDs.themodal), rtlsup = $(o.gbox).attr("dir") === "rtl" ? true : false, resizeAlso = aIDs.resizeAlso ? "#" + jqID(aIDs.resizeAlso) : false;
            css = $.extend({}, css || {});
            mw.className = getGuiStyles.call(this, "dialog.window", "ui-jqdialog");
            mw.id = aIDs.themodal;
            mw.dir = rtlsup ? "rtl" : "ltr";
            var mdoc = document.createElement("div");
            mdoc.className = getGuiStyles.call(this, "dialog.document");
            $(mdoc).attr("role", "document");
            var msubdoc = document.createElement("div");
            msubdoc.className = getGuiStyles.call(this, "dialog.subdocument");
            mdoc.appendChild(msubdoc);
            mw.appendChild(mdoc);
            var mh = document.createElement("div");
            mh.className = getGuiStyles.call(this, "dialog.header", "ui-jqdialog-titlebar " + (rtlsup ? "ui-jqdialog-titlebar-rtl" : "ui-jqdialog-titlebar-ltr"));
            mh.id = aIDs.modalhead;
            $(mh).append("<span class='ui-jqdialog-title'>" + o.caption + "</span>");
            var hoverClasses = getGuiStyles.call(this, "states.hover"), ahr = $("<a aria-label='Close' class='" + getGuiStyles.call(this, "dialog.closeButton", "ui-jqdialog-titlebar-close") + "'></a>").hover(function() {
                ahr.addClass(hoverClasses);
            }, function() {
                ahr.removeClass(hoverClasses);
            }).append("<span class='" + base.getIconRes.call(this, "form.close") + "'></span>");
            $(mh).append(ahr);
            var mc = document.createElement("div");
            $(mc).addClass(getGuiStyles.call(this, "dialog.content", "ui-jqdialog-content")).attr("id", aIDs.modalcontent);
            $(mc).append(content);
            msubdoc.appendChild(mc);
            $(msubdoc).prepend(mh);
            if (appendsel === true) {
                $("body").append(mw);
            } else if (typeof appendsel === "string") {
                $(appendsel).append(mw);
            } else {
                $(mw).insertBefore(insertSelector);
            }
            $(mw).css(css);
            if (o.jqModal === undefined) {
                o.jqModal = true;
            }
            var coord = {};
            if ($.fn.jqm && o.jqModal === true) {
                if (o.left === 0 && o.top === 0 && o.overlay) {
                    var pos = [];
                    pos = jgrid.findPos(posSelector);
                    o.left = pos[0] + 4;
                    o.top = pos[1] + 4;
                }
                coord.top = o.top + "px";
                coord.left = o.left;
            } else if (o.left !== 0 || o.top !== 0) {
                coord.left = o.left;
                coord.top = o.top + "px";
            }
            $("a.ui-jqdialog-titlebar-close", mh).click(function() {
                var oncm = $(themodalSelector).data("onClose") || o.onClose;
                var gboxclose = $(themodalSelector).data("gbox") || o.gbox;
                jgrid.hideModal(themodalSelector, {
                    "gb": gboxclose,
                    "jqm": o.jqModal,
                    "onClose": oncm,
                    "removemodal": o.removemodal || false
                });
                return false;
            });
            if (o.width === 0 || !o.width) {
                o.width = 300;
            }
            if (o.height === 0 || !o.height) {
                o.height = 200;
            }
            if (!o.zIndex) {
                var parentZ = $(insertSelector).parents("*[role=dialog]").first().css("z-index");
                if (parentZ) {
                    o.zIndex = parseInt(parentZ, 10) + 2;
                    o.toTop = true;
                } else {
                    o.zIndex = 950;
                }
            }
            if (coord.left) {
                coord.left += "px";
            }
            $(mw).css($.extend({
                "width": isNaN(o.width) ? "auto" : o.width + "px",
                "height": isNaN(o.height) ? "auto" : o.height + "px",
                "zIndex": o.zIndex
            }, coord)).attr({
                "tabIndex": "-1",
                "role": "dialog",
                "aria-labelledby": aIDs.modalhead,
                "aria-hidden": "true"
            });
            if (o.drag === undefined) {
                o.drag = true;
            }
            if (o.resize === undefined) {
                o.resize = true;
            }
            if (o.drag) {
                if ($.fn.jqDrag) {
                    $(mh).css("cursor", "move");
                    $(mw).jqDrag(mh);
                } else {
                    try {
                        $(mw).draggable({
                            "handle": $("#" + jqID(mh.id))
                        });
                    } catch (ignore) {}
                }
            }
            if (o.resize) {
                if ($.fn.jqResize) {
                    $(mc).append("<div class='jqResize ui-resizable-handle ui-resizable-se " + o.resizingRightBottomIcon + "'></div>");
                    $(themodalSelector).jqResize(".jqResize", resizeAlso);
                } else {
                    try {
                        $(mw).resizable({
                            "handles": "se, sw",
                            "alsoResize": resizeAlso
                        });
                    } catch (ignore) {}
                }
            }
            if (o.closeOnEscape === true) {
                $(mw).keydown(function(e) {
                    if (e.which === 27) {
                        var cone = $(themodalSelector).data("onClose") || o.onClose;
                        jgrid.hideModal(themodalSelector, {
                            "gb": o.gbox,
                            "jqm": o.jqModal,
                            "onClose": cone,
                            "removemodal": o.removemodal || false,
                            "formprop": !o.recreateForm || false,
                            "form": o.form || ""
                        });
                    }
                });
            }
        },
        "viewModal": function(selector, o) {
            o = $.extend(true, {
                "overlay": 30,
                "modal": false,
                "overlayClass": getGuiStyles.call(this, "overlay"),
                "onShow": jgrid.showModal,
                "onHide": jgrid.closeModal,
                "gbox": "",
                "jqm": true,
                "jqM": true
            }, jgrid.jqModal || {}, o || {});
            if ($.fn.jqm && o.jqm === true) {
                if (o.jqM) {
                    $(selector).attr("aria-hidden", "false").jqm(o).jqmShow();
                } else {
                    $(selector).attr("aria-hidden", "false").jqmShow();
                }
            } else {
                if (o.gbox !== "") {
                    $(">.jqgrid-overlay", o.gbox).first().show();
                    $(selector).data("gbox", o.gbox);
                }
                $(selector).show().attr("aria-hidden", "false");
                try {
                    $(":input:visible", selector)[0].focus();
                } catch (ignore) {}
            }
        },
        "info_dialog": function(caption, content, closeButtonText, modalopt) {
            var $t = this, p = $t.p, gridjqModal = p != null ? p.jqModal || {} : {}, mopt = $.extend(true, {
                "width": 290,
                "height": "auto",
                "dataheight": "auto",
                "drag": true,
                "resize": false,
                "left": 250,
                "top": 170,
                "zIndex": 1e3,
                "jqModal": true,
                "modal": false,
                "closeOnEscape": true,
                "align": "center",
                "buttonalign": "center",
                "buttons": []
            }, jgrid.jqModal || {}, gridjqModal, {
                "caption": "<b>" + caption + "</b>"
            }, modalopt || {}), jm = mopt.jqModal;
            if ($.fn.jqm && !jm) {
                jm = false;
            }
            var buttstr = "", i, hoverClasses = getGuiStyles.call($t, "states.hover");
            if (mopt.buttons.length > 0) {
                for (i = 0; i < mopt.buttons.length; i++) {
                    if (mopt.buttons[i].id === undefined) {
                        mopt.buttons[i].id = "info_button_" + i;
                    }
                    buttstr += jgrid.builderFmButon.call($t, mopt.buttons[i].id, mopt.buttons[i].text);
                }
            }
            var dh = isNaN(mopt.dataheight) ? mopt.dataheight : mopt.dataheight + "px", cn = "text-align:" + mopt.align + ";", cnt = "<div id='info_id'>";
            cnt += "<div id='infocnt' style='margin:0px;padding-bottom:1em;width:100%;overflow:auto;position:relative;height:" + dh + ";" + cn + "'>" + content + "</div>";
            if (closeButtonText || buttstr !== "") {
                cnt += "<hr class='" + getGuiStyles.call($t, "dialog.hr") + "' style='margin:1px'/><div style='text-align:" + mopt.buttonalign + ";padding:.8em 0 .5em 0;background-image:none;border-width: 1px 0 0 0;'>" + (closeButtonText ? jgrid.builderFmButon.call($t, "closedialog", closeButtonText) : "") + buttstr + "</div>";
            }
            cnt += "</div>";
            try {
                if ($("#info_dialog").attr("aria-hidden") === "false") {
                    jgrid.hideModal("#info_dialog", {
                        "jqm": jm
                    });
                }
                $("#info_dialog").remove();
            } catch (ignore) {}
            jgrid.createModal.call($t, {
                "themodal": "info_dialog",
                "modalhead": "info_head",
                "modalcontent": "info_content",
                "resizeAlso": "infocnt"
            }, cnt, mopt, "", "", true);
            if (buttstr) {
                $.each(mopt.buttons, function(j) {
                    $("#" + jgrid.jqID($t.id), "#info_id").bind("click", function() {
                        mopt.buttons[j].onClick.call($("#info_dialog"));
                        return false;
                    });
                });
            }
            $("#closedialog", "#info_id").click(function() {
                jgrid.hideModal("#info_dialog", {
                    "jqm": jm,
                    "onClose": $("#info_dialog").data("onClose") || mopt.onClose,
                    "gb": $("#info_dialog").data("gbox") || mopt.gbox
                });
                return false;
            });
            $(".fm-button", "#info_dialog").hover(function() {
                $(this).addClass(hoverClasses);
            }, function() {
                $(this).removeClass(hoverClasses);
            });
            if ($.isFunction(mopt.beforeOpen)) {
                mopt.beforeOpen();
            }
            jgrid.viewModal.call($t, "#info_dialog", {
                "onHide": function(h) {
                    h.w.hide().remove();
                    if (h.o) {
                        h.o.remove();
                    }
                },
                "modal": mopt.modal,
                "jqm": jm
            });
            if ($.isFunction(mopt.afterOpen)) {
                mopt.afterOpen();
            }
            try {
                $("#info_dialog").focus();
            } catch (ignore) {}
        },
        "bindEv": function(el, opt) {
            var $t = this;
            if ($.isFunction(opt.dataInit)) {
                opt.dataInit.call($t, el, opt);
            }
            if (opt.dataEvents) {
                $.each(opt.dataEvents, function() {
                    if (this.data !== undefined) {
                        $(el).bind(this.type, this.data, this.fn);
                    } else {
                        $(el).bind(this.type, this.fn);
                    }
                });
            }
        },
        "createEl": function(eltype, options, vl, autowidth, ajaxso) {
            var elem = "", $t = this, p = $t.p, infoDialog = jgrid.info_dialog, getRes = function(path) {
                return getGridRes.call($($t), path);
            }, errcap = getRes("errors.errcap"), edit = getRes("edit"), editMsg = edit.msg, bClose = edit.bClose;
            function setAttributes(elm, atr, exl) {
                var exclude = [ "dataInit", "dataEvents", "dataUrl", "buildSelect", "sopt", "searchhidden", "defaultValue", "attr", "custom_element", "custom_value", "selectFilled", "rowId", "mode" ];
                if (exl !== undefined && $.isArray(exl)) {
                    $.merge(exclude, exl);
                }
                $.each(atr, function(attrName, value) {
                    if ($.inArray(attrName, exclude) === -1) {
                        $(elm).attr(attrName, value);
                    }
                });
                if (!atr.hasOwnProperty("id")) {
                    $(elm).attr("id", jgrid.randId());
                }
            }
            if (options == null) {
                return "";
            }
            switch (eltype) {
              case "textarea":
                elem = document.createElement("textarea");
                if (autowidth) {
                    if (!options.cols) {
                        $(elem).css({
                            "width": "100%",
                            "box-sizing": "border-box"
                        });
                    }
                } else if (!options.cols) {
                    options.cols = 19;
                }
                if (!options.rows) {
                    options.rows = 2;
                }
                if (vl === "&nbsp;" || vl === "&#160;" || vl.length === 1 && vl.charCodeAt(0) === 160) {
                    vl = "";
                }
                elem.value = vl;
                setAttributes(elem, options);
                $(elem).attr({
                    "role": "textbox"
                });
                break;

              case "checkbox":
                elem = document.createElement("input");
                elem.type = "checkbox";
                if (!options.value) {
                    var vl1 = String(vl).toLowerCase();
                    if (vl1.search(/(false|f|0|no|n|off|undefined)/i) < 0 && vl1 !== "") {
                        elem.checked = true;
                        elem.defaultChecked = true;
                        elem.value = vl;
                    } else {
                        elem.value = "on";
                    }
                    $(elem).data("offval", "off");
                } else {
                    var cbval = options.value.split(":");
                    if (vl === cbval[0]) {
                        elem.checked = true;
                        elem.defaultChecked = true;
                    }
                    elem.value = cbval[0];
                    $(elem).data("offval", cbval[1]);
                }
                setAttributes(elem, options, [ "value" ]);
                $(elem).attr({
                    "role": "checkbox",
                    "aria-checked": elem.checked ? "true" : "false"
                });
                break;

              case "select":
                elem = document.createElement("select");
                var msl, ovm = [], isSelected;
                if (options.multiple === true) {
                    msl = true;
                    elem.multiple = "multiple";
                    $(elem).attr("aria-multiselectable", "true");
                    ovm = vl.split(",");
                    ovm = $.map(ovm, function(n) {
                        return $.trim(n);
                    });
                } else {
                    msl = false;
                    ovm[0] = $.trim(vl);
                }
                if (options.size === undefined) {
                    options.size = msl ? 3 : 1;
                }
                if (options.dataUrl !== undefined) {
                    var rowid = null, postData = options.postData || ajaxso.postData, ajaxContext = {
                        "elem": elem,
                        "options": options,
                        "cm": options.cm,
                        "iCol": options.iCol,
                        "ovm": ovm
                    };
                    try {
                        rowid = options.rowId;
                    } catch (ignore) {}
                    if (p && p.idPrefix) {
                        rowid = jgrid.stripPref(p.idPrefix, rowid);
                    }
                    $.ajax($.extend({
                        "url": $.isFunction(options.dataUrl) ? options.dataUrl.call($t, rowid, vl, String(options.name), ajaxContext) : options.dataUrl,
                        "type": "GET",
                        "dataType": "html",
                        "data": $.isFunction(postData) ? postData.call($t, rowid, vl, String(options.name)) : postData,
                        "context": ajaxContext,
                        "success": function(data, textStatus, jqXHR) {
                            var ovm1 = this.ovm, elem1 = this.elem, cm1 = this.cm, iCol1 = this.iCol, options1 = $.extend({}, this.options), a = $.isFunction(options1.buildSelect) ? options1.buildSelect.call($t, data, jqXHR, cm1, iCol1) : data;
                            if (typeof a === "string") {
                                a = $($.trim(a)).html();
                            }
                            if (a) {
                                $(elem1).append(a);
                                setAttributes(elem1, options1, postData ? [ "postData" ] : undefined);
                                setTimeout(function() {
                                    var isSelected1;
                                    $("option", elem1).each(function(iOpt) {
                                        if (iOpt === 0 && elem1.multiple) {
                                            this.selected = false;
                                        }
                                        if ($.inArray($.trim($(this).val()), ovm1) > -1) {
                                            this.selected = "selected";
                                            isSelected1 = true;
                                        }
                                    });
                                    if (!isSelected1) {
                                        $("option", elem1).each(function() {
                                            if ($.inArray($.trim($(this).text()), ovm1) > -1) {
                                                this.selected = "selected";
                                            }
                                        });
                                    }
                                    $(elem1).change();
                                    jgrid.fullBoolFeedback.call($t, options1.selectFilled, "jqGridSelectFilled", {
                                        "elem": elem1,
                                        "options": options1,
                                        "cm": cm1,
                                        "cmName": cm1 != null ? cm1.name : options1.name,
                                        "iCol": iCol1
                                    });
                                }, 0);
                            }
                        }
                    }, ajaxso || {}));
                } else if (options.value) {
                    if (typeof options.value === "function") {
                        options.value = options.value();
                    }
                    var i, so, sv, ov, optionInfos = [], optionInfo, sep = options.separator === undefined ? ":" : options.separator, delim = options.delimiter === undefined ? ";" : options.delimiter, mapFunc = function(n, ii) {
                        if (ii > 0) {
                            return n;
                        }
                    };
                    if (typeof options.value === "string") {
                        so = options.value.split(delim);
                        for (i = 0; i < so.length; i++) {
                            sv = so[i].split(sep);
                            if (sv.length > 2) {
                                sv[1] = $.map(sv, mapFunc).join(sep);
                            }
                            optionInfos.push({
                                "value": sv[0],
                                "innerHtml": sv[1],
                                "selectValue": $.trim(sv[0]),
                                "selectText": $.trim(sv[1])
                            });
                        }
                    } else if (typeof options.value === "object") {
                        var oSv = options.value, key;
                        for (key in oSv) {
                            if (oSv.hasOwnProperty(key)) {
                                optionInfos.push({
                                    "value": key,
                                    "innerHtml": oSv[key],
                                    "selectValue": $.trim(key),
                                    "selectText": $.trim(oSv[key])
                                });
                            }
                        }
                    }
                    for (i = 0; i < optionInfos.length; i++) {
                        optionInfo = optionInfos[i];
                        ov = document.createElement("option");
                        ov.value = optionInfo.value;
                        ov.innerHTML = optionInfo.innerHtml;
                        elem.appendChild(ov);
                        if (!msl && optionInfo.selectValue === $.trim(vl)) {
                            ov.selected = "selected";
                            isSelected = true;
                        }
                        if (msl && $.inArray(optionInfo.selectValue, ovm) > -1) {
                            ov.selected = "selected";
                            isSelected = true;
                        }
                    }
                    if (!isSelected) {
                        for (i = 0; i < optionInfos.length; i++) {
                            optionInfo = optionInfos[i];
                            if (!msl && optionInfo.selectText === $.trim(vl)) {
                                ov.selected = "selected";
                            }
                            if (msl && $.inArray(optionInfo.selectText, ovm) > -1) {
                                ov.selected = "selected";
                            }
                        }
                    }
                    setAttributes(elem, options, [ "value" ]);
                    jgrid.fullBoolFeedback.call($t, options.selectFilled, "jqGridSelectFilled", {
                        "elem": elem,
                        "options": options,
                        "cm": options.cm,
                        "cmName": options.cm != null ? options.cm.name : options.name,
                        "iCol": options.iCol
                    });
                }
                break;

              case "text":
              case "password":
              case "button":
                var role;
                if (eltype === "button") {
                    role = "button";
                } else {
                    role = "textbox";
                }
                elem = document.createElement("input");
                elem.type = eltype;
                setAttributes(elem, options);
                elem.value = vl;
                if (eltype !== "button") {
                    if (autowidth) {
                        if (!options.size) {
                            $(elem).css({
                                "width": "100%",
                                "box-sizing": "border-box"
                            });
                        }
                    } else if (!options.size) {
                        options.size = 20;
                    }
                }
                $(elem).attr("role", role);
                break;

              case "image":
              case "file":
                elem = document.createElement("input");
                elem.type = eltype;
                setAttributes(elem, options);
                break;

              case "custom":
                elem = document.createElement("span");
                try {
                    if ($.isFunction(options.custom_element)) {
                        var celm = options.custom_element.call($t, vl, options);
                        if (celm instanceof jQuery || jgrid.isHTMLElement(celm) || typeof celm === "string") {
                            celm = $(celm).addClass("customelement").attr({
                                "id": options.id,
                                "name": options.name
                            });
                            $(elem).empty().append(celm);
                        } else {
                            throw "editoptions.custom_element returns value of a wrong type";
                        }
                    } else {
                        throw "editoptions.custom_element is not a function";
                    }
                } catch (e) {
                    if (e === "e1") {
                        infoDialog.call($t, errcap, "function 'custom_element' " + editMsg.nodefined, bClose);
                    }
                    if (e === "e2") {
                        infoDialog.call($t, errcap, "function 'custom_element' " + editMsg.novalue, bClose);
                    } else {
                        infoDialog.call($t, errcap, typeof e === "string" ? e : e.message, bClose);
                    }
                }
                break;
            }
            return elem;
        },
        "checkDate": function(format, date) {
            var daysInFebruary = function(year) {
                return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0) ? 29 : 28;
            }, tsp = {}, sep;
            format = format.toLowerCase();
            if (format.indexOf("/") !== -1) {
                sep = "/";
            } else if (format.indexOf("-") !== -1) {
                sep = "-";
            } else if (format.indexOf(".") !== -1) {
                sep = ".";
            } else {
                sep = "/";
            }
            format = format.split(sep);
            date = date.split(sep);
            if (date.length !== 3) {
                return false;
            }
            var j = -1, yln, dln = -1, mln = -1, i, dv;
            for (i = 0; i < format.length; i++) {
                dv = isNaN(date[i]) ? 0 : parseInt(date[i], 10);
                tsp[format[i]] = dv;
                yln = format[i];
                if (yln.indexOf("y") !== -1) {
                    j = i;
                }
                if (yln.indexOf("m") !== -1) {
                    mln = i;
                }
                if (yln.indexOf("d") !== -1) {
                    dln = i;
                }
            }
            if (format[j] === "y" || format[j] === "yyyy") {
                yln = 4;
            } else if (format[j] === "yy") {
                yln = 2;
            } else {
                yln = -1;
            }
            var strDate, daysInMonth = [ 0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 ];
            if (j === -1) {
                return false;
            }
            strDate = tsp[format[j]].toString();
            if (yln === 2 && strDate.length === 1) {
                yln = 1;
            }
            if (strDate.length !== yln || tsp[format[j]] === 0 && date[j] !== "00") {
                return false;
            }
            if (mln === -1) {
                return false;
            }
            strDate = tsp[format[mln]].toString();
            if (strDate.length < 1 || tsp[format[mln]] < 1 || tsp[format[mln]] > 12) {
                return false;
            }
            if (dln === -1) {
                return false;
            }
            strDate = tsp[format[dln]].toString();
            if (strDate.length < 1 || tsp[format[dln]] < 1 || tsp[format[dln]] > 31 || tsp[format[mln]] === 2 && tsp[format[dln]] > daysInFebruary(tsp[format[j]]) || tsp[format[dln]] > daysInMonth[tsp[format[mln]]]) {
                return false;
            }
            return true;
        },
        "isEmpty": function(val) {
            if (val.match(/^\s+$/) || val === "") {
                return true;
            }
            return false;
        },
        "checkTime": function(time) {
            var re = /^(\d{1,2}):(\d{2})([apAP][Mm])?$/, regs;
            if (!jgrid.isEmpty(time)) {
                regs = time.match(re);
                if (regs) {
                    if (regs[3]) {
                        if (regs[1] < 1 || regs[1] > 12) {
                            return false;
                        }
                    } else {
                        if (regs[1] > 23) {
                            return false;
                        }
                    }
                    if (regs[2] > 59) {
                        return false;
                    }
                } else {
                    return false;
                }
            }
            return true;
        },
        "checkValues": function(val, iCol, customobject, nam, options) {
            var edtrul, nm, dft, g = this, p = g.p, colModel = p.colModel, cm, isEmpty = jgrid.isEmpty, editMsg = getGridRes.call($(g), "edit.msg"), ret, dateMasks = getGridRes.call($(g), "formatter.date.masks");
            if (customobject === undefined) {
                if (typeof iCol === "string") {
                    iCol = p.iColByName[iCol];
                }
                if (iCol === undefined || iCol < 0) {
                    return [ true, "", "" ];
                }
                cm = colModel[iCol];
                edtrul = cm.editrules;
                if (cm.formoptions != null) {
                    nm = cm.formoptions.label;
                }
            } else {
                edtrul = customobject;
                nm = nam === undefined ? "_" : nam;
                cm = colModel[iCol];
            }
            if (edtrul) {
                if (!nm) {
                    nm = p.colNames != null ? p.colNames[iCol] : cm.label;
                }
                if (edtrul.required === true) {
                    if (isEmpty(val)) {
                        return [ false, nm + ": " + editMsg.required, "" ];
                    }
                }
                var rqfield = edtrul.required === false ? false : true;
                if (edtrul.number === true) {
                    if (!(rqfield === false && isEmpty(val))) {
                        if (isNaN(val)) {
                            return [ false, nm + ": " + editMsg.number, "" ];
                        }
                    }
                }
                if (edtrul.minValue !== undefined && !isNaN(edtrul.minValue)) {
                    if (parseFloat(val) < parseFloat(edtrul.minValue)) {
                        return [ false, nm + ": " + editMsg.minValue + " " + edtrul.minValue, "" ];
                    }
                }
                if (edtrul.maxValue !== undefined && !isNaN(edtrul.maxValue)) {
                    if (parseFloat(val) > parseFloat(edtrul.maxValue)) {
                        return [ false, nm + ": " + editMsg.maxValue + " " + edtrul.maxValue, "" ];
                    }
                }
                var filter;
                if (edtrul.email === true) {
                    if (!(rqfield === false && isEmpty(val))) {
                        filter = /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?$/i;
                        if (!filter.test(val)) {
                            return [ false, nm + ": " + editMsg.email, "" ];
                        }
                    }
                }
                if (edtrul.integer === true) {
                    if (!(rqfield === false && isEmpty(val))) {
                        if (isNaN(val)) {
                            return [ false, nm + ": " + editMsg.integer, "" ];
                        }
                        if (val % 1 !== 0 || val.indexOf(".") !== -1) {
                            return [ false, nm + ": " + editMsg.integer, "" ];
                        }
                    }
                }
                if (edtrul.date === true) {
                    if (!(rqfield === false && isEmpty(val))) {
                        if (cm.formatoptions && cm.formatoptions.newformat) {
                            dft = cm.formatoptions.newformat;
                            if (dateMasks.hasOwnProperty(dft)) {
                                dft = dateMasks[dft];
                            }
                        } else {
                            dft = colModel[iCol].datefmt || "Y-m-d";
                        }
                        if (!jgrid.checkDate(dft, val)) {
                            return [ false, nm + ": " + editMsg.date + " - " + dft, "" ];
                        }
                    }
                }
                if (edtrul.time === true) {
                    if (!(rqfield === false && isEmpty(val))) {
                        if (!jgrid.checkTime(val)) {
                            return [ false, nm + ": " + editMsg.date + " - hh:mm (am/pm)", "" ];
                        }
                    }
                }
                if (edtrul.url === true) {
                    if (!(rqfield === false && isEmpty(val))) {
                        filter = /^(((https?)|(ftp)):\/\/([\-\w]+\.)+\w{2,3}(\/[%\-\w]+(\.\w{2,})?)*(([\w\-\.\?\\\/+@&#;`~=%!]*)(\.\w{2,})?)*\/?)/i;
                        if (!filter.test(val)) {
                            return [ false, nm + ": " + editMsg.url, "" ];
                        }
                    }
                }
                if (edtrul.custom === true) {
                    if (!(rqfield === false && isEmpty(val))) {
                        if ($.isFunction(edtrul.custom_func)) {
                            ret = edtrul.custom_func.call(g, val, nm, iCol);
                            return $.isArray(ret) ? ret : [ false, editMsg.customarray, "" ];
                        }
                        return [ false, editMsg.customfcheck, "" ];
                    }
                } else if ($.isFunction(edtrul.custom)) {
                    if (!(rqfield === false && isEmpty(val))) {
                        ret = edtrul.custom.call(g, options);
                        return $.isArray(ret) ? ret : [ false, editMsg.customarray, "" ];
                    }
                }
            }
            return [ true, "", "" ];
        }
    });
});

(function(factory) {
    "use strict";
    if (typeof define === "function" && define.amd) {
        define([ "jquery", "./grid.base" ], factory);
    } else if (typeof exports === "object") {
        factory(require("jquery"));
    } else {
        factory(jQuery);
    }
})(function($) {
    "use strict";
    var jgrid = $.jgrid, base = $.fn.jqGrid;
    jgrid.extend({
        "groupingSetup": function() {
            return this.each(function() {
                var $t = this, i, j, cml, p = $t.p, colModel = p.colModel, grp = p.groupingView, cm, summary, emptyFormatter = function() {
                    return "";
                };
                if (grp !== null && (typeof grp === "object" || $.isFunction(grp))) {
                    if (!grp.groupField.length) {
                        p.grouping = false;
                    } else {
                        if (grp.visibiltyOnNextGrouping === undefined) {
                            grp.visibiltyOnNextGrouping = [];
                        }
                        grp.lastvalues = [];
                        if (!grp._locgr) {
                            grp.groups = [];
                        }
                        grp.counters = [];
                        for (i = 0; i < grp.groupField.length; i++) {
                            if (!grp.groupOrder[i]) {
                                grp.groupOrder[i] = "asc";
                            }
                            if (!grp.groupText[i]) {
                                grp.groupText[i] = "{0}";
                            }
                            if (typeof grp.groupColumnShow[i] !== "boolean") {
                                grp.groupColumnShow[i] = true;
                            }
                            if (typeof grp.groupSummary[i] !== "boolean") {
                                grp.groupSummary[i] = false;
                            }
                            if (!grp.groupSummaryPos[i]) {
                                grp.groupSummaryPos[i] = "footer";
                            }
                            cm = colModel[p.iColByName[grp.groupField[i]]];
                            if (grp.groupColumnShow[i] === true) {
                                grp.visibiltyOnNextGrouping[i] = true;
                                if (cm != null && cm.hidden === true) {
                                    base.showCol.call($($t), grp.groupField[i]);
                                }
                            } else {
                                grp.visibiltyOnNextGrouping[i] = $("#" + jgrid.jqID(p.id + "_" + grp.groupField[i])).is(":visible");
                                if (cm != null && cm.hidden !== true) {
                                    base.hideCol.call($($t), grp.groupField[i]);
                                }
                            }
                        }
                        grp.summary = [];
                        if (grp.hideFirstGroupCol) {
                            grp.formatDisplayField[0] = function(v) {
                                return v;
                            };
                        }
                        for (j = 0, cml = colModel.length; j < cml; j++) {
                            cm = colModel[j];
                            if (grp.hideFirstGroupCol) {
                                if (!cm.hidden && grp.groupField[0] === cm.name) {
                                    cm.formatter = emptyFormatter;
                                }
                            }
                            if (cm.summaryType) {
                                summary = {
                                    "nm": cm.name,
                                    "st": cm.summaryType,
                                    "v": "",
                                    "sr": cm.summaryRound,
                                    "srt": cm.summaryRoundType || "round"
                                };
                                if (cm.summaryDivider) {
                                    summary.sd = cm.summaryDivider;
                                    summary.vd = "";
                                }
                                grp.summary.push(summary);
                            }
                        }
                    }
                } else {
                    p.grouping = false;
                }
            });
        },
        "groupingPrepare": function(record, irow) {
            this.each(function() {
                var $t = this, grp = $t.p.groupingView, groups = grp.groups, counters = grp.counters, lastvalues = grp.lastvalues, isInTheSameGroup = grp.isInTheSameGroup, groupLength = grp.groupField.length, i, j, keys, newGroup, counter, fieldName, v, displayName, displayValue, changed = false, groupingCalculationsHandler = base.groupingCalculations.handler, buildSummary = function() {
                    var iSummary, summary, st;
                    for (iSummary = 0; iSummary < counter.summary.length; iSummary++) {
                        summary = counter.summary[iSummary];
                        st = $.isArray(summary.st) ? summary.st[newGroup.idx] : summary.st;
                        if ($.isFunction(st)) {
                            summary.v = st.call($t, summary.v, summary.nm, record, newGroup);
                        } else {
                            summary.v = groupingCalculationsHandler.call($($t), st, summary.v, summary.nm, summary.sr, summary.srt, record);
                            if (st.toLowerCase() === "avg" && summary.sd) {
                                summary.vd = groupingCalculationsHandler.call($($t), st, summary.vd, summary.sd, summary.sr, summary.srt, record);
                            }
                        }
                    }
                    return counter.summary;
                };
                for (i = 0; i < groupLength; i++) {
                    fieldName = grp.groupField[i];
                    displayName = grp.displayField[i];
                    v = record[fieldName];
                    displayValue = displayName == null ? null : record[displayName];
                    if (displayValue == null) {
                        displayValue = v;
                    }
                    if (v !== undefined) {
                        keys = [];
                        for (j = 0; j <= i; j++) {
                            keys.push(record[grp.groupField[j]]);
                        }
                        newGroup = {
                            "idx": i,
                            "dataIndex": fieldName,
                            "value": v,
                            "displayValue": displayValue,
                            "startRow": irow,
                            "cnt": 1,
                            "keys": keys,
                            "summary": []
                        };
                        if (irow === 0) {
                            groups.push(newGroup);
                            lastvalues[i] = v;
                            counter = {
                                "cnt": 1,
                                "pos": groups.length - 1,
                                "summary": $.extend(true, [], grp.summary)
                            };
                            counters[i] = counter;
                            groups[counter.pos].summary = buildSummary();
                        } else {
                            counter = {
                                "cnt": 1,
                                "pos": groups.length,
                                "summary": $.extend(true, [], grp.summary)
                            };
                            if (typeof v !== "object" && ($.isArray(isInTheSameGroup) && $.isFunction(isInTheSameGroup[i]) ? !isInTheSameGroup[i].call($t, lastvalues[i], v, i, grp) : lastvalues[i] !== v)) {
                                groups.push(newGroup);
                                lastvalues[i] = v;
                                changed = true;
                                counters[i] = counter;
                                groups[counter.pos].summary = buildSummary();
                            } else {
                                if (changed) {
                                    groups.push(newGroup);
                                    lastvalues[i] = v;
                                    counters[i] = counter;
                                    groups[counter.pos].summary = buildSummary();
                                } else {
                                    counter = counters[i];
                                    counter.cnt += 1;
                                    groups[counter.pos].cnt = counter.cnt;
                                    groups[counter.pos].summary = buildSummary();
                                }
                            }
                        }
                    }
                }
            });
            return this;
        },
        "groupingToggle": function(hid, clickedElem) {
            this.each(function() {
                var $t = this, p = $t.p, grp = p.groupingView, minusClasses = grp.minusicon, plusClasses = grp.plusicon, $tr = clickedElem ? $(clickedElem).closest("tr.jqgroup") : $("#" + jgrid.jqID(hid)), getGroupHeaderIcon = function($trElem) {
                    return $trElem.find(">td>span." + "tree-wrap");
                }, itemGroupingLevel, iRowStart, showDataRowsOnExpending = true, $groupIcon, collapsed = false, rowsToHideOrShow = [], addToHideOrShow = function($elem) {
                    var i, l = $elem.length;
                    for (i = 0; i < l; i++) {
                        rowsToHideOrShow.push($elem[i]);
                    }
                }, num = parseInt($tr.data("jqgrouplevel"), 10);
                if (p.frozenColumns && $tr.length > 0) {
                    iRowStart = $tr[0].rowIndex;
                    $tr = $($t.rows[iRowStart]);
                    $tr = $tr.add($t.grid.fbRows[iRowStart]);
                }
                $groupIcon = getGroupHeaderIcon($tr);
                if (jgrid.hasAllClasses($groupIcon, minusClasses)) {
                    $groupIcon.removeClass(minusClasses).addClass(plusClasses);
                    collapsed = true;
                } else {
                    $groupIcon.removeClass(plusClasses).addClass(minusClasses);
                }
                for ($tr = $tr.next(); $tr.length; $tr = $tr.next()) {
                    if ($tr.hasClass("jqfoot")) {
                        itemGroupingLevel = parseInt($tr.data("jqfootlevel"), 10);
                        if (collapsed) {
                            itemGroupingLevel = parseInt($tr.data("jqfootlevel"), 10);
                            if (!grp.showSummaryOnHide && itemGroupingLevel === num || itemGroupingLevel > num) {
                                addToHideOrShow($tr);
                            }
                            if (itemGroupingLevel < num) {
                                break;
                            }
                        } else {
                            if (itemGroupingLevel === num || grp.showSummaryOnHide && itemGroupingLevel === num + 1) {
                                addToHideOrShow($tr);
                            }
                            if (itemGroupingLevel <= num) {
                                break;
                            }
                        }
                    } else if ($tr.hasClass("jqgroup")) {
                        itemGroupingLevel = parseInt($tr.data("jqgrouplevel"), 10);
                        if (collapsed) {
                            if (itemGroupingLevel <= num) {
                                break;
                            }
                            addToHideOrShow($tr);
                        } else {
                            if (itemGroupingLevel <= num) {
                                break;
                            }
                            if (itemGroupingLevel === num + 1) {
                                getGroupHeaderIcon($tr).removeClass(minusClasses).addClass(plusClasses);
                                addToHideOrShow($tr);
                            }
                            showDataRowsOnExpending = false;
                        }
                    } else {
                        if (collapsed || showDataRowsOnExpending) {
                            addToHideOrShow($tr);
                        }
                    }
                }
                $(rowsToHideOrShow).css("display", collapsed ? "none" : "");
                if (p.frozenColumns) {
                    $($t).triggerHandler("jqGridResetFrozenHeights", [ {
                        "header": {
                            "resizeDiv": false,
                            "resizedRows": {
                                "iRowStart": -1,
                                "iRowEnd": -1
                            }
                        },
                        "resizeFooter": false,
                        "body": {
                            "resizeDiv": true,
                            "resizedRows": {
                                "iRowStart": iRowStart,
                                "iRowEnd": $tr.length ? $tr[0].rowIndex - 1 : -1
                            }
                        }
                    } ]);
                }
                $t.fixScrollOffsetAndhBoxPadding();
                $($t).triggerHandler("jqGridGroupingClickGroup", [ hid, collapsed ]);
                if ($.isFunction(p.onClickGroup)) {
                    p.onClickGroup.call($t, hid, collapsed);
                }
            });
            return false;
        },
        "groupingRender": function(grdata, rn) {
            var str = "", $t = this[0], p = $t.p, toEnd = 0, gv, cp = [], icon = "", hid, clid, grp = p.groupingView, sumreverse = $.makeArray(grp.groupSummary), pmrtl = (grp.groupCollapse ? grp.plusicon : grp.minusicon) + " tree-wrap", groupLength = grp.groupField.length, groups = grp.groups, colModel = p.colModel, cmLength = colModel.length, page = p.page, eventNames = "jqGridShowHideCol.groupingRender", getGridRowStyles = function(classes) {
                return base.getGuiStyles.call($t, "gridRow", classes);
            }, jqgroupClass = getGridRowStyles("jqgroup ui-row-" + p.direction), jqfootClass = getGridRowStyles("jqfoot ui-row-" + p.direction);
            function buildSummaryTd(iEndGroup, offset, g, foffset, iconHtml) {
                var fdata = groups[iEndGroup], i, groupCount, strTd = "", tmpdata, colSpan, align, vv, madeHidden, nMakeHidden = 0, iSummary, summary, cm, iCol, summaryType, summaryTpl, isColumnForIconNotFound = true;
                if (offset !== 0 && groups[iEndGroup].idx !== 0) {
                    for (i = iEndGroup; i >= 0; i--) {
                        if (groups[i].idx === groups[iEndGroup].idx - offset) {
                            fdata = groups[i];
                            break;
                        }
                    }
                }
                groupCount = fdata.cnt;
                for (iCol = iconHtml === undefined ? foffset : 0; iCol < cmLength; iCol++) {
                    tmpdata = "&#160;";
                    cm = colModel[iCol];
                    for (iSummary = 0; iSummary < fdata.summary.length; iSummary++) {
                        summary = fdata.summary[iSummary];
                        summaryType = $.isArray(summary.st) ? summary.st[g.idx] : summary.st;
                        summaryTpl = $.isArray(cm.summaryTpl) ? cm.summaryTpl[g.idx] : cm.summaryTpl || "{0}";
                        if (summary.nm === cm.name) {
                            if (typeof summaryType === "string" && summaryType.toLowerCase() === "avg") {
                                if (summary.sd && summary.vd) {
                                    summary.v = summary.v / summary.vd;
                                } else if (summary.v && groupCount > 0) {
                                    summary.v = summary.v / groupCount;
                                }
                            }
                            try {
                                summary.groupCount = fdata.cnt;
                                summary.groupIndex = fdata.dataIndex;
                                summary.groupValue = fdata.value;
                                vv = $t.formatter("", summary.v, iCol, summary);
                            } catch (ef) {
                                vv = summary.v;
                            }
                            tmpdata = jgrid.format(summaryTpl, vv);
                            if (cm.summaryFormat) {
                                tmpdata = cm.summaryFormat.call($t, g, tmpdata, vv, cm);
                            }
                            break;
                        }
                    }
                    colSpan = false;
                    align = false;
                    if (iconHtml !== undefined && isColumnForIconNotFound) {
                        if (!cm.hidden) {
                            tmpdata = iconHtml;
                            isColumnForIconNotFound = false;
                            if (foffset > 1) {
                                colSpan = true;
                                nMakeHidden = foffset - 1;
                            }
                            align = cm.align;
                            cm.align = p.direction === "rtl" ? "right" : "left";
                            grp.iconColumnName = cm.name;
                        }
                    }
                    madeHidden = false;
                    if (nMakeHidden > 0 && !cm.hidden && tmpdata === "&#160;") {
                        madeHidden = true;
                        if (align) {
                            cm.align = align;
                        }
                        nMakeHidden--;
                        continue;
                    }
                    strTd += "<td role='gridcell' " + $t.formatCol(iCol, 1, "") + (colSpan ? "colspan='" + foffset + "'" : "") + ">" + tmpdata + "</td>";
                    colSpan = false;
                    if (align) {
                        cm.align = align;
                    }
                    if (madeHidden) {
                        cm.hidden = false;
                        nMakeHidden--;
                    }
                }
                return strTd;
            }
            $.each(colModel, function(i, n) {
                var iGroup;
                for (iGroup = 0; iGroup < groupLength; iGroup++) {
                    if (grp.groupField[iGroup] === n.name) {
                        cp[iGroup] = i;
                        break;
                    }
                }
            });
            sumreverse.reverse();
            $.each(groups, function(i, n) {
                if (grp._locgr) {
                    if (!(n.startRow + n.cnt > (page - 1) * rn && n.startRow < page * rn)) {
                        return true;
                    }
                }
                toEnd++;
                clid = p.id + "ghead_" + n.idx;
                hid = clid + "_" + i;
                icon = "<span style='cursor:pointer;margin-" + (p.direction === "rtl" ? "right:" : "left:") + n.idx * 12 + "px;' class='" + grp.commonIconClass + " " + pmrtl + "' onclick=\"jQuery('#" + jgrid.jqID(p.id).replace("\\", "\\\\") + "').jqGrid('groupingToggle','" + hid + "', this);return false;\"></span>";
                try {
                    if ($.isArray(grp.formatDisplayField) && $.isFunction(grp.formatDisplayField[n.idx])) {
                        n.displayValue = grp.formatDisplayField[n.idx].call($t, n.displayValue, n.value, colModel[cp[n.idx]], n.idx, grp);
                        gv = n.displayValue;
                    } else {
                        gv = $t.formatter(hid, n.displayValue, cp[n.idx], n.value);
                    }
                } catch (egv) {
                    gv = n.displayValue;
                }
                str += "<tr id='" + hid + "' data-jqgrouplevel='" + n.idx + "' " + (grp.groupCollapse && n.idx > 0 ? "style='display:none;' " : "") + "role='row' class='" + jqgroupClass + " " + clid + "'>";
                var grpTextStr = $.isFunction(grp.groupText[n.idx]) ? grp.groupText[n.idx].call($t, gv, n.cnt, n.summary) : jgrid.template(grp.groupText[n.idx], gv, n.cnt, n.summary), colspan = 1, jj, kk, ik, offset = 0, sgr, gg, end, leaf = groupLength - 1 === n.idx;
                if (typeof grpTextStr !== "string" && typeof grpTextStr !== "number") {
                    grpTextStr = gv;
                }
                if (grp.groupSummaryPos[n.idx] === "header") {
                    colspan = 1;
                    if (colModel[0].name === "cb" || colModel[1].name === "cb") {
                        colspan++;
                    }
                    if (colModel[0].name === "subgrid" || colModel[1].name === "subgrid") {
                        colspan++;
                    }
                    str += buildSummaryTd(i, 0, n, colspan, icon + "<span class='cell-wrapper'>" + grpTextStr + "</span>");
                } else {
                    str += "<td role='gridcell' style='padding-left:" + n.idx * 12 + "px;'" + " colspan='" + cmLength + "'>" + icon + grpTextStr + "</td>";
                }
                str += "</tr>";
                if (leaf) {
                    gg = groups[i + 1];
                    sgr = n.startRow;
                    end = gg !== undefined ? gg.startRow : groups[i].startRow + groups[i].cnt;
                    if (grp._locgr) {
                        offset = (page - 1) * rn;
                        if (offset > n.startRow) {
                            sgr = offset;
                        }
                    }
                    for (kk = sgr; kk < end; kk++) {
                        if (!grdata[kk - offset]) {
                            break;
                        }
                        str += grdata[kk - offset].join("");
                    }
                    if (grp.groupSummaryPos[n.idx] !== "header") {
                        if (gg !== undefined) {
                            for (jj = 0; jj < grp.groupField.length; jj++) {
                                if (gg.dataIndex === grp.groupField[jj]) {
                                    break;
                                }
                            }
                            toEnd = grp.groupField.length - jj;
                        }
                        for (ik = 0; ik < toEnd; ik++) {
                            if (!sumreverse[ik]) {
                                continue;
                            }
                            str += "<tr data-jqfootlevel='" + (n.idx - ik) + (grp.groupCollapse && (n.idx - ik > 0 || !grp.showSummaryOnHide) ? "' style='display:none;'" : "'") + " role='row' class='" + jqfootClass + "'>";
                            str += buildSummaryTd(i, ik, groups[n.idx - ik], 0);
                            str += "</tr>";
                        }
                        toEnd = jj;
                    }
                }
            });
            this.unbind(eventNames).bind(eventNames, function() {
                var iCol = p.iColByName[grp.iconColumnName], iRow, row, iColNew, i;
                if ($.inArray("header", grp.groupSummaryPos) >= 0) {
                    for (i = 0; i < colModel.length; i++) {
                        if (!colModel[i].hidden) {
                            iColNew = i;
                            break;
                        }
                    }
                    if (iColNew === undefined || iCol === iColNew) {
                        return;
                    }
                    for (iRow = 0; iRow < $t.rows.length; iRow++) {
                        row = $t.rows[iRow];
                        if ($(row).hasClass("jqgroup")) {
                            $(row.cells[iColNew]).html(row.cells[iCol].innerHTML);
                            $(row.cells[iCol]).html("&nbsp;");
                        }
                    }
                    grp.iconColumnName = colModel[iColNew].name;
                }
            });
            return str;
        },
        "groupingGroupBy": function(name, options) {
            return this.each(function() {
                var $t = this, p = $t.p, grp = p.groupingView, i, cm;
                if (typeof name === "string") {
                    name = [ name ];
                }
                p.grouping = true;
                grp._locgr = false;
                if (grp.visibiltyOnNextGrouping === undefined) {
                    grp.visibiltyOnNextGrouping = [];
                }
                for (i = 0; i < grp.groupField.length; i++) {
                    cm = p.colModel[p.iColByName[grp.groupField[i]]];
                    if (!grp.groupColumnShow[i] && grp.visibiltyOnNextGrouping[i] && cm != null && cm.hidden === true) {
                        base.showCol.call($($t), grp.groupField[i]);
                    }
                }
                for (i = 0; i < name.length; i++) {
                    grp.visibiltyOnNextGrouping[i] = $(p.idSel + "_" + jgrid.jqID(name[i])).is(":visible");
                }
                p.groupingView = $.extend(p.groupingView, options || {});
                grp.groupField = name;
                $($t).trigger("reloadGrid");
            });
        },
        "groupingRemove": function(current) {
            return this.each(function() {
                var $t = this, p = $t.p, tbody = $t.tBodies[0], grp = p.groupingView, i;
                if (current === undefined) {
                    current = true;
                }
                p.grouping = false;
                if (current === true) {
                    for (i = 0; i < grp.groupField.length; i++) {
                        if (!grp.groupColumnShow[i] && grp.visibiltyOnNextGrouping[i]) {
                            base.showCol.call($($t), grp.groupField);
                        }
                    }
                    $("tr.jqgroup, tr.jqfoot", tbody).remove();
                    $("tr.jqgrow", tbody).filter(":hidden").show();
                } else {
                    $($t).trigger("reloadGrid");
                }
            });
        },
        "groupingCalculations": {
            "handler": function(fn, v, field, round, roundType, rc) {
                var funcs = {
                    "sum": function() {
                        return parseFloat(v || 0) + parseFloat(rc[field] || 0);
                    },
                    "min": function() {
                        if (v === "") {
                            return parseFloat(rc[field] || 0);
                        }
                        return Math.min(parseFloat(v), parseFloat(rc[field] || 0));
                    },
                    "max": function() {
                        if (v === "") {
                            return parseFloat(rc[field] || 0);
                        }
                        return Math.max(parseFloat(v), parseFloat(rc[field] || 0));
                    },
                    "count": function() {
                        if (v === "") {
                            v = 0;
                        }
                        if (rc.hasOwnProperty(field)) {
                            return v + 1;
                        }
                        return 0;
                    },
                    "avg": function() {
                        return funcs.sum();
                    }
                }, res, mul;
                if (!funcs[fn]) {
                    throw "jqGrid Grouping No such method: " + fn;
                }
                res = funcs[fn]();
                if (round != null) {
                    if (roundType === "fixed") {
                        res = res.toFixed(round);
                    } else {
                        mul = Math.pow(10, round);
                        res = Math.round(res * mul) / mul;
                    }
                }
                return res;
            }
        }
    });
});

(function(factory) {
    "use strict";
    if (typeof define === "function" && define.amd) {
        define([ "jquery", "./grid.base" ], factory);
    } else if (typeof exports === "object") {
        factory(require("jquery"));
    } else {
        factory(jQuery);
    }
})(function($) {
    "use strict";
    $.jgrid = $.jgrid || {};
    var jgrid = $.jgrid, getGridRes = jgrid.getMethod("getGridRes"), base = $.fn.jqGrid;
    $.fmatter = $.fmatter || {};
    var fmatter = $.fmatter, getOptionByName = function(colModel, name) {
        var option = colModel.formatoptions || {};
        if (option.hasOwnProperty(name)) {
            return option[name];
        } else {
            return (colModel.editoptions || {})[name];
        }
    }, encodeAttr = function(v) {
        return String(v).replace(/\'/g, "&#39;");
    }, parseCheckboxOptions = function(options) {
        var colModel = options.colModel || options.cm, checked, unchecked, title = colModel.title !== false ? " title='" + encodeAttr(options.colName || colModel.name) + "'" : "", getOption = function(name) {
            return getOptionByName(colModel, name);
        }, checkedClasses = getOption("checkedClass"), uncheckedClasses = getOption("uncheckedClass"), value = getOption("value"), yes = typeof value === "string" ? value.split(":")[0] || "Yes" : "Yes", no = typeof value === "string" ? value.split(":")[1] || "No" : "No", buildCheckbox = function(classes) {
            return "<i class='" + encodeAttr(classes) + "'" + title + "></i>";
        }, disabled = getOption("disabled");
        if (disabled === undefined) {
            disabled = jgrid.formatter.checkbox.disabled;
        }
        if (disabled === true && base.isInCommonIconClass.call(this, "fa")) {
            checkedClasses = checkedClasses || "fa fa-check-square-o fa-lg";
            checked = buildCheckbox(checkedClasses);
            unchecked = buildCheckbox(uncheckedClasses || "fa fa-square-o fa-lg");
        } else if (disabled === true && base.isInCommonIconClass.call(this, "glyphicon")) {
            checkedClasses = checkedClasses || "glyphicon glyphicon-check";
            checked = buildCheckbox(checkedClasses);
            unchecked = buildCheckbox(uncheckedClasses || "glyphicon glyphicon-unchecked");
        } else {
            checkedClasses = "";
            title += disabled === true ? " disabled='disabled'" : "";
            checked = "<input type='checkbox' checked='checked'" + title + " />";
            unchecked = "<input type='checkbox'" + title + " />";
        }
        return {
            "checkedClasses": checkedClasses,
            "checked": checked,
            "unchecked": unchecked,
            "yes": yes,
            "no": no
        };
    }, YesObject = {
        "1": 1,
        "x": 1,
        "true": 1,
        "yes": 1,
        "on": 1
    }, NoObject = {
        "0": 1,
        "false": 1,
        "no": 1,
        "off": 1
    };
    $.extend(true, jgrid, {
        "formatter": {
            "date": {
                "parseRe": /[#%\\\/:_;.,\t\s\-]/,
                "masks": {
                    "ISO8601Long": "Y-m-d H:i:s",
                    "ISO8601Short": "Y-m-d",
                    "SortableDateTime": "Y-m-d\\TH:i:s",
                    "UniversalSortableDateTime": "Y-m-d H:i:sO"
                },
                "reformatAfterEdit": true,
                "userLocalTime": false
            },
            "baseLinkUrl": "",
            "showAction": "",
            "target": "",
            "checkbox": {
                "disabled": true
            },
            "idName": "id"
        },
        "cmTemplate": {
            "integerStr": {
                "formatter": "integer",
                "align": "right",
                "sorttype": "integer",
                "searchoptions": {
                    "sopt": [ "eq", "ne", "lt", "le", "gt", "ge" ]
                }
            },
            "integer": {
                "formatter": "integer",
                "align": "right",
                "sorttype": "integer",
                "convertOnSave": function(options) {
                    var nData = options.newValue;
                    return isNaN(nData) ? nData : parseInt(nData, 10);
                },
                "searchoptions": {
                    "sopt": [ "eq", "ne", "lt", "le", "gt", "ge" ]
                }
            },
            "numberStr": {
                "formatter": "number",
                "align": "right",
                "sorttype": "number",
                "searchoptions": {
                    "sopt": [ "eq", "ne", "lt", "le", "gt", "ge" ]
                }
            },
            "number": {
                "formatter": "number",
                "align": "right",
                "sorttype": "number",
                "convertOnSave": function(options) {
                    var nData = options.newValue;
                    return isNaN(nData) ? nData : parseFloat(nData);
                },
                "searchoptions": {
                    "sopt": [ "eq", "ne", "lt", "le", "gt", "ge" ]
                }
            },
            "booleanCheckbox": {
                "align": "center",
                "formatter": "checkbox",
                "edittype": "checkbox",
                "editoptions": {
                    "value": "true:false",
                    "defaultValue": "false"
                },
                "convertOnSave": function(options) {
                    var newValue = options.newValue, checkboxOptions = parseCheckboxOptions.call(this, options), lowerCaseNewData = String(newValue).toLowerCase();
                    if (YesObject[lowerCaseNewData] || lowerCaseNewData === checkboxOptions.yes.toLowerCase()) {
                        newValue = true;
                    } else if (NoObject[lowerCaseNewData] || lowerCaseNewData === checkboxOptions.no.toLowerCase()) {
                        newValue = false;
                    }
                    return newValue;
                },
                "stype": "select",
                "searchoptions": {
                    "sopt": [ "eq", "ne" ],
                    "value": "true:Yes;false:No",
                    "noFilterText": "Any"
                }
            },
            "actions": function() {
                var p = this.p;
                return {
                    "formatter": "actions",
                    "width": (p != null && (base.isInCommonIconClass.call(this, "fa") || base.isInCommonIconClass.call(this, "glyphicon")) ? $(this).jqGrid("isBootstrapGuiStyle") ? 45 : 39 : 40) + (jgrid.cellWidth() ? 5 : 0),
                    "align": "center",
                    "label": "",
                    "autoResizable": false,
                    "frozen": true,
                    "fixed": true,
                    "hidedlg": true,
                    "resizable": false,
                    "sortable": false,
                    "search": false,
                    "editable": false,
                    "viewable": false
                };
            }
        }
    });
    jgrid.cmTemplate.booleanCheckboxFa = jgrid.cmTemplate.booleanCheckbox;
    $.extend(fmatter, {
        "isObject": function(o) {
            return o && (typeof o === "object" || $.isFunction(o)) || false;
        },
        "isNumber": function(o) {
            return typeof o === "number" && isFinite(o);
        },
        "isValue": function(o) {
            return this.isObject(o) || typeof o === "string" || this.isNumber(o) || typeof o === "boolean";
        },
        "isEmpty": function(o) {
            if (typeof o !== "string" && this.isValue(o)) {
                return false;
            }
            if (!this.isValue(o)) {
                return true;
            }
            o = $.trim(o).replace(/&nbsp;/gi, "").replace(/&#160;/gi, "");
            return o === "";
        },
        "NumberFormat": function(nData, opts) {
            var isNumber = fmatter.isNumber;
            if (!isNumber(nData)) {
                nData *= 1;
            }
            if (isNumber(nData)) {
                var bNegative = nData < 0;
                var sOutput = String(nData);
                var sDecimalSeparator = opts.decimalSeparator || ".";
                var nDotIndex;
                if (isNumber(opts.decimalPlaces)) {
                    var nDecimalPlaces = opts.decimalPlaces;
                    var nDecimal = Math.pow(10, nDecimalPlaces);
                    sOutput = String(Math.round(nData * nDecimal) / nDecimal);
                    nDotIndex = sOutput.lastIndexOf(".");
                    if (nDecimalPlaces > 0) {
                        if (nDotIndex < 0) {
                            sOutput += sDecimalSeparator;
                            nDotIndex = sOutput.length - 1;
                        } else if (sDecimalSeparator !== ".") {
                            sOutput = sOutput.replace(".", sDecimalSeparator);
                        }
                        while (sOutput.length - 1 - nDotIndex < nDecimalPlaces) {
                            sOutput += "0";
                        }
                    }
                }
                if (opts.thousandsSeparator) {
                    var sThousandsSeparator = opts.thousandsSeparator;
                    nDotIndex = sOutput.lastIndexOf(sDecimalSeparator);
                    nDotIndex = nDotIndex > -1 ? nDotIndex : sOutput.length;
                    var sNewOutput = opts.decimalSeparator === undefined ? "" : sOutput.substring(nDotIndex);
                    var nCount = -1, i;
                    for (i = nDotIndex; i > 0; i--) {
                        nCount++;
                        if (nCount % 3 === 0 && i !== nDotIndex && (!bNegative || i > 1)) {
                            sNewOutput = sThousandsSeparator + sNewOutput;
                        }
                        sNewOutput = sOutput.charAt(i - 1) + sNewOutput;
                    }
                    sOutput = sNewOutput;
                }
                return sOutput;
            }
            return nData;
        }
    });
    var $FnFmatter = function(formatType, cellval, opts, rwd, act) {
        var v = cellval;
        opts = $.extend({}, getGridRes.call($(this), "formatter"), opts);
        try {
            v = $.fn.fmatter[formatType].call(this, cellval, opts, rwd, act);
        } catch (ignore) {}
        return v;
    };
    $.fn.fmatter = $FnFmatter;
    $FnFmatter.getCellBuilder = function(formatType, opts, act) {
        var cellBuilder = $.fn.fmatter[formatType] != null ? $.fn.fmatter[formatType].getCellBuilder : null;
        return $.isFunction(cellBuilder) ? cellBuilder.call(this, $.extend({}, getGridRes.call($(this), "formatter"), opts), act) : null;
    };
    $FnFmatter.defaultFormat = function(cellval, opts) {
        return fmatter.isValue(cellval) && cellval !== "" ? cellval : opts.defaultValue || "&#160;";
    };
    var defaultFormat = $FnFmatter.defaultFormat, formatCheckboxValue = function(cellValue, checkboxOptions, colModel) {
        if (cellValue === undefined || fmatter.isEmpty(cellValue)) {
            var defaultValue = getOptionByName(colModel, "defaultValue");
            if (defaultValue === undefined) {
                cellValue = checkboxOptions.no;
            }
            cellValue = defaultValue;
        }
        cellValue = String(cellValue).toLowerCase();
        return YesObject[cellValue] || cellValue === checkboxOptions.yes.toLowerCase() ? checkboxOptions.checked : checkboxOptions.unchecked;
    };
    $FnFmatter.email = function(cellval, opts) {
        if (!fmatter.isEmpty(cellval)) {
            return "<a href='mailto:" + encodeAttr(cellval) + "'>" + cellval + "</a>";
        }
        return defaultFormat(cellval, opts);
    };
    $FnFmatter.checkbox = function(cellValue, options) {
        var checkboxOptions = parseCheckboxOptions.call(this, options);
        return formatCheckboxValue(cellValue, checkboxOptions, options.colModel);
    };
    $FnFmatter.checkbox.getCellBuilder = function(options) {
        var checkboxOptions, colModel = options.colModel;
        options.colName = options.colName || this.p.colNames[options.pos];
        checkboxOptions = parseCheckboxOptions.call(this, options);
        return function(cellValue) {
            return formatCheckboxValue(cellValue, checkboxOptions, colModel);
        };
    };
    $FnFmatter.checkbox.unformat = function(cellValue, options, elem) {
        var checkboxOptions = parseCheckboxOptions.call(this, options), $elem = $(elem);
        return (checkboxOptions.checkedClasses ? jgrid.hasAllClasses($elem.children("i"), checkboxOptions.checkedClasses) : $elem.children("input").is(":checked")) ? checkboxOptions.yes : checkboxOptions.no;
    };
    $FnFmatter.checkboxFontAwesome4 = $FnFmatter.checkbox;
    $FnFmatter.checkboxFontAwesome4.getCellBuilder = $FnFmatter.checkbox.getCellBuilder;
    $FnFmatter.checkboxFontAwesome4.unformat = $FnFmatter.checkbox.unformat;
    $FnFmatter.link = function(cellval, opts) {
        var colModel = opts.colModel, target = "", op = {
            "target": opts.target
        };
        if (colModel != null) {
            op = $.extend({}, op, colModel.formatoptions || {});
        }
        if (op.target) {
            target = "target=" + op.target;
        }
        if (!fmatter.isEmpty(cellval)) {
            return "<a " + target + " href='" + encodeAttr(cellval) + "'>" + cellval + "</a>";
        }
        return defaultFormat(cellval, op);
    };
    $FnFmatter.showlink = function(cellval, opts, rowData) {
        var self = this, colModel = opts.colModel, op = {
            "baseLinkUrl": opts.baseLinkUrl,
            "showAction": opts.showAction,
            "addParam": opts.addParam || "",
            "target": opts.target,
            "idName": opts.idName,
            "hrefDefaultValue": "#"
        }, target = "", idUrl, idParam, addParam, getOptionValue = function(option) {
            return $.isFunction(option) ? option.call(self, {
                "cellValue": cellval,
                "rowid": opts.rowId,
                "rowData": rowData,
                "options": op
            }) : option || "";
        };
        if (colModel != null) {
            op = $.extend({}, op, colModel.formatoptions || {});
        }
        if (op.target) {
            target = "target=" + getOptionValue(op.target);
        }
        idUrl = getOptionValue(op.baseLinkUrl) + getOptionValue(op.showAction);
        idParam = op.idName ? encodeURIComponent(getOptionValue(op.idName)) + "=" + encodeURIComponent(getOptionValue(op.rowId) || opts.rowId) : "";
        addParam = getOptionValue(op.addParam);
        if (typeof addParam === "object" && addParam !== null) {
            addParam = (idParam !== "" ? "&" : "") + $.param(addParam);
        }
        idUrl += !idParam && !addParam ? "" : "?" + idParam + addParam;
        if (idUrl === "") {
            idUrl = getOptionValue(op.hrefDefaultValue);
        }
        if (typeof cellval === "string" || fmatter.isNumber(cellval) || $.isFunction(op.cellValue)) {
            return "<a " + target + " href='" + encodeAttr(idUrl) + "'>" + ($.isFunction(op.cellValue) ? getOptionValue(op.cellValue) : cellval) + "</a>";
        }
        return defaultFormat(cellval, op);
    };
    $FnFmatter.showlink.getCellBuilder = function(opts1) {
        var op = {
            "baseLinkUrl": opts1.baseLinkUrl,
            "showAction": opts1.showAction,
            "addParam": opts1.addParam || "",
            "target": opts1.target,
            "idName": opts1.idName,
            "hrefDefaultValue": "#"
        }, colModel = opts1.colModel;
        if (colModel != null) {
            op = $.extend({}, op, colModel.formatoptions || {});
        }
        return function(cellval, opts, rowData) {
            var self = this, rowid = opts.rowId, target = "", idUrl, idParam, addParam, getOptionValue = function(option) {
                return $.isFunction(option) ? option.call(self, {
                    "cellValue": cellval,
                    "rowid": rowid,
                    "rowData": rowData,
                    "options": op
                }) : option || "";
            };
            if (op.target) {
                target = "target=" + getOptionValue(op.target);
            }
            idUrl = getOptionValue(op.baseLinkUrl) + getOptionValue(op.showAction);
            idParam = op.idName ? encodeURIComponent(getOptionValue(op.idName)) + "=" + encodeURIComponent(getOptionValue(rowid) || opts.rowId) : "";
            addParam = getOptionValue(op.addParam);
            if (typeof addParam === "object" && addParam !== null) {
                addParam = (idParam !== "" ? "&" : "") + $.param(addParam);
            }
            idUrl += !idParam && !addParam ? "" : "?" + idParam + addParam;
            if (idUrl === "") {
                idUrl = getOptionValue(op.hrefDefaultValue);
            }
            if (typeof cellval === "string" || fmatter.isNumber(cellval) || $.isFunction(op.cellValue)) {
                return "<a " + target + " href='" + encodeAttr(idUrl) + "'>" + ($.isFunction(op.cellValue) ? getOptionValue(op.cellValue) : cellval) + "</a>";
            }
            return defaultFormat(cellval, op);
        };
    };
    $FnFmatter.showlink.pageFinalization = function(iCol) {
        var $self = $(this), p = this.p, colModel = p.colModel, cm = colModel[iCol], iRow, rows = this.rows, nRows = rows.length, row, td, onClick = function(e) {
            var $tr = $(this).closest(".jqgrow");
            if ($tr.length > 0) {
                return cm.formatoptions.onClick.call($self[0], {
                    "iCol": iCol,
                    "iRow": $tr[0].rowIndex,
                    "rowid": $tr.attr("id"),
                    "cm": cm,
                    "cmName": cm.name,
                    "cellValue": $(this).text(),
                    "a": this,
                    "event": e
                });
            }
        };
        if (cm.formatoptions != null && $.isFunction(cm.formatoptions.onClick)) {
            for (iRow = 0; iRow < nRows; iRow++) {
                row = rows[iRow];
                if ($(row).hasClass("jqgrow")) {
                    td = row.cells[iCol];
                    if (cm.autoResizable && td != null && $(td.firstChild).hasClass(p.autoResizing.wrapperClassName)) {
                        td = td.firstChild;
                    }
                    if (td != null) {
                        $(td.firstChild).bind("click", onClick);
                    }
                }
            }
        }
    };
    var insertPrefixAndSuffix = function(sOutput, opts) {
        sOutput = opts.prefix ? opts.prefix + sOutput : sOutput;
        return opts.suffix ? sOutput + opts.suffix : sOutput;
    }, numberHelper = function(cellval, opts, formatType) {
        var colModel = opts.colModel, op = $.extend({}, opts[formatType]);
        if (colModel != null) {
            op = $.extend({}, op, colModel.formatoptions || {});
        }
        if (fmatter.isEmpty(cellval)) {
            return insertPrefixAndSuffix(op.defaultValue, op);
        }
        return insertPrefixAndSuffix(fmatter.NumberFormat(cellval, op), op);
    };
    $FnFmatter.integer = function(cellval, opts) {
        return numberHelper(cellval, opts, "integer");
    };
    $FnFmatter.number = function(cellval, opts) {
        return numberHelper(cellval, opts, "number");
    };
    $FnFmatter.currency = function(cellval, opts) {
        return numberHelper(cellval, opts, "currency");
    };
    var numberCellBuilder = function(opts, formatType) {
        var colModel = opts.colModel, op = $.extend({}, opts[formatType]);
        if (colModel != null) {
            op = $.extend({}, op, colModel.formatoptions || {});
        }
        var numberFormat = fmatter.NumberFormat, defaultValue = op.defaultValue ? insertPrefixAndSuffix(op.defaultValue, op) : "";
        return function(cellValue) {
            if (fmatter.isEmpty(cellValue)) {
                return defaultValue;
            }
            return insertPrefixAndSuffix(numberFormat(cellValue, op), op);
        };
    };
    $FnFmatter.integer.getCellBuilder = function(options) {
        return numberCellBuilder(options, "integer");
    };
    $FnFmatter.number.getCellBuilder = function(options) {
        return numberCellBuilder(options, "number");
    };
    $FnFmatter.currency.getCellBuilder = function(options) {
        return numberCellBuilder(options, "currency");
    };
    $FnFmatter.date = function(cellval, opts, rwd, act) {
        var colModel = opts.colModel, op = $.extend({}, opts.date);
        if (colModel != null) {
            op = $.extend({}, op, colModel.formatoptions || {});
        }
        if (!op.reformatAfterEdit && act === "edit") {
            return defaultFormat(cellval, op);
        }
        if (!fmatter.isEmpty(cellval)) {
            return jgrid.parseDate.call(this, op.srcformat, cellval, op.newformat, op);
        }
        return defaultFormat(cellval, op);
    };
    $FnFmatter.date.getCellBuilder = function(opts, act) {
        var op = $.extend({}, opts.date);
        if (opts.colModel != null) {
            op = $.extend({}, op, opts.colModel.formatoptions || {});
        }
        var parseDate = jgrid.parseDate, srcformat = op.srcformat, newformat = op.newformat;
        if (!op.reformatAfterEdit && act === "edit") {
            return function(cellValue) {
                return defaultFormat(cellValue, op);
            };
        }
        return function(cellValue) {
            return fmatter.isEmpty(cellValue) ? defaultFormat(cellValue, op) : parseDate.call(this, srcformat, cellValue, newformat, op);
        };
    };
    $FnFmatter.select = function(cellval, opts) {
        var ret = [], colModel = opts.colModel, defaultValue, op = $.extend({}, colModel.editoptions || {}, colModel.formatoptions || {}), oSelect = op.value, sep = op.separator || ":", delim = op.delimiter || ";";
        if (oSelect) {
            var msl = op.multiple === true ? true : false, scell = [], sv, mapFunc = function(n, j) {
                if (j > 0) {
                    return n;
                }
            };
            if (msl) {
                scell = $.map(String(cellval).split(","), function(n) {
                    return $.trim(n);
                });
            }
            if (typeof oSelect === "string") {
                var so = oSelect.split(delim), i, v;
                for (i = 0; i < so.length; i++) {
                    sv = so[i].split(sep);
                    if (sv.length > 2) {
                        sv[1] = $.map(sv, mapFunc).join(sep);
                    }
                    v = $.trim(sv[0]);
                    if (op.defaultValue === v) {
                        defaultValue = sv[1];
                    }
                    if (msl) {
                        if ($.inArray(v, scell) > -1) {
                            ret.push(sv[1]);
                        }
                    } else if (v === $.trim(cellval)) {
                        ret = [ sv[1] ];
                        break;
                    }
                }
            } else if (fmatter.isObject(oSelect)) {
                defaultValue = oSelect[op.defaultValue];
                if (msl) {
                    ret = $.map(scell, function(n) {
                        return oSelect[n];
                    });
                } else {
                    ret = [ oSelect[cellval] === undefined ? "" : oSelect[cellval] ];
                }
            }
        }
        cellval = ret.join(", ");
        return cellval !== "" ? cellval : op.defaultValue !== undefined ? defaultValue : defaultFormat(cellval, op);
    };
    $FnFmatter.select.getCellBuilder = function(opts) {
        var colModel = opts.colModel, $fnDefaultFormat = $FnFmatter.defaultFormat, op = $.extend({}, colModel.editoptions || {}, colModel.formatoptions || {}), oSelect = op.value, sep = op.separator || ":", delim = op.delimiter || ";", defaultValue, defaultValueDefined = op.defaultValue !== undefined, isMultiple = op.multiple === true ? true : false, sv, so, i, nOpts, selOptions = {}, mapFunc = function(n, j) {
            if (j > 0) {
                return n;
            }
        };
        if (typeof oSelect === "string") {
            so = oSelect.split(delim);
            nOpts = so.length;
            for (i = nOpts - 1; i >= 0; i--) {
                sv = so[i].split(sep);
                if (sv.length > 2) {
                    sv[1] = $.map(sv, mapFunc).join(sep);
                }
                selOptions[$.trim(sv[0])] = sv[1];
            }
        } else if (fmatter.isObject(oSelect)) {
            selOptions = oSelect;
        } else {
            return function(cellValue) {
                return cellValue ? String(cellValue) : $fnDefaultFormat(cellValue, op);
            };
        }
        if (defaultValueDefined) {
            defaultValue = selOptions[op.defaultValue];
        }
        return isMultiple ? function(cellValue) {
            var ret = [], iOpt, splitedCell = $.map(String(cellValue).split(","), function(n) {
                return $.trim(n);
            });
            for (iOpt = 0; iOpt < splitedCell.length; iOpt++) {
                cellValue = splitedCell[iOpt];
                if (selOptions.hasOwnProperty(cellValue)) {
                    ret.push(selOptions[cellValue]);
                }
            }
            cellValue = ret.join(", ");
            return cellValue !== "" ? cellValue : defaultValueDefined ? defaultValue : $fnDefaultFormat(cellValue, op);
        } : function(cellValue) {
            var ret = selOptions[String(cellValue)];
            return ret !== "" && ret !== undefined ? ret : defaultValueDefined ? defaultValue : $fnDefaultFormat(cellValue, op);
        };
    };
    $FnFmatter.rowactions = function(e, act) {
        var $tr = $(this).closest("tr.jqgrow"), rid = $tr.attr("id"), $id = $(this).closest("table.ui-jqgrid-btable").attr("id").replace(/_frozen([^_]*)$/, "$1"), $grid = $("#" + jgrid.jqID($id)), $t = $grid[0], p = $t.p, i, n, customAction, actop, getTop = function() {
            var tr = $tr[0], gbox = $grid.closest(".ui-jqgrid")[0];
            if (tr.getBoundingClientRect != null && gbox.getBoundingClientRect != null) {
                return tr.getBoundingClientRect().top + $tr.outerHeight() - gbox.getBoundingClientRect().top;
            }
            return $tr.offset().top + $tr.outerHeight() - $(gbox).offset().top;
        }, cm = p.colModel[jgrid.getCellIndex(this)], op = $.extend(true, {
            "extraparam": {}
        }, jgrid.actionsNav || {}, p.actionsNavOptions || {}, cm.formatoptions || {});
        if (p.editOptions !== undefined) {
            op.editOptions = $.extend(true, op.editOptions || {}, p.editOptions);
        }
        if (p.delOptions !== undefined) {
            op.delOptions = p.delOptions;
        }
        if ($tr.hasClass("jqgrid-new-row")) {
            op.extraparam[p.prmNames.oper] = p.prmNames.addoper;
        }
        actop = {
            "keys": op.keys,
            "oneditfunc": op.onEdit,
            "successfunc": op.onSuccess,
            "url": op.url,
            "extraparam": op.extraparam,
            "aftersavefunc": op.afterSave,
            "errorfunc": op.onError,
            "afterrestorefunc": op.afterRestore,
            "restoreAfterError": op.restoreAfterError,
            "mtype": op.mtype
        };
        if (!p.multiselect && rid !== p.selrow || p.multiselect && $.inArray(rid, p.selarrrow) < 0) {
            $grid.jqGrid("setSelection", rid, true, e);
        } else {
            jgrid.fullBoolFeedback.call($t, "onSelectRow", "jqGridSelectRow", rid, true, e);
        }
        switch (act) {
          case "edit":
            $grid.jqGrid("editRow", rid, actop);
            break;

          case "save":
            $grid.jqGrid("saveRow", rid, actop);
            break;

          case "cancel":
            $grid.jqGrid("restoreRow", rid, op.afterRestore);
            break;

          case "del":
            op.delOptions = op.delOptions || {};
            if (op.delOptions.top === undefined) {
                op.delOptions.top = getTop();
            }
            $grid.jqGrid("delGridRow", rid, op.delOptions);
            break;

          case "formedit":
            op.editOptions = op.editOptions || {};
            if (op.editOptions.top === undefined) {
                op.editOptions.top = getTop();
                op.editOptions.recreateForm = true;
            }
            $grid.jqGrid("editGridRow", rid, op.editOptions);
            break;

          default:
            if (op.custom != null && op.custom.length > 0) {
                n = op.custom.length;
                for (i = 0; i < n; i++) {
                    customAction = op.custom[i];
                    if (customAction.action === act && $.isFunction(customAction.onClick)) {
                        customAction.onClick.call($t, {
                            "rowid": rid,
                            "event": e,
                            "action": act,
                            "options": customAction
                        });
                    }
                }
            }
        }
        if (e.stopPropagation) {
            e.stopPropagation();
        }
        return false;
    };
    $FnFmatter.actions = function(cellval, opts, rwd, act) {
        var rowid = opts.rowId, str = "", $t = this, p = $t.p, $self = $($t), i, customAction, info, displayMask = {}, edit = getGridRes.call($self, "edit") || {}, op = $.extend({
            "editbutton": true,
            "delbutton": true,
            "editformbutton": false,
            "commonIconClass": "ui-icon",
            "editicon": "ui-icon-pencil",
            "delicon": "ui-icon-trash",
            "saveicon": "ui-icon-disk",
            "cancelicon": "ui-icon-cancel",
            "savetitle": edit.bSubmit || "",
            "canceltitle": edit.bCancel || ""
        }, getGridRes.call($self, "nav") || {}, jgrid.nav || {}, p.navOptions || {}, getGridRes.call($self, "actionsNav") || {}, jgrid.actionsNav || {}, p.actionsNavOptions || {}, opts.colModel.formatoptions || {}), cssIconClass = function(name) {
            return jgrid.mergeCssClasses(op.commonIconClass, op[name + "icon"]);
        }, hoverClass = $self.jqGrid("getGuiStyles", "states.hover"), hoverAttributes = "onmouseover=\"jQuery(this).addClass('" + hoverClass + "');\" onmouseout=\"jQuery(this).removeClass('" + hoverClass + "');\"", buttonInfos = [ {
            "action": "edit",
            "actionName": "formedit",
            "display": op.editformbutton
        }, {
            "action": "edit",
            "display": !op.editformbutton && op.editbutton
        }, {
            "action": "del",
            "idPrefix": "Delete",
            "display": op.delbutton
        }, {
            "action": "save",
            "display": op.editformbutton || op.editbutton,
            "hidden": true
        }, {
            "action": "cancel",
            "display": op.editformbutton || op.editbutton,
            "hidden": true
        } ], actionButton = function(options) {
            var action = options.action, actionName = options.actionName || action, idPrefix = options.idPrefix !== undefined ? options.idPrefix : action.charAt(0).toUpperCase() + action.substring(1);
            return "<div title='" + encodeAttr(op[action + "title"]) + (options.hidden ? "' style='display:none;" : "") + "' class='" + encodeAttr($self.jqGrid("getGuiStyles", "actionsButton", "ui-pg-div ui-inline-" + action)) + "' " + (idPrefix !== null ? "id='j" + encodeAttr(idPrefix + "Button_" + rowid) : "") + "' onclick=\"return jQuery.fn.fmatter.rowactions.call(this,event,'" + actionName + "');\" " + (options.noHovering ? "" : hoverAttributes) + "><span class='" + encodeAttr(cssIconClass(action)) + "'></span></div>";
        }, n = op.custom != null ? op.custom.length - 1 : -1;
        if (rowid === undefined || fmatter.isEmpty(rowid)) {
            return "";
        }
        if ($.isFunction(op.isDisplayButtons)) {
            try {
                displayMask = op.isDisplayButtons.call($t, opts, rwd, act) || {};
            } catch (ignore) {}
        }
        while (n >= 0) {
            customAction = op.custom[n--];
            buttonInfos[customAction.position === "first" ? "unshift" : "push"](customAction);
        }
        for (i = 0, n = buttonInfos.length; i < n; i++) {
            info = $.extend({}, buttonInfos[i], displayMask[buttonInfos[i].action] || {});
            if (info.display !== false) {
                str += actionButton(info);
            }
        }
        return "<div class='" + encodeAttr($self.jqGrid("getGuiStyles", "actionsDiv", "ui-jqgrid-actions")) + "'>" + str + "</div>";
    };
    $FnFmatter.actions.pageFinalization = function(iCol) {
        var $self = $(this), p = this.p, colModel = p.colModel, cm = colModel[iCol], showHideEditDelete = function(show, rowid) {
            var maxfrozen = 0, tr, $actionsDiv, len = colModel.length, i;
            for (i = 0; i < len; i++) {
                if (colModel[i].frozen !== true) {
                    break;
                }
                maxfrozen = i;
            }
            tr = $self.jqGrid("getGridRowById", rowid);
            if (tr != null && tr.cells != null) {
                iCol = p.iColByName[cm.name];
                $actionsDiv = $(tr.cells[iCol]).children(".ui-jqgrid-actions");
                if (cm.frozen && p.frozenColumns && iCol <= maxfrozen) {
                    $actionsDiv = $actionsDiv.add($($self[0].grid.fbRows[tr.rowIndex].cells[iCol]).children(".ui-jqgrid-actions"));
                }
                if (show) {
                    $actionsDiv.find(">.ui-inline-edit,>.ui-inline-del").show();
                    $actionsDiv.find(">.ui-inline-save,>.ui-inline-cancel").hide();
                } else {
                    $actionsDiv.find(">.ui-inline-edit,>.ui-inline-del").hide();
                    $actionsDiv.find(">.ui-inline-save,>.ui-inline-cancel").show();
                }
            }
        }, showEditDelete = function(e, rowid) {
            showHideEditDelete(true, rowid);
            return false;
        }, hideEditDelete = function(e, rowid) {
            showHideEditDelete(false, rowid);
            return false;
        };
        if (cm.formatoptions == null || !cm.formatoptions.editformbutton) {
            $self.unbind("jqGridInlineAfterRestoreRow.jqGridFormatter jqGridInlineAfterSaveRow.jqGridFormatter", showEditDelete);
            $self.bind("jqGridInlineAfterRestoreRow.jqGridFormatter jqGridInlineAfterSaveRow.jqGridFormatter", showEditDelete);
            $self.unbind("jqGridInlineEditRow.jqGridFormatter", hideEditDelete);
            $self.bind("jqGridInlineEditRow.jqGridFormatter", hideEditDelete);
        }
    };
    $.unformat = function(cellval, options, pos, cnt) {
        var ret, colModel = options.colModel, formatType = colModel.formatter, p = this.p, op = colModel.formatoptions || {}, unformatFunc = colModel.unformat || $FnFmatter[formatType] && $FnFmatter[formatType].unformat;
        if (cellval instanceof jQuery && cellval.length > 0) {
            cellval = cellval[0];
        }
        if (p.treeGrid && cellval != null && $(cellval.firstChild).hasClass("tree-wrap") && ($(cellval.lastChild).hasClass("cell-wrapper") || $(cellval.lastChild).hasClass("cell-wrapperleaf"))) {
            cellval = cellval.lastChild;
        }
        if (colModel.autoResizable && cellval != null && $(cellval.firstChild).hasClass(p.autoResizing.wrapperClassName)) {
            cellval = cellval.firstChild;
        }
        if (unformatFunc !== undefined && $.isFunction(unformatFunc)) {
            ret = unformatFunc.call(this, $(cellval).text(), options, cellval);
        } else if (formatType !== undefined && typeof formatType === "string") {
            var $self = $(this), getFormaterOption = function(formatterName, optionName) {
                return op[optionName] !== undefined ? op[optionName] : getGridRes.call($self, "formatter." + formatterName + "." + optionName);
            }, cutThousandsSeparator = function(formatterName, val) {
                var separator = getFormaterOption(formatterName, "thousandsSeparator").replace(/([\.\*\_\'\(\)\{\}\+\?\\])/g, "\\$1");
                return val.replace(new RegExp(separator, "g"), "");
            };
            switch (formatType) {
              case "integer":
                ret = cutThousandsSeparator("integer", $(cellval).text());
                break;

              case "number":
                ret = cutThousandsSeparator("number", $(cellval).text()).replace(getFormaterOption("number", "decimalSeparator"), ".");
                break;

              case "currency":
                ret = $(cellval).text();
                var prefix = getFormaterOption("currency", "prefix"), suffix = getFormaterOption("currency", "suffix");
                if (prefix && prefix.length) {
                    ret = ret.substr(prefix.length);
                }
                if (suffix && suffix.length) {
                    ret = ret.substr(0, ret.length - suffix.length);
                }
                ret = cutThousandsSeparator("number", ret).replace(getFormaterOption("number", "decimalSeparator"), ".");
                break;

              case "checkbox":
                ret = $FnFmatter.checkbox.unformat(cellval, options, cellval);
                break;

              case "select":
                ret = $.unformat.select(cellval, options, pos, cnt);
                break;

              case "actions":
                return "";

              default:
                ret = $(cellval).text();
            }
        }
        ret = ret !== undefined ? ret : cnt === true ? $(cellval).text() : jgrid.htmlDecode($(cellval).html());
        return ret;
    };
    $.unformat.select = function(cellval, options, pos, cnt) {
        var ret = [], cell = $(cellval).text(), colModel = options.colModel;
        if (cnt === true) {
            return cell;
        }
        var op = $.extend({}, colModel.editoptions || {}, colModel.formatoptions || {}), sep = op.separator === undefined ? ":" : op.separator, delim = op.delimiter === undefined ? ";" : op.delimiter;
        if (op.value) {
            var oSelect = op.value, msl = op.multiple === true ? true : false, scell = [], sv, mapFunc = function(n, k) {
                if (k > 0) {
                    return n;
                }
            };
            if (msl) {
                scell = cell.split(",");
                scell = $.map(scell, function(n) {
                    return $.trim(n);
                });
            }
            if (typeof oSelect === "string") {
                var so = oSelect.split(delim), j = 0, i;
                for (i = 0; i < so.length; i++) {
                    sv = so[i].split(sep);
                    if (sv.length > 2) {
                        sv[1] = $.map(sv, mapFunc).join(sep);
                    }
                    if (msl) {
                        if ($.inArray($.trim(sv[1]), scell) > -1) {
                            ret[j] = sv[0];
                            j++;
                        }
                    } else if ($.trim(sv[1]) === $.trim(cell)) {
                        ret[0] = sv[0];
                        break;
                    }
                }
            } else if (fmatter.isObject(oSelect) || $.isArray(oSelect)) {
                if (!msl) {
                    scell[0] = cell;
                }
                ret = $.map(scell, function(n) {
                    var rv;
                    $.each(oSelect, function(k, val) {
                        if (val === n) {
                            rv = k;
                            return false;
                        }
                    });
                    if (rv !== undefined) {
                        return rv;
                    }
                });
            }
            return ret.join(", ");
        }
        return cell || "";
    };
    $.unformat.date = function(cellval, opts) {
        var op = $.extend(true, {}, getGridRes.call($(this), "formatter.date"), jgrid.formatter.date || {}, opts.formatoptions || {});
        return !fmatter.isEmpty(cellval) ? jgrid.parseDate.call(this, op.newformat, cellval, op.srcformat, op) : "";
    };
});

(function() {
    var gridz;
    gridz = angular.module("angleGrinder.gridz", [ "ngSanitize", "angleGrinder.common", "ui.select2", "angleGrinder.resources", "dndLists" ]);
    gridz.run([ "$window", "agDateFilter", "agCurrencyFilter", "agLocalDateTimeFilter", function($window, agDateFilter, agCurrencyFilter, agLocalDateTimeFilter) {
        $window.agDateFilter = agDateFilter;
        $window.agLocalDateTimeFilter = agLocalDateTimeFilter;
        return $window.agCurrencyFilter = agCurrencyFilter;
    } ]);
}).call(this);

(function() {
    "use strict";
    angular.module("ui.grid.i18n", []);
    angular.module("ui.grid", [ "ui.grid.i18n" ]);
})();

(function() {
    "use strict";
    angular.module("ui.grid").constant("uiGridConstants", {
        "LOG_DEBUG_MESSAGES": true,
        "LOG_WARN_MESSAGES": true,
        "LOG_ERROR_MESSAGES": true,
        "CUSTOM_FILTERS": /CUSTOM_FILTERS/g,
        "COL_FIELD": /COL_FIELD/g,
        "MODEL_COL_FIELD": /MODEL_COL_FIELD/g,
        "TOOLTIP": /title=\"TOOLTIP\"/g,
        "DISPLAY_CELL_TEMPLATE": /DISPLAY_CELL_TEMPLATE/g,
        "TEMPLATE_REGEXP": /<.+>/,
        "FUNC_REGEXP": /(\([^)]*\))?$/,
        "DOT_REGEXP": /\./g,
        "APOS_REGEXP": /'/g,
        "BRACKET_REGEXP": /^(.*)((?:\s*\[\s*\d+\s*\]\s*)|(?:\s*\[\s*"(?:[^"\\]|\\.)*"\s*\]\s*)|(?:\s*\[\s*'(?:[^'\\]|\\.)*'\s*\]\s*))(.*)$/,
        "COL_CLASS_PREFIX": "ui-grid-col",
        "events": {
            "GRID_SCROLL": "uiGridScroll",
            "COLUMN_MENU_SHOWN": "uiGridColMenuShown",
            "ITEM_DRAGGING": "uiGridItemDragStart",
            "COLUMN_HEADER_CLICK": "uiGridColumnHeaderClick"
        },
        "keymap": {
            "TAB": 9,
            "STRG": 17,
            "CAPSLOCK": 20,
            "CTRL": 17,
            "CTRLRIGHT": 18,
            "CTRLR": 18,
            "SHIFT": 16,
            "RETURN": 13,
            "ENTER": 13,
            "BACKSPACE": 8,
            "BCKSP": 8,
            "ALT": 18,
            "ALTR": 17,
            "ALTRIGHT": 17,
            "SPACE": 32,
            "WIN": 91,
            "MAC": 91,
            "FN": null,
            "PG_UP": 33,
            "PG_DOWN": 34,
            "UP": 38,
            "DOWN": 40,
            "LEFT": 37,
            "RIGHT": 39,
            "ESC": 27,
            "DEL": 46,
            "F1": 112,
            "F2": 113,
            "F3": 114,
            "F4": 115,
            "F5": 116,
            "F6": 117,
            "F7": 118,
            "F8": 119,
            "F9": 120,
            "F10": 121,
            "F11": 122,
            "F12": 123
        },
        "ASC": "asc",
        "DESC": "desc",
        "filter": {
            "STARTS_WITH": 2,
            "ENDS_WITH": 4,
            "EXACT": 8,
            "CONTAINS": 16,
            "GREATER_THAN": 32,
            "GREATER_THAN_OR_EQUAL": 64,
            "LESS_THAN": 128,
            "LESS_THAN_OR_EQUAL": 256,
            "NOT_EQUAL": 512,
            "SELECT": "select",
            "INPUT": "input"
        },
        "aggregationTypes": {
            "sum": 2,
            "count": 4,
            "avg": 8,
            "min": 16,
            "max": 32
        },
        "CURRENCY_SYMBOLS": [ "\u0192", "$", "\xa3", "$", "\xa4", "\xa5", "\u17db", "\u20a9", "\u20b1", "\u0e3f", "\u20ab" ],
        "scrollDirection": {
            "UP": "up",
            "DOWN": "down",
            "LEFT": "left",
            "RIGHT": "right",
            "NONE": "none"
        },
        "dataChange": {
            "ALL": "all",
            "EDIT": "edit",
            "ROW": "row",
            "COLUMN": "column",
            "OPTIONS": "options"
        },
        "scrollbars": {
            "NEVER": 0,
            "ALWAYS": 1
        }
    });
})();

angular.module("ui.grid").directive("uiGridCell", [ "$compile", "$parse", "gridUtil", "uiGridConstants", function($compile, $parse, gridUtil, uiGridConstants) {
    var uiGridCell = {
        "priority": 0,
        "scope": false,
        "require": "?^uiGrid",
        "compile": function() {
            return {
                "pre": function($scope, $elm, $attrs, uiGridCtrl) {
                    function compileTemplate() {
                        var compiledElementFn = $scope.col.compiledElementFn;
                        compiledElementFn($scope, function(clonedElement, scope) {
                            $elm.append(clonedElement);
                        });
                    }
                    if (uiGridCtrl && $scope.col.compiledElementFn) {
                        compileTemplate();
                    } else {
                        if (uiGridCtrl && !$scope.col.compiledElementFn) {
                            $scope.col.getCompiledElementFn().then(function(compiledElementFn) {
                                compiledElementFn($scope, function(clonedElement, scope) {
                                    $elm.append(clonedElement);
                                });
                            });
                        } else {
                            var html = $scope.col.cellTemplate.replace(uiGridConstants.MODEL_COL_FIELD, "row.entity." + gridUtil.preEval($scope.col.field)).replace(uiGridConstants.COL_FIELD, "grid.getCellValue(row, col)");
                            var cellElement = $compile(html)($scope);
                            $elm.append(cellElement);
                        }
                    }
                },
                "post": function($scope, $elm, $attrs, uiGridCtrl) {
                    var initColClass = $scope.col.getColClass(false);
                    $elm.addClass(initColClass);
                    var classAdded;
                    var updateClass = function(grid) {
                        var contents = $elm;
                        if (classAdded) {
                            contents.removeClass(classAdded);
                            classAdded = null;
                        }
                        if (angular.isFunction($scope.col.cellClass)) {
                            classAdded = $scope.col.cellClass($scope.grid, $scope.row, $scope.col, $scope.rowRenderIndex, $scope.colRenderIndex);
                        } else {
                            classAdded = $scope.col.cellClass;
                        }
                        contents.addClass(classAdded);
                    };
                    if ($scope.col.cellClass) {
                        updateClass();
                    }
                    var dataChangeDereg = $scope.grid.registerDataChangeCallback(updateClass, [ uiGridConstants.dataChange.COLUMN, uiGridConstants.dataChange.EDIT ]);
                    var cellChangeFunction = function(n, o) {
                        if (n !== o) {
                            if (classAdded || $scope.col.cellClass) {
                                updateClass();
                            }
                            var newColClass = $scope.col.getColClass(false);
                            if (newColClass !== initColClass) {
                                $elm.removeClass(initColClass);
                                $elm.addClass(newColClass);
                                initColClass = newColClass;
                            }
                        }
                    };
                    var rowWatchDereg = $scope.$watch("row", cellChangeFunction);
                    var deregisterFunction = function() {
                        dataChangeDereg();
                        rowWatchDereg();
                    };
                    $scope.$on("$destroy", deregisterFunction);
                    $elm.on("$destroy", deregisterFunction);
                }
            };
        }
    };
    return uiGridCell;
} ]);

(function() {
    angular.module("ui.grid").service("uiGridColumnMenuService", [ "i18nService", "uiGridConstants", "gridUtil", function(i18nService, uiGridConstants, gridUtil) {
        var service = {
            "initialize": function($scope, uiGridCtrl) {
                $scope.grid = uiGridCtrl.grid;
                uiGridCtrl.columnMenuScope = $scope;
                $scope.menuShown = false;
            },
            "setColMenuItemWatch": function($scope) {
                var deregFunction = $scope.$watch("col.menuItems", function(n) {
                    if (typeof n !== "undefined" && n && angular.isArray(n)) {
                        n.forEach(function(item) {
                            if (typeof item.context === "undefined" || !item.context) {
                                item.context = {};
                            }
                            item.context.col = $scope.col;
                        });
                        $scope.menuItems = $scope.defaultMenuItems.concat(n);
                    } else {
                        $scope.menuItems = $scope.defaultMenuItems;
                    }
                });
                $scope.$on("$destroy", deregFunction);
            },
            "sortable": function($scope) {
                if ($scope.grid.options.enableSorting && typeof $scope.col !== "undefined" && $scope.col && $scope.col.enableSorting) {
                    return true;
                } else {
                    return false;
                }
            },
            "isActiveSort": function($scope, direction) {
                return typeof $scope.col !== "undefined" && typeof $scope.col.sort !== "undefined" && typeof $scope.col.sort.direction !== "undefined" && $scope.col.sort.direction === direction;
            },
            "suppressRemoveSort": function($scope) {
                if ($scope.col && $scope.col.suppressRemoveSort) {
                    return true;
                } else {
                    return false;
                }
            },
            "hideable": function($scope) {
                if (typeof $scope.col !== "undefined" && $scope.col && $scope.col.colDef && $scope.col.colDef.enableHiding === false) {
                    return false;
                } else {
                    return true;
                }
            },
            "getDefaultMenuItems": function($scope) {
                return [ {
                    "title": i18nService.getSafeText("sort.ascending"),
                    "icon": "ui-grid-icon-sort-alt-up",
                    "action": function($event) {
                        $event.stopPropagation();
                        $scope.sortColumn($event, uiGridConstants.ASC);
                    },
                    "shown": function() {
                        return service.sortable($scope);
                    },
                    "active": function() {
                        return service.isActiveSort($scope, uiGridConstants.ASC);
                    }
                }, {
                    "title": i18nService.getSafeText("sort.descending"),
                    "icon": "ui-grid-icon-sort-alt-down",
                    "action": function($event) {
                        $event.stopPropagation();
                        $scope.sortColumn($event, uiGridConstants.DESC);
                    },
                    "shown": function() {
                        return service.sortable($scope);
                    },
                    "active": function() {
                        return service.isActiveSort($scope, uiGridConstants.DESC);
                    }
                }, {
                    "title": i18nService.getSafeText("sort.remove"),
                    "icon": "ui-grid-icon-cancel",
                    "action": function($event) {
                        $event.stopPropagation();
                        $scope.unsortColumn();
                    },
                    "shown": function() {
                        return service.sortable($scope) && typeof $scope.col !== "undefined" && (typeof $scope.col.sort !== "undefined" && typeof $scope.col.sort.direction !== "undefined") && $scope.col.sort.direction !== null && !service.suppressRemoveSort($scope);
                    }
                }, {
                    "title": i18nService.getSafeText("column.hide"),
                    "icon": "ui-grid-icon-cancel",
                    "shown": function() {
                        return service.hideable($scope);
                    },
                    "action": function($event) {
                        $event.stopPropagation();
                        $scope.hideColumn();
                    }
                } ];
            },
            "getColumnElementPosition": function($scope, column, $columnElement) {
                var positionData = {};
                positionData.left = $columnElement[0].offsetLeft;
                positionData.top = $columnElement[0].offsetTop;
                positionData.parentLeft = $columnElement[0].offsetParent.offsetLeft;
                positionData.offset = 0;
                if (column.grid.options.offsetLeft) {
                    positionData.offset = column.grid.options.offsetLeft;
                }
                positionData.height = gridUtil.elementHeight($columnElement, true);
                positionData.width = gridUtil.elementWidth($columnElement, true);
                return positionData;
            },
            "repositionMenu": function($scope, column, positionData, $elm, $columnElement) {
                var menu = $elm[0].querySelectorAll(".ui-grid-menu");
                var renderContainerElm = gridUtil.closestElm($columnElement, ".ui-grid-render-container");
                var renderContainerOffset = renderContainerElm.getBoundingClientRect().left - $scope.grid.element[0].getBoundingClientRect().left;
                var containerScrollLeft = renderContainerElm.querySelectorAll(".ui-grid-viewport")[0].scrollLeft;
                var myWidth = column.lastMenuWidth ? column.lastMenuWidth : $scope.lastMenuWidth ? $scope.lastMenuWidth : 170;
                var paddingRight = column.lastMenuPaddingRight ? column.lastMenuPaddingRight : $scope.lastMenuPaddingRight ? $scope.lastMenuPaddingRight : 10;
                if (menu.length !== 0) {
                    var mid = menu[0].querySelectorAll(".ui-grid-menu-mid");
                    if (mid.length !== 0 && !angular.element(mid).hasClass("ng-hide")) {
                        myWidth = gridUtil.elementWidth(menu, true);
                        $scope.lastMenuWidth = myWidth;
                        column.lastMenuWidth = myWidth;
                        paddingRight = parseInt(gridUtil.getStyles(angular.element(menu)[0])["paddingRight"], 10);
                        $scope.lastMenuPaddingRight = paddingRight;
                        column.lastMenuPaddingRight = paddingRight;
                    }
                }
                var left = positionData.left + renderContainerOffset - containerScrollLeft + positionData.parentLeft + positionData.width - myWidth + paddingRight;
                if (left < positionData.offset) {
                    left = positionData.offset;
                }
                $elm.css("left", left + "px");
                $elm.css("top", positionData.top + positionData.height + "px");
            }
        };
        return service;
    } ]).directive("uiGridColumnMenu", [ "$timeout", "gridUtil", "uiGridConstants", "uiGridColumnMenuService", "$document", function($timeout, gridUtil, uiGridConstants, uiGridColumnMenuService, $document) {
        var uiGridColumnMenu = {
            "priority": 0,
            "scope": true,
            "require": "^uiGrid",
            "templateUrl": "ui-grid/uiGridColumnMenu",
            "replace": true,
            "link": function($scope, $elm, $attrs, uiGridCtrl) {
                uiGridColumnMenuService.initialize($scope, uiGridCtrl);
                $scope.defaultMenuItems = uiGridColumnMenuService.getDefaultMenuItems($scope);
                $scope.menuItems = $scope.defaultMenuItems;
                uiGridColumnMenuService.setColMenuItemWatch($scope);
                $scope.showMenu = function(column, $columnElement, event) {
                    $scope.col = column;
                    var colElementPosition = uiGridColumnMenuService.getColumnElementPosition($scope, column, $columnElement);
                    if ($scope.menuShown) {
                        $scope.colElement = $columnElement;
                        $scope.colElementPosition = colElementPosition;
                        $scope.hideThenShow = true;
                        $scope.$broadcast("hide-menu", {
                            "originalEvent": event
                        });
                    } else {
                        $scope.menuShown = true;
                        uiGridColumnMenuService.repositionMenu($scope, column, colElementPosition, $elm, $columnElement);
                        $scope.colElement = $columnElement;
                        $scope.colElementPosition = colElementPosition;
                        $scope.$broadcast("show-menu", {
                            "originalEvent": event
                        });
                    }
                };
                $scope.hideMenu = function(broadcastTrigger) {
                    $scope.menuShown = false;
                    if (!broadcastTrigger) {
                        $scope.$broadcast("hide-menu");
                    }
                };
                $scope.$on("menu-hidden", function() {
                    if ($scope.hideThenShow) {
                        delete $scope.hideThenShow;
                        uiGridColumnMenuService.repositionMenu($scope, $scope.col, $scope.colElementPosition, $elm, $scope.colElement);
                        $scope.$broadcast("show-menu");
                        $scope.menuShown = true;
                    } else {
                        $scope.hideMenu(true);
                        if ($scope.col) {
                            gridUtil.focus.bySelector($document, ".ui-grid-header-cell." + $scope.col.getColClass() + " .ui-grid-column-menu-button", $scope.col.grid, false);
                        }
                    }
                });
                $scope.$on("menu-shown", function() {
                    $timeout(function() {
                        uiGridColumnMenuService.repositionMenu($scope, $scope.col, $scope.colElementPosition, $elm, $scope.colElement);
                        gridUtil.focus.bySelector($document, ".ui-grid-menu-items .ui-grid-menu-item", true);
                        delete $scope.colElementPosition;
                        delete $scope.columnElement;
                    }, 200);
                });
                $scope.sortColumn = function(event, dir) {
                    event.stopPropagation();
                    $scope.grid.sortColumn($scope.col, dir, true).then(function() {
                        $scope.grid.refresh();
                        $scope.hideMenu();
                    });
                };
                $scope.unsortColumn = function() {
                    $scope.col.unsort();
                    $scope.grid.refresh();
                    $scope.hideMenu();
                };
                var setFocusOnHideColumn = function() {
                    $timeout(function() {
                        var focusToGridMenu = function() {
                            return gridUtil.focus.byId("grid-menu", $scope.grid);
                        };
                        var thisIndex;
                        $scope.grid.columns.some(function(element, index) {
                            if (angular.equals(element, $scope.col)) {
                                thisIndex = index;
                                return true;
                            }
                        });
                        var previousVisibleCol;
                        $scope.grid.columns.some(function(element, index) {
                            if (!element.visible) {
                                return false;
                            } else if (index < thisIndex) {
                                previousVisibleCol = element;
                            } else if (index > thisIndex && !previousVisibleCol) {
                                previousVisibleCol = element;
                                return true;
                            } else if (index > thisIndex && previousVisibleCol) {
                                return true;
                            }
                        });
                        if (previousVisibleCol) {
                            var colClass = previousVisibleCol.getColClass();
                            gridUtil.focus.bySelector($document, ".ui-grid-header-cell." + colClass + " .ui-grid-header-cell-primary-focus", true).then(angular.noop, function(reason) {
                                if (reason !== "canceled") {
                                    return focusToGridMenu();
                                }
                            });
                        } else {
                            focusToGridMenu();
                        }
                    });
                };
                $scope.hideColumn = function() {
                    $scope.col.colDef.visible = false;
                    $scope.col.visible = false;
                    $scope.grid.queueGridRefresh();
                    $scope.hideMenu();
                    $scope.grid.api.core.notifyDataChange(uiGridConstants.dataChange.COLUMN);
                    $scope.grid.api.core.raise.columnVisibilityChanged($scope.col);
                    setFocusOnHideColumn();
                };
            },
            "controller": [ "$scope", function($scope) {
                var self = this;
                $scope.$watch("menuItems", function(n) {
                    self.menuItems = n;
                });
            } ]
        };
        return uiGridColumnMenu;
    } ]);
})();

(function() {
    "use strict";
    angular.module("ui.grid").directive("uiGridFilter", [ "$compile", "$templateCache", "i18nService", "gridUtil", function($compile, $templateCache, i18nService, gridUtil) {
        return {
            "compile": function() {
                return {
                    "pre": function($scope, $elm, $attrs, controllers) {
                        $scope.col.updateFilters = function(filterable) {
                            $elm.children().remove();
                            if (filterable) {
                                var template = $scope.col.filterHeaderTemplate;
                                $elm.append($compile(template)($scope));
                            }
                        };
                        $scope.$on("$destroy", function() {
                            delete $scope.col.updateFilters;
                        });
                    },
                    "post": function($scope, $elm, $attrs, controllers) {
                        $scope.aria = i18nService.getSafeText("headerCell.aria");
                        $scope.removeFilter = function(colFilter, index) {
                            colFilter.term = null;
                            gridUtil.focus.bySelector($elm, ".ui-grid-filter-input-" + index);
                        };
                    }
                };
            }
        };
    } ]);
})();

(function() {
    "use strict";
    angular.module("ui.grid").directive("uiGridFooterCell", [ "$timeout", "gridUtil", "uiGridConstants", "$compile", function($timeout, gridUtil, uiGridConstants, $compile) {
        var uiGridFooterCell = {
            "priority": 0,
            "scope": {
                "col": "=",
                "row": "=",
                "renderIndex": "="
            },
            "replace": true,
            "require": "^uiGrid",
            "compile": function compile(tElement, tAttrs, transclude) {
                return {
                    "pre": function($scope, $elm, $attrs, uiGridCtrl) {
                        var cellFooter = $compile($scope.col.footerCellTemplate)($scope);
                        $elm.append(cellFooter);
                    },
                    "post": function($scope, $elm, $attrs, uiGridCtrl) {
                        $scope.grid = uiGridCtrl.grid;
                        var initColClass = $scope.col.getColClass(false);
                        $elm.addClass(initColClass);
                        var classAdded;
                        var updateClass = function(grid) {
                            var contents = $elm;
                            if (classAdded) {
                                contents.removeClass(classAdded);
                                classAdded = null;
                            }
                            if (angular.isFunction($scope.col.footerCellClass)) {
                                classAdded = $scope.col.footerCellClass($scope.grid, $scope.row, $scope.col, $scope.rowRenderIndex, $scope.colRenderIndex);
                            } else {
                                classAdded = $scope.col.footerCellClass;
                            }
                            contents.addClass(classAdded);
                        };
                        if ($scope.col.footerCellClass) {
                            updateClass();
                        }
                        $scope.col.updateAggregationValue();
                        var dataChangeDereg = $scope.grid.registerDataChangeCallback(updateClass, [ uiGridConstants.dataChange.COLUMN ]);
                        $scope.grid.api.core.on.rowsRendered($scope, $scope.col.updateAggregationValue);
                        $scope.grid.api.core.on.rowsRendered($scope, updateClass);
                        $scope.$on("$destroy", dataChangeDereg);
                    }
                };
            }
        };
        return uiGridFooterCell;
    } ]);
})();

(function() {
    "use strict";
    angular.module("ui.grid").directive("uiGridFooter", [ "$templateCache", "$compile", "uiGridConstants", "gridUtil", "$timeout", function($templateCache, $compile, uiGridConstants, gridUtil, $timeout) {
        return {
            "restrict": "EA",
            "replace": true,
            "require": [ "^uiGrid", "^uiGridRenderContainer" ],
            "scope": true,
            "compile": function($elm, $attrs) {
                return {
                    "pre": function($scope, $elm, $attrs, controllers) {
                        var uiGridCtrl = controllers[0];
                        var containerCtrl = controllers[1];
                        $scope.grid = uiGridCtrl.grid;
                        $scope.colContainer = containerCtrl.colContainer;
                        containerCtrl.footer = $elm;
                        var footerTemplate = $scope.grid.options.footerTemplate;
                        gridUtil.getTemplate(footerTemplate).then(function(contents) {
                            var template = angular.element(contents);
                            var newElm = $compile(template)($scope);
                            $elm.append(newElm);
                            if (containerCtrl) {
                                var footerViewport = $elm[0].getElementsByClassName("ui-grid-footer-viewport")[0];
                                if (footerViewport) {
                                    containerCtrl.footerViewport = footerViewport;
                                }
                            }
                        });
                    },
                    "post": function($scope, $elm, $attrs, controllers) {
                        var uiGridCtrl = controllers[0];
                        var containerCtrl = controllers[1];
                        var grid = uiGridCtrl.grid;
                        gridUtil.disableAnimations($elm);
                        containerCtrl.footer = $elm;
                        var footerViewport = $elm[0].getElementsByClassName("ui-grid-footer-viewport")[0];
                        if (footerViewport) {
                            containerCtrl.footerViewport = footerViewport;
                        }
                    }
                };
            }
        };
    } ]);
})();

(function() {
    "use strict";
    angular.module("ui.grid").directive("uiGridGridFooter", [ "$templateCache", "$compile", "uiGridConstants", "gridUtil", "$timeout", function($templateCache, $compile, uiGridConstants, gridUtil, $timeout) {
        return {
            "restrict": "EA",
            "replace": true,
            "require": "^uiGrid",
            "scope": true,
            "compile": function($elm, $attrs) {
                return {
                    "pre": function($scope, $elm, $attrs, uiGridCtrl) {
                        $scope.grid = uiGridCtrl.grid;
                        var footerTemplate = $scope.grid.options.gridFooterTemplate;
                        gridUtil.getTemplate(footerTemplate).then(function(contents) {
                            var template = angular.element(contents);
                            var newElm = $compile(template)($scope);
                            $elm.append(newElm);
                        });
                    },
                    "post": function($scope, $elm, $attrs, controllers) {}
                };
            }
        };
    } ]);
})();

(function() {
    "use strict";
    angular.module("ui.grid").directive("uiGridGroupPanel", [ "$compile", "uiGridConstants", "gridUtil", function($compile, uiGridConstants, gridUtil) {
        var defaultTemplate = "ui-grid/ui-grid-group-panel";
        return {
            "restrict": "EA",
            "replace": true,
            "require": "?^uiGrid",
            "scope": false,
            "compile": function($elm, $attrs) {
                return {
                    "pre": function($scope, $elm, $attrs, uiGridCtrl) {
                        var groupPanelTemplate = $scope.grid.options.groupPanelTemplate || defaultTemplate;
                        gridUtil.getTemplate(groupPanelTemplate).then(function(contents) {
                            var template = angular.element(contents);
                            var newElm = $compile(template)($scope);
                            $elm.append(newElm);
                        });
                    },
                    "post": function($scope, $elm, $attrs, uiGridCtrl) {
                        $elm.bind("$destroy", function() {});
                    }
                };
            }
        };
    } ]);
})();

(function() {
    "use strict";
    angular.module("ui.grid").directive("uiGridHeaderCell", [ "$compile", "$timeout", "$window", "$document", "gridUtil", "uiGridConstants", "ScrollEvent", "i18nService", function($compile, $timeout, $window, $document, gridUtil, uiGridConstants, ScrollEvent, i18nService) {
        var mousedownTimeout = 500;
        var changeModeTimeout = 500;
        var uiGridHeaderCell = {
            "priority": 0,
            "scope": {
                "col": "=",
                "row": "=",
                "renderIndex": "="
            },
            "require": [ "^uiGrid", "^uiGridRenderContainer" ],
            "replace": true,
            "compile": function() {
                return {
                    "pre": function($scope, $elm, $attrs) {
                        var cellHeader = $compile($scope.col.headerCellTemplate)($scope);
                        $elm.append(cellHeader);
                    },
                    "post": function($scope, $elm, $attrs, controllers) {
                        var uiGridCtrl = controllers[0];
                        var renderContainerCtrl = controllers[1];
                        $scope.i18n = {
                            "headerCell": i18nService.getSafeText("headerCell"),
                            "sort": i18nService.getSafeText("sort")
                        };
                        $scope.isSortPriorityVisible = function() {
                            return angular.isNumber($scope.col.sort.priority) && $scope.grid.columns.some(function(element, index) {
                                return angular.isNumber(element.sort.priority) && element !== $scope.col;
                            });
                        };
                        $scope.getSortDirectionAriaLabel = function() {
                            var col = $scope.col;
                            var sortDirectionText = col.sort.direction === uiGridConstants.ASC ? $scope.i18n.sort.ascending : col.sort.direction === uiGridConstants.DESC ? $scope.i18n.sort.descending : $scope.i18n.sort.none;
                            var label = sortDirectionText;
                            if ($scope.isSortPriorityVisible()) {
                                label = label + ". " + $scope.i18n.headerCell.priority + " " + col.sort.priority;
                            }
                            return label;
                        };
                        $scope.grid = uiGridCtrl.grid;
                        $scope.renderContainer = uiGridCtrl.grid.renderContainers[renderContainerCtrl.containerId];
                        var initColClass = $scope.col.getColClass(false);
                        $elm.addClass(initColClass);
                        $scope.menuShown = false;
                        $scope.asc = uiGridConstants.ASC;
                        $scope.desc = uiGridConstants.DESC;
                        var $colMenu = angular.element($elm[0].querySelectorAll(".ui-grid-header-cell-menu"));
                        var $contentsElm = angular.element($elm[0].querySelectorAll(".ui-grid-cell-contents"));
                        var classAdded;
                        var previousMouseX;
                        var filterDeregisters = [];
                        $scope.downFn = function(event) {
                            event.stopPropagation();
                            if (typeof event.originalEvent !== "undefined" && event.originalEvent !== undefined) {
                                event = event.originalEvent;
                            }
                            if (event.button && event.button !== 0) {
                                return;
                            }
                            previousMouseX = event.pageX;
                            $scope.mousedownStartTime = new Date().getTime();
                            $scope.mousedownTimeout = $timeout(function() {}, mousedownTimeout);
                            $scope.mousedownTimeout.then(function() {
                                if ($scope.colMenu) {
                                    uiGridCtrl.columnMenuScope.showMenu($scope.col, $elm, event);
                                }
                            });
                            uiGridCtrl.fireEvent(uiGridConstants.events.COLUMN_HEADER_CLICK, {
                                "event": event,
                                "columnName": $scope.col.colDef.name
                            });
                            $scope.offAllEvents();
                            if (event.type === "touchstart") {
                                $document.on("touchend", $scope.upFn);
                                $document.on("touchmove", $scope.moveFn);
                            } else if (event.type === "mousedown") {
                                $document.on("mouseup", $scope.upFn);
                                $document.on("mousemove", $scope.moveFn);
                            }
                        };
                        $scope.upFn = function(event) {
                            event.stopPropagation();
                            $timeout.cancel($scope.mousedownTimeout);
                            $scope.offAllEvents();
                            $scope.onDownEvents(event.type);
                            var mousedownEndTime = new Date().getTime();
                            var mousedownTime = mousedownEndTime - $scope.mousedownStartTime;
                            if (mousedownTime > mousedownTimeout) {} else {
                                if ($scope.sortable) {
                                    $scope.handleClick(event);
                                }
                            }
                        };
                        $scope.moveFn = function(event) {
                            var changeValue = event.pageX - previousMouseX;
                            if (changeValue === 0) {
                                return;
                            }
                            $timeout.cancel($scope.mousedownTimeout);
                            $scope.offAllEvents();
                            $scope.onDownEvents(event.type);
                        };
                        $scope.clickFn = function(event) {
                            event.stopPropagation();
                            $contentsElm.off("click", $scope.clickFn);
                        };
                        $scope.offAllEvents = function() {
                            $contentsElm.off("touchstart", $scope.downFn);
                            $contentsElm.off("mousedown", $scope.downFn);
                            $document.off("touchend", $scope.upFn);
                            $document.off("mouseup", $scope.upFn);
                            $document.off("touchmove", $scope.moveFn);
                            $document.off("mousemove", $scope.moveFn);
                            $contentsElm.off("click", $scope.clickFn);
                        };
                        $scope.onDownEvents = function(type) {
                            switch (type) {
                              case "touchmove":
                              case "touchend":
                                $contentsElm.on("click", $scope.clickFn);
                                $contentsElm.on("touchstart", $scope.downFn);
                                $timeout(function() {
                                    $contentsElm.on("mousedown", $scope.downFn);
                                }, changeModeTimeout);
                                break;

                              case "mousemove":
                              case "mouseup":
                                $contentsElm.on("click", $scope.clickFn);
                                $contentsElm.on("mousedown", $scope.downFn);
                                $timeout(function() {
                                    $contentsElm.on("touchstart", $scope.downFn);
                                }, changeModeTimeout);
                                break;

                              default:
                                $contentsElm.on("click", $scope.clickFn);
                                $contentsElm.on("touchstart", $scope.downFn);
                                $contentsElm.on("mousedown", $scope.downFn);
                            }
                        };
                        var updateHeaderOptions = function(grid) {
                            var contents = $elm;
                            if (classAdded) {
                                contents.removeClass(classAdded);
                                classAdded = null;
                            }
                            if (angular.isFunction($scope.col.headerCellClass)) {
                                classAdded = $scope.col.headerCellClass($scope.grid, $scope.row, $scope.col, $scope.rowRenderIndex, $scope.colRenderIndex);
                            } else {
                                classAdded = $scope.col.headerCellClass;
                            }
                            contents.addClass(classAdded);
                            $timeout(function() {
                                var rightMostContainer = $scope.grid.renderContainers["right"] ? $scope.grid.renderContainers["right"] : $scope.grid.renderContainers["body"];
                                $scope.isLastCol = $scope.col === rightMostContainer.visibleColumnCache[rightMostContainer.visibleColumnCache.length - 1];
                            });
                            if (uiGridCtrl.grid.options.enableSorting && $scope.col.enableSorting) {
                                $scope.sortable = true;
                            } else {
                                $scope.sortable = false;
                            }
                            var oldFilterable = $scope.filterable;
                            if (uiGridCtrl.grid.options.enableFiltering && $scope.col.enableFiltering) {
                                $scope.filterable = true;
                            } else {
                                $scope.filterable = false;
                            }
                            if (oldFilterable !== $scope.filterable) {
                                if (typeof $scope.col.updateFilters !== "undefined") {
                                    $scope.col.updateFilters($scope.filterable);
                                }
                                if ($scope.filterable) {
                                    $scope.col.filters.forEach(function(filter, i) {
                                        filterDeregisters.push($scope.$watch("col.filters[" + i + "].term", function(n, o) {
                                            if (n !== o) {
                                                uiGridCtrl.grid.api.core.raise.filterChanged();
                                                uiGridCtrl.grid.api.core.notifyDataChange(uiGridConstants.dataChange.COLUMN);
                                                uiGridCtrl.grid.queueGridRefresh();
                                            }
                                        }));
                                    });
                                    $scope.$on("$destroy", function() {
                                        filterDeregisters.forEach(function(filterDeregister) {
                                            filterDeregister();
                                        });
                                    });
                                } else {
                                    filterDeregisters.forEach(function(filterDeregister) {
                                        filterDeregister();
                                    });
                                }
                            }
                            if ($scope.col.grid.options && $scope.col.grid.options.enableColumnMenus !== false && $scope.col.colDef && $scope.col.colDef.enableColumnMenu !== false) {
                                $scope.colMenu = true;
                            } else {
                                $scope.colMenu = false;
                            }
                            $scope.offAllEvents();
                            if ($scope.sortable || $scope.colMenu) {
                                $scope.onDownEvents();
                                $scope.$on("$destroy", function() {
                                    $scope.offAllEvents();
                                });
                            }
                        };
                        updateHeaderOptions();
                        var dataChangeDereg = $scope.grid.registerDataChangeCallback(updateHeaderOptions, [ uiGridConstants.dataChange.COLUMN ]);
                        $scope.$on("$destroy", dataChangeDereg);
                        $scope.handleClick = function(event) {
                            var add = false;
                            if (event.shiftKey) {
                                add = true;
                            }
                            uiGridCtrl.grid.sortColumn($scope.col, add).then(function() {
                                if (uiGridCtrl.columnMenuScope) {
                                    uiGridCtrl.columnMenuScope.hideMenu();
                                }
                                uiGridCtrl.grid.refresh();
                            });
                        };
                        $scope.toggleMenu = function(event) {
                            event.stopPropagation();
                            if (uiGridCtrl.columnMenuScope.menuShown) {
                                if (uiGridCtrl.columnMenuScope.col === $scope.col) {
                                    uiGridCtrl.columnMenuScope.hideMenu();
                                } else {
                                    uiGridCtrl.columnMenuScope.showMenu($scope.col, $elm);
                                }
                            } else {
                                uiGridCtrl.columnMenuScope.showMenu($scope.col, $elm);
                            }
                        };
                    }
                };
            }
        };
        return uiGridHeaderCell;
    } ]);
})();

(function() {
    "use strict";
    angular.module("ui.grid").directive("uiGridHeader", [ "$templateCache", "$compile", "uiGridConstants", "gridUtil", "$timeout", "ScrollEvent", function($templateCache, $compile, uiGridConstants, gridUtil, $timeout, ScrollEvent) {
        var defaultTemplate = "ui-grid/ui-grid-header";
        var emptyTemplate = "ui-grid/ui-grid-no-header";
        return {
            "restrict": "EA",
            "replace": true,
            "require": [ "^uiGrid", "^uiGridRenderContainer" ],
            "scope": true,
            "compile": function($elm, $attrs) {
                return {
                    "pre": function($scope, $elm, $attrs, controllers) {
                        var uiGridCtrl = controllers[0];
                        var containerCtrl = controllers[1];
                        $scope.grid = uiGridCtrl.grid;
                        $scope.colContainer = containerCtrl.colContainer;
                        updateHeaderReferences();
                        var headerTemplate;
                        if (!$scope.grid.options.showHeader) {
                            headerTemplate = emptyTemplate;
                        } else {
                            headerTemplate = $scope.grid.options.headerTemplate ? $scope.grid.options.headerTemplate : defaultTemplate;
                        }
                        gridUtil.getTemplate(headerTemplate).then(function(contents) {
                            var template = angular.element(contents);
                            var newElm = $compile(template)($scope);
                            $elm.replaceWith(newElm);
                            $elm = newElm;
                            updateHeaderReferences();
                            if (containerCtrl) {
                                var headerViewport = $elm[0].getElementsByClassName("ui-grid-header-viewport")[0];
                                if (headerViewport) {
                                    containerCtrl.headerViewport = headerViewport;
                                    angular.element(headerViewport).on("scroll", scrollHandler);
                                    $scope.$on("$destroy", function() {
                                        angular.element(headerViewport).off("scroll", scrollHandler);
                                    });
                                }
                            }
                            $scope.grid.queueRefresh();
                        });
                        function updateHeaderReferences() {
                            containerCtrl.header = containerCtrl.colContainer.header = $elm;
                            var headerCanvases = $elm[0].getElementsByClassName("ui-grid-header-canvas");
                            if (headerCanvases.length > 0) {
                                containerCtrl.headerCanvas = containerCtrl.colContainer.headerCanvas = headerCanvases[0];
                            } else {
                                containerCtrl.headerCanvas = null;
                            }
                        }
                        function scrollHandler(evt) {
                            if (uiGridCtrl.grid.isScrollingHorizontally) {
                                return;
                            }
                            var newScrollLeft = gridUtil.normalizeScrollLeft(containerCtrl.headerViewport, uiGridCtrl.grid);
                            var horizScrollPercentage = containerCtrl.colContainer.scrollHorizontal(newScrollLeft);
                            var scrollEvent = new ScrollEvent(uiGridCtrl.grid, null, containerCtrl.colContainer, ScrollEvent.Sources.ViewPortScroll);
                            scrollEvent.newScrollLeft = newScrollLeft;
                            if (horizScrollPercentage > -1) {
                                scrollEvent.x = {
                                    "percentage": horizScrollPercentage
                                };
                            }
                            uiGridCtrl.grid.scrollContainers(null, scrollEvent);
                        }
                    },
                    "post": function($scope, $elm, $attrs, controllers) {
                        var uiGridCtrl = controllers[0];
                        var containerCtrl = controllers[1];
                        var grid = uiGridCtrl.grid;
                        gridUtil.disableAnimations($elm);
                        function updateColumnWidths() {
                            var columnCache = containerCtrl.colContainer.visibleColumnCache;
                            var ret = "";
                            var canvasWidth = 0;
                            columnCache.forEach(function(column) {
                                ret = ret + column.getColClassDefinition();
                                canvasWidth += column.drawnWidth;
                            });
                            containerCtrl.colContainer.canvasWidth = canvasWidth;
                            return ret;
                        }
                        containerCtrl.header = $elm;
                        var headerViewport = $elm[0].getElementsByClassName("ui-grid-header-viewport")[0];
                        if (headerViewport) {
                            containerCtrl.headerViewport = headerViewport;
                        }
                        if (uiGridCtrl) {
                            uiGridCtrl.grid.registerStyleComputation({
                                "priority": 15,
                                "func": updateColumnWidths
                            });
                        }
                    }
                };
            }
        };
    } ]);
})();

(function() {
    angular.module("ui.grid").service("uiGridGridMenuService", [ "gridUtil", "i18nService", "uiGridConstants", function(gridUtil, i18nService, uiGridConstants) {
        var service = {
            "initialize": function($scope, grid) {
                grid.gridMenuScope = $scope;
                $scope.grid = grid;
                $scope.registeredMenuItems = [];
                $scope.$on("$destroy", function() {
                    if ($scope.grid && $scope.grid.gridMenuScope) {
                        $scope.grid.gridMenuScope = null;
                    }
                    if ($scope.grid) {
                        $scope.grid = null;
                    }
                    if ($scope.registeredMenuItems) {
                        $scope.registeredMenuItems = null;
                    }
                });
                $scope.registeredMenuItems = [];
                grid.api.registerMethod("core", "addToGridMenu", service.addToGridMenu);
                grid.api.registerMethod("core", "removeFromGridMenu", service.removeFromGridMenu);
            },
            "addToGridMenu": function(grid, menuItems) {
                if (!angular.isArray(menuItems)) {
                    gridUtil.logError("addToGridMenu: menuItems must be an array, and is not, not adding any items");
                } else {
                    if (grid.gridMenuScope) {
                        grid.gridMenuScope.registeredMenuItems = grid.gridMenuScope.registeredMenuItems ? grid.gridMenuScope.registeredMenuItems : [];
                        grid.gridMenuScope.registeredMenuItems = grid.gridMenuScope.registeredMenuItems.concat(menuItems);
                    } else {
                        gridUtil.logError("Asked to addToGridMenu, but gridMenuScope not present.  Timing issue?  Please log issue with ui-grid");
                    }
                }
            },
            "removeFromGridMenu": function(grid, id) {
                var foundIndex = -1;
                if (grid && grid.gridMenuScope) {
                    grid.gridMenuScope.registeredMenuItems.forEach(function(value, index) {
                        if (value.id === id) {
                            if (foundIndex > -1) {
                                gridUtil.logError("removeFromGridMenu: found multiple items with the same id, removing only the last");
                            } else {
                                foundIndex = index;
                            }
                        }
                    });
                }
                if (foundIndex > -1) {
                    grid.gridMenuScope.registeredMenuItems.splice(foundIndex, 1);
                }
            },
            "getMenuItems": function($scope) {
                var menuItems = [];
                if ($scope.grid.options.gridMenuCustomItems) {
                    if (!angular.isArray($scope.grid.options.gridMenuCustomItems)) {
                        gridUtil.logError("gridOptions.gridMenuCustomItems must be an array, and is not");
                    } else {
                        menuItems = menuItems.concat($scope.grid.options.gridMenuCustomItems);
                    }
                }
                var clearFilters = [ {
                    "title": i18nService.getSafeText("gridMenu.clearAllFilters"),
                    "action": function($event) {
                        $scope.grid.clearAllFilters(undefined, true, undefined);
                    },
                    "shown": function() {
                        return $scope.grid.options.enableFiltering;
                    },
                    "order": 100
                } ];
                menuItems = menuItems.concat(clearFilters);
                menuItems = menuItems.concat($scope.registeredMenuItems);
                if ($scope.grid.options.gridMenuShowHideColumns !== false) {
                    menuItems = menuItems.concat(service.showHideColumns($scope));
                }
                menuItems.sort(function(a, b) {
                    return a.order - b.order;
                });
                return menuItems;
            },
            "showHideColumns": function($scope) {
                var showHideColumns = [];
                if (!$scope.grid.options.columnDefs || $scope.grid.options.columnDefs.length === 0 || $scope.grid.columns.length === 0) {
                    return showHideColumns;
                }
                showHideColumns.push({
                    "title": i18nService.getSafeText("gridMenu.columns"),
                    "order": 300
                });
                $scope.grid.options.gridMenuTitleFilter = $scope.grid.options.gridMenuTitleFilter ? $scope.grid.options.gridMenuTitleFilter : function(title) {
                    return title;
                };
                $scope.grid.options.columnDefs.forEach(function(colDef, index) {
                    if (colDef.enableHiding !== false) {
                        var menuItem = {
                            "icon": "ui-grid-icon-ok",
                            "action": function($event) {
                                $event.stopPropagation();
                                service.toggleColumnVisibility(this.context.gridCol);
                            },
                            "shown": function() {
                                return this.context.gridCol.colDef.visible === true || this.context.gridCol.colDef.visible === undefined;
                            },
                            "context": {
                                "gridCol": $scope.grid.getColumn(colDef.name || colDef.field)
                            },
                            "leaveOpen": true,
                            "order": 301 + index * 2
                        };
                        service.setMenuItemTitle(menuItem, colDef, $scope.grid);
                        showHideColumns.push(menuItem);
                        menuItem = {
                            "icon": "ui-grid-icon-cancel",
                            "action": function($event) {
                                $event.stopPropagation();
                                service.toggleColumnVisibility(this.context.gridCol);
                            },
                            "shown": function() {
                                return !(this.context.gridCol.colDef.visible === true || this.context.gridCol.colDef.visible === undefined);
                            },
                            "context": {
                                "gridCol": $scope.grid.getColumn(colDef.name || colDef.field)
                            },
                            "leaveOpen": true,
                            "order": 301 + index * 2 + 1
                        };
                        service.setMenuItemTitle(menuItem, colDef, $scope.grid);
                        showHideColumns.push(menuItem);
                    }
                });
                return showHideColumns;
            },
            "setMenuItemTitle": function(menuItem, colDef, grid) {
                var title = grid.options.gridMenuTitleFilter(colDef.displayName || gridUtil.readableColumnName(colDef.name) || colDef.field);
                if (typeof title === "string") {
                    menuItem.title = title;
                } else if (title.then) {
                    menuItem.title = "";
                    title.then(function(successValue) {
                        menuItem.title = successValue;
                    }, function(errorValue) {
                        menuItem.title = errorValue;
                    });
                } else {
                    gridUtil.logError("Expected gridMenuTitleFilter to return a string or a promise, it has returned neither, bad config");
                    menuItem.title = "badconfig";
                }
            },
            "toggleColumnVisibility": function(gridCol) {
                gridCol.colDef.visible = !(gridCol.colDef.visible === true || gridCol.colDef.visible === undefined);
                gridCol.grid.refresh();
                gridCol.grid.api.core.notifyDataChange(uiGridConstants.dataChange.COLUMN);
                gridCol.grid.api.core.raise.columnVisibilityChanged(gridCol);
            }
        };
        return service;
    } ]).directive("uiGridMenuButton", [ "gridUtil", "uiGridConstants", "uiGridGridMenuService", "i18nService", function(gridUtil, uiGridConstants, uiGridGridMenuService, i18nService) {
        return {
            "priority": 0,
            "scope": true,
            "require": [ "^uiGrid" ],
            "templateUrl": "ui-grid/ui-grid-menu-button",
            "replace": true,
            "link": function($scope, $elm, $attrs, controllers) {
                var uiGridCtrl = controllers[0];
                $scope.i18n = {
                    "aria": i18nService.getSafeText("gridMenu.aria")
                };
                uiGridGridMenuService.initialize($scope, uiGridCtrl.grid);
                $scope.shown = false;
                $scope.toggleMenu = function() {
                    if ($scope.shown) {
                        $scope.$broadcast("hide-menu");
                        $scope.shown = false;
                    } else {
                        $scope.menuItems = uiGridGridMenuService.getMenuItems($scope);
                        $scope.$broadcast("show-menu");
                        $scope.shown = true;
                    }
                };
                $scope.$on("menu-hidden", function() {
                    $scope.shown = false;
                    gridUtil.focus.bySelector($elm, ".ui-grid-icon-container");
                });
            }
        };
    } ]);
})();

(function() {
    angular.module("ui.grid").directive("uiGridMenu", [ "$compile", "$timeout", "$window", "$document", "gridUtil", "uiGridConstants", "i18nService", function($compile, $timeout, $window, $document, gridUtil, uiGridConstants, i18nService) {
        var uiGridMenu = {
            "priority": 0,
            "scope": {
                "menuItems": "=",
                "autoHide": "=?"
            },
            "require": "?^uiGrid",
            "templateUrl": "ui-grid/uiGridMenu",
            "replace": false,
            "link": function($scope, $elm, $attrs, uiGridCtrl) {
                var gridMenuMaxHeight;
                $scope.dynamicStyles = "";
                if (uiGridCtrl) {
                    gridMenuMaxHeight = uiGridCtrl.grid.gridHeight - 30;
                    $scope.dynamicStyles = [ ".grid" + uiGridCtrl.grid.id + " .ui-grid-menu-mid {", "max-height: " + gridMenuMaxHeight + "px;", "}" ].join(" ");
                }
                $scope.i18n = {
                    "close": i18nService.getSafeText("columnMenu.close")
                };
                $scope.showMenu = function(event, args) {
                    if (!$scope.shown) {
                        $scope.shown = true;
                        $timeout(function() {
                            $scope.shownMid = true;
                            $scope.$emit("menu-shown");
                        });
                    } else if (!$scope.shownMid) {
                        $scope.shownMid = true;
                        $scope.$emit("menu-shown");
                    }
                    var docEventType = "click";
                    if (args && args.originalEvent && args.originalEvent.type && args.originalEvent.type === "touchstart") {
                        docEventType = args.originalEvent.type;
                    }
                    angular.element(document).off("click touchstart", applyHideMenu);
                    $elm.off("keyup", checkKeyUp);
                    $elm.off("keydown", checkKeyDown);
                    $timeout(function() {
                        angular.element(document).on(docEventType, applyHideMenu);
                        $elm.on("keyup", checkKeyUp);
                        $elm.on("keydown", checkKeyDown);
                    });
                    gridUtil.focus.bySelector($elm, "button[type=button]", true);
                };
                $scope.hideMenu = function(event) {
                    if ($scope.shown) {
                        $scope.shownMid = false;
                        $timeout(function() {
                            if (!$scope.shownMid) {
                                $scope.shown = false;
                                $scope.$emit("menu-hidden");
                            }
                        }, 200);
                    }
                    angular.element(document).off("click touchstart", applyHideMenu);
                    $elm.off("keyup", checkKeyUp);
                    $elm.off("keydown", checkKeyDown);
                };
                $scope.$on("hide-menu", function(event, args) {
                    $scope.hideMenu(event, args);
                });
                $scope.$on("show-menu", function(event, args) {
                    $scope.showMenu(event, args);
                });
                var applyHideMenu = function() {
                    if ($scope.shown) {
                        $scope.$apply(function() {
                            $scope.hideMenu();
                        });
                    }
                };
                var checkKeyUp = function(event) {
                    if (event.keyCode === 27) {
                        $scope.hideMenu();
                    }
                };
                var checkKeyDown = function(event) {
                    var setFocus = function(elm) {
                        elm.focus();
                        event.preventDefault();
                        return false;
                    };
                    if (event.keyCode === 9) {
                        var firstMenuItem, lastMenuItem;
                        var menuItemButtons = $elm[0].querySelectorAll("button:not(.ng-hide)");
                        if (menuItemButtons.length > 0) {
                            firstMenuItem = menuItemButtons[0];
                            lastMenuItem = menuItemButtons[menuItemButtons.length - 1];
                            if (event.target === lastMenuItem && !event.shiftKey) {
                                setFocus(firstMenuItem);
                            } else if (event.target === firstMenuItem && event.shiftKey) {
                                setFocus(lastMenuItem);
                            }
                        }
                    }
                };
                if (typeof $scope.autoHide === "undefined" || $scope.autoHide === undefined) {
                    $scope.autoHide = true;
                }
                if ($scope.autoHide) {
                    angular.element($window).on("resize", applyHideMenu);
                }
                $scope.$on("$destroy", function() {
                    angular.element(document).off("click touchstart", applyHideMenu);
                });
                $scope.$on("$destroy", function() {
                    angular.element($window).off("resize", applyHideMenu);
                });
                if (uiGridCtrl) {
                    $scope.$on("$destroy", uiGridCtrl.grid.api.core.on.scrollBegin($scope, applyHideMenu));
                }
                $scope.$on("$destroy", $scope.$on(uiGridConstants.events.ITEM_DRAGGING, applyHideMenu));
            }
        };
        return uiGridMenu;
    } ]).directive("uiGridMenuItem", [ "gridUtil", "$compile", "i18nService", function(gridUtil, $compile, i18nService) {
        var uiGridMenuItem = {
            "priority": 0,
            "scope": {
                "name": "=",
                "active": "=",
                "action": "=",
                "icon": "=",
                "shown": "=",
                "context": "=",
                "templateUrl": "=",
                "leaveOpen": "=",
                "screenReaderOnly": "="
            },
            "require": [ "?^uiGrid" ],
            "templateUrl": "ui-grid/uiGridMenuItem",
            "replace": false,
            "compile": function() {
                return {
                    "pre": function($scope, $elm) {
                        if ($scope.templateUrl) {
                            gridUtil.getTemplate($scope.templateUrl).then(function(contents) {
                                var template = angular.element(contents);
                                var newElm = $compile(template)($scope);
                                $elm.replaceWith(newElm);
                            });
                        }
                    },
                    "post": function($scope, $elm, $attrs, controllers) {
                        var uiGridCtrl = controllers[0];
                        if (typeof $scope.shown === "undefined" || $scope.shown === null) {
                            $scope.shown = function() {
                                return true;
                            };
                        }
                        $scope.itemShown = function() {
                            var context = {};
                            if ($scope.context) {
                                context.context = $scope.context;
                            }
                            if (typeof uiGridCtrl !== "undefined" && uiGridCtrl) {
                                context.grid = uiGridCtrl.grid;
                            }
                            return $scope.shown.call(context);
                        };
                        $scope.itemAction = function($event, title) {
                            gridUtil.logDebug("itemAction");
                            $event.stopPropagation();
                            if (typeof $scope.action === "function") {
                                var context = {};
                                if ($scope.context) {
                                    context.context = $scope.context;
                                }
                                if (typeof uiGridCtrl !== "undefined" && uiGridCtrl) {
                                    context.grid = uiGridCtrl.grid;
                                }
                                $scope.action.call(context, $event, title);
                                if (!$scope.leaveOpen) {
                                    $scope.$emit("hide-menu");
                                } else {
                                    gridUtil.focus.bySelector(angular.element(gridUtil.closestElm($elm, ".ui-grid-menu-items")), "button[type=button]", true);
                                }
                            }
                        };
                        $scope.i18n = i18nService.get();
                    }
                };
            }
        };
        return uiGridMenuItem;
    } ]);
})();

(function() {
    "use strict";
    var oneBinders = angular.module("ui.grid");
    angular.forEach([ {
        "tag": "Src",
        "method": "attr"
    }, {
        "tag": "Text",
        "method": "text"
    }, {
        "tag": "Href",
        "method": "attr"
    }, {
        "tag": "Class",
        "method": "addClass"
    }, {
        "tag": "Html",
        "method": "html"
    }, {
        "tag": "Alt",
        "method": "attr"
    }, {
        "tag": "Style",
        "method": "css"
    }, {
        "tag": "Value",
        "method": "attr"
    }, {
        "tag": "Id",
        "method": "attr"
    }, {
        "tag": "Id",
        "directiveName": "IdGrid",
        "method": "attr",
        "appendGridId": true
    }, {
        "tag": "Title",
        "method": "attr"
    }, {
        "tag": "Label",
        "method": "attr",
        "aria": true
    }, {
        "tag": "Labelledby",
        "method": "attr",
        "aria": true
    }, {
        "tag": "Labelledby",
        "directiveName": "LabelledbyGrid",
        "appendGridId": true,
        "method": "attr",
        "aria": true
    }, {
        "tag": "Describedby",
        "method": "attr",
        "aria": true
    }, {
        "tag": "Describedby",
        "directiveName": "DescribedbyGrid",
        "appendGridId": true,
        "method": "attr",
        "aria": true
    } ], function(v) {
        var baseDirectiveName = "uiGridOneBind";
        var directiveName = (v.aria ? baseDirectiveName + "Aria" : baseDirectiveName) + (v.directiveName ? v.directiveName : v.tag);
        oneBinders.directive(directiveName, [ "gridUtil", function(gridUtil) {
            return {
                "restrict": "A",
                "require": [ "?uiGrid", "?^uiGrid" ],
                "link": function(scope, iElement, iAttrs, controllers) {
                    var appendGridId = function(val) {
                        var grid;
                        if (scope.grid) {
                            grid = scope.grid;
                        } else if (scope.col && scope.col.grid) {
                            grid = scope.col.grid;
                        } else if (!controllers.some(function(controller) {
                            if (controller && controller.grid) {
                                grid = controller.grid;
                                return true;
                            }
                        })) {
                            gridUtil.logError("[" + directiveName + "] A valid grid could not be found to bind id. Are you using this directive " + "within the correct scope? Trying to generate id: [gridID]-" + val);
                            throw new Error("No valid grid could be found");
                        }
                        if (grid) {
                            var idRegex = new RegExp(grid.id.toString());
                            if (!idRegex.test(val)) {
                                val = grid.id.toString() + "-" + val;
                            }
                        }
                        return val;
                    };
                    var rmWatcher = scope.$watch(iAttrs[directiveName], function(newV) {
                        if (newV) {
                            if (v.appendGridId) {
                                var newIdString = null;
                                angular.forEach(newV.split(" "), function(s) {
                                    newIdString = (newIdString ? newIdString + " " : "") + appendGridId(s);
                                });
                                newV = newIdString;
                            }
                            switch (v.method) {
                              case "attr":
                                if (v.aria) {
                                    iElement[v.method]("aria-" + v.tag.toLowerCase(), newV);
                                } else {
                                    iElement[v.method](v.tag.toLowerCase(), newV);
                                }
                                break;

                              case "addClass":
                                if (angular.isObject(newV) && !angular.isArray(newV)) {
                                    var results = [];
                                    var nonNullFound = false;
                                    angular.forEach(newV, function(value, index) {
                                        if (value !== null && typeof value !== "undefined") {
                                            nonNullFound = true;
                                            if (value) {
                                                results.push(index);
                                            }
                                        }
                                    });
                                    if (!nonNullFound) {
                                        return;
                                    }
                                    newV = results;
                                }
                                if (newV) {
                                    iElement.addClass(angular.isArray(newV) ? newV.join(" ") : newV);
                                } else {
                                    return;
                                }
                                break;

                              default:
                                iElement[v.method](newV);
                                break;
                            }
                            rmWatcher();
                        }
                    }, true);
                }
            };
        } ]);
    });
})();

(function() {
    "use strict";
    var module = angular.module("ui.grid");
    module.directive("uiGridRenderContainer", [ "$timeout", "$document", "uiGridConstants", "gridUtil", "ScrollEvent", function($timeout, $document, uiGridConstants, gridUtil, ScrollEvent) {
        return {
            "replace": true,
            "transclude": true,
            "templateUrl": "ui-grid/uiGridRenderContainer",
            "require": [ "^uiGrid", "uiGridRenderContainer" ],
            "scope": {
                "containerId": "=",
                "rowContainerName": "=",
                "colContainerName": "=",
                "bindScrollHorizontal": "=",
                "bindScrollVertical": "=",
                "enableVerticalScrollbar": "=",
                "enableHorizontalScrollbar": "="
            },
            "controller": "uiGridRenderContainer as RenderContainer",
            "compile": function() {
                return {
                    "pre": function prelink($scope, $elm, $attrs, controllers) {
                        var uiGridCtrl = controllers[0];
                        var containerCtrl = controllers[1];
                        var grid = $scope.grid = uiGridCtrl.grid;
                        if (!$scope.rowContainerName) {
                            throw "No row render container name specified";
                        }
                        if (!$scope.colContainerName) {
                            throw "No column render container name specified";
                        }
                        if (!grid.renderContainers[$scope.rowContainerName]) {
                            throw "Row render container '" + $scope.rowContainerName + "' is not registered.";
                        }
                        if (!grid.renderContainers[$scope.colContainerName]) {
                            throw "Column render container '" + $scope.colContainerName + "' is not registered.";
                        }
                        var rowContainer = $scope.rowContainer = grid.renderContainers[$scope.rowContainerName];
                        var colContainer = $scope.colContainer = grid.renderContainers[$scope.colContainerName];
                        containerCtrl.containerId = $scope.containerId;
                        containerCtrl.rowContainer = rowContainer;
                        containerCtrl.colContainer = colContainer;
                    },
                    "post": function postlink($scope, $elm, $attrs, controllers) {
                        var uiGridCtrl = controllers[0];
                        var containerCtrl = controllers[1];
                        var grid = uiGridCtrl.grid;
                        var rowContainer = containerCtrl.rowContainer;
                        var colContainer = containerCtrl.colContainer;
                        var scrollTop = null;
                        var scrollLeft = null;
                        var renderContainer = grid.renderContainers[$scope.containerId];
                        $elm.addClass("ui-grid-render-container-" + $scope.containerId);
                        gridUtil.on.mousewheel($elm, function(event) {
                            var scrollEvent = new ScrollEvent(grid, rowContainer, colContainer, ScrollEvent.Sources.RenderContainerMouseWheel);
                            if (event.deltaY !== 0) {
                                var scrollYAmount = event.deltaY * -1 * event.deltaFactor;
                                scrollTop = containerCtrl.viewport[0].scrollTop;
                                scrollEvent.verticalScrollLength = rowContainer.getVerticalScrollLength();
                                var scrollYPercentage = (scrollTop + scrollYAmount) / scrollEvent.verticalScrollLength;
                                if (scrollYPercentage >= 1 && scrollTop < scrollEvent.verticalScrollLength) {
                                    containerCtrl.viewport[0].scrollTop = scrollEvent.verticalScrollLength;
                                }
                                if (scrollYPercentage < 0) {
                                    scrollYPercentage = 0;
                                } else if (scrollYPercentage > 1) {
                                    scrollYPercentage = 1;
                                }
                                scrollEvent.y = {
                                    "percentage": scrollYPercentage,
                                    "pixels": scrollYAmount
                                };
                            }
                            if (event.deltaX !== 0) {
                                var scrollXAmount = event.deltaX * event.deltaFactor;
                                scrollLeft = gridUtil.normalizeScrollLeft(containerCtrl.viewport, grid);
                                scrollEvent.horizontalScrollLength = colContainer.getCanvasWidth() - colContainer.getViewportWidth();
                                var scrollXPercentage = (scrollLeft + scrollXAmount) / scrollEvent.horizontalScrollLength;
                                if (scrollXPercentage < 0) {
                                    scrollXPercentage = 0;
                                } else if (scrollXPercentage > 1) {
                                    scrollXPercentage = 1;
                                }
                                scrollEvent.x = {
                                    "percentage": scrollXPercentage,
                                    "pixels": scrollXAmount
                                };
                            }
                            if (event.deltaY !== 0 && (scrollEvent.atTop(scrollTop) || scrollEvent.atBottom(scrollTop)) || event.deltaX !== 0 && (scrollEvent.atLeft(scrollLeft) || scrollEvent.atRight(scrollLeft))) {} else {
                                event.preventDefault();
                                event.stopPropagation();
                                scrollEvent.fireThrottledScrollingEvent("", scrollEvent);
                            }
                        });
                        $elm.bind("$destroy", function() {
                            $elm.unbind("keydown");
                            [ "touchstart", "touchmove", "touchend", "keydown", "wheel", "mousewheel", "DomMouseScroll", "MozMousePixelScroll" ].forEach(function(eventName) {
                                $elm.unbind(eventName);
                            });
                        });
                        function update() {
                            var ret = "";
                            var canvasWidth = colContainer.canvasWidth;
                            var viewportWidth = colContainer.getViewportWidth();
                            var canvasHeight = rowContainer.getCanvasHeight();
                            var viewportHeight = rowContainer.getViewportHeight();
                            if (colContainer.needsHScrollbarPlaceholder()) {
                                viewportHeight -= grid.scrollbarHeight;
                            }
                            var headerViewportWidth, footerViewportWidth;
                            headerViewportWidth = footerViewportWidth = colContainer.getHeaderViewportWidth();
                            ret += "\n .grid" + uiGridCtrl.grid.id + " .ui-grid-render-container-" + $scope.containerId + " .ui-grid-canvas { width: " + canvasWidth + "px; height: " + canvasHeight + "px; }";
                            ret += "\n .grid" + uiGridCtrl.grid.id + " .ui-grid-render-container-" + $scope.containerId + " .ui-grid-header-canvas { width: " + (canvasWidth + grid.scrollbarWidth) + "px; }";
                            if (renderContainer.explicitHeaderCanvasHeight) {
                                ret += "\n .grid" + uiGridCtrl.grid.id + " .ui-grid-render-container-" + $scope.containerId + " .ui-grid-header-canvas { height: " + renderContainer.explicitHeaderCanvasHeight + "px; }";
                            } else {
                                ret += "\n .grid" + uiGridCtrl.grid.id + " .ui-grid-render-container-" + $scope.containerId + " .ui-grid-header-canvas { height: inherit; }";
                            }
                            ret += "\n .grid" + uiGridCtrl.grid.id + " .ui-grid-render-container-" + $scope.containerId + " .ui-grid-viewport { width: " + viewportWidth + "px; height: " + viewportHeight + "px; }";
                            ret += "\n .grid" + uiGridCtrl.grid.id + " .ui-grid-render-container-" + $scope.containerId + " .ui-grid-header-viewport { width: " + headerViewportWidth + "px; }";
                            ret += "\n .grid" + uiGridCtrl.grid.id + " .ui-grid-render-container-" + $scope.containerId + " .ui-grid-footer-canvas { width: " + (canvasWidth + grid.scrollbarWidth) + "px; }";
                            ret += "\n .grid" + uiGridCtrl.grid.id + " .ui-grid-render-container-" + $scope.containerId + " .ui-grid-footer-viewport { width: " + footerViewportWidth + "px; }";
                            return ret;
                        }
                        uiGridCtrl.grid.registerStyleComputation({
                            "priority": 6,
                            "func": update
                        });
                    }
                };
            }
        };
    } ]);
    module.controller("uiGridRenderContainer", [ "$scope", "gridUtil", function($scope, gridUtil) {} ]);
})();

(function() {
    "use strict";
    angular.module("ui.grid").directive("uiGridRow", [ "gridUtil", function(gridUtil) {
        return {
            "replace": true,
            "require": [ "^uiGrid", "^uiGridRenderContainer" ],
            "scope": {
                "row": "=uiGridRow",
                "rowRenderIndex": "="
            },
            "compile": function() {
                return {
                    "pre": function($scope, $elm, $attrs, controllers) {
                        var uiGridCtrl = controllers[0];
                        var containerCtrl = controllers[1];
                        var grid = uiGridCtrl.grid;
                        $scope.grid = uiGridCtrl.grid;
                        $scope.colContainer = containerCtrl.colContainer;
                        var clonedElement, cloneScope;
                        function compileTemplate() {
                            $scope.row.getRowTemplateFn.then(function(compiledElementFn) {
                                var newScope = $scope.$new();
                                compiledElementFn(newScope, function(newElm, scope) {
                                    if (clonedElement) {
                                        clonedElement.remove();
                                        cloneScope.$destroy();
                                    }
                                    $elm.empty().append(newElm);
                                    clonedElement = newElm;
                                    cloneScope = newScope;
                                });
                            });
                        }
                        compileTemplate();
                        $scope.$watch("row.getRowTemplateFn", function(newFunc, oldFunc) {
                            if (newFunc !== oldFunc) {
                                compileTemplate();
                            }
                        });
                    },
                    "post": function($scope, $elm, $attrs, controllers) {}
                };
            }
        };
    } ]);
})();

(function() {
    angular.module("ui.grid").directive("uiGridStyle", [ "gridUtil", "$interpolate", function(gridUtil, $interpolate) {
        return {
            "link": function($scope, $elm, $attrs, uiGridCtrl) {
                var interpolateFn = $interpolate($elm.text(), true);
                if (interpolateFn) {
                    $scope.$watch(interpolateFn, function(value) {
                        $elm.text(value);
                    });
                }
            }
        };
    } ]);
})();

(function() {
    "use strict";
    angular.module("ui.grid").directive("uiGridViewport", [ "gridUtil", "ScrollEvent", "uiGridConstants", "$log", function(gridUtil, ScrollEvent, uiGridConstants, $log) {
        return {
            "replace": true,
            "scope": {},
            "controllerAs": "Viewport",
            "templateUrl": "ui-grid/uiGridViewport",
            "require": [ "^uiGrid", "^uiGridRenderContainer" ],
            "link": function($scope, $elm, $attrs, controllers) {
                var uiGridCtrl = controllers[0];
                var containerCtrl = controllers[1];
                $scope.containerCtrl = containerCtrl;
                var rowContainer = containerCtrl.rowContainer;
                var colContainer = containerCtrl.colContainer;
                var grid = uiGridCtrl.grid;
                $scope.grid = uiGridCtrl.grid;
                $scope.rowContainer = containerCtrl.rowContainer;
                $scope.colContainer = containerCtrl.colContainer;
                containerCtrl.viewport = $elm;
                $elm.on("scroll", scrollHandler);
                var ignoreScroll = false;
                function scrollHandler(evt) {
                    var newScrollTop = $elm[0].scrollTop;
                    var newScrollLeft = gridUtil.normalizeScrollLeft($elm, grid);
                    var vertScrollPercentage = rowContainer.scrollVertical(newScrollTop);
                    var horizScrollPercentage = colContainer.scrollHorizontal(newScrollLeft);
                    var scrollEvent = new ScrollEvent(grid, rowContainer, colContainer, ScrollEvent.Sources.ViewPortScroll);
                    scrollEvent.newScrollLeft = newScrollLeft;
                    scrollEvent.newScrollTop = newScrollTop;
                    if (horizScrollPercentage > -1) {
                        scrollEvent.x = {
                            "percentage": horizScrollPercentage
                        };
                    }
                    if (vertScrollPercentage > -1) {
                        scrollEvent.y = {
                            "percentage": vertScrollPercentage
                        };
                    }
                    grid.scrollContainers($scope.$parent.containerId, scrollEvent);
                }
                if ($scope.$parent.bindScrollVertical) {
                    grid.addVerticalScrollSync($scope.$parent.containerId, syncVerticalScroll);
                }
                if ($scope.$parent.bindScrollHorizontal) {
                    grid.addHorizontalScrollSync($scope.$parent.containerId, syncHorizontalScroll);
                    grid.addHorizontalScrollSync($scope.$parent.containerId + "header", syncHorizontalHeader);
                    grid.addHorizontalScrollSync($scope.$parent.containerId + "footer", syncHorizontalFooter);
                }
                function syncVerticalScroll(scrollEvent) {
                    containerCtrl.prevScrollArgs = scrollEvent;
                    var newScrollTop = scrollEvent.getNewScrollTop(rowContainer, containerCtrl.viewport);
                    $elm[0].scrollTop = newScrollTop;
                }
                function syncHorizontalScroll(scrollEvent) {
                    containerCtrl.prevScrollArgs = scrollEvent;
                    var newScrollLeft = scrollEvent.getNewScrollLeft(colContainer, containerCtrl.viewport);
                    $elm[0].scrollLeft = gridUtil.denormalizeScrollLeft(containerCtrl.viewport, newScrollLeft, grid);
                }
                function syncHorizontalHeader(scrollEvent) {
                    var newScrollLeft = scrollEvent.getNewScrollLeft(colContainer, containerCtrl.viewport);
                    if (containerCtrl.headerViewport) {
                        containerCtrl.headerViewport.scrollLeft = gridUtil.denormalizeScrollLeft(containerCtrl.viewport, newScrollLeft, grid);
                    }
                }
                function syncHorizontalFooter(scrollEvent) {
                    var newScrollLeft = scrollEvent.getNewScrollLeft(colContainer, containerCtrl.viewport);
                    if (containerCtrl.footerViewport) {
                        containerCtrl.footerViewport.scrollLeft = gridUtil.denormalizeScrollLeft(containerCtrl.viewport, newScrollLeft, grid);
                    }
                }
            },
            "controller": [ "$scope", function($scope) {
                this.rowStyle = function(index) {
                    var rowContainer = $scope.rowContainer;
                    var colContainer = $scope.colContainer;
                    var styles = {};
                    if (index === 0 && rowContainer.currentTopRow !== 0) {
                        var hiddenRowWidth = rowContainer.currentTopRow * rowContainer.grid.options.rowHeight;
                        styles["margin-top"] = hiddenRowWidth + "px";
                    }
                    if (colContainer.currentFirstColumn !== 0) {
                        if (colContainer.grid.isRTL()) {
                            styles["margin-right"] = colContainer.columnOffset + "px";
                        } else {
                            styles["margin-left"] = colContainer.columnOffset + "px";
                        }
                    }
                    return styles;
                };
            } ]
        };
    } ]);
})();

(function() {
    angular.module("ui.grid").directive("uiGridVisible", function uiGridVisibleAction() {
        return function($scope, $elm, $attr) {
            $scope.$watch($attr.uiGridVisible, function(visible) {
                $elm[visible ? "removeClass" : "addClass"]("ui-grid-invisible");
            });
        };
    });
})();

(function() {
    "use strict";
    angular.module("ui.grid").controller("uiGridController", [ "$scope", "$element", "$attrs", "gridUtil", "$q", "uiGridConstants", "$templateCache", "gridClassFactory", "$timeout", "$parse", "$compile", function($scope, $elm, $attrs, gridUtil, $q, uiGridConstants, $templateCache, gridClassFactory, $timeout, $parse, $compile) {
        var self = this;
        self.grid = gridClassFactory.createGrid($scope.uiGrid);
        self.grid.appScope = self.grid.appScope || $scope.$parent;
        $elm.addClass("grid" + self.grid.id);
        self.grid.rtl = gridUtil.getStyles($elm[0])["direction"] === "rtl";
        $scope.grid = self.grid;
        if ($attrs.uiGridColumns) {
            $attrs.$observe("uiGridColumns", function(value) {
                self.grid.options.columnDefs = value;
                self.grid.buildColumns().then(function() {
                    self.grid.preCompileCellTemplates();
                    self.grid.refreshCanvas(true);
                });
            });
        }
        var deregFunctions = [];
        if (self.grid.options.fastWatch) {
            self.uiGrid = $scope.uiGrid;
            if (angular.isString($scope.uiGrid.data)) {
                deregFunctions.push($scope.$parent.$watch($scope.uiGrid.data, dataWatchFunction));
                deregFunctions.push($scope.$parent.$watch(function() {
                    if (self.grid.appScope[$scope.uiGrid.data]) {
                        return self.grid.appScope[$scope.uiGrid.data].length;
                    } else {
                        return undefined;
                    }
                }, dataWatchFunction));
            } else {
                deregFunctions.push($scope.$parent.$watch(function() {
                    return $scope.uiGrid.data;
                }, dataWatchFunction));
                deregFunctions.push($scope.$parent.$watch(function() {
                    return $scope.uiGrid.data.length;
                }, function() {
                    dataWatchFunction($scope.uiGrid.data);
                }));
            }
            deregFunctions.push($scope.$parent.$watch(function() {
                return $scope.uiGrid.columnDefs;
            }, columnDefsWatchFunction));
            deregFunctions.push($scope.$parent.$watch(function() {
                return $scope.uiGrid.columnDefs.length;
            }, function() {
                columnDefsWatchFunction($scope.uiGrid.columnDefs);
            }));
        } else {
            if (angular.isString($scope.uiGrid.data)) {
                deregFunctions.push($scope.$parent.$watchCollection($scope.uiGrid.data, dataWatchFunction));
            } else {
                deregFunctions.push($scope.$parent.$watchCollection(function() {
                    return $scope.uiGrid.data;
                }, dataWatchFunction));
            }
            deregFunctions.push($scope.$parent.$watchCollection(function() {
                return $scope.uiGrid.columnDefs;
            }, columnDefsWatchFunction));
        }
        function columnDefsWatchFunction(n, o) {
            if (n && n !== o) {
                self.grid.options.columnDefs = $scope.uiGrid.columnDefs;
                self.grid.buildColumns({
                    "orderByColumnDefs": true
                }).then(function() {
                    self.grid.preCompileCellTemplates();
                    self.grid.callDataChangeCallbacks(uiGridConstants.dataChange.COLUMN);
                });
            }
        }
        var mostRecentData;
        function dataWatchFunction(newData) {
            var promises = [];
            if (self.grid.options.fastWatch) {
                if (angular.isString($scope.uiGrid.data)) {
                    newData = self.grid.appScope[$scope.uiGrid.data];
                } else {
                    newData = $scope.uiGrid.data;
                }
            }
            mostRecentData = newData;
            if (newData) {
                var hasColumns = self.grid.columns.length > (self.grid.rowHeaderColumns ? self.grid.rowHeaderColumns.length : 0);
                if (!hasColumns && !$attrs.uiGridColumns && self.grid.options.columnDefs.length === 0 && newData.length > 0) {
                    self.grid.buildColumnDefsFromData(newData);
                }
                if (!hasColumns && (self.grid.options.columnDefs.length > 0 || newData.length > 0)) {
                    promises.push(self.grid.buildColumns().then(function() {
                        self.grid.preCompileCellTemplates();
                    }));
                }
                $q.all(promises).then(function() {
                    self.grid.modifyRows(mostRecentData).then(function() {
                        self.grid.redrawInPlace(true);
                        $scope.$evalAsync(function() {
                            self.grid.refreshCanvas(true);
                            self.grid.callDataChangeCallbacks(uiGridConstants.dataChange.ROW);
                        });
                    });
                });
            }
        }
        var styleWatchDereg = $scope.$watch(function() {
            return self.grid.styleComputations;
        }, function() {
            self.grid.refreshCanvas(true);
        });
        $scope.$on("$destroy", function() {
            deregFunctions.forEach(function(deregFn) {
                deregFn();
            });
            styleWatchDereg();
        });
        self.fireEvent = function(eventName, args) {
            if (typeof args === "undefined" || args === undefined) {
                args = {};
            }
            if (typeof args.grid === "undefined" || args.grid === undefined) {
                args.grid = self.grid;
            }
            $scope.$broadcast(eventName, args);
        };
        self.innerCompile = function innerCompile(elm) {
            $compile(elm)($scope);
        };
    } ]);
    angular.module("ui.grid").directive("uiGrid", uiGridDirective);
    uiGridDirective.$inject = [ "$compile", "$templateCache", "$timeout", "$window", "gridUtil", "uiGridConstants" ];
    function uiGridDirective($compile, $templateCache, $timeout, $window, gridUtil, uiGridConstants) {
        return {
            "templateUrl": "ui-grid/ui-grid",
            "scope": {
                "uiGrid": "="
            },
            "replace": true,
            "transclude": true,
            "controller": "uiGridController",
            "compile": function() {
                return {
                    "post": function($scope, $elm, $attrs, uiGridCtrl) {
                        var grid = uiGridCtrl.grid;
                        uiGridCtrl.scrollbars = [];
                        grid.element = $elm;
                        var sizeCheckInterval = 100;
                        var maxSizeChecks = 20;
                        var sizeChecks = 0;
                        setup();
                        init();
                        grid.renderingComplete();
                        checkSize();
                        function checkSize() {
                            if ($elm[0].offsetWidth <= 0 && sizeChecks < maxSizeChecks) {
                                setTimeout(checkSize, sizeCheckInterval);
                                sizeChecks++;
                            } else {
                                $timeout(init);
                            }
                        }
                        function setup() {
                            angular.element($window).on("resize", gridResize);
                            $elm.on("$destroy", function() {
                                angular.element($window).off("resize", gridResize);
                            });
                            $scope.$watch(function() {
                                return grid.hasLeftContainer();
                            }, function(newValue, oldValue) {
                                if (newValue === oldValue) {
                                    return;
                                }
                                grid.refreshCanvas(true);
                            });
                            $scope.$watch(function() {
                                return grid.hasRightContainer();
                            }, function(newValue, oldValue) {
                                if (newValue === oldValue) {
                                    return;
                                }
                                grid.refreshCanvas(true);
                            });
                        }
                        function init() {
                            grid.gridWidth = $scope.gridWidth = gridUtil.elementWidth($elm);
                            grid.canvasWidth = uiGridCtrl.grid.gridWidth;
                            grid.gridHeight = $scope.gridHeight = gridUtil.elementHeight($elm);
                            if (grid.gridHeight <= grid.options.rowHeight && grid.options.enableMinHeightCheck) {
                                autoAdjustHeight();
                            }
                            grid.refreshCanvas(true);
                        }
                        function autoAdjustHeight() {
                            var contentHeight = grid.options.minRowsToShow * grid.options.rowHeight;
                            var headerHeight = grid.options.showHeader ? grid.options.headerRowHeight : 0;
                            var footerHeight = grid.calcFooterHeight();
                            var scrollbarHeight = 0;
                            if (grid.options.enableHorizontalScrollbar === uiGridConstants.scrollbars.ALWAYS) {
                                scrollbarHeight = gridUtil.getScrollbarWidth();
                            }
                            var maxNumberOfFilters = 0;
                            angular.forEach(grid.options.columnDefs, function(col) {
                                if (col.hasOwnProperty("filter")) {
                                    if (maxNumberOfFilters < 1) {
                                        maxNumberOfFilters = 1;
                                    }
                                } else if (col.hasOwnProperty("filters")) {
                                    if (maxNumberOfFilters < col.filters.length) {
                                        maxNumberOfFilters = col.filters.length;
                                    }
                                }
                            });
                            if (grid.options.enableFiltering && !maxNumberOfFilters) {
                                var allColumnsHaveFilteringTurnedOff = grid.options.columnDefs.length && grid.options.columnDefs.every(function(col) {
                                    return col.enableFiltering === false;
                                });
                                if (!allColumnsHaveFilteringTurnedOff) {
                                    maxNumberOfFilters = 1;
                                }
                            }
                            var filterHeight = maxNumberOfFilters * headerHeight;
                            var newHeight = headerHeight + contentHeight + footerHeight + scrollbarHeight + filterHeight;
                            $elm.css("height", newHeight + "px");
                            grid.gridHeight = $scope.gridHeight = gridUtil.elementHeight($elm);
                        }
                        function gridResize($event) {
                            grid.gridWidth = $scope.gridWidth = gridUtil.elementWidth($elm);
                            grid.gridHeight = $scope.gridHeight = gridUtil.elementHeight($elm);
                            grid.refreshCanvas(true);
                        }
                    }
                };
            }
        };
    }
})();

(function() {
    "use strict";
    angular.module("ui.grid").directive("uiGridPinnedContainer", [ "gridUtil", function(gridUtil) {
        return {
            "restrict": "EA",
            "replace": true,
            "template": '<div class="ui-grid-pinned-container"><div ui-grid-render-container container-id="side" row-container-name="\'body\'" col-container-name="side" bind-scroll-vertical="true" class="{{ side }} ui-grid-render-container-{{ side }}"></div></div>',
            "scope": {
                "side": "=uiGridPinnedContainer"
            },
            "require": "^uiGrid",
            "compile": function compile() {
                return {
                    "post": function($scope, $elm, $attrs, uiGridCtrl) {
                        var grid = uiGridCtrl.grid;
                        var myWidth = 0;
                        $elm.addClass("ui-grid-pinned-container-" + $scope.side);
                        if ($scope.side === "left" || $scope.side === "right") {
                            grid.renderContainers[$scope.side].getViewportWidth = monkeyPatchedGetViewportWidth;
                        }
                        function monkeyPatchedGetViewportWidth() {
                            var self = this;
                            var viewportWidth = 0;
                            self.visibleColumnCache.forEach(function(column) {
                                viewportWidth += column.drawnWidth;
                            });
                            var adjustment = self.getViewportAdjustment();
                            viewportWidth = viewportWidth + adjustment.width;
                            return viewportWidth;
                        }
                        function updateContainerWidth() {
                            if ($scope.side === "left" || $scope.side === "right") {
                                var cols = grid.renderContainers[$scope.side].visibleColumnCache;
                                var width = 0;
                                for (var i = 0; i < cols.length; i++) {
                                    var col = cols[i];
                                    width += col.drawnWidth || col.width || 0;
                                }
                                return width;
                            }
                        }
                        function updateContainerDimensions() {
                            var ret = "";
                            if ($scope.side === "left" || $scope.side === "right") {
                                myWidth = updateContainerWidth();
                                $elm.attr("style", null);
                                ret += ".grid" + grid.id + " .ui-grid-pinned-container-" + $scope.side + ", .grid" + grid.id + " .ui-grid-pinned-container-" + $scope.side + " .ui-grid-render-container-" + $scope.side + " .ui-grid-viewport { width: " + myWidth + "px; } ";
                            }
                            return ret;
                        }
                        grid.renderContainers.body.registerViewportAdjuster(function(adjustment) {
                            myWidth = updateContainerWidth();
                            adjustment.width -= myWidth;
                            adjustment.side = $scope.side;
                            return adjustment;
                        });
                        grid.registerStyleComputation({
                            "priority": 15,
                            "func": updateContainerDimensions
                        });
                    }
                };
            }
        };
    } ]);
})();

(function() {
    angular.module("ui.grid").factory("Grid", [ "$q", "$compile", "$parse", "gridUtil", "uiGridConstants", "GridOptions", "GridColumn", "GridRow", "GridApi", "rowSorter", "rowSearcher", "GridRenderContainer", "$timeout", "ScrollEvent", function($q, $compile, $parse, gridUtil, uiGridConstants, GridOptions, GridColumn, GridRow, GridApi, rowSorter, rowSearcher, GridRenderContainer, $timeout, ScrollEvent) {
        var Grid = function Grid(options) {
            var self = this;
            if (options !== undefined && typeof options.id !== "undefined" && options.id) {
                if (!/^[_a-zA-Z0-9-]+$/.test(options.id)) {
                    throw new Error("Grid id '" + options.id + '" is invalid. It must follow CSS selector syntax rules.');
                }
            } else {
                throw new Error("No ID provided. An ID must be given when creating a grid.");
            }
            self.id = options.id;
            delete options.id;
            self.options = GridOptions.initialize(options);
            self.appScope = self.options.appScopeProvider;
            self.headerHeight = self.options.headerRowHeight;
            self.footerHeight = self.calcFooterHeight();
            self.columnFooterHeight = self.calcColumnFooterHeight();
            self.rtl = false;
            self.gridHeight = 0;
            self.gridWidth = 0;
            self.columnBuilders = [];
            self.rowBuilders = [];
            self.rowsProcessors = [];
            self.columnsProcessors = [];
            self.styleComputations = [];
            self.viewportAdjusters = [];
            self.rowHeaderColumns = [];
            self.dataChangeCallbacks = {};
            self.verticalScrollSyncCallBackFns = {};
            self.horizontalScrollSyncCallBackFns = {};
            self.renderContainers = {};
            self.renderContainers.body = new GridRenderContainer("body", self);
            self.cellValueGetterCache = {};
            self.getRowTemplateFn = null;
            self.rows = [];
            self.columns = [];
            self.isScrollingVertically = false;
            self.isScrollingHorizontally = false;
            self.scrollDirection = uiGridConstants.scrollDirection.NONE;
            self.disableScrolling = false;
            function vertical(scrollEvent) {
                self.isScrollingVertically = false;
                self.api.core.raise.scrollEnd(scrollEvent);
                self.scrollDirection = uiGridConstants.scrollDirection.NONE;
            }
            var debouncedVertical = gridUtil.debounce(vertical, self.options.scrollDebounce);
            var debouncedVerticalMinDelay = gridUtil.debounce(vertical, 0);
            function horizontal(scrollEvent) {
                self.isScrollingHorizontally = false;
                self.api.core.raise.scrollEnd(scrollEvent);
                self.scrollDirection = uiGridConstants.scrollDirection.NONE;
            }
            var debouncedHorizontal = gridUtil.debounce(horizontal, self.options.scrollDebounce);
            var debouncedHorizontalMinDelay = gridUtil.debounce(horizontal, 0);
            self.flagScrollingVertically = function(scrollEvent) {
                if (!self.isScrollingVertically && !self.isScrollingHorizontally) {
                    self.api.core.raise.scrollBegin(scrollEvent);
                }
                self.isScrollingVertically = true;
                if (self.options.scrollDebounce === 0 || !scrollEvent.withDelay) {
                    debouncedVerticalMinDelay(scrollEvent);
                } else {
                    debouncedVertical(scrollEvent);
                }
            };
            self.flagScrollingHorizontally = function(scrollEvent) {
                if (!self.isScrollingVertically && !self.isScrollingHorizontally) {
                    self.api.core.raise.scrollBegin(scrollEvent);
                }
                self.isScrollingHorizontally = true;
                if (self.options.scrollDebounce === 0 || !scrollEvent.withDelay) {
                    debouncedHorizontalMinDelay(scrollEvent);
                } else {
                    debouncedHorizontal(scrollEvent);
                }
            };
            self.scrollbarHeight = 0;
            self.scrollbarWidth = 0;
            if (self.options.enableHorizontalScrollbar === uiGridConstants.scrollbars.ALWAYS) {
                self.scrollbarHeight = gridUtil.getScrollbarWidth();
            }
            if (self.options.enableVerticalScrollbar === uiGridConstants.scrollbars.ALWAYS) {
                self.scrollbarWidth = gridUtil.getScrollbarWidth();
            }
            self.api = new GridApi(self);
            self.api.registerMethod("core", "refresh", this.refresh);
            self.api.registerMethod("core", "queueGridRefresh", this.queueGridRefresh);
            self.api.registerMethod("core", "refreshRows", this.refreshRows);
            self.api.registerMethod("core", "queueRefresh", this.queueRefresh);
            self.api.registerMethod("core", "handleWindowResize", this.handleWindowResize);
            self.api.registerMethod("core", "addRowHeaderColumn", this.addRowHeaderColumn);
            self.api.registerMethod("core", "scrollToIfNecessary", function(gridRow, gridCol) {
                return self.scrollToIfNecessary(gridRow, gridCol);
            });
            self.api.registerMethod("core", "scrollTo", function(rowEntity, colDef) {
                return self.scrollTo(rowEntity, colDef);
            });
            self.api.registerMethod("core", "registerRowsProcessor", this.registerRowsProcessor);
            self.api.registerMethod("core", "registerColumnsProcessor", this.registerColumnsProcessor);
            self.api.registerMethod("core", "sortHandleNulls", rowSorter.handleNulls);
            self.api.registerEvent("core", "sortChanged");
            self.api.registerEvent("core", "columnVisibilityChanged");
            self.api.registerMethod("core", "notifyDataChange", this.notifyDataChange);
            self.api.registerMethod("core", "clearAllFilters", this.clearAllFilters);
            self.registerDataChangeCallback(self.columnRefreshCallback, [ uiGridConstants.dataChange.COLUMN ]);
            self.registerDataChangeCallback(self.processRowsCallback, [ uiGridConstants.dataChange.EDIT ]);
            self.registerDataChangeCallback(self.updateFooterHeightCallback, [ uiGridConstants.dataChange.OPTIONS ]);
            self.registerStyleComputation({
                "priority": 10,
                "func": self.getFooterStyles
            });
        };
        Grid.prototype.calcFooterHeight = function() {
            if (!this.hasFooter()) {
                return 0;
            }
            var height = 0;
            if (this.options.showGridFooter) {
                height += this.options.gridFooterHeight;
            }
            height += this.calcColumnFooterHeight();
            return height;
        };
        Grid.prototype.calcColumnFooterHeight = function() {
            var height = 0;
            if (this.options.showColumnFooter) {
                height += this.options.columnFooterHeight;
            }
            return height;
        };
        Grid.prototype.getFooterStyles = function() {
            var style = ".grid" + this.id + " .ui-grid-footer-aggregates-row { height: " + this.options.columnFooterHeight + "px; }";
            style += " .grid" + this.id + " .ui-grid-footer-info { height: " + this.options.gridFooterHeight + "px; }";
            return style;
        };
        Grid.prototype.hasFooter = function() {
            return this.options.showGridFooter || this.options.showColumnFooter;
        };
        Grid.prototype.isRTL = function() {
            return this.rtl;
        };
        Grid.prototype.registerColumnBuilder = function registerColumnBuilder(columnBuilder) {
            this.columnBuilders.push(columnBuilder);
        };
        Grid.prototype.buildColumnDefsFromData = function(dataRows) {
            this.options.columnDefs = gridUtil.getColumnsFromData(dataRows, this.options.excludeProperties);
        };
        Grid.prototype.registerRowBuilder = function registerRowBuilder(rowBuilder) {
            this.rowBuilders.push(rowBuilder);
        };
        Grid.prototype.registerDataChangeCallback = function registerDataChangeCallback(callback, types, _this) {
            var uid = gridUtil.nextUid();
            if (!types) {
                types = [ uiGridConstants.dataChange.ALL ];
            }
            if (!Array.isArray(types)) {
                gridUtil.logError("Expected types to be an array or null in registerDataChangeCallback, value passed was: " + types);
            }
            this.dataChangeCallbacks[uid] = {
                "callback": callback,
                "types": types,
                "_this": _this
            };
            var self = this;
            var deregisterFunction = function() {
                delete self.dataChangeCallbacks[uid];
            };
            return deregisterFunction;
        };
        Grid.prototype.callDataChangeCallbacks = function callDataChangeCallbacks(type, options) {
            angular.forEach(this.dataChangeCallbacks, function(callback, uid) {
                if (callback.types.indexOf(uiGridConstants.dataChange.ALL) !== -1 || callback.types.indexOf(type) !== -1 || type === uiGridConstants.dataChange.ALL) {
                    if (callback._this) {
                        callback.callback.apply(callback._this, this);
                    } else {
                        callback.callback(this);
                    }
                }
            }, this);
        };
        Grid.prototype.notifyDataChange = function notifyDataChange(type) {
            var constants = uiGridConstants.dataChange;
            if (type === constants.ALL || type === constants.COLUMN || type === constants.EDIT || type === constants.ROW || type === constants.OPTIONS) {
                this.callDataChangeCallbacks(type);
            } else {
                gridUtil.logError("Notified of a data change, but the type was not recognised, so no action taken, type was: " + type);
            }
        };
        Grid.prototype.columnRefreshCallback = function columnRefreshCallback(grid) {
            grid.buildColumns();
            grid.queueGridRefresh();
        };
        Grid.prototype.processRowsCallback = function processRowsCallback(grid) {
            grid.queueGridRefresh();
        };
        Grid.prototype.updateFooterHeightCallback = function updateFooterHeightCallback(grid) {
            grid.footerHeight = grid.calcFooterHeight();
            grid.columnFooterHeight = grid.calcColumnFooterHeight();
        };
        Grid.prototype.getColumn = function getColumn(name) {
            var columns = this.columns.filter(function(column) {
                return column.colDef.name === name;
            });
            return columns.length > 0 ? columns[0] : null;
        };
        Grid.prototype.getColDef = function getColDef(name) {
            var colDefs = this.options.columnDefs.filter(function(colDef) {
                return colDef.name === name;
            });
            return colDefs.length > 0 ? colDefs[0] : null;
        };
        Grid.prototype.assignTypes = function() {
            var self = this;
            self.options.columnDefs.forEach(function(colDef, index) {
                if (!colDef.type) {
                    var col = new GridColumn(colDef, index, self);
                    var firstRow = self.rows.length > 0 ? self.rows[0] : null;
                    if (firstRow) {
                        colDef.type = gridUtil.guessType(self.getCellValue(firstRow, col));
                    } else {
                        colDef.type = "string";
                    }
                }
            });
        };
        Grid.prototype.isRowHeaderColumn = function isRowHeaderColumn(column) {
            return this.rowHeaderColumns.indexOf(column) !== -1;
        };
        Grid.prototype.addRowHeaderColumn = function addRowHeaderColumn(colDef) {
            var self = this;
            var rowHeaderCol = new GridColumn(colDef, gridUtil.nextUid(), self);
            rowHeaderCol.isRowHeader = true;
            if (self.isRTL()) {
                self.createRightContainer();
                rowHeaderCol.renderContainer = "right";
            } else {
                self.createLeftContainer();
                rowHeaderCol.renderContainer = "left";
            }
            self.columnBuilders[0](colDef, rowHeaderCol, self.options).then(function() {
                rowHeaderCol.enableFiltering = false;
                rowHeaderCol.enableSorting = false;
                rowHeaderCol.enableHiding = false;
                self.rowHeaderColumns.push(rowHeaderCol);
                self.buildColumns().then(function() {
                    self.preCompileCellTemplates();
                    self.queueGridRefresh();
                });
            });
        };
        Grid.prototype.getOnlyDataColumns = function getOnlyDataColumns() {
            var self = this;
            var cols = [];
            self.columns.forEach(function(col) {
                if (self.rowHeaderColumns.indexOf(col) === -1) {
                    cols.push(col);
                }
            });
            return cols;
        };
        Grid.prototype.buildColumns = function buildColumns(opts) {
            var options = {
                "orderByColumnDefs": false
            };
            angular.extend(options, opts);
            var self = this;
            var builderPromises = [];
            var headerOffset = self.rowHeaderColumns.length;
            var i;
            for (i = 0; i < self.columns.length; i++) {
                if (!self.getColDef(self.columns[i].name)) {
                    self.columns.splice(i, 1);
                    i--;
                }
            }
            self.rowHeaderColumns.forEach(function(rowHeaderColumn) {
                self.columns.unshift(rowHeaderColumn);
            });
            self.options.columnDefs.forEach(function(colDef, index) {
                self.preprocessColDef(colDef);
                var col = self.getColumn(colDef.name);
                if (!col) {
                    col = new GridColumn(colDef, gridUtil.nextUid(), self);
                    self.columns.splice(index + headerOffset, 0, col);
                } else {
                    col.updateColumnDef(colDef, false);
                }
                self.columnBuilders.forEach(function(builder) {
                    builderPromises.push(builder.call(self, colDef, col, self.options));
                });
            });
            if (!!options.orderByColumnDefs) {
                var columnCache = self.columns.slice(0);
                var len = Math.min(self.options.columnDefs.length, self.columns.length);
                for (i = 0; i < len; i++) {
                    if (self.columns[i + headerOffset].name !== self.options.columnDefs[i].name) {
                        columnCache[i + headerOffset] = self.getColumn(self.options.columnDefs[i].name);
                    } else {
                        columnCache[i + headerOffset] = self.columns[i + headerOffset];
                    }
                }
                self.columns.length = 0;
                Array.prototype.splice.apply(self.columns, [ 0, 0 ].concat(columnCache));
            }
            return $q.all(builderPromises).then(function() {
                if (self.rows.length > 0) {
                    self.assignTypes();
                }
            });
        };
        Grid.prototype.preCompileCellTemplates = function() {
            var self = this;
            var preCompileTemplate = function(col) {
                var html = col.cellTemplate.replace(uiGridConstants.MODEL_COL_FIELD, self.getQualifiedColField(col));
                html = html.replace(uiGridConstants.COL_FIELD, "grid.getCellValue(row, col)");
                var compiledElementFn = $compile(html);
                col.compiledElementFn = compiledElementFn;
                if (col.compiledElementFnDefer) {
                    col.compiledElementFnDefer.resolve(col.compiledElementFn);
                }
            };
            this.columns.forEach(function(col) {
                if (col.cellTemplate) {
                    preCompileTemplate(col);
                } else if (col.cellTemplatePromise) {
                    col.cellTemplatePromise.then(function() {
                        preCompileTemplate(col);
                    });
                }
            });
        };
        Grid.prototype.getQualifiedColField = function(col) {
            return "row.entity." + gridUtil.preEval(col.field);
        };
        Grid.prototype.createLeftContainer = function() {
            if (!this.hasLeftContainer()) {
                this.renderContainers.left = new GridRenderContainer("left", this, {
                    "disableColumnOffset": true
                });
            }
        };
        Grid.prototype.createRightContainer = function() {
            if (!this.hasRightContainer()) {
                this.renderContainers.right = new GridRenderContainer("right", this, {
                    "disableColumnOffset": true
                });
            }
        };
        Grid.prototype.hasLeftContainer = function() {
            return this.renderContainers.left !== undefined;
        };
        Grid.prototype.hasRightContainer = function() {
            return this.renderContainers.right !== undefined;
        };
        Grid.prototype.preprocessColDef = function preprocessColDef(colDef) {
            var self = this;
            if (!colDef.field && !colDef.name) {
                throw new Error("colDef.name or colDef.field property is required");
            }
            if (colDef.name === undefined && colDef.field !== undefined) {
                var newName = colDef.field, counter = 2;
                while (self.getColumn(newName)) {
                    newName = colDef.field + counter.toString();
                    counter++;
                }
                colDef.name = newName;
            }
        };
        Grid.prototype.newInN = function newInN(o, n, oAccessor, nAccessor) {
            var self = this;
            var t = [];
            for (var i = 0; i < n.length; i++) {
                var nV = nAccessor ? n[i][nAccessor] : n[i];
                var found = false;
                for (var j = 0; j < o.length; j++) {
                    var oV = oAccessor ? o[j][oAccessor] : o[j];
                    if (self.options.rowEquality(nV, oV)) {
                        found = true;
                        break;
                    }
                }
                if (!found) {
                    t.push(nV);
                }
            }
            return t;
        };
        Grid.prototype.getRow = function getRow(rowEntity, lookInRows) {
            var self = this;
            lookInRows = typeof lookInRows === "undefined" ? self.rows : lookInRows;
            var rows = lookInRows.filter(function(row) {
                return self.options.rowEquality(row.entity, rowEntity);
            });
            return rows.length > 0 ? rows[0] : null;
        };
        Grid.prototype.modifyRows = function modifyRows(newRawData) {
            var self = this;
            var oldRows = self.rows.slice(0);
            var oldRowHash = self.rowHashMap || self.createRowHashMap();
            self.rowHashMap = self.createRowHashMap();
            self.rows.length = 0;
            newRawData.forEach(function(newEntity, i) {
                var newRow;
                if (self.options.enableRowHashing) {
                    newRow = oldRowHash.get(newEntity);
                } else {
                    newRow = self.getRow(newEntity, oldRows);
                }
                if (!newRow) {
                    newRow = self.processRowBuilders(new GridRow(newEntity, i, self));
                }
                self.rows.push(newRow);
                self.rowHashMap.put(newEntity, newRow);
            });
            self.assignTypes();
            var p1 = $q.when(self.processRowsProcessors(self.rows)).then(function(renderableRows) {
                return self.setVisibleRows(renderableRows);
            });
            var p2 = $q.when(self.processColumnsProcessors(self.columns)).then(function(renderableColumns) {
                return self.setVisibleColumns(renderableColumns);
            });
            return $q.all([ p1, p2 ]);
        };
        Grid.prototype.addRows = function addRows(newRawData) {
            var self = this;
            var existingRowCount = self.rows.length;
            for (var i = 0; i < newRawData.length; i++) {
                var newRow = self.processRowBuilders(new GridRow(newRawData[i], i + existingRowCount, self));
                if (self.options.enableRowHashing) {
                    var found = self.rowHashMap.get(newRow.entity);
                    if (found) {
                        found.row = newRow;
                    }
                }
                self.rows.push(newRow);
            }
        };
        Grid.prototype.processRowBuilders = function processRowBuilders(gridRow) {
            var self = this;
            self.rowBuilders.forEach(function(builder) {
                builder.call(self, gridRow, self.options);
            });
            return gridRow;
        };
        Grid.prototype.registerStyleComputation = function registerStyleComputation(styleComputationInfo) {
            this.styleComputations.push(styleComputationInfo);
        };
        Grid.prototype.registerRowsProcessor = function registerRowsProcessor(processor, priority) {
            if (!angular.isFunction(processor)) {
                throw "Attempt to register non-function rows processor: " + processor;
            }
            this.rowsProcessors.push({
                "processor": processor,
                "priority": priority
            });
            this.rowsProcessors.sort(function sortByPriority(a, b) {
                return a.priority - b.priority;
            });
        };
        Grid.prototype.removeRowsProcessor = function removeRowsProcessor(processor) {
            var idx = -1;
            this.rowsProcessors.forEach(function(rowsProcessor, index) {
                if (rowsProcessor.processor === processor) {
                    idx = index;
                }
            });
            if (idx !== -1) {
                this.rowsProcessors.splice(idx, 1);
            }
        };
        Grid.prototype.processRowsProcessors = function processRowsProcessors(renderableRows) {
            var self = this;
            var myRenderableRows = renderableRows.slice(0);
            if (self.rowsProcessors.length === 0) {
                return $q.when(myRenderableRows);
            }
            var i = 0;
            var finished = $q.defer();
            function startProcessor(i, renderedRowsToProcess) {
                var processor = self.rowsProcessors[i].processor;
                return $q.when(processor.call(self, renderedRowsToProcess, self.columns)).then(function handleProcessedRows(processedRows) {
                    if (!processedRows) {
                        throw "Processor at index " + i + " did not return a set of renderable rows";
                    }
                    if (!angular.isArray(processedRows)) {
                        throw "Processor at index " + i + " did not return an array";
                    }
                    i++;
                    if (i <= self.rowsProcessors.length - 1) {
                        return startProcessor(i, processedRows);
                    } else {
                        finished.resolve(processedRows);
                    }
                });
            }
            startProcessor(0, myRenderableRows);
            return finished.promise;
        };
        Grid.prototype.setVisibleRows = function setVisibleRows(rows) {
            var self = this;
            for (var i in self.renderContainers) {
                var container = self.renderContainers[i];
                container.canvasHeightShouldUpdate = true;
                if (typeof container.visibleRowCache === "undefined") {
                    container.visibleRowCache = [];
                } else {
                    container.visibleRowCache.length = 0;
                }
            }
            for (var ri = 0; ri < rows.length; ri++) {
                var row = rows[ri];
                var targetContainer = typeof row.renderContainer !== "undefined" && row.renderContainer ? row.renderContainer : "body";
                if (row.visible) {
                    self.renderContainers[targetContainer].visibleRowCache.push(row);
                }
            }
            self.api.core.raise.rowsRendered(this.api);
        };
        Grid.prototype.registerColumnsProcessor = function registerColumnsProcessor(processor, priority) {
            if (!angular.isFunction(processor)) {
                throw "Attempt to register non-function rows processor: " + processor;
            }
            this.columnsProcessors.push({
                "processor": processor,
                "priority": priority
            });
            this.columnsProcessors.sort(function sortByPriority(a, b) {
                return a.priority - b.priority;
            });
        };
        Grid.prototype.removeColumnsProcessor = function removeColumnsProcessor(processor) {
            var idx = this.columnsProcessors.indexOf(processor);
            if (typeof idx !== "undefined" && idx !== undefined) {
                this.columnsProcessors.splice(idx, 1);
            }
        };
        Grid.prototype.processColumnsProcessors = function processColumnsProcessors(renderableColumns) {
            var self = this;
            var myRenderableColumns = renderableColumns.slice(0);
            if (self.columnsProcessors.length === 0) {
                return $q.when(myRenderableColumns);
            }
            var i = 0;
            var finished = $q.defer();
            function startProcessor(i, renderedColumnsToProcess) {
                var processor = self.columnsProcessors[i].processor;
                return $q.when(processor.call(self, renderedColumnsToProcess, self.rows)).then(function handleProcessedRows(processedColumns) {
                    if (!processedColumns) {
                        throw "Processor at index " + i + " did not return a set of renderable rows";
                    }
                    if (!angular.isArray(processedColumns)) {
                        throw "Processor at index " + i + " did not return an array";
                    }
                    i++;
                    if (i <= self.columnsProcessors.length - 1) {
                        return startProcessor(i, myRenderableColumns);
                    } else {
                        finished.resolve(myRenderableColumns);
                    }
                });
            }
            startProcessor(0, myRenderableColumns);
            return finished.promise;
        };
        Grid.prototype.setVisibleColumns = function setVisibleColumns(columns) {
            var self = this;
            for (var i in self.renderContainers) {
                var container = self.renderContainers[i];
                container.visibleColumnCache.length = 0;
            }
            for (var ci = 0; ci < columns.length; ci++) {
                var column = columns[ci];
                if (column.visible) {
                    if (typeof column.renderContainer !== "undefined" && column.renderContainer) {
                        self.renderContainers[column.renderContainer].visibleColumnCache.push(column);
                    } else {
                        self.renderContainers.body.visibleColumnCache.push(column);
                    }
                }
            }
        };
        Grid.prototype.handleWindowResize = function handleWindowResize($event) {
            var self = this;
            self.gridWidth = gridUtil.elementWidth(self.element);
            self.gridHeight = gridUtil.elementHeight(self.element);
            return self.queueRefresh();
        };
        Grid.prototype.queueRefresh = function queueRefresh() {
            var self = this;
            if (self.refreshCanceller) {
                $timeout.cancel(self.refreshCanceller);
            }
            self.refreshCanceller = $timeout(function() {
                self.refreshCanvas(true);
            });
            self.refreshCanceller.then(function() {
                self.refreshCanceller = null;
            });
            return self.refreshCanceller;
        };
        Grid.prototype.queueGridRefresh = function queueGridRefresh() {
            var self = this;
            if (self.gridRefreshCanceller) {
                $timeout.cancel(self.gridRefreshCanceller);
            }
            self.gridRefreshCanceller = $timeout(function() {
                self.refresh(true);
            });
            self.gridRefreshCanceller.then(function() {
                self.gridRefreshCanceller = null;
            });
            return self.gridRefreshCanceller;
        };
        Grid.prototype.updateCanvasHeight = function updateCanvasHeight() {
            var self = this;
            for (var containerId in self.renderContainers) {
                if (self.renderContainers.hasOwnProperty(containerId)) {
                    var container = self.renderContainers[containerId];
                    container.canvasHeightShouldUpdate = true;
                }
            }
        };
        Grid.prototype.buildStyles = function buildStyles() {
            var self = this;
            self.customStyles = "";
            self.styleComputations.sort(function(a, b) {
                if (a.priority === null) {
                    return 1;
                }
                if (b.priority === null) {
                    return -1;
                }
                if (a.priority === null && b.priority === null) {
                    return 0;
                }
                return a.priority - b.priority;
            }).forEach(function(compInfo) {
                var ret = compInfo.func.call(self);
                if (angular.isString(ret)) {
                    self.customStyles += "\n" + ret;
                }
            });
        };
        Grid.prototype.minColumnsToRender = function minColumnsToRender() {
            var self = this;
            var viewport = this.getViewportWidth();
            var min = 0;
            var totalWidth = 0;
            self.columns.forEach(function(col, i) {
                if (totalWidth < viewport) {
                    totalWidth += col.drawnWidth;
                    min++;
                } else {
                    var currWidth = 0;
                    for (var j = i; j >= i - min; j--) {
                        currWidth += self.columns[j].drawnWidth;
                    }
                    if (currWidth < viewport) {
                        min++;
                    }
                }
            });
            return min;
        };
        Grid.prototype.getBodyHeight = function getBodyHeight() {
            var bodyHeight = this.getViewportHeight();
            return bodyHeight;
        };
        Grid.prototype.getViewportHeight = function getViewportHeight() {
            var self = this;
            var viewPortHeight = this.gridHeight - this.headerHeight - this.footerHeight;
            var adjustment = self.getViewportAdjustment();
            viewPortHeight = viewPortHeight + adjustment.height;
            return viewPortHeight;
        };
        Grid.prototype.getViewportWidth = function getViewportWidth() {
            var self = this;
            var viewPortWidth = this.gridWidth;
            var adjustment = self.getViewportAdjustment();
            viewPortWidth = viewPortWidth + adjustment.width;
            return viewPortWidth;
        };
        Grid.prototype.getHeaderViewportWidth = function getHeaderViewportWidth() {
            var viewPortWidth = this.getViewportWidth();
            return viewPortWidth;
        };
        Grid.prototype.addVerticalScrollSync = function(containerId, callBackFn) {
            this.verticalScrollSyncCallBackFns[containerId] = callBackFn;
        };
        Grid.prototype.addHorizontalScrollSync = function(containerId, callBackFn) {
            this.horizontalScrollSyncCallBackFns[containerId] = callBackFn;
        };
        Grid.prototype.scrollContainers = function(sourceContainerId, scrollEvent) {
            if (scrollEvent.y) {
                var verts = [ "body", "left", "right" ];
                this.flagScrollingVertically(scrollEvent);
                if (sourceContainerId === "body") {
                    verts = [ "left", "right" ];
                } else if (sourceContainerId === "left") {
                    verts = [ "body", "right" ];
                } else if (sourceContainerId === "right") {
                    verts = [ "body", "left" ];
                }
                for (var i = 0; i < verts.length; i++) {
                    var id = verts[i];
                    if (this.verticalScrollSyncCallBackFns[id]) {
                        this.verticalScrollSyncCallBackFns[id](scrollEvent);
                    }
                }
            }
            if (scrollEvent.x) {
                var horizs = [ "body", "bodyheader", "bodyfooter" ];
                this.flagScrollingHorizontally(scrollEvent);
                if (sourceContainerId === "body") {
                    horizs = [ "bodyheader", "bodyfooter" ];
                }
                for (var j = 0; j < horizs.length; j++) {
                    var idh = horizs[j];
                    if (this.horizontalScrollSyncCallBackFns[idh]) {
                        this.horizontalScrollSyncCallBackFns[idh](scrollEvent);
                    }
                }
            }
        };
        Grid.prototype.registerViewportAdjuster = function registerViewportAdjuster(func) {
            this.viewportAdjusters.push(func);
        };
        Grid.prototype.removeViewportAdjuster = function registerViewportAdjuster(func) {
            var idx = this.viewportAdjusters.indexOf(func);
            if (typeof idx !== "undefined" && idx !== undefined) {
                this.viewportAdjusters.splice(idx, 1);
            }
        };
        Grid.prototype.getViewportAdjustment = function getViewportAdjustment() {
            var self = this;
            var adjustment = {
                "height": 0,
                "width": 0
            };
            self.viewportAdjusters.forEach(function(func) {
                adjustment = func.call(this, adjustment);
            });
            return adjustment;
        };
        Grid.prototype.getVisibleRowCount = function getVisibleRowCount() {
            return this.renderContainers.body.visibleRowCache.length;
        };
        Grid.prototype.getVisibleRows = function getVisibleRows() {
            return this.renderContainers.body.visibleRowCache;
        };
        Grid.prototype.getVisibleColumnCount = function getVisibleColumnCount() {
            return this.renderContainers.body.visibleColumnCache.length;
        };
        Grid.prototype.searchRows = function searchRows(renderableRows) {
            return rowSearcher.search(this, renderableRows, this.columns);
        };
        Grid.prototype.sortByColumn = function sortByColumn(renderableRows) {
            return rowSorter.sort(this, renderableRows, this.columns);
        };
        Grid.prototype.getCellValue = function getCellValue(row, col) {
            if (typeof row.entity["$$" + col.uid] !== "undefined") {
                return row.entity["$$" + col.uid].rendered;
            } else if (this.options.flatEntityAccess && typeof col.field !== "undefined") {
                return row.entity[col.field];
            } else {
                if (!col.cellValueGetterCache) {
                    col.cellValueGetterCache = $parse(row.getEntityQualifiedColField(col));
                }
                return col.cellValueGetterCache(row);
            }
        };
        Grid.prototype.getCellDisplayValue = function getCellDisplayValue(row, col) {
            if (!col.cellDisplayGetterCache) {
                var custom_filter = col.cellFilter ? " | " + col.cellFilter : "";
                if (typeof row.entity["$$" + col.uid] !== "undefined") {
                    col.cellDisplayGetterCache = $parse(row.entity["$$" + col.uid].rendered + custom_filter);
                } else if (this.options.flatEntityAccess && typeof col.field !== "undefined") {
                    col.cellDisplayGetterCache = $parse(row.entity[col.field] + custom_filter);
                } else {
                    col.cellDisplayGetterCache = $parse(row.getEntityQualifiedColField(col) + custom_filter);
                }
            }
            return col.cellDisplayGetterCache(row);
        };
        Grid.prototype.getNextColumnSortPriority = function getNextColumnSortPriority() {
            var self = this, p = 0;
            self.columns.forEach(function(col) {
                if (col.sort && col.sort.priority !== undefined && col.sort.priority >= p) {
                    p = col.sort.priority + 1;
                }
            });
            return p;
        };
        Grid.prototype.resetColumnSorting = function resetColumnSorting(excludeCol) {
            var self = this;
            self.columns.forEach(function(col) {
                if (col !== excludeCol && !col.suppressRemoveSort) {
                    col.sort = {};
                }
            });
        };
        Grid.prototype.getColumnSorting = function getColumnSorting() {
            var self = this;
            var sortedCols = [], myCols;
            myCols = self.columns.slice(0);
            myCols.sort(rowSorter.prioritySort).forEach(function(col) {
                if (col.sort && typeof col.sort.direction !== "undefined" && col.sort.direction && (col.sort.direction === uiGridConstants.ASC || col.sort.direction === uiGridConstants.DESC)) {
                    sortedCols.push(col);
                }
            });
            return sortedCols;
        };
        Grid.prototype.sortColumn = function sortColumn(column, directionOrAdd, add) {
            var self = this, direction = null;
            if (typeof column === "undefined" || !column) {
                throw new Error("No column parameter provided");
            }
            if (typeof directionOrAdd === "boolean") {
                add = directionOrAdd;
            } else {
                direction = directionOrAdd;
            }
            if (!add) {
                self.resetColumnSorting(column);
                column.sort.priority = undefined;
                column.sort.priority = self.getNextColumnSortPriority();
            } else if (!column.sort.priority) {
                column.sort.priority = self.getNextColumnSortPriority();
            }
            if (!direction) {
                var i = column.sortDirectionCycle.indexOf(column.sort.direction ? column.sort.direction : null);
                i = (i + 1) % column.sortDirectionCycle.length;
                if (column.colDef && column.suppressRemoveSort && !column.sortDirectionCycle[i]) {
                    i = (i + 1) % column.sortDirectionCycle.length;
                }
                if (column.sortDirectionCycle[i]) {
                    column.sort.direction = column.sortDirectionCycle[i];
                } else {
                    column.sort = {};
                }
            } else {
                column.sort.direction = direction;
            }
            self.api.core.raise.sortChanged(self, self.getColumnSorting());
            return $q.when(column);
        };
        Grid.prototype.renderingComplete = function() {
            if (angular.isFunction(this.options.onRegisterApi)) {
                this.options.onRegisterApi(this.api);
            }
            this.api.core.raise.renderingComplete(this.api);
        };
        Grid.prototype.createRowHashMap = function createRowHashMap() {
            var self = this;
            var hashMap = new RowHashMap();
            hashMap.grid = self;
            return hashMap;
        };
        Grid.prototype.refresh = function refresh(rowsAltered) {
            var self = this;
            var p1 = self.processRowsProcessors(self.rows).then(function(renderableRows) {
                self.setVisibleRows(renderableRows);
            });
            var p2 = self.processColumnsProcessors(self.columns).then(function(renderableColumns) {
                self.setVisibleColumns(renderableColumns);
            });
            return $q.all([ p1, p2 ]).then(function() {
                self.redrawInPlace(rowsAltered);
                self.refreshCanvas(true);
            });
        };
        Grid.prototype.refreshRows = function refreshRows() {
            var self = this;
            return self.processRowsProcessors(self.rows).then(function(renderableRows) {
                self.setVisibleRows(renderableRows);
                self.redrawInPlace();
                self.refreshCanvas(true);
            });
        };
        Grid.prototype.refreshCanvas = function(buildStyles) {
            var self = this;
            if (buildStyles) {
                self.buildStyles();
            }
            var p = $q.defer();
            var containerHeadersToRecalc = [];
            for (var containerId in self.renderContainers) {
                if (self.renderContainers.hasOwnProperty(containerId)) {
                    var container = self.renderContainers[containerId];
                    if (container.canvasWidth === null || isNaN(container.canvasWidth)) {
                        continue;
                    }
                    if (container.header || container.headerCanvas) {
                        container.explicitHeaderHeight = container.explicitHeaderHeight || null;
                        container.explicitHeaderCanvasHeight = container.explicitHeaderCanvasHeight || null;
                        containerHeadersToRecalc.push(container);
                    }
                }
            }
            if (containerHeadersToRecalc.length > 0) {
                if (buildStyles) {
                    self.buildStyles();
                }
                $timeout(function() {
                    var rebuildStyles = false;
                    var maxHeaderHeight = 0;
                    var maxHeaderCanvasHeight = 0;
                    var i, container;
                    var getHeight = function(oldVal, newVal) {
                        if (oldVal !== newVal) {
                            rebuildStyles = true;
                        }
                        return newVal;
                    };
                    for (i = 0; i < containerHeadersToRecalc.length; i++) {
                        container = containerHeadersToRecalc[i];
                        if (container.canvasWidth === null || isNaN(container.canvasWidth)) {
                            continue;
                        }
                        if (container.header) {
                            var headerHeight = container.headerHeight = getHeight(container.headerHeight, parseInt(gridUtil.outerElementHeight(container.header), 10));
                            var topBorder = gridUtil.getBorderSize(container.header, "top");
                            var bottomBorder = gridUtil.getBorderSize(container.header, "bottom");
                            var innerHeaderHeight = parseInt(headerHeight - topBorder - bottomBorder, 10);
                            innerHeaderHeight = innerHeaderHeight < 0 ? 0 : innerHeaderHeight;
                            container.innerHeaderHeight = innerHeaderHeight;
                            if (!container.explicitHeaderHeight && innerHeaderHeight > maxHeaderHeight) {
                                maxHeaderHeight = innerHeaderHeight;
                            }
                        }
                        if (container.headerCanvas) {
                            var headerCanvasHeight = container.headerCanvasHeight = getHeight(container.headerCanvasHeight, parseInt(gridUtil.outerElementHeight(container.headerCanvas), 10));
                            if (!container.explicitHeaderCanvasHeight && headerCanvasHeight > maxHeaderCanvasHeight) {
                                maxHeaderCanvasHeight = headerCanvasHeight;
                            }
                        }
                    }
                    for (i = 0; i < containerHeadersToRecalc.length; i++) {
                        container = containerHeadersToRecalc[i];
                        if (maxHeaderHeight > 0 && typeof container.headerHeight !== "undefined" && container.headerHeight !== null && (container.explicitHeaderHeight || container.headerHeight < maxHeaderHeight)) {
                            container.explicitHeaderHeight = getHeight(container.explicitHeaderHeight, maxHeaderHeight);
                        }
                        if (maxHeaderCanvasHeight > 0 && typeof container.headerCanvasHeight !== "undefined" && container.headerCanvasHeight !== null && (container.explicitHeaderCanvasHeight || container.headerCanvasHeight < maxHeaderCanvasHeight)) {
                            container.explicitHeaderCanvasHeight = getHeight(container.explicitHeaderCanvasHeight, maxHeaderCanvasHeight);
                        }
                    }
                    if (buildStyles && rebuildStyles) {
                        self.buildStyles();
                    }
                    p.resolve();
                });
            } else {
                $timeout(function() {
                    p.resolve();
                });
            }
            return p.promise;
        };
        Grid.prototype.redrawInPlace = function redrawInPlace(rowsAdded) {
            var self = this;
            for (var i in self.renderContainers) {
                var container = self.renderContainers[i];
                if (rowsAdded) {
                    container.adjustRows(container.prevScrollTop, null);
                    container.adjustColumns(container.prevScrollLeft, null);
                } else {
                    container.adjustRows(null, container.prevScrolltopPercentage);
                    container.adjustColumns(null, container.prevScrollleftPercentage);
                }
            }
        };
        Grid.prototype.hasLeftContainerColumns = function() {
            return this.hasLeftContainer() && this.renderContainers.left.renderedColumns.length > 0;
        };
        Grid.prototype.hasRightContainerColumns = function() {
            return this.hasRightContainer() && this.renderContainers.right.renderedColumns.length > 0;
        };
        Grid.prototype.scrollToIfNecessary = function(gridRow, gridCol) {
            var self = this;
            var scrollEvent = new ScrollEvent(self, "uiGrid.scrollToIfNecessary");
            var visRowCache = self.renderContainers.body.visibleRowCache;
            var visColCache = self.renderContainers.body.visibleColumnCache;
            var topBound = self.renderContainers.body.prevScrollTop + self.headerHeight;
            topBound = topBound < 0 ? 0 : topBound;
            var leftBound = self.renderContainers.body.prevScrollLeft;
            var bottomBound = self.renderContainers.body.prevScrollTop + self.gridHeight - self.renderContainers.body.headerHeight - self.footerHeight - self.scrollbarWidth;
            var rightBound = self.renderContainers.body.prevScrollLeft + Math.ceil(self.renderContainers.body.getViewportWidth());
            if (gridRow !== null) {
                var seekRowIndex = visRowCache.indexOf(gridRow);
                var scrollLength = self.renderContainers.body.getCanvasHeight() - self.renderContainers.body.getViewportHeight();
                var pixelsToSeeRow = seekRowIndex * self.options.rowHeight + self.headerHeight;
                pixelsToSeeRow = pixelsToSeeRow < 0 ? 0 : pixelsToSeeRow;
                var scrollPixels, percentage;
                if (pixelsToSeeRow < topBound) {
                    scrollPixels = self.renderContainers.body.prevScrollTop - (topBound - pixelsToSeeRow);
                    percentage = scrollPixels / scrollLength;
                    scrollEvent.y = {
                        "percentage": percentage
                    };
                } else if (pixelsToSeeRow > bottomBound) {
                    scrollPixels = pixelsToSeeRow - bottomBound + self.renderContainers.body.prevScrollTop;
                    percentage = scrollPixels / scrollLength;
                    scrollEvent.y = {
                        "percentage": percentage
                    };
                }
            }
            if (gridCol !== null) {
                var seekColumnIndex = visColCache.indexOf(gridCol);
                var horizScrollLength = self.renderContainers.body.getCanvasWidth() - self.renderContainers.body.getViewportWidth();
                var columnLeftEdge = 0;
                for (var i = 0; i < seekColumnIndex; i++) {
                    var col = visColCache[i];
                    columnLeftEdge += col.drawnWidth;
                }
                columnLeftEdge = columnLeftEdge < 0 ? 0 : columnLeftEdge;
                var columnRightEdge = columnLeftEdge + gridCol.drawnWidth;
                columnRightEdge = columnRightEdge < 0 ? 0 : columnRightEdge;
                var horizScrollPixels, horizPercentage;
                if (columnLeftEdge < leftBound) {
                    horizScrollPixels = self.renderContainers.body.prevScrollLeft - (leftBound - columnLeftEdge);
                    horizPercentage = horizScrollPixels / horizScrollLength;
                    horizPercentage = horizPercentage > 1 ? 1 : horizPercentage;
                    scrollEvent.x = {
                        "percentage": horizPercentage
                    };
                } else if (columnRightEdge > rightBound) {
                    horizScrollPixels = columnRightEdge - rightBound + self.renderContainers.body.prevScrollLeft;
                    horizPercentage = horizScrollPixels / horizScrollLength;
                    horizPercentage = horizPercentage > 1 ? 1 : horizPercentage;
                    scrollEvent.x = {
                        "percentage": horizPercentage
                    };
                }
            }
            var deferred = $q.defer();
            if (scrollEvent.y || scrollEvent.x) {
                scrollEvent.withDelay = false;
                self.scrollContainers("", scrollEvent);
                var dereg = self.api.core.on.scrollEnd(null, function() {
                    deferred.resolve(scrollEvent);
                    dereg();
                });
            } else {
                deferred.resolve();
            }
            return deferred.promise;
        };
        Grid.prototype.scrollTo = function(rowEntity, colDef) {
            var gridRow = null, gridCol = null;
            if (rowEntity !== null && typeof rowEntity !== "undefined") {
                gridRow = this.getRow(rowEntity);
            }
            if (colDef !== null && typeof colDef !== "undefined") {
                gridCol = this.getColumn(colDef.name ? colDef.name : colDef.field);
            }
            return this.scrollToIfNecessary(gridRow, gridCol);
        };
        Grid.prototype.clearAllFilters = function clearAllFilters(refreshRows, clearConditions, clearFlags) {
            if (refreshRows === undefined) {
                refreshRows = true;
            }
            if (clearConditions === undefined) {
                clearConditions = false;
            }
            if (clearFlags === undefined) {
                clearFlags = false;
            }
            this.columns.forEach(function(column) {
                column.filters.forEach(function(filter) {
                    filter.term = undefined;
                    if (clearConditions) {
                        filter.condition = undefined;
                    }
                    if (clearFlags) {
                        filter.flags = undefined;
                    }
                });
            });
            if (refreshRows) {
                return this.refreshRows();
            }
        };
        function RowHashMap() {}
        RowHashMap.prototype = {
            "put": function(key, value) {
                this[this.grid.options.rowIdentity(key)] = value;
            },
            "get": function(key) {
                return this[this.grid.options.rowIdentity(key)];
            },
            "remove": function(key) {
                var value = this[key = this.grid.options.rowIdentity(key)];
                delete this[key];
                return value;
            }
        };
        return Grid;
    } ]);
})();

(function() {
    angular.module("ui.grid").factory("GridApi", [ "$q", "$rootScope", "gridUtil", "uiGridConstants", "GridRow", "uiGridGridMenuService", function($q, $rootScope, gridUtil, uiGridConstants, GridRow, uiGridGridMenuService) {
        var GridApi = function GridApi(grid) {
            this.grid = grid;
            this.listeners = [];
            this.registerEvent("core", "renderingComplete");
            this.registerEvent("core", "filterChanged");
            this.registerMethod("core", "setRowInvisible", GridRow.prototype.setRowInvisible);
            this.registerMethod("core", "clearRowInvisible", GridRow.prototype.clearRowInvisible);
            this.registerMethod("core", "getVisibleRows", this.grid.getVisibleRows);
            this.registerEvent("core", "rowsVisibleChanged");
            this.registerEvent("core", "rowsRendered");
            this.registerEvent("core", "scrollBegin");
            this.registerEvent("core", "scrollEnd");
            this.registerEvent("core", "canvasHeightChanged");
        };
        GridApi.prototype.suppressEvents = function(listenerFuncs, callBackFn) {
            var self = this;
            var listeners = angular.isArray(listenerFuncs) ? listenerFuncs : [ listenerFuncs ];
            var foundListeners = self.listeners.filter(function(listener) {
                return listeners.some(function(l) {
                    return listener.handler === l;
                });
            });
            foundListeners.forEach(function(l) {
                l.dereg();
            });
            callBackFn();
            foundListeners.forEach(function(l) {
                l.dereg = registerEventWithAngular(l.eventId, l.handler, self.grid, l._this);
            });
        };
        GridApi.prototype.registerEvent = function(featureName, eventName) {
            var self = this;
            if (!self[featureName]) {
                self[featureName] = {};
            }
            var feature = self[featureName];
            if (!feature.on) {
                feature.on = {};
                feature.raise = {};
            }
            var eventId = self.grid.id + featureName + eventName;
            feature.raise[eventName] = function() {
                $rootScope.$emit.apply($rootScope, [ eventId ].concat(Array.prototype.slice.call(arguments)));
            };
            feature.on[eventName] = function(scope, handler, _this) {
                if (scope !== null && typeof scope.$on === "undefined") {
                    gridUtil.logError("asked to listen on " + featureName + ".on." + eventName + " but scope wasn't passed in the input parameters.  It is legitimate to pass null, but you've passed something else, so you probably forgot to provide scope rather than did it deliberately, not registering");
                    return;
                }
                var deregAngularOn = registerEventWithAngular(eventId, handler, self.grid, _this);
                var listener = {
                    "handler": handler,
                    "dereg": deregAngularOn,
                    "eventId": eventId,
                    "scope": scope,
                    "_this": _this
                };
                self.listeners.push(listener);
                var removeListener = function() {
                    listener.dereg();
                    var index = self.listeners.indexOf(listener);
                    self.listeners.splice(index, 1);
                };
                if (scope) {
                    scope.$on("$destroy", function() {
                        removeListener();
                    });
                }
                return removeListener;
            };
        };
        function registerEventWithAngular(eventId, handler, grid, _this) {
            return $rootScope.$on(eventId, function(event) {
                var args = Array.prototype.slice.call(arguments);
                args.splice(0, 1);
                handler.apply(_this ? _this : grid.api, args);
            });
        }
        GridApi.prototype.registerEventsFromObject = function(eventObjectMap) {
            var self = this;
            var features = [];
            angular.forEach(eventObjectMap, function(featProp, featPropName) {
                var feature = {
                    "name": featPropName,
                    "events": []
                };
                angular.forEach(featProp, function(prop, propName) {
                    feature.events.push(propName);
                });
                features.push(feature);
            });
            features.forEach(function(feature) {
                feature.events.forEach(function(event) {
                    self.registerEvent(feature.name, event);
                });
            });
        };
        GridApi.prototype.registerMethod = function(featureName, methodName, callBackFn, _this) {
            if (!this[featureName]) {
                this[featureName] = {};
            }
            var feature = this[featureName];
            feature[methodName] = gridUtil.createBoundedWrapper(_this || this.grid, callBackFn);
        };
        GridApi.prototype.registerMethodsFromObject = function(methodMap, _this) {
            var self = this;
            var features = [];
            angular.forEach(methodMap, function(featProp, featPropName) {
                var feature = {
                    "name": featPropName,
                    "methods": []
                };
                angular.forEach(featProp, function(prop, propName) {
                    feature.methods.push({
                        "name": propName,
                        "fn": prop
                    });
                });
                features.push(feature);
            });
            features.forEach(function(feature) {
                feature.methods.forEach(function(method) {
                    self.registerMethod(feature.name, method.name, method.fn, _this);
                });
            });
        };
        return GridApi;
    } ]);
})();

(function() {
    angular.module("ui.grid").factory("GridColumn", [ "gridUtil", "uiGridConstants", "i18nService", function(gridUtil, uiGridConstants, i18nService) {
        function GridColumn(colDef, uid, grid) {
            var self = this;
            self.grid = grid;
            self.uid = uid;
            self.updateColumnDef(colDef, true);
            self.aggregationValue = undefined;
            self.updateAggregationValue = function() {
                if (!self.aggregationType) {
                    self.aggregationValue = undefined;
                    return;
                }
                var result = 0;
                var visibleRows = self.grid.getVisibleRows();
                var cellValues = function() {
                    var values = [];
                    visibleRows.forEach(function(row) {
                        var cellValue = self.grid.getCellValue(row, self);
                        var cellNumber = Number(cellValue);
                        if (!isNaN(cellNumber)) {
                            values.push(cellNumber);
                        }
                    });
                    return values;
                };
                if (angular.isFunction(self.aggregationType)) {
                    self.aggregationValue = self.aggregationType(visibleRows, self);
                } else if (self.aggregationType === uiGridConstants.aggregationTypes.count) {
                    self.aggregationValue = self.grid.getVisibleRowCount();
                } else if (self.aggregationType === uiGridConstants.aggregationTypes.sum) {
                    cellValues().forEach(function(value) {
                        result += value;
                    });
                    self.aggregationValue = result;
                } else if (self.aggregationType === uiGridConstants.aggregationTypes.avg) {
                    cellValues().forEach(function(value) {
                        result += value;
                    });
                    result = result / cellValues().length;
                    self.aggregationValue = result;
                } else if (self.aggregationType === uiGridConstants.aggregationTypes.min) {
                    self.aggregationValue = Math.min.apply(null, cellValues());
                } else if (self.aggregationType === uiGridConstants.aggregationTypes.max) {
                    self.aggregationValue = Math.max.apply(null, cellValues());
                } else {
                    self.aggregationValue = "\xa0";
                }
            };
            this.getAggregationValue = function() {
                return self.aggregationValue;
            };
        }
        GridColumn.prototype.hideColumn = function() {
            this.colDef.visible = false;
        };
        GridColumn.prototype.setPropertyOrDefault = function(colDef, propName, defaultValue) {
            var self = this;
            if (typeof colDef[propName] !== "undefined" && colDef[propName]) {
                self[propName] = colDef[propName];
            } else if (typeof self[propName] !== "undefined") {
                self[propName] = self[propName];
            } else {
                self[propName] = defaultValue ? defaultValue : {};
            }
        };
        GridColumn.prototype.updateColumnDef = function(colDef, isNew) {
            var self = this;
            self.colDef = colDef;
            if (colDef.name === undefined) {
                throw new Error("colDef.name is required for column at index " + self.grid.options.columnDefs.indexOf(colDef));
            }
            self.displayName = colDef.displayName === undefined ? gridUtil.readableColumnName(colDef.name) : colDef.displayName;
            if (!angular.isNumber(self.width) || !self.hasCustomWidth || colDef.allowCustomWidthOverride) {
                var colDefWidth = colDef.width;
                var parseErrorMsg = "Cannot parse column width '" + colDefWidth + "' for column named '" + colDef.name + "'";
                self.hasCustomWidth = false;
                if (!angular.isString(colDefWidth) && !angular.isNumber(colDefWidth)) {
                    self.width = "*";
                } else if (angular.isString(colDefWidth)) {
                    if (gridUtil.endsWith(colDefWidth, "%")) {
                        var percentStr = colDefWidth.replace(/%/g, "");
                        var percent = parseInt(percentStr, 10);
                        if (isNaN(percent)) {
                            throw new Error(parseErrorMsg);
                        }
                        self.width = colDefWidth;
                    } else if (colDefWidth.match(/^(\d+)$/)) {
                        self.width = parseInt(colDefWidth.match(/^(\d+)$/)[1], 10);
                    } else if (colDefWidth.match(/^\*+$/)) {
                        self.width = colDefWidth;
                    } else {
                        throw new Error(parseErrorMsg);
                    }
                } else {
                    self.width = colDefWidth;
                }
            }
            [ "minWidth", "maxWidth" ].forEach(function(name) {
                var minOrMaxWidth = colDef[name];
                var parseErrorMsg = "Cannot parse column " + name + " '" + minOrMaxWidth + "' for column named '" + colDef.name + "'";
                if (!angular.isString(minOrMaxWidth) && !angular.isNumber(minOrMaxWidth)) {
                    self[name] = name === "minWidth" ? 30 : 9e3;
                } else if (angular.isString(minOrMaxWidth)) {
                    if (minOrMaxWidth.match(/^(\d+)$/)) {
                        self[name] = parseInt(minOrMaxWidth.match(/^(\d+)$/)[1], 10);
                    } else {
                        throw new Error(parseErrorMsg);
                    }
                } else {
                    self[name] = minOrMaxWidth;
                }
            });
            self.field = colDef.field === undefined ? colDef.name : colDef.field;
            if (typeof self.field !== "string") {
                gridUtil.logError("Field is not a string, this is likely to break the code, Field is: " + self.field);
            }
            self.name = colDef.name;
            self.displayName = colDef.displayName === undefined ? gridUtil.readableColumnName(colDef.name) : colDef.displayName;
            self.aggregationType = angular.isDefined(colDef.aggregationType) ? colDef.aggregationType : null;
            self.footerCellTemplate = angular.isDefined(colDef.footerCellTemplate) ? colDef.footerCellTemplate : null;
            if (typeof colDef.cellTooltip === "undefined" || colDef.cellTooltip === false) {
                self.cellTooltip = false;
            } else if (colDef.cellTooltip === true) {
                self.cellTooltip = function(row, col) {
                    return self.grid.getCellValue(row, col);
                };
            } else if (typeof colDef.cellTooltip === "function") {
                self.cellTooltip = colDef.cellTooltip;
            } else {
                self.cellTooltip = function(row, col) {
                    return col.colDef.cellTooltip;
                };
            }
            if (typeof colDef.headerTooltip === "undefined" || colDef.headerTooltip === false) {
                self.headerTooltip = false;
            } else if (colDef.headerTooltip === true) {
                self.headerTooltip = function(col) {
                    return col.displayName;
                };
            } else if (typeof colDef.headerTooltip === "function") {
                self.headerTooltip = colDef.headerTooltip;
            } else {
                self.headerTooltip = function(col) {
                    return col.colDef.headerTooltip;
                };
            }
            self.footerCellClass = colDef.footerCellClass;
            self.cellClass = colDef.cellClass;
            self.headerCellClass = colDef.headerCellClass;
            self.cellFilter = colDef.cellFilter ? colDef.cellFilter : "";
            self.sortCellFiltered = colDef.sortCellFiltered ? true : false;
            self.filterCellFiltered = colDef.filterCellFiltered ? true : false;
            self.headerCellFilter = colDef.headerCellFilter ? colDef.headerCellFilter : "";
            self.footerCellFilter = colDef.footerCellFilter ? colDef.footerCellFilter : "";
            self.visible = gridUtil.isNullOrUndefined(colDef.visible) || colDef.visible;
            self.headerClass = colDef.headerClass;
            self.enableSorting = typeof colDef.enableSorting !== "undefined" ? colDef.enableSorting : true;
            self.sortingAlgorithm = colDef.sortingAlgorithm;
            self.sortDirectionCycle = typeof colDef.sortDirectionCycle !== "undefined" ? colDef.sortDirectionCycle : [ null, uiGridConstants.ASC, uiGridConstants.DESC ];
            if (typeof self.suppressRemoveSort === "undefined") {
                self.suppressRemoveSort = typeof colDef.suppressRemoveSort !== "undefined" ? colDef.suppressRemoveSort : false;
            }
            self.enableFiltering = typeof colDef.enableFiltering !== "undefined" ? colDef.enableFiltering : true;
            self.setPropertyOrDefault(colDef, "menuItems", []);
            if (isNew) {
                self.setPropertyOrDefault(colDef, "sort");
            }
            var defaultFilters = [];
            if (colDef.filter) {
                defaultFilters.push(colDef.filter);
            } else if (colDef.filters) {
                defaultFilters = colDef.filters;
            } else {
                defaultFilters.push({});
            }
            if (isNew) {
                self.setPropertyOrDefault(colDef, "filter");
                self.setPropertyOrDefault(colDef, "filters", defaultFilters);
            } else if (self.filters.length === defaultFilters.length) {
                self.filters.forEach(function(filter, index) {
                    if (typeof defaultFilters[index].placeholder !== "undefined") {
                        filter.placeholder = defaultFilters[index].placeholder;
                    }
                    if (typeof defaultFilters[index].ariaLabel !== "undefined") {
                        filter.ariaLabel = defaultFilters[index].ariaLabel;
                    }
                    if (typeof defaultFilters[index].flags !== "undefined") {
                        filter.flags = defaultFilters[index].flags;
                    }
                    if (typeof defaultFilters[index].type !== "undefined") {
                        filter.type = defaultFilters[index].type;
                    }
                    if (typeof defaultFilters[index].selectOptions !== "undefined") {
                        filter.selectOptions = defaultFilters[index].selectOptions;
                    }
                });
            }
        };
        GridColumn.prototype.unsort = function() {
            this.sort = {};
            this.grid.api.core.raise.sortChanged(this.grid, this.grid.getColumnSorting());
        };
        GridColumn.prototype.getColClass = function(prefixDot) {
            var cls = uiGridConstants.COL_CLASS_PREFIX + this.uid;
            return prefixDot ? "." + cls : cls;
        };
        GridColumn.prototype.isPinnedLeft = function() {
            return this.renderContainer === "left";
        };
        GridColumn.prototype.isPinnedRight = function() {
            return this.renderContainer === "right";
        };
        GridColumn.prototype.getColClassDefinition = function() {
            return " .grid" + this.grid.id + " " + this.getColClass(true) + " { min-width: " + this.drawnWidth + "px; max-width: " + this.drawnWidth + "px; }";
        };
        GridColumn.prototype.getRenderContainer = function getRenderContainer() {
            var self = this;
            var containerId = self.renderContainer;
            if (containerId === null || containerId === "" || containerId === undefined) {
                containerId = "body";
            }
            return self.grid.renderContainers[containerId];
        };
        GridColumn.prototype.showColumn = function() {
            this.colDef.visible = true;
        };
        GridColumn.prototype.getAggregationText = function() {
            var self = this;
            if (self.colDef.aggregationHideLabel) {
                return "";
            } else if (self.colDef.aggregationLabel) {
                return self.colDef.aggregationLabel;
            } else {
                switch (self.colDef.aggregationType) {
                  case uiGridConstants.aggregationTypes.count:
                    return i18nService.getSafeText("aggregation.count");

                  case uiGridConstants.aggregationTypes.sum:
                    return i18nService.getSafeText("aggregation.sum");

                  case uiGridConstants.aggregationTypes.avg:
                    return i18nService.getSafeText("aggregation.avg");

                  case uiGridConstants.aggregationTypes.min:
                    return i18nService.getSafeText("aggregation.min");

                  case uiGridConstants.aggregationTypes.max:
                    return i18nService.getSafeText("aggregation.max");

                  default:
                    return "";
                }
            }
        };
        GridColumn.prototype.getCellTemplate = function() {
            var self = this;
            return self.cellTemplatePromise;
        };
        GridColumn.prototype.getCompiledElementFn = function() {
            var self = this;
            return self.compiledElementFnDefer.promise;
        };
        return GridColumn;
    } ]);
})();

(function() {
    angular.module("ui.grid").factory("GridOptions", [ "gridUtil", "uiGridConstants", function(gridUtil, uiGridConstants) {
        return {
            "initialize": function(baseOptions) {
                baseOptions.onRegisterApi = baseOptions.onRegisterApi || angular.noop();
                baseOptions.data = baseOptions.data || [];
                baseOptions.columnDefs = baseOptions.columnDefs || [];
                baseOptions.excludeProperties = baseOptions.excludeProperties || [ "$$hashKey" ];
                baseOptions.enableRowHashing = baseOptions.enableRowHashing !== false;
                baseOptions.rowIdentity = baseOptions.rowIdentity || function rowIdentity(row) {
                    return gridUtil.hashKey(row);
                };
                baseOptions.getRowIdentity = baseOptions.getRowIdentity || function getRowIdentity(row) {
                    return row.$$hashKey;
                };
                baseOptions.flatEntityAccess = baseOptions.flatEntityAccess === true;
                baseOptions.showHeader = typeof baseOptions.showHeader !== "undefined" ? baseOptions.showHeader : true;
                if (!baseOptions.showHeader) {
                    baseOptions.headerRowHeight = 0;
                } else {
                    baseOptions.headerRowHeight = typeof baseOptions.headerRowHeight !== "undefined" ? baseOptions.headerRowHeight : 30;
                }
                baseOptions.rowHeight = baseOptions.rowHeight || 30;
                baseOptions.minRowsToShow = typeof baseOptions.minRowsToShow !== "undefined" ? baseOptions.minRowsToShow : 10;
                baseOptions.showGridFooter = baseOptions.showGridFooter === true;
                baseOptions.showColumnFooter = baseOptions.showColumnFooter === true;
                baseOptions.columnFooterHeight = typeof baseOptions.columnFooterHeight !== "undefined" ? baseOptions.columnFooterHeight : 30;
                baseOptions.gridFooterHeight = typeof baseOptions.gridFooterHeight !== "undefined" ? baseOptions.gridFooterHeight : 30;
                baseOptions.columnWidth = typeof baseOptions.columnWidth !== "undefined" ? baseOptions.columnWidth : 50;
                baseOptions.maxVisibleColumnCount = typeof baseOptions.maxVisibleColumnCount !== "undefined" ? baseOptions.maxVisibleColumnCount : 200;
                baseOptions.virtualizationThreshold = typeof baseOptions.virtualizationThreshold !== "undefined" ? baseOptions.virtualizationThreshold : 20;
                baseOptions.columnVirtualizationThreshold = typeof baseOptions.columnVirtualizationThreshold !== "undefined" ? baseOptions.columnVirtualizationThreshold : 10;
                baseOptions.excessRows = typeof baseOptions.excessRows !== "undefined" ? baseOptions.excessRows : 4;
                baseOptions.scrollThreshold = typeof baseOptions.scrollThreshold !== "undefined" ? baseOptions.scrollThreshold : 4;
                baseOptions.excessColumns = typeof baseOptions.excessColumns !== "undefined" ? baseOptions.excessColumns : 4;
                baseOptions.horizontalScrollThreshold = typeof baseOptions.horizontalScrollThreshold !== "undefined" ? baseOptions.horizontalScrollThreshold : 2;
                baseOptions.aggregationCalcThrottle = typeof baseOptions.aggregationCalcThrottle !== "undefined" ? baseOptions.aggregationCalcThrottle : 500;
                baseOptions.wheelScrollThrottle = typeof baseOptions.wheelScrollThrottle !== "undefined" ? baseOptions.wheelScrollThrottle : 70;
                baseOptions.scrollDebounce = typeof baseOptions.scrollDebounce !== "undefined" ? baseOptions.scrollDebounce : 300;
                baseOptions.enableSorting = baseOptions.enableSorting !== false;
                baseOptions.enableFiltering = baseOptions.enableFiltering === true;
                baseOptions.enableColumnMenus = baseOptions.enableColumnMenus !== false;
                baseOptions.enableVerticalScrollbar = typeof baseOptions.enableVerticalScrollbar !== "undefined" ? baseOptions.enableVerticalScrollbar : uiGridConstants.scrollbars.ALWAYS;
                baseOptions.enableHorizontalScrollbar = typeof baseOptions.enableHorizontalScrollbar !== "undefined" ? baseOptions.enableHorizontalScrollbar : uiGridConstants.scrollbars.ALWAYS;
                baseOptions.enableMinHeightCheck = baseOptions.enableMinHeightCheck !== false;
                baseOptions.minimumColumnSize = typeof baseOptions.minimumColumnSize !== "undefined" ? baseOptions.minimumColumnSize : 10;
                baseOptions.rowEquality = baseOptions.rowEquality || function(entityA, entityB) {
                    return entityA === entityB;
                };
                baseOptions.headerTemplate = baseOptions.headerTemplate || null;
                baseOptions.footerTemplate = baseOptions.footerTemplate || "ui-grid/ui-grid-footer";
                baseOptions.gridFooterTemplate = baseOptions.gridFooterTemplate || "ui-grid/ui-grid-grid-footer";
                baseOptions.rowTemplate = baseOptions.rowTemplate || "ui-grid/ui-grid-row";
                baseOptions.appScopeProvider = baseOptions.appScopeProvider || null;
                return baseOptions;
            }
        };
    } ]);
})();

(function() {
    angular.module("ui.grid").factory("GridRenderContainer", [ "gridUtil", "uiGridConstants", function(gridUtil, uiGridConstants) {
        function GridRenderContainer(name, grid, options) {
            var self = this;
            self.name = name;
            self.grid = grid;
            self.visibleRowCache = [];
            self.visibleColumnCache = [];
            self.renderedRows = [];
            self.renderedColumns = [];
            self.prevScrollTop = 0;
            self.prevScrolltopPercentage = 0;
            self.prevRowScrollIndex = 0;
            self.prevScrollLeft = 0;
            self.prevScrollleftPercentage = 0;
            self.prevColumnScrollIndex = 0;
            self.columnStyles = "";
            self.viewportAdjusters = [];
            self.hasHScrollbar = false;
            self.hasVScrollbar = false;
            self.canvasHeightShouldUpdate = true;
            self.$$canvasHeight = 0;
            if (options && angular.isObject(options)) {
                angular.extend(self, options);
            }
            grid.registerStyleComputation({
                "priority": 5,
                "func": function() {
                    self.updateColumnWidths();
                    return self.columnStyles;
                }
            });
        }
        GridRenderContainer.prototype.reset = function reset() {
            this.visibleColumnCache.length = 0;
            this.visibleRowCache.length = 0;
            this.renderedRows.length = 0;
            this.renderedColumns.length = 0;
        };
        GridRenderContainer.prototype.containsColumn = function(col) {
            return this.visibleColumnCache.indexOf(col) !== -1;
        };
        GridRenderContainer.prototype.minRowsToRender = function minRowsToRender() {
            var self = this;
            var minRows = 0;
            var rowAddedHeight = 0;
            var viewPortHeight = self.getViewportHeight();
            for (var i = self.visibleRowCache.length - 1; rowAddedHeight < viewPortHeight && i >= 0; i--) {
                rowAddedHeight += self.visibleRowCache[i].height;
                minRows++;
            }
            return minRows;
        };
        GridRenderContainer.prototype.minColumnsToRender = function minColumnsToRender() {
            var self = this;
            var viewportWidth = this.getViewportWidth();
            var min = 0;
            var totalWidth = 0;
            for (var i = 0; i < self.visibleColumnCache.length; i++) {
                var col = self.visibleColumnCache[i];
                if (totalWidth < viewportWidth) {
                    totalWidth += col.drawnWidth ? col.drawnWidth : 0;
                    min++;
                } else {
                    var currWidth = 0;
                    for (var j = i; j >= i - min; j--) {
                        currWidth += self.visibleColumnCache[j].drawnWidth ? self.visibleColumnCache[j].drawnWidth : 0;
                    }
                    if (currWidth < viewportWidth) {
                        min++;
                    }
                }
            }
            return min;
        };
        GridRenderContainer.prototype.getVisibleRowCount = function getVisibleRowCount() {
            return this.visibleRowCache.length;
        };
        GridRenderContainer.prototype.registerViewportAdjuster = function registerViewportAdjuster(func) {
            this.viewportAdjusters.push(func);
        };
        GridRenderContainer.prototype.removeViewportAdjuster = function removeViewportAdjuster(func) {
            var idx = this.viewportAdjusters.indexOf(func);
            if (idx > -1) {
                this.viewportAdjusters.splice(idx, 1);
            }
        };
        GridRenderContainer.prototype.getViewportAdjustment = function getViewportAdjustment() {
            var self = this;
            var adjustment = {
                "height": 0,
                "width": 0
            };
            self.viewportAdjusters.forEach(function(func) {
                adjustment = func.call(this, adjustment);
            });
            return adjustment;
        };
        GridRenderContainer.prototype.getMargin = function getMargin(side) {
            var self = this;
            var amount = 0;
            self.viewportAdjusters.forEach(function(func) {
                var adjustment = func.call(this, {
                    "height": 0,
                    "width": 0
                });
                if (adjustment.side && adjustment.side === side) {
                    amount += adjustment.width * -1;
                }
            });
            return amount;
        };
        GridRenderContainer.prototype.getViewportHeight = function getViewportHeight() {
            var self = this;
            var headerHeight = self.headerHeight ? self.headerHeight : self.grid.headerHeight;
            var viewPortHeight = self.grid.gridHeight - headerHeight - self.grid.footerHeight;
            var adjustment = self.getViewportAdjustment();
            viewPortHeight = viewPortHeight + adjustment.height;
            return viewPortHeight;
        };
        GridRenderContainer.prototype.getViewportWidth = function getViewportWidth() {
            var self = this;
            var viewportWidth = self.grid.gridWidth;
            var adjustment = self.getViewportAdjustment();
            viewportWidth = viewportWidth + adjustment.width;
            return viewportWidth;
        };
        GridRenderContainer.prototype.getHeaderViewportWidth = function getHeaderViewportWidth() {
            var self = this;
            var viewportWidth = this.getViewportWidth();
            return viewportWidth;
        };
        GridRenderContainer.prototype.getCanvasHeight = function getCanvasHeight() {
            var self = this;
            if (!self.canvasHeightShouldUpdate) {
                return self.$$canvasHeight;
            }
            var oldCanvasHeight = self.$$canvasHeight;
            self.$$canvasHeight = 0;
            self.visibleRowCache.forEach(function(row) {
                self.$$canvasHeight += row.height;
            });
            self.canvasHeightShouldUpdate = false;
            self.grid.api.core.raise.canvasHeightChanged(oldCanvasHeight, self.$$canvasHeight);
            return self.$$canvasHeight;
        };
        GridRenderContainer.prototype.getVerticalScrollLength = function getVerticalScrollLength() {
            return this.getCanvasHeight() - this.getViewportHeight() + this.grid.scrollbarHeight;
        };
        GridRenderContainer.prototype.getCanvasWidth = function getCanvasWidth() {
            var self = this;
            var ret = self.canvasWidth;
            return ret;
        };
        GridRenderContainer.prototype.setRenderedRows = function setRenderedRows(newRows) {
            this.renderedRows.length = newRows.length;
            for (var i = 0; i < newRows.length; i++) {
                this.renderedRows[i] = newRows[i];
            }
        };
        GridRenderContainer.prototype.setRenderedColumns = function setRenderedColumns(newColumns) {
            var self = this;
            this.renderedColumns.length = newColumns.length;
            for (var i = 0; i < newColumns.length; i++) {
                this.renderedColumns[i] = newColumns[i];
            }
            this.updateColumnOffset();
        };
        GridRenderContainer.prototype.updateColumnOffset = function updateColumnOffset() {
            var hiddenColumnsWidth = 0;
            for (var i = 0; i < this.currentFirstColumn; i++) {
                hiddenColumnsWidth += this.visibleColumnCache[i].drawnWidth;
            }
            this.columnOffset = hiddenColumnsWidth;
        };
        GridRenderContainer.prototype.scrollVertical = function(newScrollTop) {
            var vertScrollPercentage = -1;
            if (newScrollTop !== this.prevScrollTop) {
                var yDiff = newScrollTop - this.prevScrollTop;
                if (yDiff > 0) {
                    this.grid.scrollDirection = uiGridConstants.scrollDirection.DOWN;
                }
                if (yDiff < 0) {
                    this.grid.scrollDirection = uiGridConstants.scrollDirection.UP;
                }
                var vertScrollLength = this.getVerticalScrollLength();
                vertScrollPercentage = newScrollTop / vertScrollLength;
                if (vertScrollPercentage > 1) {
                    vertScrollPercentage = 1;
                }
                if (vertScrollPercentage < 0) {
                    vertScrollPercentage = 0;
                }
                this.adjustScrollVertical(newScrollTop, vertScrollPercentage);
                return vertScrollPercentage;
            }
        };
        GridRenderContainer.prototype.scrollHorizontal = function(newScrollLeft) {
            var horizScrollPercentage = -1;
            if (newScrollLeft !== this.prevScrollLeft) {
                var xDiff = newScrollLeft - this.prevScrollLeft;
                if (xDiff > 0) {
                    this.grid.scrollDirection = uiGridConstants.scrollDirection.RIGHT;
                }
                if (xDiff < 0) {
                    this.grid.scrollDirection = uiGridConstants.scrollDirection.LEFT;
                }
                var horizScrollLength = this.canvasWidth - this.getViewportWidth();
                if (horizScrollLength !== 0) {
                    horizScrollPercentage = newScrollLeft / horizScrollLength;
                } else {
                    horizScrollPercentage = 0;
                }
                this.adjustScrollHorizontal(newScrollLeft, horizScrollPercentage);
                return horizScrollPercentage;
            }
        };
        GridRenderContainer.prototype.adjustScrollVertical = function adjustScrollVertical(scrollTop, scrollPercentage, force) {
            if (this.prevScrollTop === scrollTop && !force) {
                return;
            }
            if (typeof scrollTop === "undefined" || scrollTop === undefined || scrollTop === null) {
                scrollTop = (this.getCanvasHeight() - this.getViewportHeight()) * scrollPercentage;
            }
            this.adjustRows(scrollTop, scrollPercentage, false);
            this.prevScrollTop = scrollTop;
            this.prevScrolltopPercentage = scrollPercentage;
            this.grid.queueRefresh();
        };
        GridRenderContainer.prototype.adjustScrollHorizontal = function adjustScrollHorizontal(scrollLeft, scrollPercentage, force) {
            if (this.prevScrollLeft === scrollLeft && !force) {
                return;
            }
            if (typeof scrollLeft === "undefined" || scrollLeft === undefined || scrollLeft === null) {
                scrollLeft = (this.getCanvasWidth() - this.getViewportWidth()) * scrollPercentage;
            }
            this.adjustColumns(scrollLeft, scrollPercentage);
            this.prevScrollLeft = scrollLeft;
            this.prevScrollleftPercentage = scrollPercentage;
            this.grid.queueRefresh();
        };
        GridRenderContainer.prototype.adjustRows = function adjustRows(scrollTop, scrollPercentage, postDataLoaded) {
            var self = this;
            var minRows = self.minRowsToRender();
            var rowCache = self.visibleRowCache;
            var maxRowIndex = rowCache.length - minRows;
            if ((typeof scrollPercentage === "undefined" || scrollPercentage === null) && scrollTop) {
                scrollPercentage = scrollTop / self.getVerticalScrollLength();
            }
            var rowIndex = Math.ceil(Math.min(maxRowIndex, maxRowIndex * scrollPercentage));
            if (rowIndex > maxRowIndex) {
                rowIndex = maxRowIndex;
            }
            var newRange = [];
            if (rowCache.length > self.grid.options.virtualizationThreshold) {
                if (!(typeof scrollTop === "undefined" || scrollTop === null)) {
                    if (!self.grid.suppressParentScrollDown && self.prevScrollTop < scrollTop && rowIndex < self.prevRowScrollIndex + self.grid.options.scrollThreshold && rowIndex < maxRowIndex) {
                        return;
                    }
                    if (!self.grid.suppressParentScrollUp && self.prevScrollTop > scrollTop && rowIndex > self.prevRowScrollIndex - self.grid.options.scrollThreshold && rowIndex < maxRowIndex) {
                        return;
                    }
                }
                var rangeStart = {};
                var rangeEnd = {};
                rangeStart = Math.max(0, rowIndex - self.grid.options.excessRows);
                rangeEnd = Math.min(rowCache.length, rowIndex + minRows + self.grid.options.excessRows);
                newRange = [ rangeStart, rangeEnd ];
            } else {
                var maxLen = self.visibleRowCache.length;
                newRange = [ 0, Math.max(maxLen, minRows + self.grid.options.excessRows) ];
            }
            self.updateViewableRowRange(newRange);
            self.prevRowScrollIndex = rowIndex;
        };
        GridRenderContainer.prototype.adjustColumns = function adjustColumns(scrollLeft, scrollPercentage) {
            var self = this;
            var minCols = self.minColumnsToRender();
            var columnCache = self.visibleColumnCache;
            var maxColumnIndex = columnCache.length - minCols;
            if ((typeof scrollPercentage === "undefined" || scrollPercentage === null) && scrollLeft) {
                var horizScrollLength = self.getCanvasWidth() - self.getViewportWidth();
                scrollPercentage = scrollLeft / horizScrollLength;
            }
            var colIndex = Math.ceil(Math.min(maxColumnIndex, maxColumnIndex * scrollPercentage));
            if (colIndex > maxColumnIndex) {
                colIndex = maxColumnIndex;
            }
            var newRange = [];
            if (columnCache.length > self.grid.options.columnVirtualizationThreshold && self.getCanvasWidth() > self.getViewportWidth()) {
                var rangeStart = Math.max(0, colIndex - self.grid.options.excessColumns);
                var rangeEnd = Math.min(columnCache.length, colIndex + minCols + self.grid.options.excessColumns);
                newRange = [ rangeStart, rangeEnd ];
            } else {
                var maxLen = self.visibleColumnCache.length;
                newRange = [ 0, Math.max(maxLen, minCols + self.grid.options.excessColumns) ];
            }
            self.updateViewableColumnRange(newRange);
            self.prevColumnScrollIndex = colIndex;
        };
        GridRenderContainer.prototype.updateViewableRowRange = function updateViewableRowRange(renderedRange) {
            var rowArr = this.visibleRowCache.slice(renderedRange[0], renderedRange[1]);
            this.currentTopRow = renderedRange[0];
            this.setRenderedRows(rowArr);
        };
        GridRenderContainer.prototype.updateViewableColumnRange = function updateViewableColumnRange(renderedRange) {
            var columnArr = this.visibleColumnCache.slice(renderedRange[0], renderedRange[1]);
            this.currentFirstColumn = renderedRange[0];
            this.setRenderedColumns(columnArr);
        };
        GridRenderContainer.prototype.headerCellWrapperStyle = function() {
            var self = this;
            if (self.currentFirstColumn !== 0) {
                var offset = self.columnOffset;
                if (self.grid.isRTL()) {
                    return {
                        "margin-right": offset + "px"
                    };
                } else {
                    return {
                        "margin-left": offset + "px"
                    };
                }
            }
            return null;
        };
        GridRenderContainer.prototype.updateColumnWidths = function() {
            var self = this;
            var asterisksArray = [], asteriskNum = 0, usedWidthSum = 0, ret = "";
            var availableWidth = self.grid.getViewportWidth() - self.grid.scrollbarWidth;
            var columnCache = [];
            angular.forEach(self.grid.renderContainers, function(container, name) {
                columnCache = columnCache.concat(container.visibleColumnCache);
            });
            columnCache.forEach(function(column, i) {
                var width = 0;
                if (!column.visible) {
                    return;
                }
                if (angular.isNumber(column.width)) {
                    width = parseInt(column.width, 10);
                    usedWidthSum = usedWidthSum + width;
                    column.drawnWidth = width;
                } else if (gridUtil.endsWith(column.width, "%")) {
                    width = parseInt(parseInt(column.width.replace(/%/g, ""), 10) / 100 * availableWidth);
                    if (width > column.maxWidth) {
                        width = column.maxWidth;
                    }
                    if (width < column.minWidth) {
                        width = column.minWidth;
                    }
                    usedWidthSum = usedWidthSum + width;
                    column.drawnWidth = width;
                } else if (angular.isString(column.width) && column.width.indexOf("*") !== -1) {
                    asteriskNum = asteriskNum + column.width.length;
                    asterisksArray.push(column);
                }
            });
            var remainingWidth = availableWidth - usedWidthSum;
            var i, column, colWidth;
            if (asterisksArray.length > 0) {
                var asteriskVal = remainingWidth / asteriskNum;
                asterisksArray.forEach(function(column) {
                    var width = parseInt(column.width.length * asteriskVal, 10);
                    if (width > column.maxWidth) {
                        width = column.maxWidth;
                    }
                    if (width < column.minWidth) {
                        width = column.minWidth;
                    }
                    usedWidthSum = usedWidthSum + width;
                    column.drawnWidth = width;
                });
            }
            var processColumnUpwards = function(column) {
                if (column.drawnWidth < column.maxWidth && leftoverWidth > 0) {
                    column.drawnWidth++;
                    usedWidthSum++;
                    leftoverWidth--;
                    columnsToChange = true;
                }
            };
            var leftoverWidth = availableWidth - usedWidthSum;
            var columnsToChange = true;
            while (leftoverWidth > 0 && columnsToChange) {
                columnsToChange = false;
                asterisksArray.forEach(processColumnUpwards);
            }
            var processColumnDownwards = function(column) {
                if (column.drawnWidth > column.minWidth && excessWidth > 0) {
                    column.drawnWidth--;
                    usedWidthSum--;
                    excessWidth--;
                    columnsToChange = true;
                }
            };
            var excessWidth = usedWidthSum - availableWidth;
            columnsToChange = true;
            while (excessWidth > 0 && columnsToChange) {
                columnsToChange = false;
                asterisksArray.forEach(processColumnDownwards);
            }
            var canvasWidth = 0;
            self.visibleColumnCache.forEach(function(column) {
                if (column.visible) {
                    canvasWidth = canvasWidth + column.drawnWidth;
                }
            });
            columnCache.forEach(function(column) {
                ret = ret + column.getColClassDefinition();
            });
            self.canvasWidth = canvasWidth;
            this.columnStyles = ret;
        };
        GridRenderContainer.prototype.needsHScrollbarPlaceholder = function() {
            return this.grid.options.enableHorizontalScrollbar && !this.hasHScrollbar && !this.grid.disableScrolling;
        };
        GridRenderContainer.prototype.getViewportStyle = function() {
            var self = this;
            var styles = {};
            self.hasHScrollbar = false;
            self.hasVScrollbar = false;
            if (self.grid.disableScrolling) {
                styles["overflow-x"] = "hidden";
                styles["overflow-y"] = "hidden";
                return styles;
            }
            if (self.name === "body") {
                self.hasHScrollbar = self.grid.options.enableHorizontalScrollbar !== uiGridConstants.scrollbars.NEVER;
                if (!self.grid.isRTL()) {
                    if (!self.grid.hasRightContainerColumns()) {
                        self.hasVScrollbar = self.grid.options.enableVerticalScrollbar !== uiGridConstants.scrollbars.NEVER;
                    }
                } else {
                    if (!self.grid.hasLeftContainerColumns()) {
                        self.hasVScrollbar = self.grid.options.enableVerticalScrollbar !== uiGridConstants.scrollbars.NEVER;
                    }
                }
            } else if (self.name === "left") {
                self.hasVScrollbar = self.grid.isRTL() ? self.grid.options.enableVerticalScrollbar !== uiGridConstants.scrollbars.NEVER : false;
            } else {
                self.hasVScrollbar = !self.grid.isRTL() ? self.grid.options.enableVerticalScrollbar !== uiGridConstants.scrollbars.NEVER : false;
            }
            styles["overflow-x"] = self.hasHScrollbar ? "scroll" : "hidden";
            styles["overflow-y"] = self.hasVScrollbar ? "scroll" : "hidden";
            return styles;
        };
        return GridRenderContainer;
    } ]);
})();

(function() {
    angular.module("ui.grid").factory("GridRow", [ "gridUtil", function(gridUtil) {
        function GridRow(entity, index, grid) {
            this.grid = grid;
            this.entity = entity;
            this.uid = gridUtil.nextUid();
            this.visible = true;
            this.$$height = grid.options.rowHeight;
        }
        Object.defineProperty(GridRow.prototype, "height", {
            "get": function() {
                return this.$$height;
            },
            "set": function(height) {
                if (height !== this.$$height) {
                    this.grid.updateCanvasHeight();
                    this.$$height = height;
                }
            }
        });
        GridRow.prototype.getQualifiedColField = function(col) {
            return "row." + this.getEntityQualifiedColField(col);
        };
        GridRow.prototype.getEntityQualifiedColField = function(col) {
            return gridUtil.preEval("entity." + col.field);
        };
        GridRow.prototype.setRowInvisible = function(row) {
            if (row && row.setThisRowInvisible) {
                row.setThisRowInvisible("user");
            }
        };
        GridRow.prototype.clearRowInvisible = function(row) {
            if (row && row.clearThisRowInvisible) {
                row.clearThisRowInvisible("user");
            }
        };
        GridRow.prototype.setThisRowInvisible = function(reason, fromRowsProcessor) {
            if (!this.invisibleReason) {
                this.invisibleReason = {};
            }
            this.invisibleReason[reason] = true;
            this.evaluateRowVisibility(fromRowsProcessor);
        };
        GridRow.prototype.clearThisRowInvisible = function(reason, fromRowsProcessor) {
            if (typeof this.invisibleReason !== "undefined") {
                delete this.invisibleReason[reason];
            }
            this.evaluateRowVisibility(fromRowsProcessor);
        };
        GridRow.prototype.evaluateRowVisibility = function(fromRowProcessor) {
            var newVisibility = true;
            if (typeof this.invisibleReason !== "undefined") {
                angular.forEach(this.invisibleReason, function(value, key) {
                    if (value) {
                        newVisibility = false;
                    }
                });
            }
            if (typeof this.visible === "undefined" || this.visible !== newVisibility) {
                this.visible = newVisibility;
                if (!fromRowProcessor) {
                    this.grid.queueGridRefresh();
                    this.grid.api.core.raise.rowsVisibleChanged(this);
                }
            }
        };
        return GridRow;
    } ]);
})();

(function() {
    "use strict";
    angular.module("ui.grid").factory("GridRowColumn", [ "$parse", "$filter", function GridRowColumnFactory($parse, $filter) {
        var GridRowColumn = function GridRowColumn(row, col) {
            if (!(this instanceof GridRowColumn)) {
                throw "Using GridRowColumn as a function insead of as a constructor. Must be called with `new` keyword";
            }
            this.row = row;
            this.col = col;
        };
        GridRowColumn.prototype.getIntersectionValueRaw = function() {
            var getter = $parse(this.row.getEntityQualifiedColField(this.col));
            var context = this.row;
            return getter(context);
        };
        GridRowColumn.prototype.getIntersectionValueFiltered = function() {
            var value = this.getIntersectionValueRaw();
            if (this.col.cellFilter && this.col.cellFilter !== "") {
                var getFilterIfExists = function(filterName) {
                    try {
                        return $filter(filterName);
                    } catch (e) {
                        return null;
                    }
                };
                var filter = getFilterIfExists(this.col.cellFilter);
                if (filter) {
                    value = filter(value);
                } else {
                    var re = /([^:]*):([^:]*):?([\s\S]+)?/;
                    var matches;
                    if ((matches = re.exec(this.col.cellFilter)) !== null) {
                        value = $filter(matches[1])(value, matches[2], matches[3]);
                    }
                }
            }
            return value;
        };
        return GridRowColumn;
    } ]);
})();

(function() {
    angular.module("ui.grid").factory("ScrollEvent", [ "gridUtil", function(gridUtil) {
        function ScrollEvent(grid, sourceRowContainer, sourceColContainer, source) {
            var self = this;
            if (!grid) {
                throw new Error("grid argument is required");
            }
            self.grid = grid;
            self.source = source;
            self.withDelay = true;
            self.sourceRowContainer = sourceRowContainer;
            self.sourceColContainer = sourceColContainer;
            self.newScrollLeft = null;
            self.newScrollTop = null;
            self.x = null;
            self.y = null;
            self.verticalScrollLength = -9999999;
            self.horizontalScrollLength = -999999;
            self.fireThrottledScrollingEvent = gridUtil.throttle(function(sourceContainerId) {
                self.grid.scrollContainers(sourceContainerId, self);
            }, self.grid.options.wheelScrollThrottle, {
                "trailing": true
            });
        }
        ScrollEvent.prototype.getNewScrollLeft = function(colContainer, viewport) {
            var self = this;
            if (!self.newScrollLeft) {
                var scrollWidth = colContainer.getCanvasWidth() - colContainer.getViewportWidth();
                var oldScrollLeft = gridUtil.normalizeScrollLeft(viewport, self.grid);
                var scrollXPercentage;
                if (typeof self.x.percentage !== "undefined" && self.x.percentage !== undefined) {
                    scrollXPercentage = self.x.percentage;
                } else if (typeof self.x.pixels !== "undefined" && self.x.pixels !== undefined) {
                    scrollXPercentage = self.x.percentage = (oldScrollLeft + self.x.pixels) / scrollWidth;
                } else {
                    throw new Error("No percentage or pixel value provided for scroll event X axis");
                }
                return Math.max(0, scrollXPercentage * scrollWidth);
            }
            return self.newScrollLeft;
        };
        ScrollEvent.prototype.getNewScrollTop = function(rowContainer, viewport) {
            var self = this;
            if (!self.newScrollTop) {
                var scrollLength = rowContainer.getVerticalScrollLength();
                var oldScrollTop = viewport[0].scrollTop;
                var scrollYPercentage;
                if (typeof self.y.percentage !== "undefined" && self.y.percentage !== undefined) {
                    scrollYPercentage = self.y.percentage;
                } else if (typeof self.y.pixels !== "undefined" && self.y.pixels !== undefined) {
                    scrollYPercentage = self.y.percentage = (oldScrollTop + self.y.pixels) / scrollLength;
                } else {
                    throw new Error("No percentage or pixel value provided for scroll event Y axis");
                }
                return Math.max(0, scrollYPercentage * scrollLength);
            }
            return self.newScrollTop;
        };
        ScrollEvent.prototype.atTop = function(scrollTop) {
            return this.y && (this.y.percentage === 0 || this.verticalScrollLength < 0) && scrollTop === 0;
        };
        ScrollEvent.prototype.atBottom = function(scrollTop) {
            return this.y && (this.y.percentage === 1 || this.verticalScrollLength === 0) && scrollTop > 0;
        };
        ScrollEvent.prototype.atLeft = function(scrollLeft) {
            return this.x && (this.x.percentage === 0 || this.horizontalScrollLength < 0) && scrollLeft === 0;
        };
        ScrollEvent.prototype.atRight = function(scrollLeft) {
            return this.x && (this.x.percentage === 1 || this.horizontalScrollLength === 0) && scrollLeft > 0;
        };
        ScrollEvent.Sources = {
            "ViewPortScroll": "ViewPortScroll",
            "RenderContainerMouseWheel": "RenderContainerMouseWheel",
            "RenderContainerTouchMove": "RenderContainerTouchMove",
            "Other": 99
        };
        return ScrollEvent;
    } ]);
})();

(function() {
    "use strict";
    angular.module("ui.grid").service("gridClassFactory", [ "gridUtil", "$q", "$compile", "$templateCache", "uiGridConstants", "Grid", "GridColumn", "GridRow", function(gridUtil, $q, $compile, $templateCache, uiGridConstants, Grid, GridColumn, GridRow) {
        var service = {
            "createGrid": function(options) {
                options = typeof options !== "undefined" ? options : {};
                options.id = gridUtil.newId();
                var grid = new Grid(options);
                if (grid.options.rowTemplate) {
                    var rowTemplateFnPromise = $q.defer();
                    grid.getRowTemplateFn = rowTemplateFnPromise.promise;
                    gridUtil.getTemplate(grid.options.rowTemplate).then(function(template) {
                        var rowTemplateFn = $compile(template);
                        rowTemplateFnPromise.resolve(rowTemplateFn);
                    }, function(res) {
                        throw new Error("Couldn't fetch/use row template '" + grid.options.rowTemplate + "'");
                    });
                }
                grid.registerColumnBuilder(service.defaultColumnBuilder);
                grid.registerRowBuilder(service.rowTemplateAssigner);
                grid.registerRowsProcessor(function allRowsVisible(rows) {
                    rows.forEach(function(row) {
                        row.evaluateRowVisibility(true);
                    }, 50);
                    return rows;
                });
                grid.registerColumnsProcessor(function allColumnsVisible(columns) {
                    columns.forEach(function(column) {
                        column.visible = true;
                    });
                    return columns;
                }, 50);
                grid.registerColumnsProcessor(function(renderableColumns) {
                    renderableColumns.forEach(function(column) {
                        if (column.colDef.visible === false) {
                            column.visible = false;
                        }
                    });
                    return renderableColumns;
                }, 50);
                grid.registerRowsProcessor(grid.searchRows, 100);
                if (grid.options.externalSort && angular.isFunction(grid.options.externalSort)) {
                    grid.registerRowsProcessor(grid.options.externalSort, 200);
                } else {
                    grid.registerRowsProcessor(grid.sortByColumn, 200);
                }
                return grid;
            },
            "defaultColumnBuilder": function(colDef, col, gridOptions) {
                var templateGetPromises = [];
                var processTemplate = function(templateType, providedType, defaultTemplate, filterType, tooltipType) {
                    if (!colDef[templateType]) {
                        col[providedType] = defaultTemplate;
                    } else {
                        col[providedType] = colDef[templateType];
                    }
                    templateGetPromises.push(gridUtil.getTemplate(col[providedType]).then(function(template) {
                        if (angular.isFunction(template)) {
                            template = template();
                        }
                        var tooltipCall = tooltipType === "cellTooltip" ? "col.cellTooltip(row,col)" : "col.headerTooltip(col)";
                        if (tooltipType && col[tooltipType] === false) {
                            template = template.replace(uiGridConstants.TOOLTIP, "");
                        } else if (tooltipType && col[tooltipType]) {
                            template = template.replace(uiGridConstants.TOOLTIP, 'title="{{' + tooltipCall + ' CUSTOM_FILTERS }}"');
                        }
                        if (filterType) {
                            col[templateType] = template.replace(uiGridConstants.CUSTOM_FILTERS, function() {
                                return col[filterType] ? "|" + col[filterType] : "";
                            });
                        } else {
                            col[templateType] = template;
                        }
                    }, function(res) {
                        throw new Error("Couldn't fetch/use colDef." + templateType + " '" + colDef[templateType] + "'");
                    }));
                };
                processTemplate("cellTemplate", "providedCellTemplate", "ui-grid/uiGridCell", "cellFilter", "cellTooltip");
                col.cellTemplatePromise = templateGetPromises[0];
                processTemplate("headerCellTemplate", "providedHeaderCellTemplate", "ui-grid/uiGridHeaderCell", "headerCellFilter", "headerTooltip");
                processTemplate("footerCellTemplate", "providedFooterCellTemplate", "ui-grid/uiGridFooterCell", "footerCellFilter");
                processTemplate("filterHeaderTemplate", "providedFilterHeaderTemplate", "ui-grid/ui-grid-filter");
                col.compiledElementFnDefer = $q.defer();
                return $q.all(templateGetPromises);
            },
            "rowTemplateAssigner": function rowTemplateAssigner(row) {
                var grid = this;
                if (!row.rowTemplate) {
                    row.rowTemplate = grid.options.rowTemplate;
                    row.getRowTemplateFn = grid.getRowTemplateFn;
                } else {
                    var perRowTemplateFnPromise = $q.defer();
                    row.getRowTemplateFn = perRowTemplateFnPromise.promise;
                    gridUtil.getTemplate(row.rowTemplate).then(function(template) {
                        var rowTemplateFn = $compile(template);
                        perRowTemplateFnPromise.resolve(rowTemplateFn);
                    }, function(res) {
                        throw new Error("Couldn't fetch/use row template '" + row.rowTemplate + "'");
                    });
                }
                return row.getRowTemplateFn;
            }
        };
        return service;
    } ]);
})();

(function() {
    var module = angular.module("ui.grid");
    function escapeRegExp(str) {
        return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
    }
    module.service("rowSearcher", [ "gridUtil", "uiGridConstants", function(gridUtil, uiGridConstants) {
        var defaultCondition = uiGridConstants.filter.CONTAINS;
        var rowSearcher = {};
        rowSearcher.getTerm = function getTerm(filter) {
            if (typeof filter.term === "undefined") {
                return filter.term;
            }
            var term = filter.term;
            if (typeof term === "string") {
                term = term.trim();
            }
            return term;
        };
        rowSearcher.stripTerm = function stripTerm(filter) {
            var term = rowSearcher.getTerm(filter);
            if (typeof term === "string") {
                return escapeRegExp(term.replace(/(^\*|\*$)/g, ""));
            } else {
                return term;
            }
        };
        rowSearcher.guessCondition = function guessCondition(filter) {
            if (typeof filter.term === "undefined" || !filter.term) {
                return defaultCondition;
            }
            var term = rowSearcher.getTerm(filter);
            if (/\*/.test(term)) {
                var regexpFlags = "";
                if (!filter.flags || !filter.flags.caseSensitive) {
                    regexpFlags += "i";
                }
                var reText = term.replace(/(\\)?\*/g, function($0, $1) {
                    return $1 ? $0 : "[\\s\\S]*?";
                });
                return new RegExp("^" + reText + "$", regexpFlags);
            } else {
                return defaultCondition;
            }
        };
        rowSearcher.setupFilters = function setupFilters(filters) {
            var newFilters = [];
            var filtersLength = filters.length;
            for (var i = 0; i < filtersLength; i++) {
                var filter = filters[i];
                if (filter.noTerm || !gridUtil.isNullOrUndefined(filter.term)) {
                    var newFilter = {};
                    var regexpFlags = "";
                    if (!filter.flags || !filter.flags.caseSensitive) {
                        regexpFlags += "i";
                    }
                    if (!gridUtil.isNullOrUndefined(filter.term)) {
                        newFilter.term = rowSearcher.stripTerm(filter);
                    }
                    if (filter.condition) {
                        newFilter.condition = filter.condition;
                    } else {
                        newFilter.condition = rowSearcher.guessCondition(filter);
                    }
                    newFilter.flags = angular.extend({
                        "caseSensitive": false,
                        "date": false
                    }, filter.flags);
                    if (newFilter.condition === uiGridConstants.filter.STARTS_WITH) {
                        newFilter.startswithRE = new RegExp("^" + newFilter.term, regexpFlags);
                    }
                    if (newFilter.condition === uiGridConstants.filter.ENDS_WITH) {
                        newFilter.endswithRE = new RegExp(newFilter.term + "$", regexpFlags);
                    }
                    if (newFilter.condition === uiGridConstants.filter.CONTAINS) {
                        newFilter.containsRE = new RegExp(newFilter.term, regexpFlags);
                    }
                    if (newFilter.condition === uiGridConstants.filter.EXACT) {
                        newFilter.exactRE = new RegExp("^" + newFilter.term + "$", regexpFlags);
                    }
                    newFilters.push(newFilter);
                }
            }
            return newFilters;
        };
        rowSearcher.runColumnFilter = function runColumnFilter(grid, row, column, filter) {
            var conditionType = typeof filter.condition;
            var term = filter.term;
            var value;
            if (column.filterCellFiltered) {
                value = grid.getCellDisplayValue(row, column);
            } else {
                value = grid.getCellValue(row, column);
            }
            if (filter.condition instanceof RegExp) {
                return filter.condition.test(value);
            }
            if (conditionType === "function") {
                return filter.condition(term, value, row, column);
            }
            if (filter.startswithRE) {
                return filter.startswithRE.test(value);
            }
            if (filter.endswithRE) {
                return filter.endswithRE.test(value);
            }
            if (filter.containsRE) {
                return filter.containsRE.test(value);
            }
            if (filter.exactRE) {
                return filter.exactRE.test(value);
            }
            if (filter.condition === uiGridConstants.filter.NOT_EQUAL) {
                var regex = new RegExp("^" + term + "$");
                return !regex.exec(value);
            }
            if (typeof value === "number" && typeof term === "string") {
                var tempFloat = parseFloat(term.replace(/\\\./, ".").replace(/\\\-/, "-"));
                if (!isNaN(tempFloat)) {
                    term = tempFloat;
                }
            }
            if (filter.flags.date === true) {
                value = new Date(value);
                term = new Date(term.replace(/\\/g, ""));
            }
            if (filter.condition === uiGridConstants.filter.GREATER_THAN) {
                return value > term;
            }
            if (filter.condition === uiGridConstants.filter.GREATER_THAN_OR_EQUAL) {
                return value >= term;
            }
            if (filter.condition === uiGridConstants.filter.LESS_THAN) {
                return value < term;
            }
            if (filter.condition === uiGridConstants.filter.LESS_THAN_OR_EQUAL) {
                return value <= term;
            }
            return true;
        };
        rowSearcher.searchColumn = function searchColumn(grid, row, column, filters) {
            if (grid.options.useExternalFiltering) {
                return true;
            }
            var filtersLength = filters.length;
            for (var i = 0; i < filtersLength; i++) {
                var filter = filters[i];
                var ret = rowSearcher.runColumnFilter(grid, row, column, filter);
                if (!ret) {
                    return false;
                }
            }
            return true;
        };
        rowSearcher.search = function search(grid, rows, columns) {
            if (!rows) {
                return;
            }
            if (!grid.options.enableFiltering) {
                return rows;
            }
            var filterData = [];
            var colsLength = columns.length;
            var hasTerm = function(filters) {
                var hasTerm = false;
                filters.forEach(function(filter) {
                    if (!gridUtil.isNullOrUndefined(filter.term) && filter.term !== "" || filter.noTerm) {
                        hasTerm = true;
                    }
                });
                return hasTerm;
            };
            for (var i = 0; i < colsLength; i++) {
                var col = columns[i];
                if (typeof col.filters !== "undefined" && hasTerm(col.filters)) {
                    filterData.push({
                        "col": col,
                        "filters": rowSearcher.setupFilters(col.filters)
                    });
                }
            }
            if (filterData.length > 0) {
                var foreachRow = function(grid, row, col, filters) {
                    if (row.visible && !rowSearcher.searchColumn(grid, row, col, filters)) {
                        row.visible = false;
                    }
                };
                var foreachFilterCol = function(grid, filterData) {
                    var rowsLength = rows.length;
                    for (var i = 0; i < rowsLength; i++) {
                        foreachRow(grid, rows[i], filterData.col, filterData.filters);
                    }
                };
                var filterDataLength = filterData.length;
                for (var j = 0; j < filterDataLength; j++) {
                    foreachFilterCol(grid, filterData[j]);
                }
                if (grid.api.core.raise.rowsVisibleChanged) {
                    grid.api.core.raise.rowsVisibleChanged();
                }
            }
            return rows;
        };
        return rowSearcher;
    } ]);
})();

(function() {
    var module = angular.module("ui.grid");
    module.service("rowSorter", [ "$parse", "uiGridConstants", function($parse, uiGridConstants) {
        var currencyRegexStr = "(" + uiGridConstants.CURRENCY_SYMBOLS.map(function(a) {
            return "\\" + a;
        }).join("|") + ")?";
        var numberStrRegex = new RegExp("^[-+]?" + currencyRegexStr + "[\\d,.]+" + currencyRegexStr + "%?$");
        var rowSorter = {
            "colSortFnCache": {}
        };
        rowSorter.guessSortFn = function guessSortFn(itemType) {
            switch (itemType) {
              case "number":
                return rowSorter.sortNumber;

              case "numberStr":
                return rowSorter.sortNumberStr;

              case "boolean":
                return rowSorter.sortBool;

              case "string":
                return rowSorter.sortAlpha;

              case "date":
                return rowSorter.sortDate;

              case "object":
                return rowSorter.basicSort;

              default:
                throw new Error("No sorting function found for type:" + itemType);
            }
        };
        rowSorter.handleNulls = function handleNulls(a, b) {
            if (!a && a !== 0 && a !== false || !b && b !== 0 && b !== false) {
                if (!a && a !== 0 && a !== false && (!b && b !== 0 && b !== false)) {
                    return 0;
                } else if (!a && a !== 0 && a !== false) {
                    return 1;
                } else if (!b && b !== 0 && b !== false) {
                    return -1;
                }
            }
            return null;
        };
        rowSorter.basicSort = function basicSort(a, b) {
            var nulls = rowSorter.handleNulls(a, b);
            if (nulls !== null) {
                return nulls;
            } else {
                if (a === b) {
                    return 0;
                }
                if (a < b) {
                    return -1;
                }
                return 1;
            }
        };
        rowSorter.sortNumber = function sortNumber(a, b) {
            var nulls = rowSorter.handleNulls(a, b);
            if (nulls !== null) {
                return nulls;
            } else {
                return a - b;
            }
        };
        rowSorter.sortNumberStr = function sortNumberStr(a, b) {
            var nulls = rowSorter.handleNulls(a, b);
            if (nulls !== null) {
                return nulls;
            } else {
                var numA, numB, badA = false, badB = false;
                numA = parseFloat(a.replace(/[^0-9.-]/g, ""));
                if (isNaN(numA)) {
                    badA = true;
                }
                numB = parseFloat(b.replace(/[^0-9.-]/g, ""));
                if (isNaN(numB)) {
                    badB = true;
                }
                if (badA && badB) {
                    return 0;
                }
                if (badA) {
                    return 1;
                }
                if (badB) {
                    return -1;
                }
                return numA - numB;
            }
        };
        rowSorter.sortAlpha = function sortAlpha(a, b) {
            var nulls = rowSorter.handleNulls(a, b);
            if (nulls !== null) {
                return nulls;
            } else {
                var strA = a.toString().toLowerCase(), strB = b.toString().toLowerCase();
                return strA === strB ? 0 : strA.localeCompare(strB);
            }
        };
        rowSorter.sortDate = function sortDate(a, b) {
            var nulls = rowSorter.handleNulls(a, b);
            if (nulls !== null) {
                return nulls;
            } else {
                if (!(a instanceof Date)) {
                    a = new Date(a);
                }
                if (!(b instanceof Date)) {
                    b = new Date(b);
                }
                var timeA = a.getTime(), timeB = b.getTime();
                return timeA === timeB ? 0 : timeA < timeB ? -1 : 1;
            }
        };
        rowSorter.sortBool = function sortBool(a, b) {
            var nulls = rowSorter.handleNulls(a, b);
            if (nulls !== null) {
                return nulls;
            } else {
                if (a && b) {
                    return 0;
                }
                if (!a && !b) {
                    return 0;
                } else {
                    return a ? 1 : -1;
                }
            }
        };
        rowSorter.getSortFn = function getSortFn(grid, col, rows) {
            var sortFn, item;
            if (rowSorter.colSortFnCache[col.colDef.name]) {
                sortFn = rowSorter.colSortFnCache[col.colDef.name];
            } else if (col.sortingAlgorithm !== undefined) {
                sortFn = col.sortingAlgorithm;
                rowSorter.colSortFnCache[col.colDef.name] = col.sortingAlgorithm;
            } else if (col.sortCellFiltered && col.cellFilter) {
                sortFn = rowSorter.sortAlpha;
                rowSorter.colSortFnCache[col.colDef.name] = sortFn;
            } else {
                sortFn = rowSorter.guessSortFn(col.colDef.type);
                if (sortFn) {
                    rowSorter.colSortFnCache[col.colDef.name] = sortFn;
                } else {
                    sortFn = rowSorter.sortAlpha;
                }
            }
            return sortFn;
        };
        rowSorter.prioritySort = function(a, b) {
            if (a.sort.priority !== undefined && b.sort.priority !== undefined) {
                if (a.sort.priority < b.sort.priority) {
                    return -1;
                } else if (a.sort.priority === b.sort.priority) {
                    return 0;
                } else {
                    return 1;
                }
            } else if (a.sort.priority || a.sort.priority === undefined) {
                return -1;
            } else if (b.sort.priority || b.sort.priority === undefined) {
                return 1;
            } else {
                return 0;
            }
        };
        rowSorter.sort = function rowSorterSort(grid, rows, columns) {
            if (!rows) {
                return;
            }
            if (grid.options.useExternalSorting) {
                return rows;
            }
            var sortCols = [];
            columns.forEach(function(col) {
                if (col.sort && !col.sort.ignoreSort && col.sort.direction && (col.sort.direction === uiGridConstants.ASC || col.sort.direction === uiGridConstants.DESC)) {
                    sortCols.push(col);
                }
            });
            sortCols = sortCols.sort(rowSorter.prioritySort);
            if (sortCols.length === 0) {
                return rows;
            }
            var col, direction;
            var setIndex = function(row, idx) {
                row.entity.$$uiGridIndex = idx;
            };
            rows.forEach(setIndex);
            var r = rows.slice(0);
            var rowSortFn = function(rowA, rowB) {
                var tem = 0, idx = 0, sortFn;
                while (tem === 0 && idx < sortCols.length) {
                    col = sortCols[idx];
                    direction = sortCols[idx].sort.direction;
                    sortFn = rowSorter.getSortFn(grid, col, r);
                    var propA, propB;
                    if (col.sortCellFiltered) {
                        propA = grid.getCellDisplayValue(rowA, col);
                        propB = grid.getCellDisplayValue(rowB, col);
                    } else {
                        propA = grid.getCellValue(rowA, col);
                        propB = grid.getCellValue(rowB, col);
                    }
                    tem = sortFn(propA, propB, rowA, rowB, direction);
                    idx++;
                }
                if (tem === 0) {
                    return rowA.entity.$$uiGridIndex - rowB.entity.$$uiGridIndex;
                }
                if (direction === uiGridConstants.ASC) {
                    return tem;
                } else {
                    return 0 - tem;
                }
            };
            var newRows = rows.sort(rowSortFn);
            var clearIndex = function(row, idx) {
                delete row.entity.$$uiGridIndex;
            };
            rows.forEach(clearIndex);
            return newRows;
        };
        return rowSorter;
    } ]);
})();

(function() {
    var module = angular.module("ui.grid");
    var bindPolyfill;
    if (typeof Function.prototype.bind !== "function") {
        bindPolyfill = function() {
            var slice = Array.prototype.slice;
            return function(context) {
                var fn = this, args = slice.call(arguments, 1);
                if (args.length) {
                    return function() {
                        return arguments.length ? fn.apply(context, args.concat(slice.call(arguments))) : fn.apply(context, args);
                    };
                }
                return function() {
                    return arguments.length ? fn.apply(context, arguments) : fn.call(context);
                };
            };
        };
    }
    function getStyles(elem) {
        var e = elem;
        if (typeof e.length !== "undefined" && e.length) {
            e = elem[0];
        }
        return e.ownerDocument.defaultView.getComputedStyle(e, null);
    }
    var rnumnonpx = new RegExp("^(" + /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source + ")(?!px)[a-z%]+$", "i"), rdisplayswap = /^(block|none|table(?!-c[ea]).+)/, cssShow = {
        "position": "absolute",
        "visibility": "hidden",
        "display": "block"
    };
    function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
        var i = extra === (isBorderBox ? "border" : "content") ? 4 : name === "width" ? 1 : 0, val = 0;
        var sides = [ "Top", "Right", "Bottom", "Left" ];
        for (;i < 4; i += 2) {
            var side = sides[i];
            if (extra === "margin") {
                var marg = parseFloat(styles[extra + side]);
                if (!isNaN(marg)) {
                    val += marg;
                }
            }
            if (isBorderBox) {
                if (extra === "content") {
                    var padd = parseFloat(styles["padding" + side]);
                    if (!isNaN(padd)) {
                        val -= padd;
                    }
                }
                if (extra !== "margin") {
                    var bordermarg = parseFloat(styles["border" + side + "Width"]);
                    if (!isNaN(bordermarg)) {
                        val -= bordermarg;
                    }
                }
            } else {
                var nocontentPad = parseFloat(styles["padding" + side]);
                if (!isNaN(nocontentPad)) {
                    val += nocontentPad;
                }
                if (extra !== "padding") {
                    var nocontentnopad = parseFloat(styles["border" + side + "Width"]);
                    if (!isNaN(nocontentnopad)) {
                        val += nocontentnopad;
                    }
                }
            }
        }
        return val;
    }
    function getWidthOrHeight(elem, name, extra) {
        var valueIsBorderBox = true, val, styles = getStyles(elem), isBorderBox = styles["boxSizing"] === "border-box";
        if (val <= 0 || val == null) {
            val = styles[name];
            if (val < 0 || val == null) {
                val = elem.style[name];
            }
            if (rnumnonpx.test(val)) {
                return val;
            }
            valueIsBorderBox = isBorderBox && (true || val === elem.style[name]);
            val = parseFloat(val) || 0;
        }
        var ret = val + augmentWidthOrHeight(elem, name, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox, styles);
        return ret;
    }
    function getLineHeight(elm) {
        elm = angular.element(elm)[0];
        var parent = elm.parentElement;
        if (!parent) {
            parent = document.getElementsByTagName("body")[0];
        }
        return parseInt(getStyles(parent).fontSize) || parseInt(getStyles(elm).fontSize) || 16;
    }
    var uid = [ "0", "0", "0", "0" ];
    var uidPrefix = "uiGrid-";
    module.service("gridUtil", [ "$log", "$window", "$document", "$http", "$templateCache", "$timeout", "$interval", "$injector", "$q", "$interpolate", "uiGridConstants", function($log, $window, $document, $http, $templateCache, $timeout, $interval, $injector, $q, $interpolate, uiGridConstants) {
        var s = {
            "augmentWidthOrHeight": augmentWidthOrHeight,
            "getStyles": getStyles,
            "createBoundedWrapper": function(object, method) {
                return function() {
                    return method.apply(object, arguments);
                };
            },
            "readableColumnName": function(columnName) {
                if (typeof columnName === "undefined" || columnName === undefined || columnName === null) {
                    return columnName;
                }
                if (typeof columnName !== "string") {
                    columnName = String(columnName);
                }
                return columnName.replace(/_+/g, " ").replace(/^[A-Z]+$/, function(match) {
                    return angular.lowercase(angular.uppercase(match.charAt(0)) + match.slice(1));
                }).replace(/([\w\u00C0-\u017F]+)/g, function(match) {
                    return angular.uppercase(match.charAt(0)) + match.slice(1);
                }).replace(/(\w+?(?=[A-Z]))/g, "$1 ");
            },
            "getColumnsFromData": function(data, excludeProperties) {
                var columnDefs = [];
                if (!data || typeof data[0] === "undefined" || data[0] === undefined) {
                    return [];
                }
                if (angular.isUndefined(excludeProperties)) {
                    excludeProperties = [];
                }
                var item = data[0];
                angular.forEach(item, function(prop, propName) {
                    if (excludeProperties.indexOf(propName) === -1) {
                        columnDefs.push({
                            "name": propName
                        });
                    }
                });
                return columnDefs;
            },
            "newId": function() {
                var seedId = new Date().getTime();
                return function() {
                    return seedId += 1;
                };
            }(),
            "getTemplate": function(template) {
                if ($templateCache.get(template)) {
                    return s.postProcessTemplate($templateCache.get(template));
                }
                if (template.hasOwnProperty("then")) {
                    return template.then(s.postProcessTemplate);
                }
                try {
                    if (angular.element(template).length > 0) {
                        return $q.when(template).then(s.postProcessTemplate);
                    }
                } catch (err) {}
                s.logDebug("fetching url", template);
                return $http({
                    "method": "GET",
                    "url": template
                }).then(function(result) {
                    var templateHtml = result.data.trim();
                    $templateCache.put(template, templateHtml);
                    return templateHtml;
                }, function(err) {
                    throw new Error("Could not get template " + template + ": " + err);
                }).then(s.postProcessTemplate);
            },
            "postProcessTemplate": function(template) {
                var startSym = $interpolate.startSymbol(), endSym = $interpolate.endSymbol();
                if (startSym !== "{{" || endSym !== "}}") {
                    template = template.replace(/\{\{/g, startSym);
                    template = template.replace(/\}\}/g, endSym);
                }
                return $q.when(template);
            },
            "guessType": function(item) {
                var itemType = typeof item;
                switch (itemType) {
                  case "number":
                  case "boolean":
                  case "string":
                    return itemType;

                  default:
                    if (angular.isDate(item)) {
                        return "date";
                    }
                    return "object";
                }
            },
            "elementWidth": function(elem) {},
            "elementHeight": function(elem) {},
            "getScrollbarWidth": function() {
                var outer = document.createElement("div");
                outer.style.visibility = "hidden";
                outer.style.width = "100px";
                outer.style.msOverflowStyle = "scrollbar";
                document.body.appendChild(outer);
                var widthNoScroll = outer.offsetWidth;
                outer.style.overflow = "scroll";
                var inner = document.createElement("div");
                inner.style.width = "100%";
                outer.appendChild(inner);
                var widthWithScroll = inner.offsetWidth;
                outer.parentNode.removeChild(outer);
                return widthNoScroll - widthWithScroll;
            },
            "swap": function(elem, options, callback, args) {
                var ret, name, old = {};
                for (name in options) {
                    old[name] = elem.style[name];
                    elem.style[name] = options[name];
                }
                ret = callback.apply(elem, args || []);
                for (name in options) {
                    elem.style[name] = old[name];
                }
                return ret;
            },
            "fakeElement": function(elem, options, callback, args) {
                var ret, name, newElement = angular.element(elem).clone()[0];
                for (name in options) {
                    newElement.style[name] = options[name];
                }
                angular.element(document.body).append(newElement);
                ret = callback.call(newElement, newElement);
                angular.element(newElement).remove();
                return ret;
            },
            "normalizeWheelEvent": function(event) {
                var lowestDelta, lowestDeltaXY;
                var orgEvent = event || window.event, args = [].slice.call(arguments, 1), delta = 0, deltaX = 0, deltaY = 0, absDelta = 0, absDeltaXY = 0, fn;
                if (orgEvent.originalEvent) {
                    orgEvent = orgEvent.originalEvent;
                }
                if (orgEvent.wheelDelta) {
                    delta = orgEvent.wheelDelta;
                }
                if (orgEvent.detail) {
                    delta = orgEvent.detail * -1;
                }
                deltaY = delta;
                if (orgEvent.axis !== undefined && orgEvent.axis === orgEvent.HORIZONTAL_AXIS) {
                    deltaY = 0;
                    deltaX = delta * -1;
                }
                if (orgEvent.deltaY) {
                    deltaY = orgEvent.deltaY * -1;
                    delta = deltaY;
                }
                if (orgEvent.deltaX) {
                    deltaX = orgEvent.deltaX;
                    delta = deltaX * -1;
                }
                if (orgEvent.wheelDeltaY !== undefined) {
                    deltaY = orgEvent.wheelDeltaY;
                }
                if (orgEvent.wheelDeltaX !== undefined) {
                    deltaX = orgEvent.wheelDeltaX;
                }
                absDelta = Math.abs(delta);
                if (!lowestDelta || absDelta < lowestDelta) {
                    lowestDelta = absDelta;
                }
                absDeltaXY = Math.max(Math.abs(deltaY), Math.abs(deltaX));
                if (!lowestDeltaXY || absDeltaXY < lowestDeltaXY) {
                    lowestDeltaXY = absDeltaXY;
                }
                fn = delta > 0 ? "floor" : "ceil";
                delta = Math[fn](delta / lowestDelta);
                deltaX = Math[fn](deltaX / lowestDeltaXY);
                deltaY = Math[fn](deltaY / lowestDeltaXY);
                return {
                    "delta": delta,
                    "deltaX": deltaX,
                    "deltaY": deltaY
                };
            },
            "isTouchEnabled": function() {
                var bool;
                if ("ontouchstart" in $window || $window.DocumentTouch && $document instanceof DocumentTouch) {
                    bool = true;
                }
                return bool;
            },
            "isNullOrUndefined": function(obj) {
                if (obj === undefined || obj === null) {
                    return true;
                }
                return false;
            },
            "endsWith": function(str, suffix) {
                if (!str || !suffix || typeof str !== "string") {
                    return false;
                }
                return str.indexOf(suffix, str.length - suffix.length) !== -1;
            },
            "arrayContainsObjectWithProperty": function(array, propertyName, propertyValue) {
                var found = false;
                angular.forEach(array, function(object) {
                    if (object[propertyName] === propertyValue) {
                        found = true;
                    }
                });
                return found;
            },
            "numericAndNullSort": function(a, b) {
                if (a === null) {
                    return 1;
                }
                if (b === null) {
                    return -1;
                }
                if (a === null && b === null) {
                    return 0;
                }
                return a - b;
            },
            "disableAnimations": function(element) {
                var $animate;
                try {
                    $animate = $injector.get("$animate");
                    if (angular.version.major > 1 || angular.version.major === 1 && angular.version.minor >= 4) {
                        $animate.enabled(element, false);
                    } else {
                        $animate.enabled(false, element);
                    }
                } catch (e) {}
            },
            "enableAnimations": function(element) {
                var $animate;
                try {
                    $animate = $injector.get("$animate");
                    if (angular.version.major > 1 || angular.version.major === 1 && angular.version.minor >= 4) {
                        $animate.enabled(element, true);
                    } else {
                        $animate.enabled(true, element);
                    }
                    return $animate;
                } catch (e) {}
            },
            "nextUid": function nextUid() {
                var index = uid.length;
                var digit;
                while (index) {
                    index--;
                    digit = uid[index].charCodeAt(0);
                    if (digit === 57) {
                        uid[index] = "A";
                        return uidPrefix + uid.join("");
                    }
                    if (digit === 90) {
                        uid[index] = "0";
                    } else {
                        uid[index] = String.fromCharCode(digit + 1);
                        return uidPrefix + uid.join("");
                    }
                }
                uid.unshift("0");
                return uidPrefix + uid.join("");
            },
            "hashKey": function hashKey(obj) {
                var objType = typeof obj, key;
                if (objType === "object" && obj !== null) {
                    if (typeof (key = obj.$$hashKey) === "function") {
                        key = obj.$$hashKey();
                    } else if (typeof obj.$$hashKey !== "undefined" && obj.$$hashKey) {
                        key = obj.$$hashKey;
                    } else if (key === undefined) {
                        key = obj.$$hashKey = s.nextUid();
                    }
                } else {
                    key = obj;
                }
                return objType + ":" + key;
            },
            "resetUids": function() {
                uid = [ "0", "0", "0" ];
            },
            "logError": function(logMessage) {
                if (uiGridConstants.LOG_ERROR_MESSAGES) {
                    $log.error(logMessage);
                }
            },
            "logWarn": function(logMessage) {
                if (uiGridConstants.LOG_WARN_MESSAGES) {
                    $log.warn(logMessage);
                }
            },
            "logDebug": function() {
                if (uiGridConstants.LOG_DEBUG_MESSAGES) {
                    $log.debug.apply($log, arguments);
                }
            }
        };
        s.focus = {
            "queue": [],
            "byId": function(id, Grid) {
                this._purgeQueue();
                var promise = $timeout(function() {
                    var elementID = (Grid && Grid.id ? Grid.id + "-" : "") + id;
                    var element = $window.document.getElementById(elementID);
                    if (element) {
                        element.focus();
                    } else {
                        s.logWarn("[focus.byId] Element id " + elementID + " was not found.");
                    }
                });
                this.queue.push(promise);
                return promise;
            },
            "byElement": function(element) {
                if (!angular.isElement(element)) {
                    s.logWarn("Trying to focus on an element that isn't an element.");
                    return $q.reject("not-element");
                }
                element = angular.element(element);
                this._purgeQueue();
                var promise = $timeout(function() {
                    if (element) {
                        element[0].focus();
                    }
                });
                this.queue.push(promise);
                return promise;
            },
            "bySelector": function(parentElement, querySelector, aSync) {
                var self = this;
                if (!angular.isElement(parentElement)) {
                    throw new Error("The parent element is not an element.");
                }
                parentElement = angular.element(parentElement);
                var focusBySelector = function() {
                    var element = parentElement[0].querySelector(querySelector);
                    return self.byElement(element);
                };
                this._purgeQueue();
                if (aSync) {
                    var promise = $timeout(focusBySelector);
                    this.queue.push($timeout(focusBySelector));
                    return promise;
                } else {
                    return focusBySelector();
                }
            },
            "_purgeQueue": function() {
                this.queue.forEach(function(element) {
                    $timeout.cancel(element);
                });
                this.queue = [];
            }
        };
        [ "width", "height" ].forEach(function(name) {
            var capsName = angular.uppercase(name.charAt(0)) + name.substr(1);
            s["element" + capsName] = function(elem, extra) {
                var e = elem;
                if (e && typeof e.length !== "undefined" && e.length) {
                    e = elem[0];
                }
                if (e) {
                    var styles = getStyles(e);
                    return e.offsetWidth === 0 && rdisplayswap.test(styles.display) ? s.swap(e, cssShow, function() {
                        return getWidthOrHeight(e, name, extra);
                    }) : getWidthOrHeight(e, name, extra);
                } else {
                    return null;
                }
            };
            s["outerElement" + capsName] = function(elem, margin) {
                return elem ? s["element" + capsName].call(this, elem, margin ? "margin" : "border") : null;
            };
        });
        s.closestElm = function closestElm(el, selector) {
            if (typeof el.length !== "undefined" && el.length) {
                el = el[0];
            }
            var matchesFn;
            [ "matches", "webkitMatchesSelector", "mozMatchesSelector", "msMatchesSelector", "oMatchesSelector" ].some(function(fn) {
                if (typeof document.body[fn] === "function") {
                    matchesFn = fn;
                    return true;
                }
                return false;
            });
            var parent;
            while (el !== null) {
                parent = el.parentElement;
                if (parent !== null && parent[matchesFn](selector)) {
                    return parent;
                }
                el = parent;
            }
            return null;
        };
        s.type = function(obj) {
            var text = Function.prototype.toString.call(obj.constructor);
            return text.match(/function (.*?)\(/)[1];
        };
        s.getBorderSize = function getBorderSize(elem, borderType) {
            if (typeof elem.length !== "undefined" && elem.length) {
                elem = elem[0];
            }
            var styles = getStyles(elem);
            if (borderType) {
                borderType = "border" + borderType.charAt(0).toUpperCase() + borderType.slice(1);
            } else {
                borderType = "border";
            }
            borderType += "Width";
            var val = parseInt(styles[borderType], 10);
            if (isNaN(val)) {
                return 0;
            } else {
                return val;
            }
        };
        s.detectBrowser = function detectBrowser() {
            var userAgent = $window.navigator.userAgent;
            var browsers = {
                "chrome": /chrome/i,
                "safari": /safari/i,
                "firefox": /firefox/i,
                "ie": /internet explorer|trident\//i
            };
            for (var key in browsers) {
                if (browsers[key].test(userAgent)) {
                    return key;
                }
            }
            return "unknown";
        };
        s.rtlScrollType = function rtlScrollType() {
            if (rtlScrollType.type) {
                return rtlScrollType.type;
            }
            var definer = angular.element('<div dir="rtl" style="font-size: 14px; width: 1px; height: 1px; position: absolute; top: -1000px; overflow: scroll">A</div>')[0], type = "reverse";
            document.body.appendChild(definer);
            if (definer.scrollLeft > 0) {
                type = "default";
            } else {
                definer.scrollLeft = 1;
                if (definer.scrollLeft === 0) {
                    type = "negative";
                }
            }
            angular.element(definer).remove();
            rtlScrollType.type = type;
            return type;
        };
        s.normalizeScrollLeft = function normalizeScrollLeft(element, grid) {
            if (typeof element.length !== "undefined" && element.length) {
                element = element[0];
            }
            var scrollLeft = element.scrollLeft;
            if (grid.isRTL()) {
                switch (s.rtlScrollType()) {
                  case "default":
                    return element.scrollWidth - scrollLeft - element.clientWidth;

                  case "negative":
                    return Math.abs(scrollLeft);

                  case "reverse":
                    return scrollLeft;
                }
            }
            return scrollLeft;
        };
        s.denormalizeScrollLeft = function denormalizeScrollLeft(element, scrollLeft, grid) {
            if (typeof element.length !== "undefined" && element.length) {
                element = element[0];
            }
            if (grid.isRTL()) {
                switch (s.rtlScrollType()) {
                  case "default":
                    var maxScrollLeft = element.scrollWidth - element.clientWidth;
                    return maxScrollLeft - scrollLeft;

                  case "negative":
                    return scrollLeft * -1;

                  case "reverse":
                    return scrollLeft;
                }
            }
            return scrollLeft;
        };
        s.preEval = function(path) {
            var m = uiGridConstants.BRACKET_REGEXP.exec(path);
            if (m) {
                return (m[1] ? s.preEval(m[1]) : m[1]) + m[2] + (m[3] ? s.preEval(m[3]) : m[3]);
            } else {
                path = path.replace(uiGridConstants.APOS_REGEXP, "\\'");
                var parts = path.split(uiGridConstants.DOT_REGEXP);
                var preparsed = [ parts.shift() ];
                angular.forEach(parts, function(part) {
                    preparsed.push(part.replace(uiGridConstants.FUNC_REGEXP, "']$1"));
                });
                return preparsed.join("['");
            }
        };
        s.debounce = function(func, wait, immediate) {
            var timeout, args, context, result;
            function debounce() {
                context = this;
                args = arguments;
                var later = function() {
                    timeout = null;
                    if (!immediate) {
                        result = func.apply(context, args);
                    }
                };
                var callNow = immediate && !timeout;
                if (timeout) {
                    $timeout.cancel(timeout);
                }
                timeout = $timeout(later, wait, false);
                if (callNow) {
                    result = func.apply(context, args);
                }
                return result;
            }
            debounce.cancel = function() {
                $timeout.cancel(timeout);
                timeout = null;
            };
            return debounce;
        };
        s.throttle = function(func, wait, options) {
            options = options || {};
            var lastCall = 0, queued = null, context, args;
            function runFunc(endDate) {
                lastCall = +new Date();
                func.apply(context, args);
                $interval(function() {
                    queued = null;
                }, 0, 1, false);
            }
            return function() {
                context = this;
                args = arguments;
                if (queued === null) {
                    var sinceLast = +new Date() - lastCall;
                    if (sinceLast > wait) {
                        runFunc();
                    } else if (options.trailing) {
                        queued = $interval(runFunc, wait - sinceLast, 1, false);
                    }
                }
            };
        };
        s.on = {};
        s.off = {};
        s._events = {};
        s.addOff = function(eventName) {
            s.off[eventName] = function(elm, fn) {
                var idx = s._events[eventName].indexOf(fn);
                if (idx > 0) {
                    s._events[eventName].removeAt(idx);
                }
            };
        };
        var mouseWheeltoBind = "onwheel" in document || document.documentMode >= 9 ? [ "wheel" ] : [ "mousewheel", "DomMouseScroll", "MozMousePixelScroll" ], nullLowestDeltaTimeout, lowestDelta;
        s.on.mousewheel = function(elm, fn) {
            if (!elm || !fn) {
                return;
            }
            var $elm = angular.element(elm);
            $elm.data("mousewheel-line-height", getLineHeight($elm));
            $elm.data("mousewheel-page-height", s.elementHeight($elm));
            if (!$elm.data("mousewheel-callbacks")) {
                $elm.data("mousewheel-callbacks", {});
            }
            var cbs = $elm.data("mousewheel-callbacks");
            cbs[fn] = (Function.prototype.bind || bindPolyfill).call(mousewheelHandler, $elm[0], fn);
            for (var i = mouseWheeltoBind.length; i; ) {
                $elm.on(mouseWheeltoBind[--i], cbs[fn]);
            }
        };
        s.off.mousewheel = function(elm, fn) {
            var $elm = angular.element(elm);
            var cbs = $elm.data("mousewheel-callbacks");
            var handler = cbs[fn];
            if (handler) {
                for (var i = mouseWheeltoBind.length; i; ) {
                    $elm.off(mouseWheeltoBind[--i], handler);
                }
            }
            delete cbs[fn];
            if (Object.keys(cbs).length === 0) {
                $elm.removeData("mousewheel-line-height");
                $elm.removeData("mousewheel-page-height");
                $elm.removeData("mousewheel-callbacks");
            }
        };
        function mousewheelHandler(fn, event) {
            var $elm = angular.element(this);
            var delta = 0, deltaX = 0, deltaY = 0, absDelta = 0, offsetX = 0, offsetY = 0;
            if (event.originalEvent) {
                event = event.originalEvent;
            }
            if ("detail" in event) {
                deltaY = event.detail * -1;
            }
            if ("wheelDelta" in event) {
                deltaY = event.wheelDelta;
            }
            if ("wheelDeltaY" in event) {
                deltaY = event.wheelDeltaY;
            }
            if ("wheelDeltaX" in event) {
                deltaX = event.wheelDeltaX * -1;
            }
            if ("axis" in event && event.axis === event.HORIZONTAL_AXIS) {
                deltaX = deltaY * -1;
                deltaY = 0;
            }
            delta = deltaY === 0 ? deltaX : deltaY;
            if ("deltaY" in event) {
                deltaY = event.deltaY * -1;
                delta = deltaY;
            }
            if ("deltaX" in event) {
                deltaX = event.deltaX;
                if (deltaY === 0) {
                    delta = deltaX * -1;
                }
            }
            if (deltaY === 0 && deltaX === 0) {
                return;
            }
            if (event.deltaMode === 1) {
                var lineHeight = $elm.data("mousewheel-line-height");
                delta *= lineHeight;
                deltaY *= lineHeight;
                deltaX *= lineHeight;
            } else if (event.deltaMode === 2) {
                var pageHeight = $elm.data("mousewheel-page-height");
                delta *= pageHeight;
                deltaY *= pageHeight;
                deltaX *= pageHeight;
            }
            absDelta = Math.max(Math.abs(deltaY), Math.abs(deltaX));
            if (!lowestDelta || absDelta < lowestDelta) {
                lowestDelta = absDelta;
                if (shouldAdjustOldDeltas(event, absDelta)) {
                    lowestDelta /= 40;
                }
            }
            delta = Math[delta >= 1 ? "floor" : "ceil"](delta / lowestDelta);
            deltaX = Math[deltaX >= 1 ? "floor" : "ceil"](deltaX / lowestDelta);
            deltaY = Math[deltaY >= 1 ? "floor" : "ceil"](deltaY / lowestDelta);
            event.deltaMode = 0;
            var newEvent = {
                "originalEvent": event,
                "deltaX": deltaX,
                "deltaY": deltaY,
                "deltaFactor": lowestDelta,
                "preventDefault": function() {
                    event.preventDefault();
                },
                "stopPropagation": function() {
                    event.stopPropagation();
                }
            };
            if (nullLowestDeltaTimeout) {
                clearTimeout(nullLowestDeltaTimeout);
            }
            nullLowestDeltaTimeout = setTimeout(nullLowestDelta, 200);
            fn.call($elm[0], newEvent);
        }
        function nullLowestDelta() {
            lowestDelta = null;
        }
        function shouldAdjustOldDeltas(orgEvent, absDelta) {
            return orgEvent.type === "mousewheel" && absDelta % 120 === 0;
        }
        return s;
    } ]);
    module.filter("px", function() {
        return function(str) {
            if (str.match(/^[\d\.]+$/)) {
                return str + "px";
            } else {
                return str;
            }
        };
    });
})();

(function() {
    angular.module("ui.grid").config([ "$provide", function($provide) {
        $provide.decorator("i18nService", [ "$delegate", function($delegate) {
            var lang = {
                "aggregate": {
                    "label": "polo\u017eky"
                },
                "groupPanel": {
                    "description": "P\u0159esu\u0148te z\xe1hlav\xed zde pro vytvo\u0159en\xed skupiny dle sloupce."
                },
                "search": {
                    "placeholder": "Hledat...",
                    "showingItems": "Zobrazuji polo\u017eky:",
                    "selectedItems": "Vybran\xe9 polo\u017eky:",
                    "totalItems": "Celkem polo\u017eek:",
                    "size": "Velikost strany:",
                    "first": "Prvn\xed strana",
                    "next": "Dal\u0161\xed strana",
                    "previous": "P\u0159edchoz\xed strana",
                    "last": "Posledn\xed strana"
                },
                "menu": {
                    "text": "Vyberte sloupec:"
                },
                "sort": {
                    "ascending": "Se\u0159adit od A-Z",
                    "descending": "Se\u0159adit od Z-A",
                    "remove": "Odebrat se\u0159azen\xed"
                },
                "column": {
                    "hide": "Schovat sloupec"
                },
                "aggregation": {
                    "count": "celkem \u0159\xe1dk\u016f: ",
                    "sum": "celkem: ",
                    "avg": "avg: ",
                    "min": "min.: ",
                    "max": "max.: "
                },
                "pinning": {
                    "pinLeft": "Zamknout vlevo",
                    "pinRight": "Zamknout vpravo",
                    "unpin": "Odemknout"
                },
                "gridMenu": {
                    "columns": "Sloupce:",
                    "importerTitle": "Importovat soubor",
                    "exporterAllAsCsv": "Exportovat v\u0161echna data do csv",
                    "exporterVisibleAsCsv": "Exportovat viditeln\xe1 data do csv",
                    "exporterSelectedAsCsv": "Exportovat vybran\xe1 data do csv",
                    "exporterAllAsPdf": "Exportovat v\u0161echna data do pdf",
                    "exporterVisibleAsPdf": "Exportovat viditeln\xe1 data do pdf",
                    "exporterSelectedAsPdf": "Exportovat vybran\xe1 data do pdf",
                    "clearAllFilters": "Odstranit v\u0161echny filtry"
                },
                "importer": {
                    "noHeaders": "N\xe1zvy sloupc\u016f se nepoda\u0159ilo z\xedskat, obsahuje soubor z\xe1hlav\xed?",
                    "noObjects": "Data se nepoda\u0159ilo zpracovat, obsahuje soubor \u0159\xe1dky mimo z\xe1hlav\xed?",
                    "invalidCsv": "Soubor nelze zpracovat, jedn\xe1 se o CSV?",
                    "invalidJson": "Soubor nelze zpracovat, je to JSON?",
                    "jsonNotArray": "Soubor mus\xed obsahovat json. Ukon\u010duji.."
                },
                "pagination": {
                    "sizes": "polo\u017eek na str\xe1nku",
                    "totalItems": "polo\u017eek"
                },
                "grouping": {
                    "group": "Seskupit",
                    "ungroup": "Odebrat seskupen\xed",
                    "aggregate_count": "Agregace: Count",
                    "aggregate_sum": "Agregace: Sum",
                    "aggregate_max": "Agregace: Max",
                    "aggregate_min": "Agregace: Min",
                    "aggregate_avg": "Agregace: Avg",
                    "aggregate_remove": "Agregace: Odebrat"
                }
            };
            $delegate.add("cs", lang);
            $delegate.add("cz", lang);
            $delegate.add("cs-cz", lang);
            $delegate.add("cs-CZ", lang);
            return $delegate;
        } ]);
    } ]);
})();

(function() {
    angular.module("ui.grid").config([ "$provide", function($provide) {
        $provide.decorator("i18nService", [ "$delegate", function($delegate) {
            $delegate.add("da", {
                "aggregate": {
                    "label": "artikler"
                },
                "groupPanel": {
                    "description": "Grup\xe9r r\xe6kker udfra en kolonne ved at tr\xe6kke dens overskift hertil."
                },
                "search": {
                    "placeholder": "S\xf8g...",
                    "showingItems": "Viste r\xe6kker:",
                    "selectedItems": "Valgte r\xe6kker:",
                    "totalItems": "R\xe6kker totalt:",
                    "size": "Side st\xf8rrelse:",
                    "first": "F\xf8rste side",
                    "next": "N\xe6ste side",
                    "previous": "Forrige side",
                    "last": "Sidste side"
                },
                "menu": {
                    "text": "V\xe6lg kolonner:"
                },
                "sort": {
                    "ascending": "Sorter stigende",
                    "descending": "Sorter faldende",
                    "none": "Sorter ingen",
                    "remove": "Fjern sortering"
                },
                "column": {
                    "hide": "Skjul kolonne"
                },
                "aggregation": {
                    "count": "antal r\xe6kker: ",
                    "sum": "sum: ",
                    "avg": "gns: ",
                    "min": "min: ",
                    "max": "max: "
                },
                "gridMenu": {
                    "columns": "Columns:",
                    "importerTitle": "Import file",
                    "exporterAllAsCsv": "Export all data as csv",
                    "exporterVisibleAsCsv": "Export visible data as csv",
                    "exporterSelectedAsCsv": "Export selected data as csv",
                    "exporterAllAsPdf": "Export all data as pdf",
                    "exporterVisibleAsPdf": "Export visible data as pdf",
                    "exporterSelectedAsPdf": "Export selected data as pdf",
                    "clearAllFilters": "Clear all filters"
                },
                "importer": {
                    "noHeaders": "Column names were unable to be derived, does the file have a header?",
                    "noObjects": "Objects were not able to be derived, was there data in the file other than headers?",
                    "invalidCsv": "File was unable to be processed, is it valid CSV?",
                    "invalidJson": "File was unable to be processed, is it valid Json?",
                    "jsonNotArray": "Imported json file must contain an array, aborting."
                }
            });
            return $delegate;
        } ]);
    } ]);
})();

(function() {
    angular.module("ui.grid").config([ "$provide", function($provide) {
        $provide.decorator("i18nService", [ "$delegate", function($delegate) {
            $delegate.add("de", {
                "headerCell": {
                    "aria": {
                        "defaultFilterLabel": "Filter f\xfcr Spalte",
                        "removeFilter": "Filter l\xf6schen",
                        "columnMenuButtonLabel": "Spaltenmen\xfc"
                    },
                    "priority": "Priorit\xe4t:",
                    "filterLabel": "Filter f\xfcr Spalte: "
                },
                "aggregate": {
                    "label": "Eintrag"
                },
                "groupPanel": {
                    "description": "Ziehen Sie eine Spalten\xfcberschrift hierhin, um nach dieser Spalte zu gruppieren."
                },
                "search": {
                    "placeholder": "Suche...",
                    "showingItems": "Zeige Eintr\xe4ge:",
                    "selectedItems": "Ausgew\xe4hlte Eintr\xe4ge:",
                    "totalItems": "Eintr\xe4ge gesamt:",
                    "size": "Eintr\xe4ge pro Seite:",
                    "first": "Erste Seite",
                    "next": "N\xe4chste Seite",
                    "previous": "Vorherige Seite",
                    "last": "Letzte Seite"
                },
                "menu": {
                    "text": "Spalten ausw\xe4hlen:"
                },
                "sort": {
                    "ascending": "aufsteigend sortieren",
                    "descending": "absteigend sortieren",
                    "none": "keine Sortierung",
                    "remove": "Sortierung zur\xfccksetzen"
                },
                "column": {
                    "hide": "Spalte ausblenden"
                },
                "aggregation": {
                    "count": "Zeilen insgesamt: ",
                    "sum": "gesamt: ",
                    "avg": "Durchschnitt: ",
                    "min": "min: ",
                    "max": "max: "
                },
                "pinning": {
                    "pinLeft": "Links anheften",
                    "pinRight": "Rechts anheften",
                    "unpin": "L\xf6sen"
                },
                "columnMenu": {
                    "close": "Schlie\xdfen"
                },
                "gridMenu": {
                    "aria": {
                        "buttonLabel": "Tabellenmen\xfc"
                    },
                    "columns": "Spalten:",
                    "importerTitle": "Datei importieren",
                    "exporterAllAsCsv": "Alle Daten als CSV exportieren",
                    "exporterVisibleAsCsv": "sichtbare Daten als CSV exportieren",
                    "exporterSelectedAsCsv": "markierte Daten als CSV exportieren",
                    "exporterAllAsPdf": "Alle Daten als PDF exportieren",
                    "exporterVisibleAsPdf": "sichtbare Daten als PDF exportieren",
                    "exporterSelectedAsPdf": "markierte Daten als CSV exportieren",
                    "clearAllFilters": "Alle Filter zur\xfccksetzen"
                },
                "importer": {
                    "noHeaders": "Es konnten keine Spaltennamen ermittelt werden. Sind in der Datei Spaltendefinitionen enthalten?",
                    "noObjects": "Es konnten keine Zeileninformationen gelesen werden, Sind in der Datei au\xdfer den Spaltendefinitionen auch Daten enthalten?",
                    "invalidCsv": "Die Datei konnte nicht eingelesen werden, ist es eine g\xfcltige CSV-Datei?",
                    "invalidJson": "Die Datei konnte nicht eingelesen werden. Enth\xe4lt sie g\xfcltiges JSON?",
                    "jsonNotArray": "Die importierte JSON-Datei mu\xdf ein Array enthalten. Breche Import ab."
                },
                "pagination": {
                    "aria": {
                        "pageToFirst": "Zum Anfang",
                        "pageBack": "Seite zur\xfcck",
                        "pageSelected": "Ausgw\xe4hlte Seite",
                        "pageForward": "Seite vor",
                        "pageToLast": "Zum Ende"
                    },
                    "sizes": "Eintr\xe4ge pro Seite",
                    "totalItems": "Eintr\xe4ge",
                    "through": "bis",
                    "of": "von"
                },
                "grouping": {
                    "group": "Gruppieren",
                    "ungroup": "Gruppierung aufheben",
                    "aggregate_count": "Agg: Anzahl",
                    "aggregate_sum": "Agg: Summe",
                    "aggregate_max": "Agg: Maximum",
                    "aggregate_min": "Agg: Minimum",
                    "aggregate_avg": "Agg: Mittelwert",
                    "aggregate_remove": "Aggregation entfernen"
                }
            });
            return $delegate;
        } ]);
    } ]);
})();

(function() {
    angular.module("ui.grid").config([ "$provide", function($provide) {
        $provide.decorator("i18nService", [ "$delegate", function($delegate) {
            $delegate.add("en", {
                "headerCell": {
                    "aria": {
                        "defaultFilterLabel": "Filter for column",
                        "removeFilter": "Remove Filter",
                        "columnMenuButtonLabel": "Column Menu"
                    },
                    "priority": "Priority:",
                    "filterLabel": "Filter for column: "
                },
                "aggregate": {
                    "label": "items"
                },
                "groupPanel": {
                    "description": "Drag a column header here and drop it to group by that column."
                },
                "search": {
                    "placeholder": "Search...",
                    "showingItems": "Showing Items:",
                    "selectedItems": "Selected Items:",
                    "totalItems": "Total Items:",
                    "size": "Page Size:",
                    "first": "First Page",
                    "next": "Next Page",
                    "previous": "Previous Page",
                    "last": "Last Page"
                },
                "menu": {
                    "text": "Choose Columns:"
                },
                "sort": {
                    "ascending": "Sort Ascending",
                    "descending": "Sort Descending",
                    "none": "Sort None",
                    "remove": "Remove Sort"
                },
                "column": {
                    "hide": "Hide Column"
                },
                "aggregation": {
                    "count": "total rows: ",
                    "sum": "total: ",
                    "avg": "avg: ",
                    "min": "min: ",
                    "max": "max: "
                },
                "pinning": {
                    "pinLeft": "Pin Left",
                    "pinRight": "Pin Right",
                    "unpin": "Unpin"
                },
                "columnMenu": {
                    "close": "Close"
                },
                "gridMenu": {
                    "aria": {
                        "buttonLabel": "Grid Menu"
                    },
                    "columns": "Columns:",
                    "importerTitle": "Import file",
                    "exporterAllAsCsv": "Export all data as csv",
                    "exporterVisibleAsCsv": "Export visible data as csv",
                    "exporterSelectedAsCsv": "Export selected data as csv",
                    "exporterAllAsPdf": "Export all data as pdf",
                    "exporterVisibleAsPdf": "Export visible data as pdf",
                    "exporterSelectedAsPdf": "Export selected data as pdf",
                    "clearAllFilters": "Clear all filters"
                },
                "importer": {
                    "noHeaders": "Column names were unable to be derived, does the file have a header?",
                    "noObjects": "Objects were not able to be derived, was there data in the file other than headers?",
                    "invalidCsv": "File was unable to be processed, is it valid CSV?",
                    "invalidJson": "File was unable to be processed, is it valid Json?",
                    "jsonNotArray": "Imported json file must contain an array, aborting."
                },
                "pagination": {
                    "aria": {
                        "pageToFirst": "Page to first",
                        "pageBack": "Page back",
                        "pageSelected": "Selected page",
                        "pageForward": "Page forward",
                        "pageToLast": "Page to last"
                    },
                    "sizes": "items per page",
                    "totalItems": "items",
                    "through": "through",
                    "of": "of"
                },
                "grouping": {
                    "group": "Group",
                    "ungroup": "Ungroup",
                    "aggregate_count": "Agg: Count",
                    "aggregate_sum": "Agg: Sum",
                    "aggregate_max": "Agg: Max",
                    "aggregate_min": "Agg: Min",
                    "aggregate_avg": "Agg: Avg",
                    "aggregate_remove": "Agg: Remove"
                },
                "validate": {
                    "error": "Error:",
                    "minLength": "Value should be at least THRESHOLD characters long.",
                    "maxLength": "Value should be at most THRESHOLD characters long.",
                    "required": "A value is needed."
                }
            });
            return $delegate;
        } ]);
    } ]);
})();

(function() {
    angular.module("ui.grid").config([ "$provide", function($provide) {
        $provide.decorator("i18nService", [ "$delegate", function($delegate) {
            $delegate.add("es", {
                "aggregate": {
                    "label": "Art\xedculos"
                },
                "groupPanel": {
                    "description": "Arrastre un encabezado de columna aqu\xed y su\xe9ltelo para agrupar por esa columna."
                },
                "search": {
                    "placeholder": "Buscar...",
                    "showingItems": "Art\xedculos Mostrados:",
                    "selectedItems": "Art\xedculos Seleccionados:",
                    "totalItems": "Art\xedculos Totales:",
                    "size": "Tama\xf1o de P\xe1gina:",
                    "first": "Primera P\xe1gina",
                    "next": "P\xe1gina Siguiente",
                    "previous": "P\xe1gina Anterior",
                    "last": "\xdaltima P\xe1gina"
                },
                "menu": {
                    "text": "Elegir columnas:"
                },
                "sort": {
                    "ascending": "Orden Ascendente",
                    "descending": "Orden Descendente",
                    "remove": "Sin Ordenar"
                },
                "column": {
                    "hide": "Ocultar la columna"
                },
                "aggregation": {
                    "count": "filas totales: ",
                    "sum": "total: ",
                    "avg": "media: ",
                    "min": "min: ",
                    "max": "max: "
                },
                "pinning": {
                    "pinLeft": "Fijar a la Izquierda",
                    "pinRight": "Fijar a la Derecha",
                    "unpin": "Quitar Fijaci\xf3n"
                },
                "gridMenu": {
                    "columns": "Columnas:",
                    "importerTitle": "Importar archivo",
                    "exporterAllAsCsv": "Exportar todo como csv",
                    "exporterVisibleAsCsv": "Exportar vista como csv",
                    "exporterSelectedAsCsv": "Exportar selecci\xf3n como csv",
                    "exporterAllAsPdf": "Exportar todo como pdf",
                    "exporterVisibleAsPdf": "Exportar vista como pdf",
                    "exporterSelectedAsPdf": "Exportar selecci\xf3n como pdf",
                    "clearAllFilters": "Limpiar todos los filtros"
                },
                "importer": {
                    "noHeaders": "No fue posible derivar los nombres de las columnas, \xbftiene encabezados el archivo?",
                    "noObjects": "No fue posible obtener registros, \xbfcontiene datos el archivo, aparte de los encabezados?",
                    "invalidCsv": "No fue posible procesar el archivo, \xbfes un CSV v\xe1lido?",
                    "invalidJson": "No fue posible procesar el archivo, \xbfes un Json v\xe1lido?",
                    "jsonNotArray": "El archivo json importado debe contener un array, abortando."
                },
                "pagination": {
                    "sizes": "registros por p\xe1gina",
                    "totalItems": "registros",
                    "of": "de"
                },
                "grouping": {
                    "group": "Agrupar",
                    "ungroup": "Desagrupar",
                    "aggregate_count": "Agr: Cont",
                    "aggregate_sum": "Agr: Sum",
                    "aggregate_max": "Agr: M\xe1x",
                    "aggregate_min": "Agr: Min",
                    "aggregate_avg": "Agr: Prom",
                    "aggregate_remove": "Agr: Quitar"
                }
            });
            return $delegate;
        } ]);
    } ]);
})();

(function() {
    angular.module("ui.grid").config([ "$provide", function($provide) {
        $provide.decorator("i18nService", [ "$delegate", function($delegate) {
            $delegate.add("fa", {
                "aggregate": {
                    "label": "\u0642\u0644\u0645"
                },
                "groupPanel": {
                    "description": "\u0639\u0646\u0648\u0627\u0646 \u06cc\u06a9 \u0633\u062a\u0648\u0646 \u0631\u0627 \u0628\u06af\u06cc\u0631 \u0648 \u0628\u0647 \u06af\u0631\u0648\u0647\u06cc \u0627\u0632 \u0622\u0646 \u0633\u062a\u0648\u0646 \u0631\u0647\u0627 \u06a9\u0646."
                },
                "search": {
                    "placeholder": "\u062c\u0633\u062a\u062c\u0648...",
                    "showingItems": "\u0646\u0645\u0627\u06cc\u0634 \u0627\u0642\u0644\u0627\u0645:",
                    "selectedItems": "\u0642\u0644\u0645\u200c\u0647\u0627\u06cc \u0627\u0646\u062a\u062e\u0627\u0628 \u0634\u062f\u0647:",
                    "totalItems": "\u0645\u062c\u0645\u0648\u0639 \u0627\u0642\u0644\u0627\u0645:",
                    "size": "\u0627\u0646\u062f\u0627\u0632\u0647\u200c\u06cc \u0635\u0641\u062d\u0647:",
                    "first": "\u0627\u0648\u0644\u06cc\u0646 \u0635\u0641\u062d\u0647",
                    "next": "\u0635\u0641\u062d\u0647\u200c\u06cc\u200c\u0628\u0639\u062f\u06cc",
                    "previous": "\u0635\u0641\u062d\u0647\u200c\u06cc\u200c \u0642\u0628\u0644\u06cc",
                    "last": "\u0622\u062e\u0631\u06cc\u0646 \u0635\u0641\u062d\u0647"
                },
                "menu": {
                    "text": "\u0633\u062a\u0648\u0646\u200c\u0647\u0627\u06cc \u0627\u0646\u062a\u062e\u0627\u0628\u06cc:"
                },
                "sort": {
                    "ascending": "\u062a\u0631\u062a\u06cc\u0628 \u0635\u0639\u0648\u062f\u06cc",
                    "descending": "\u062a\u0631\u062a\u06cc\u0628 \u0646\u0632\u0648\u0644\u06cc",
                    "remove": "\u062d\u0630\u0641 \u0645\u0631\u062a\u0628 \u06a9\u0631\u062f\u0646"
                },
                "column": {
                    "hide": "\u067e\u0646\u0647\u0627\u0646\u200c\u06a9\u0631\u062f\u0646 \u0633\u062a\u0648\u0646"
                },
                "aggregation": {
                    "count": "\u062a\u0639\u062f\u0627\u062f: ",
                    "sum": "\u0645\u062c\u0645\u0648\u0639: ",
                    "avg": "\u0645\u06cc\u0627\u0646\u06af\u06cc\u0646: ",
                    "min": "\u06a9\u0645\u062a\u0631\u06cc\u0646: ",
                    "max": "\u0628\u06cc\u0634\u062a\u0631\u06cc\u0646: "
                },
                "pinning": {
                    "pinLeft": "\u067e\u06cc\u0646 \u06a9\u0631\u062f\u0646 \u0633\u0645\u062a \u0686\u067e",
                    "pinRight": "\u067e\u06cc\u0646 \u06a9\u0631\u062f\u0646 \u0633\u0645\u062a \u0631\u0627\u0633\u062a",
                    "unpin": "\u062d\u0630\u0641 \u067e\u06cc\u0646"
                },
                "gridMenu": {
                    "columns": "\u0633\u062a\u0648\u0646\u200c\u0647\u0627:",
                    "importerTitle": "\u0648\u0627\u0631\u062f \u06a9\u0631\u062f\u0646 \u0641\u0627\u06cc\u0644",
                    "exporterAllAsCsv": "\u062e\u0631\u0648\u062c\u06cc \u062a\u0645\u0627\u0645 \u062f\u0627\u062f\u0647\u200c\u0647\u0627 \u062f\u0631 \u0641\u0627\u06cc\u0644 csv",
                    "exporterVisibleAsCsv": "\u062e\u0631\u0648\u062c\u06cc \u062f\u0627\u062f\u0647\u200c\u0647\u0627\u06cc \u0642\u0627\u0628\u0644 \u0645\u0634\u0627\u0647\u062f\u0647 \u062f\u0631 \u0641\u0627\u06cc\u0644 csv",
                    "exporterSelectedAsCsv": "\u062e\u0631\u0648\u062c\u06cc \u062f\u0627\u062f\u0647\u200c\u0647\u0627\u06cc \u0627\u0646\u062a\u062e\u0627\u0628\u200c\u0634\u062f\u0647 \u062f\u0631 \u0641\u0627\u06cc\u0644 csv",
                    "exporterAllAsPdf": "\u062e\u0631\u0648\u062c\u06cc \u062a\u0645\u0627\u0645 \u062f\u0627\u062f\u0647\u200c\u0647\u0627 \u062f\u0631 \u0641\u0627\u06cc\u0644 pdf",
                    "exporterVisibleAsPdf": "\u062e\u0631\u0648\u062c\u06cc \u062f\u0627\u062f\u0647\u200c\u0647\u0627\u06cc \u0642\u0627\u0628\u0644 \u0645\u0634\u0627\u0647\u062f\u0647 \u062f\u0631 \u0641\u0627\u06cc\u0644 pdf",
                    "exporterSelectedAsPdf": "\u062e\u0631\u0648\u062c\u06cc \u062f\u0627\u062f\u0647\u200c\u0647\u0627\u06cc \u0627\u0646\u062a\u062e\u0627\u0628\u200c\u0634\u062f\u0647 \u062f\u0631 \u0641\u0627\u06cc\u0644 pdf",
                    "clearAllFilters": "\u067e\u0627\u06a9 \u06a9\u0631\u062f\u0646 \u062a\u0645\u0627\u0645 \u0641\u06cc\u0644\u062a\u0631"
                },
                "importer": {
                    "noHeaders": "\u0646\u0627\u0645 \u0633\u062a\u0648\u0646 \u0642\u0627\u0628\u0644 \u0627\u0633\u062a\u062e\u0631\u0627\u062c \u0646\u06cc\u0633\u062a. \u0622\u06cc\u0627 \u0641\u0627\u06cc\u0644 \u0639\u0646\u0648\u0627\u0646 \u062f\u0627\u0631\u062f\u061f",
                    "noObjects": "\u0627\u0634\u06cc\u0627 \u0642\u0627\u0628\u0644 \u0627\u0633\u062a\u062e\u0631\u0627\u062c \u0646\u06cc\u0633\u062a\u0646\u062f. \u0622\u06cc\u0627 \u0628\u0647 \u062c\u0632 \u0639\u0646\u0648\u0627\u0646\u200c\u0647\u0627 \u062f\u0631 \u0641\u0627\u06cc\u0644 \u062f\u0627\u062f\u0647 \u0648\u062c\u0648\u062f \u062f\u0627\u0631\u062f\u061f",
                    "invalidCsv": "\u0641\u0627\u06cc\u0644 \u0642\u0627\u0628\u0644 \u067e\u0631\u062f\u0627\u0632\u0634 \u0646\u06cc\u0633\u062a. \u0622\u06cc\u0627 \u0641\u0631\u0645\u062a  csv  \u0645\u0639\u062a\u0628\u0631 \u0627\u0633\u062a\u061f",
                    "invalidJson": "\u0641\u0627\u06cc\u0644 \u0642\u0627\u0628\u0644 \u067e\u0631\u062f\u0627\u0632\u0634 \u0646\u06cc\u0633\u062a. \u0622\u06cc\u0627 \u0641\u0631\u0645\u062a json   \u0645\u0639\u062a\u0628\u0631 \u0627\u0633\u062a\u061f",
                    "jsonNotArray": "\u0641\u0627\u06cc\u0644 json \u0648\u0627\u0631\u062f \u0634\u062f\u0647 \u0628\u0627\u06cc\u062f \u062d\u0627\u0648\u06cc \u0622\u0631\u0627\u06cc\u0647 \u0628\u0627\u0634\u062f. \u0639\u0645\u0644\u06cc\u0627\u062a \u0633\u0627\u0642\u0637 \u0634\u062f."
                },
                "pagination": {
                    "sizes": "\u0627\u0642\u0644\u0627\u0645 \u062f\u0631 \u0647\u0631 \u0635\u0641\u062d\u0647",
                    "totalItems": "\u0627\u0642\u0644\u0627\u0645",
                    "of": "\u0627\u0632"
                },
                "grouping": {
                    "group": "\u06af\u0631\u0648\u0647\u200c\u0628\u0646\u062f\u06cc",
                    "ungroup": "\u062d\u0630\u0641 \u06af\u0631\u0648\u0647\u200c\u0628\u0646\u062f\u06cc",
                    "aggregate_count": "Agg: \u062a\u0639\u062f\u0627\u062f",
                    "aggregate_sum": "Agg: \u062c\u0645\u0639",
                    "aggregate_max": "Agg: \u0628\u06cc\u0634\u06cc\u0646\u0647",
                    "aggregate_min": "Agg: \u06a9\u0645\u06cc\u0646\u0647",
                    "aggregate_avg": "Agg: \u0645\u06cc\u0627\u0646\u06af\u06cc\u0646",
                    "aggregate_remove": "Agg: \u062d\u0630\u0641"
                }
            });
            return $delegate;
        } ]);
    } ]);
})();

(function() {
    angular.module("ui.grid").config([ "$provide", function($provide) {
        $provide.decorator("i18nService", [ "$delegate", function($delegate) {
            $delegate.add("fi", {
                "aggregate": {
                    "label": "rivit"
                },
                "groupPanel": {
                    "description": "Raahaa ja pudota otsikko t\xe4h\xe4n ryhmitt\xe4\xe4ksesi sarakkeen mukaan."
                },
                "search": {
                    "placeholder": "Hae...",
                    "showingItems": "N\xe4ytet\xe4\xe4n rivej\xe4:",
                    "selectedItems": "Valitut rivit:",
                    "totalItems": "Rivej\xe4 yht.:",
                    "size": "N\xe4yt\xe4:",
                    "first": "Ensimm\xe4inen sivu",
                    "next": "Seuraava sivu",
                    "previous": "Edellinen sivu",
                    "last": "Viimeinen sivu"
                },
                "menu": {
                    "text": "Valitse sarakkeet:"
                },
                "sort": {
                    "ascending": "J\xe4rjest\xe4 nouseva",
                    "descending": "J\xe4rjest\xe4 laskeva",
                    "remove": "Poista j\xe4rjestys"
                },
                "column": {
                    "hide": "Piilota sarake"
                },
                "aggregation": {
                    "count": "Rivej\xe4 yht.: ",
                    "sum": "Summa: ",
                    "avg": "K.a.: ",
                    "min": "Min: ",
                    "max": "Max: "
                },
                "pinning": {
                    "pinLeft": "Lukitse vasemmalle",
                    "pinRight": "Lukitse oikealle",
                    "unpin": "Poista lukitus"
                },
                "gridMenu": {
                    "columns": "Sarakkeet:",
                    "importerTitle": "Tuo tiedosto",
                    "exporterAllAsCsv": "Vie tiedot csv-muodossa",
                    "exporterVisibleAsCsv": "Vie n\xe4kyv\xe4 tieto csv-muodossa",
                    "exporterSelectedAsCsv": "Vie valittu tieto csv-muodossa",
                    "exporterAllAsPdf": "Vie tiedot pdf-muodossa",
                    "exporterVisibleAsPdf": "Vie n\xe4kyv\xe4 tieto pdf-muodossa",
                    "exporterSelectedAsPdf": "Vie valittu tieto pdf-muodossa",
                    "clearAllFilters": "Puhdista kaikki suodattimet"
                },
                "importer": {
                    "noHeaders": "Sarakkeen nimi\xe4 ei voitu p\xe4\xe4tell\xe4, onko tiedostossa otsikkorivi\xe4?",
                    "noObjects": "Tietoja ei voitu lukea, onko tiedostossa muuta kuin otsikkot?",
                    "invalidCsv": "Tiedostoa ei voitu k\xe4sitell\xe4, oliko se CSV-muodossa?",
                    "invalidJson": "Tiedostoa ei voitu k\xe4sitell\xe4, oliko se JSON-muodossa?",
                    "jsonNotArray": "Tiedosto ei sis\xe4lt\xe4nyt taulukkoa, lopetetaan."
                }
            });
            return $delegate;
        } ]);
    } ]);
})();

(function() {
    angular.module("ui.grid").config([ "$provide", function($provide) {
        $provide.decorator("i18nService", [ "$delegate", function($delegate) {
            $delegate.add("fr", {
                "aggregate": {
                    "label": "\xe9l\xe9ments"
                },
                "groupPanel": {
                    "description": "Faites glisser une en-t\xeate de colonne ici pour cr\xe9er un groupe de colonnes."
                },
                "search": {
                    "placeholder": "Recherche...",
                    "showingItems": "Affichage des \xe9l\xe9ments :",
                    "selectedItems": "\xc9l\xe9ments s\xe9lectionn\xe9s :",
                    "totalItems": "Nombre total d'\xe9l\xe9ments:",
                    "size": "Taille de page:",
                    "first": "Premi\xe8re page",
                    "next": "Page Suivante",
                    "previous": "Page pr\xe9c\xe9dente",
                    "last": "Derni\xe8re page"
                },
                "menu": {
                    "text": "Choisir des colonnes :"
                },
                "sort": {
                    "ascending": "Trier par ordre croissant",
                    "descending": "Trier par ordre d\xe9croissant",
                    "remove": "Enlever le tri"
                },
                "column": {
                    "hide": "Cacher la colonne"
                },
                "aggregation": {
                    "count": "lignes totales: ",
                    "sum": "total: ",
                    "avg": "moy: ",
                    "min": "min: ",
                    "max": "max: "
                },
                "pinning": {
                    "pinLeft": "\xc9pingler \xe0 gauche",
                    "pinRight": "\xc9pingler \xe0 droite",
                    "unpin": "D\xe9tacher"
                },
                "gridMenu": {
                    "columns": "Colonnes:",
                    "importerTitle": "Importer un fichier",
                    "exporterAllAsCsv": "Exporter toutes les donn\xe9es en CSV",
                    "exporterVisibleAsCsv": "Exporter les donn\xe9es visibles en CSV",
                    "exporterSelectedAsCsv": "Exporter les donn\xe9es s\xe9lectionn\xe9es en CSV",
                    "exporterAllAsPdf": "Exporter toutes les donn\xe9es en PDF",
                    "exporterVisibleAsPdf": "Exporter les donn\xe9es visibles en PDF",
                    "exporterSelectedAsPdf": "Exporter les donn\xe9es s\xe9lectionn\xe9es en PDF",
                    "clearAllFilters": "Nettoyez tous les filtres"
                },
                "importer": {
                    "noHeaders": "Impossible de d\xe9terminer le nom des colonnes, le fichier poss\xe8de-t-il une en-t\xeate ?",
                    "noObjects": "Aucun objet trouv\xe9, le fichier poss\xe8de-t-il des donn\xe9es autres que l'en-t\xeate ?",
                    "invalidCsv": "Le fichier n'a pas pu \xeatre trait\xe9, le CSV est-il valide ?",
                    "invalidJson": "Le fichier n'a pas pu \xeatre trait\xe9, le JSON est-il valide ?",
                    "jsonNotArray": "Le fichier JSON import\xe9 doit contenir un tableau, abandon."
                },
                "pagination": {
                    "sizes": "\xe9l\xe9ments par page",
                    "totalItems": "\xe9l\xe9ments",
                    "of": "sur"
                },
                "grouping": {
                    "group": "Grouper",
                    "ungroup": "D\xe9grouper",
                    "aggregate_count": "Agg: Compte",
                    "aggregate_sum": "Agg: Somme",
                    "aggregate_max": "Agg: Max",
                    "aggregate_min": "Agg: Min",
                    "aggregate_avg": "Agg: Moy",
                    "aggregate_remove": "Agg: Retirer"
                }
            });
            return $delegate;
        } ]);
    } ]);
})();

(function() {
    angular.module("ui.grid").config([ "$provide", function($provide) {
        $provide.decorator("i18nService", [ "$delegate", function($delegate) {
            $delegate.add("he", {
                "aggregate": {
                    "label": "items"
                },
                "groupPanel": {
                    "description": "\u05d2\u05e8\u05d5\u05e8 \u05e2\u05de\u05d5\u05d3\u05d4 \u05dc\u05db\u05d0\u05df \u05d5\u05e9\u05d7\u05e8\u05e8 \u05d1\u05db\u05d3\u05d9 \u05dc\u05e7\u05d1\u05e5 \u05e2\u05de\u05d5\u05d3\u05d4 \u05d6\u05d5."
                },
                "search": {
                    "placeholder": "\u05d7\u05e4\u05e9...",
                    "showingItems": "\u05de\u05e6\u05d9\u05d2:",
                    "selectedItems": '\u05e1\u05d4"\u05db \u05e0\u05d1\u05d7\u05e8\u05d5:',
                    "totalItems": '\u05e1\u05d4"\u05db \u05e8\u05e9\u05d5\u05de\u05d5\u05ea:',
                    "size": "\u05ea\u05d5\u05e6\u05d0\u05d5\u05ea \u05d1\u05d3\u05e3:",
                    "first": "\u05d3\u05e3 \u05e8\u05d0\u05e9\u05d5\u05df",
                    "next": "\u05d3\u05e3 \u05d4\u05d1\u05d0",
                    "previous": "\u05d3\u05e3 \u05e7\u05d5\u05d3\u05dd",
                    "last": "\u05d3\u05e3 \u05d0\u05d7\u05e8\u05d5\u05df"
                },
                "menu": {
                    "text": "\u05d1\u05d7\u05e8 \u05e2\u05de\u05d5\u05d3\u05d5\u05ea:"
                },
                "sort": {
                    "ascending": "\u05e1\u05d3\u05e8 \u05e2\u05d5\u05dc\u05d4",
                    "descending": "\u05e1\u05d3\u05e8 \u05d9\u05d5\u05e8\u05d3",
                    "remove": "\u05d1\u05d8\u05dc"
                },
                "column": {
                    "hide": "\u05d8\u05d5\u05e8 \u05d4\u05e1\u05ea\u05e8"
                },
                "aggregation": {
                    "count": "total rows: ",
                    "sum": "total: ",
                    "avg": "avg: ",
                    "min": "min: ",
                    "max": "max: "
                },
                "gridMenu": {
                    "columns": "Columns:",
                    "importerTitle": "Import file",
                    "exporterAllAsCsv": "Export all data as csv",
                    "exporterVisibleAsCsv": "Export visible data as csv",
                    "exporterSelectedAsCsv": "Export selected data as csv",
                    "exporterAllAsPdf": "Export all data as pdf",
                    "exporterVisibleAsPdf": "Export visible data as pdf",
                    "exporterSelectedAsPdf": "Export selected data as pdf",
                    "clearAllFilters": "Clean all filters"
                },
                "importer": {
                    "noHeaders": "Column names were unable to be derived, does the file have a header?",
                    "noObjects": "Objects were not able to be derived, was there data in the file other than headers?",
                    "invalidCsv": "File was unable to be processed, is it valid CSV?",
                    "invalidJson": "File was unable to be processed, is it valid Json?",
                    "jsonNotArray": "Imported json file must contain an array, aborting."
                }
            });
            return $delegate;
        } ]);
    } ]);
})();

(function() {
    angular.module("ui.grid").config([ "$provide", function($provide) {
        $provide.decorator("i18nService", [ "$delegate", function($delegate) {
            $delegate.add("hy", {
                "aggregate": {
                    "label": "\u057f\u057e\u0575\u0561\u056c\u0576\u0565\u0580"
                },
                "groupPanel": {
                    "description": "\u0538\u057d\u057f \u057d\u0575\u0561\u0576 \u056d\u0574\u0562\u0561\u057e\u0578\u0580\u0565\u056c\u0578\u0582 \u0570\u0561\u0574\u0561\u0580 \u0584\u0561\u0577\u0565\u0584 \u0587 \u0563\u0581\u0565\u0584 \u057e\u0565\u0580\u0576\u0561\u0563\u056b\u0580\u0576 \u0561\u0575\u057d\u057f\u0565\u0572\u0589"
                },
                "search": {
                    "placeholder": "\u0553\u0576\u057f\u0580\u0578\u0582\u0574...",
                    "showingItems": "\u0551\u0578\u0582\u0581\u0561\u0564\u0580\u057e\u0561\u056e \u057f\u057e\u0575\u0561\u056c\u0576\u0565\u0580\u055d",
                    "selectedItems": "\u0538\u0576\u057f\u0580\u057e\u0561\u056e:",
                    "totalItems": "\u0538\u0576\u0564\u0561\u0574\u0565\u0576\u0568\u055d",
                    "size": "\u054f\u0578\u0572\u0565\u0580\u056b \u0584\u0561\u0576\u0561\u056f\u0568 \u0567\u057b\u0578\u0582\u0574\u055d",
                    "first": "\u0531\u057c\u0561\u057b\u056b\u0576 \u0567\u057b",
                    "next": "\u0540\u0561\u057b\u0578\u0580\u0564 \u0567\u057b",
                    "previous": "\u0546\u0561\u056d\u0578\u0580\u0564 \u0567\u057b",
                    "last": "\u054e\u0565\u0580\u057b\u056b\u0576 \u0567\u057b"
                },
                "menu": {
                    "text": "\u0538\u0576\u057f\u0580\u0565\u056c \u057d\u0575\u0578\u0582\u0576\u0565\u0580\u0568:"
                },
                "sort": {
                    "ascending": "\u0531\u0573\u0574\u0561\u0576 \u056f\u0561\u0580\u0563\u0578\u057e",
                    "descending": "\u0546\u057e\u0561\u0566\u0574\u0561\u0576 \u056f\u0561\u0580\u0563\u0578\u057e",
                    "remove": "\u0540\u0561\u0576\u0565\u056c "
                },
                "column": {
                    "hide": "\u0539\u0561\u0584\u0581\u0576\u0565\u056c \u057d\u0575\u0578\u0582\u0576\u0568"
                },
                "aggregation": {
                    "count": "\u0568\u0576\u0564\u0561\u0574\u0565\u0576\u0568 \u057f\u0578\u0572\u055d ",
                    "sum": "\u0568\u0576\u0564\u0561\u0574\u0565\u0576\u0568\u055d ",
                    "avg": "\u0574\u056b\u057b\u056b\u0576\u055d ",
                    "min": "\u0574\u056b\u0576\u055d ",
                    "max": "\u0574\u0561\u0584\u057d\u055d "
                },
                "pinning": {
                    "pinLeft": "\u053f\u057a\u0581\u0576\u0565\u056c \u0571\u0561\u056d \u056f\u0578\u0572\u0574\u0578\u0582\u0574",
                    "pinRight": "\u053f\u057a\u0581\u0576\u0565\u056c \u0561\u057b \u056f\u0578\u0572\u0574\u0578\u0582\u0574",
                    "unpin": "\u0531\u0580\u0571\u0561\u056f\u0565\u056c"
                },
                "gridMenu": {
                    "columns": "\u054d\u0575\u0578\u0582\u0576\u0565\u0580:",
                    "importerTitle": "\u0546\u0565\u0580\u0574\u0578\u0582\u056e\u0565\u056c \u0586\u0561\u0575\u056c",
                    "exporterAllAsCsv": "\u0531\u0580\u057f\u0561\u0570\u0561\u0576\u0565\u056c \u0561\u0574\u0562\u0578\u0572\u057b\u0568 CSV",
                    "exporterVisibleAsCsv": "\u0531\u0580\u057f\u0561\u0570\u0561\u0576\u0565\u056c \u0565\u0580\u0587\u0561\u0581\u0578\u0572 \u057f\u057e\u0575\u0561\u056c\u0576\u0565\u0580\u0568 CSV",
                    "exporterSelectedAsCsv": "\u0531\u0580\u057f\u0561\u0570\u0561\u0576\u0565\u056c \u0568\u0576\u057f\u0580\u057e\u0561\u056e \u057f\u057e\u0575\u0561\u056c\u0576\u0565\u0580\u0568 CSV",
                    "exporterAllAsPdf": "\u0531\u0580\u057f\u0561\u0570\u0561\u0576\u0565\u056c PDF",
                    "exporterVisibleAsPdf": "\u0531\u0580\u057f\u0561\u0570\u0561\u0576\u0565\u056c \u0565\u0580\u0587\u0561\u0581\u0578\u0572 \u057f\u057e\u0575\u0561\u056c\u0576\u0565\u0580\u0568 PDF",
                    "exporterSelectedAsPdf": "\u0531\u0580\u057f\u0561\u0570\u0561\u0576\u0565\u056c \u0568\u0576\u057f\u0580\u057e\u0561\u056e \u057f\u057e\u0575\u0561\u056c\u0576\u0565\u0580\u0568 PDF",
                    "clearAllFilters": "\u0544\u0561\u0584\u0580\u0565\u056c \u0562\u0578\u056c\u0578\u0580 \u0586\u056b\u056c\u057f\u0580\u0565\u0580\u0568"
                },
                "importer": {
                    "noHeaders": "\u0540\u0576\u0561\u0580\u0561\u057e\u0578\u0580 \u0579\u0565\u0572\u0561\u057e \u0578\u0580\u0578\u0577\u0565\u056c \u057d\u0575\u0561\u0576 \u057e\u0565\u0580\u0576\u0561\u0563\u0580\u0565\u0580\u0568\u0589 \u0531\u0580\u0564\u0575\u0578\u055e\u0584 \u0586\u0561\u0575\u056c\u0568 \u0578\u0582\u0576\u056b \u057e\u0565\u0580\u0576\u0561\u0563\u0580\u0565\u0580\u0589",
                    "noObjects": "\u0540\u0576\u0561\u0580\u0561\u057e\u0578\u0580 \u0579\u0565\u0572\u0561\u057e \u056f\u0561\u0580\u0564\u0561\u056c \u057f\u057e\u0575\u0561\u056c\u0576\u0565\u0580\u0568\u0589 \u0531\u0580\u0564\u0575\u0578\u055e\u0584 \u0586\u0561\u0575\u056c\u0578\u0582\u0574 \u056f\u0561\u0576 \u057f\u057e\u0575\u0561\u056c\u0576\u0565\u0580\u0589",
                    "invalidCsv": "\u0540\u0576\u0561\u0580\u0561\u057e\u0578\u0580 \u0579\u0565\u0572\u0561\u057e \u0574\u0577\u0561\u056f\u0565\u056c \u0586\u0561\u0575\u056c\u0568\u0589 \u0531\u0580\u0564\u0575\u0578\u055e\u0584 \u0561\u0575\u0576 \u057e\u0561\u057e\u0565\u0580 CSV \u0567\u0589",
                    "invalidJson": "\u0540\u0576\u0561\u0580\u0561\u057e\u0578\u0580 \u0579\u0565\u0572\u0561\u057e \u0574\u0577\u0561\u056f\u0565\u056c \u0586\u0561\u0575\u056c\u0568\u0589 \u0531\u0580\u0564\u0575\u0578\u055e\u0584 \u0561\u0575\u0576 \u057e\u0561\u057e\u0565\u0580 Json \u0567\u0589",
                    "jsonNotArray": "\u0546\u0565\u0580\u0574\u0578\u0582\u056e\u057e\u0561\u056e json \u0586\u0561\u0575\u056c\u0568 \u057a\u0565\u057f\u0584 \u0567 \u057a\u0561\u0580\u0578\u0582\u0576\u0561\u056f\u056b \u0566\u0561\u0576\u0563\u057e\u0561\u056e, \u056f\u0561\u057d\u0565\u0581\u057e\u0578\u0582\u0574 \u0567\u0589"
                }
            });
            return $delegate;
        } ]);
    } ]);
})();

(function() {
    angular.module("ui.grid").config([ "$provide", function($provide) {
        $provide.decorator("i18nService", [ "$delegate", function($delegate) {
            $delegate.add("it", {
                "aggregate": {
                    "label": "elementi"
                },
                "groupPanel": {
                    "description": "Trascina un'intestazione all'interno del gruppo della colonna."
                },
                "search": {
                    "placeholder": "Ricerca...",
                    "showingItems": "Mostra:",
                    "selectedItems": "Selezionati:",
                    "totalItems": "Totali:",
                    "size": "Tot Pagine:",
                    "first": "Prima",
                    "next": "Prossima",
                    "previous": "Precedente",
                    "last": "Ultima"
                },
                "menu": {
                    "text": "Scegli le colonne:"
                },
                "sort": {
                    "ascending": "Asc.",
                    "descending": "Desc.",
                    "remove": "Annulla ordinamento"
                },
                "column": {
                    "hide": "Nascondi"
                },
                "aggregation": {
                    "count": "righe totali: ",
                    "sum": "tot: ",
                    "avg": "media: ",
                    "min": "minimo: ",
                    "max": "massimo: "
                },
                "pinning": {
                    "pinLeft": "Blocca a sx",
                    "pinRight": "Blocca a dx",
                    "unpin": "Blocca in alto"
                },
                "gridMenu": {
                    "columns": "Colonne:",
                    "importerTitle": "Importa",
                    "exporterAllAsCsv": "Esporta tutti i dati in CSV",
                    "exporterVisibleAsCsv": "Esporta i dati visibili in CSV",
                    "exporterSelectedAsCsv": "Esporta i dati selezionati in CSV",
                    "exporterAllAsPdf": "Esporta tutti i dati in PDF",
                    "exporterVisibleAsPdf": "Esporta i dati visibili in PDF",
                    "exporterSelectedAsPdf": "Esporta i dati selezionati in PDF",
                    "clearAllFilters": "Pulire tutti i filtri"
                },
                "importer": {
                    "noHeaders": "Impossibile reperire i nomi delle colonne, sicuro che siano indicati all'interno del file?",
                    "noObjects": "Impossibile reperire gli oggetti, sicuro che siano indicati all'interno del file?",
                    "invalidCsv": "Impossibile elaborare il file, sicuro che sia un CSV?",
                    "invalidJson": "Impossibile elaborare il file, sicuro che sia un JSON valido?",
                    "jsonNotArray": "Errore! Il file JSON da importare deve contenere un array."
                },
                "grouping": {
                    "group": "Raggruppa",
                    "ungroup": "Separa",
                    "aggregate_count": "Agg: N. Elem.",
                    "aggregate_sum": "Agg: Somma",
                    "aggregate_max": "Agg: Massimo",
                    "aggregate_min": "Agg: Minimo",
                    "aggregate_avg": "Agg: Media",
                    "aggregate_remove": "Agg: Rimuovi"
                },
                "validate": {
                    "error": "Errore:",
                    "minLength": "Lunghezza minima pari a THRESHOLD caratteri.",
                    "maxLength": "Lunghezza massima pari a THRESHOLD caratteri.",
                    "required": "Necessario inserire un valore."
                }
            });
            return $delegate;
        } ]);
    } ]);
})();

(function() {
    angular.module("ui.grid").config([ "$provide", function($provide) {
        $provide.decorator("i18nService", [ "$delegate", function($delegate) {
            $delegate.add("ja", {
                "aggregate": {
                    "label": "\u9805\u76ee"
                },
                "groupPanel": {
                    "description": "\u3053\u3053\u306b\u5217\u30d8\u30c3\u30c0\u3092\u30c9\u30e9\u30c3\u30b0\u30a2\u30f3\u30c9\u30c9\u30ed\u30c3\u30d7\u3057\u3066\u3001\u305d\u306e\u5217\u3067\u30b0\u30eb\u30fc\u30d7\u5316\u3057\u307e\u3059\u3002"
                },
                "search": {
                    "placeholder": "\u691c\u7d22...",
                    "showingItems": "\u8868\u793a\u4e2d\u306e\u9805\u76ee:",
                    "selectedItems": "\u9078\u629e\u3057\u305f\u9805\u76ee:",
                    "totalItems": "\u9805\u76ee\u306e\u7dcf\u6570:",
                    "size": "\u30da\u30fc\u30b8\u30b5\u30a4\u30ba:",
                    "first": "\u6700\u521d\u306e\u30da\u30fc\u30b8",
                    "next": "\u6b21\u306e\u30da\u30fc\u30b8",
                    "previous": "\u524d\u306e\u30da\u30fc\u30b8",
                    "last": "\u524d\u306e\u30da\u30fc\u30b8"
                },
                "menu": {
                    "text": "\u5217\u306e\u9078\u629e:"
                },
                "sort": {
                    "ascending": "\u6607\u9806\u306b\u4e26\u3079\u66ff\u3048",
                    "descending": "\u964d\u9806\u306b\u4e26\u3079\u66ff\u3048",
                    "remove": "\u4e26\u3079\u66ff\u3048\u306e\u89e3\u9664"
                },
                "column": {
                    "hide": "\u5217\u306e\u975e\u8868\u793a"
                },
                "aggregation": {
                    "count": "\u5408\u8a08\u884c\u6570: ",
                    "sum": "\u5408\u8a08: ",
                    "avg": "\u5e73\u5747: ",
                    "min": "\u6700\u5c0f: ",
                    "max": "\u6700\u5927: "
                },
                "pinning": {
                    "pinLeft": "\u5de6\u306b\u56fa\u5b9a",
                    "pinRight": "\u53f3\u306b\u56fa\u5b9a",
                    "unpin": "\u56fa\u5b9a\u89e3\u9664"
                },
                "gridMenu": {
                    "columns": "\u5217:",
                    "importerTitle": "\u30d5\u30a1\u30a4\u30eb\u306e\u30a4\u30f3\u30dd\u30fc\u30c8",
                    "exporterAllAsCsv": "\u3059\u3079\u3066\u306e\u30c7\u30fc\u30bf\u3092CSV\u5f62\u5f0f\u3067\u30a8\u30af\u30b9\u30dd\u30fc\u30c8",
                    "exporterVisibleAsCsv": "\u8868\u793a\u4e2d\u306e\u30c7\u30fc\u30bf\u3092CSV\u5f62\u5f0f\u3067\u30a8\u30af\u30b9\u30dd\u30fc\u30c8",
                    "exporterSelectedAsCsv": "\u9078\u629e\u3057\u305f\u30c7\u30fc\u30bf\u3092CSV\u5f62\u5f0f\u3067\u30a8\u30af\u30b9\u30dd\u30fc\u30c8",
                    "exporterAllAsPdf": "\u3059\u3079\u3066\u306e\u30c7\u30fc\u30bf\u3092PDF\u5f62\u5f0f\u3067\u30a8\u30af\u30b9\u30dd\u30fc\u30c8",
                    "exporterVisibleAsPdf": "\u8868\u793a\u4e2d\u306e\u30c7\u30fc\u30bf\u3092PDF\u5f62\u5f0f\u3067\u30a8\u30af\u30b9\u30dd\u30fc\u30c8",
                    "exporterSelectedAsPdf": "\u9078\u629e\u3057\u305f\u30c7\u30fc\u30bf\u3092PDF\u5f62\u5f0f\u3067\u30a8\u30af\u30b9\u30dd\u30fc\u30c8",
                    "clearAllFilters": "\u3059\u3079\u3066\u306e\u30d5\u30a3\u30eb\u30bf\u3092\u6e05\u6383\u3057\u3066\u304f\u3060\u3055\u3044"
                },
                "importer": {
                    "noHeaders": "\u5217\u540d\u3092\u53d6\u5f97\u3067\u304d\u307e\u305b\u3093\u3002\u30d5\u30a1\u30a4\u30eb\u306b\u30d8\u30c3\u30c0\u304c\u542b\u307e\u308c\u3066\u3044\u308b\u3053\u3068\u3092\u78ba\u8a8d\u3057\u3066\u304f\u3060\u3055\u3044\u3002",
                    "noObjects": "\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3092\u53d6\u5f97\u3067\u304d\u307e\u305b\u3093\u3002\u30d5\u30a1\u30a4\u30eb\u306b\u30d8\u30c3\u30c0\u4ee5\u5916\u306e\u30c7\u30fc\u30bf\u304c\u542b\u307e\u308c\u3066\u3044\u308b\u3053\u3068\u3092\u78ba\u8a8d\u3057\u3066\u304f\u3060\u3055\u3044\u3002",
                    "invalidCsv": "\u30d5\u30a1\u30a4\u30eb\u3092\u51e6\u7406\u3067\u304d\u307e\u305b\u3093\u3002\u30d5\u30a1\u30a4\u30eb\u304c\u6709\u52b9\u306aCSV\u5f62\u5f0f\u3067\u3042\u308b\u3053\u3068\u3092\u78ba\u8a8d\u3057\u3066\u304f\u3060\u3055\u3044\u3002",
                    "invalidJson": "\u30d5\u30a1\u30a4\u30eb\u3092\u51e6\u7406\u3067\u304d\u307e\u305b\u3093\u3002\u30d5\u30a1\u30a4\u30eb\u304c\u6709\u52b9\u306aJSON\u5f62\u5f0f\u3067\u3042\u308b\u3053\u3068\u3092\u78ba\u8a8d\u3057\u3066\u304f\u3060\u3055\u3044\u3002",
                    "jsonNotArray": "\u30a4\u30f3\u30dd\u30fc\u30c8\u3057\u305fJSON\u30d5\u30a1\u30a4\u30eb\u306b\u306f\u914d\u5217\u304c\u542b\u307e\u308c\u3066\u3044\u308b\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u3002\u51e6\u7406\u3092\u4e2d\u6b62\u3057\u307e\u3059\u3002"
                },
                "pagination": {
                    "aria": {
                        "pageToFirst": "\u6700\u521d\u306e\u30da\u30fc\u30b8",
                        "pageBack": "\u524d\u306e\u30da\u30fc\u30b8",
                        "pageSelected": "\u73fe\u5728\u306e\u30da\u30fc\u30b8",
                        "pageForward": "\u6b21\u306e\u30da\u30fc\u30b8",
                        "pageToLast": "\u6700\u5f8c\u306e\u30da\u30fc\u30b8"
                    },
                    "sizes": "\u9805\u76ee/\u30da\u30fc\u30b8",
                    "totalItems": "\u9805\u76ee",
                    "through": "\u304b\u3089",
                    "of": "\u9805\u76ee/\u5168"
                }
            });
            return $delegate;
        } ]);
    } ]);
})();

(function() {
    angular.module("ui.grid").config([ "$provide", function($provide) {
        $provide.decorator("i18nService", [ "$delegate", function($delegate) {
            $delegate.add("ko", {
                "aggregate": {
                    "label": "\uc544\uc774\ud15c"
                },
                "groupPanel": {
                    "description": "\uceec\ub7fc\uc73c\ub85c \uadf8\ub8f9\ud551\ud558\uae30 \uc704\ud574\uc11c\ub294 \uceec\ub7fc \ud5e4\ub354\ub97c \ub04c\uc5b4 \ub5a8\uc5b4\ub728\ub824 \uc8fc\uc138\uc694."
                },
                "search": {
                    "placeholder": "\uac80\uc0c9...",
                    "showingItems": "\ud56d\ubaa9 \ubcf4\uc5ec\uc8fc\uae30:",
                    "selectedItems": "\uc120\ud0dd \ud56d\ubaa9:",
                    "totalItems": "\uc804\uccb4 \ud56d\ubaa9:",
                    "size": "\ud398\uc774\uc9c0 \ud06c\uae30:",
                    "first": "\uccab\ubc88\uc9f8 \ud398\uc774\uc9c0",
                    "next": "\ub2e4\uc74c \ud398\uc774\uc9c0",
                    "previous": "\uc774\uc804 \ud398\uc774\uc9c0",
                    "last": "\ub9c8\uc9c0\ub9c9 \ud398\uc774\uc9c0"
                },
                "menu": {
                    "text": "\uceec\ub7fc\uc744 \uc120\ud0dd\ud558\uc138\uc694:"
                },
                "sort": {
                    "ascending": "\uc624\ub984\ucc28\uc21c \uc815\ub82c",
                    "descending": "\ub0b4\ub9bc\ucc28\uc21c \uc815\ub82c",
                    "remove": "\uc18c\ud305 \uc81c\uac70"
                },
                "column": {
                    "hide": "\uceec\ub7fc \uc81c\uac70"
                },
                "aggregation": {
                    "count": "\uc804\uccb4 \uac2f\uc218: ",
                    "sum": "\uc804\uccb4: ",
                    "avg": "\ud3c9\uade0: ",
                    "min": "\ucd5c\uc18c: ",
                    "max": "\ucd5c\ub300: "
                },
                "pinning": {
                    "pinLeft": "\uc67c\ucabd \ud540",
                    "pinRight": "\uc624\ub978\ucabd \ud540",
                    "unpin": "\ud540 \uc81c\uac70"
                },
                "gridMenu": {
                    "columns": "\uceec\ub7fc:",
                    "importerTitle": "\ud30c\uc77c \uac00\uc838\uc624\uae30",
                    "exporterAllAsCsv": "csv\ub85c \ubaa8\ub4e0 \ub370\uc774\ud130 \ub0b4\ubcf4\ub0b4\uae30",
                    "exporterVisibleAsCsv": "csv\ub85c \ubcf4\uc774\ub294 \ub370\uc774\ud130 \ub0b4\ubcf4\ub0b4\uae30",
                    "exporterSelectedAsCsv": "csv\ub85c \uc120\ud0dd\ub41c \ub370\uc774\ud130 \ub0b4\ubcf4\ub0b4\uae30",
                    "exporterAllAsPdf": "pdf\ub85c \ubaa8\ub4e0 \ub370\uc774\ud130 \ub0b4\ubcf4\ub0b4\uae30",
                    "exporterVisibleAsPdf": "pdf\ub85c \ubcf4\uc774\ub294 \ub370\uc774\ud130 \ub0b4\ubcf4\ub0b4\uae30",
                    "exporterSelectedAsPdf": "pdf\ub85c \uc120\ud0dd \ub370\uc774\ud130 \ub0b4\ubcf4\ub0b4\uae30",
                    "clearAllFilters": "\ubaa8\ub4e0 \ud544\ud130\ub97c \uccad\uc18c"
                },
                "importer": {
                    "noHeaders": "\uceec\ub7fc\uba85\uc774 \uc9c0\uc815\ub418\uc5b4 \uc788\uc9c0 \uc54a\uc2b5\ub2c8\ub2e4. \ud30c\uc77c\uc5d0 \ud5e4\ub354\uac00 \uba85\uc2dc\ub418\uc5b4 \uc788\ub294\uc9c0 \ud655\uc778\ud574 \uc8fc\uc138\uc694.",
                    "noObjects": "\ub370\uc774\ud130\uac00 \uc9c0\uc815\ub418\uc5b4 \uc788\uc9c0 \uc54a\uc2b5\ub2c8\ub2e4. \ub370\uc774\ud130\uac00 \ud30c\uc77c\uc5d0 \uc788\ub294\uc9c0 \ud655\uc778\ud574 \uc8fc\uc138\uc694.",
                    "invalidCsv": "\ud30c\uc77c\uc744 \ucc98\ub9ac\ud560 \uc218 \uc5c6\uc2b5\ub2c8\ub2e4. \uc62c\ubc14\ub978 csv\uc778\uc9c0 \ud655\uc778\ud574 \uc8fc\uc138\uc694.",
                    "invalidJson": "\ud30c\uc77c\uc744 \ucc98\ub9ac\ud560 \uc218 \uc5c6\uc2b5\ub2c8\ub2e4. \uc62c\ubc14\ub978 json\uc778\uc9c0 \ud655\uc778\ud574 \uc8fc\uc138\uc694.",
                    "jsonNotArray": "json \ud30c\uc77c\uc740 \ubc30\uc5f4\uc744 \ud3ec\ud568\ud574\uc57c \ud569\ub2c8\ub2e4."
                },
                "pagination": {
                    "sizes": "\ud398\uc774\uc9c0\ub2f9 \ud56d\ubaa9",
                    "totalItems": "\uc804\uccb4 \ud56d\ubaa9"
                }
            });
            return $delegate;
        } ]);
    } ]);
})();

(function() {
    angular.module("ui.grid").config([ "$provide", function($provide) {
        $provide.decorator("i18nService", [ "$delegate", function($delegate) {
            $delegate.add("nl", {
                "aggregate": {
                    "label": "items"
                },
                "groupPanel": {
                    "description": "Sleep hier een kolomnaam heen om op te groeperen."
                },
                "search": {
                    "placeholder": "Zoeken...",
                    "showingItems": "Getoonde items:",
                    "selectedItems": "Geselecteerde items:",
                    "totalItems": "Totaal aantal items:",
                    "size": "Items per pagina:",
                    "first": "Eerste pagina",
                    "next": "Volgende pagina",
                    "previous": "Vorige pagina",
                    "last": "Laatste pagina"
                },
                "menu": {
                    "text": "Kies kolommen:"
                },
                "sort": {
                    "ascending": "Sorteer oplopend",
                    "descending": "Sorteer aflopend",
                    "remove": "Verwijder sortering"
                },
                "column": {
                    "hide": "Verberg kolom"
                },
                "aggregation": {
                    "count": "Aantal rijen: ",
                    "sum": "Som: ",
                    "avg": "Gemiddelde: ",
                    "min": "Min: ",
                    "max": "Max: "
                },
                "pinning": {
                    "pinLeft": "Zet links vast",
                    "pinRight": "Zet rechts vast",
                    "unpin": "Maak los"
                },
                "gridMenu": {
                    "columns": "Kolommen:",
                    "importerTitle": "Importeer bestand",
                    "exporterAllAsCsv": "Exporteer alle data als csv",
                    "exporterVisibleAsCsv": "Exporteer zichtbare data als csv",
                    "exporterSelectedAsCsv": "Exporteer geselecteerde data als csv",
                    "exporterAllAsPdf": "Exporteer alle data als pdf",
                    "exporterVisibleAsPdf": "Exporteer zichtbare data als pdf",
                    "exporterSelectedAsPdf": "Exporteer geselecteerde data als pdf",
                    "clearAllFilters": "Reinig alle filters"
                },
                "importer": {
                    "noHeaders": "Kolomnamen kunnen niet worden afgeleid. Heeft het bestand een header?",
                    "noObjects": "Objecten kunnen niet worden afgeleid. Bevat het bestand data naast de headers?",
                    "invalidCsv": "Het bestand kan niet verwerkt worden. Is het een valide csv bestand?",
                    "invalidJson": "Het bestand kan niet verwerkt worden. Is het valide json?",
                    "jsonNotArray": "Het json bestand moet een array bevatten. De actie wordt geannuleerd."
                },
                "pagination": {
                    "sizes": "items per pagina",
                    "totalItems": "items",
                    "of": "van de"
                },
                "grouping": {
                    "group": "Groepeer",
                    "ungroup": "Groepering opheffen",
                    "aggregate_count": "Agg: Aantal",
                    "aggregate_sum": "Agg: Som",
                    "aggregate_max": "Agg: Max",
                    "aggregate_min": "Agg: Min",
                    "aggregate_avg": "Agg: Gem",
                    "aggregate_remove": "Agg: Verwijder"
                }
            });
            return $delegate;
        } ]);
    } ]);
})();

(function() {
    angular.module("ui.grid").config([ "$provide", function($provide) {
        $provide.decorator("i18nService", [ "$delegate", function($delegate) {
            $delegate.add("pl", {
                "headerCell": {
                    "aria": {
                        "defaultFilterLabel": "Filter dla kolumny",
                        "removeFilter": "Usu\u0144 filter",
                        "columnMenuButtonLabel": "Menu kolumny"
                    },
                    "priority": "Prioritet:",
                    "filterLabel": "Filtr dla kolumny: "
                },
                "aggregate": {
                    "label": "pozycji"
                },
                "groupPanel": {
                    "description": "Przeci\u0105gnij nag\u0142\xf3wek kolumny tutaj, aby pogrupowa\u0107 wed\u0142ug niej."
                },
                "search": {
                    "placeholder": "Szukaj...",
                    "showingItems": "Widoczne pozycje:",
                    "selectedItems": "Zaznaczone pozycje:",
                    "totalItems": "Wszystkich pozycji:",
                    "size": "Rozmiar strony:",
                    "first": "Pierwsza strona",
                    "next": "Nast\u0119pna strona",
                    "previous": "Poprzednia strona",
                    "last": "Ostatnia strona"
                },
                "menu": {
                    "text": "Wybierz kolumny:"
                },
                "sort": {
                    "ascending": "Sortuj rosn\u0105co",
                    "descending": "Sortuj malej\u0105co",
                    "none": "Brak sortowania",
                    "remove": "Wy\u0142\u0105cz sortowanie"
                },
                "column": {
                    "hide": "Ukryj kolumne"
                },
                "aggregation": {
                    "count": "Razem pozycji: ",
                    "sum": "Razem: ",
                    "avg": "\u015arednia: ",
                    "min": "Min: ",
                    "max": "Max: "
                },
                "pinning": {
                    "pinLeft": "Przypnij do lewej",
                    "pinRight": "Przypnij do prawej",
                    "unpin": "Odepnij"
                },
                "columnMenu": {
                    "close": "Zamknij"
                },
                "gridMenu": {
                    "aria": {
                        "buttonLabel": "Menu Grida"
                    },
                    "columns": "Kolumny:",
                    "importerTitle": "Importuj plik",
                    "exporterAllAsCsv": "Eksportuj wszystkie dane do csv",
                    "exporterVisibleAsCsv": "Eksportuj widoczne dane do csv",
                    "exporterSelectedAsCsv": "Eksportuj zaznaczone dane do csv",
                    "exporterAllAsPdf": "Eksportuj wszystkie dane do pdf",
                    "exporterVisibleAsPdf": "Eksportuj widoczne dane do pdf",
                    "exporterSelectedAsPdf": "Eksportuj zaznaczone dane do pdf",
                    "clearAllFilters": "Wyczy\u015b\u0107 filtry"
                },
                "importer": {
                    "noHeaders": "Nie uda\u0142o si\u0119 wczyta\u0107 nazw kolumn. Czy plik posiada nag\u0142\xf3wek?",
                    "noObjects": "Nie udalo si\u0119 wczyta\u0107 pozycji. Czy plik zawiera dane??",
                    "invalidCsv": "Nie uda\u0142o si\u0119 przetworzy\u0107 pliku, jest to prawidlowy plik CSV??",
                    "invalidJson": "Nie uda\u0142o si\u0119 przetworzy\u0107 pliku, jest to prawidlowy plik Json?",
                    "jsonNotArray": "Importowany plik json musi zawiera\u0107 tablic\u0119, importowanie przerwane."
                },
                "pagination": {
                    "aria": {
                        "pageToFirst": "Pierwsza strona",
                        "pageBack": "Poprzednia strona",
                        "pageSelected": "Wybrana strona",
                        "pageForward": "Nast\u0119pna strona",
                        "pageToLast": "Ostatnia strona"
                    },
                    "sizes": "pozycji na stron\u0119",
                    "totalItems": "pozycji",
                    "through": "do",
                    "of": "z"
                },
                "grouping": {
                    "group": "Grupuj",
                    "ungroup": "Rozgrupuj",
                    "aggregate_count": "Zbiorczo: Razem",
                    "aggregate_sum": "Zbiorczo: Suma",
                    "aggregate_max": "Zbiorczo: Max",
                    "aggregate_min": "Zbiorczo: Min",
                    "aggregate_avg": "Zbiorczo: \u015arednia",
                    "aggregate_remove": "Zbiorczo: Usu\u0144"
                }
            });
            return $delegate;
        } ]);
    } ]);
})();

(function() {
    angular.module("ui.grid").config([ "$provide", function($provide) {
        $provide.decorator("i18nService", [ "$delegate", function($delegate) {
            $delegate.add("pt-br", {
                "headerCell": {
                    "aria": {
                        "defaultFilterLabel": "Filtro por coluna",
                        "removeFilter": "Remover filtro",
                        "columnMenuButtonLabel": "Menu coluna"
                    },
                    "priority": "Prioridade:",
                    "filterLabel": "Filtro por coluna: "
                },
                "aggregate": {
                    "label": "itens"
                },
                "groupPanel": {
                    "description": "Arraste e solte uma coluna aqui para agrupar por essa coluna"
                },
                "search": {
                    "placeholder": "Procurar...",
                    "showingItems": "Mostrando os Itens:",
                    "selectedItems": "Items Selecionados:",
                    "totalItems": "Total de Itens:",
                    "size": "Tamanho da P\xe1gina:",
                    "first": "Primeira P\xe1gina",
                    "next": "Pr\xf3xima P\xe1gina",
                    "previous": "P\xe1gina Anterior",
                    "last": "\xdaltima P\xe1gina"
                },
                "menu": {
                    "text": "Selecione as colunas:"
                },
                "sort": {
                    "ascending": "Ordenar Ascendente",
                    "descending": "Ordenar Descendente",
                    "none": "Nenhuma Ordem",
                    "remove": "Remover Ordena\xe7\xe3o"
                },
                "column": {
                    "hide": "Esconder coluna"
                },
                "aggregation": {
                    "count": "total de linhas: ",
                    "sum": "total: ",
                    "avg": "med: ",
                    "min": "min: ",
                    "max": "max: "
                },
                "pinning": {
                    "pinLeft": "Fixar Esquerda",
                    "pinRight": "Fixar Direita",
                    "unpin": "Desprender"
                },
                "columnMenu": {
                    "close": "Fechar"
                },
                "gridMenu": {
                    "aria": {
                        "buttonLabel": "Menu Grid"
                    },
                    "columns": "Colunas:",
                    "importerTitle": "Importar arquivo",
                    "exporterAllAsCsv": "Exportar todos os dados como csv",
                    "exporterVisibleAsCsv": "Exportar dados vis\xedveis como csv",
                    "exporterSelectedAsCsv": "Exportar dados selecionados como csv",
                    "exporterAllAsPdf": "Exportar todos os dados como pdf",
                    "exporterVisibleAsPdf": "Exportar dados vis\xedveis como pdf",
                    "exporterSelectedAsPdf": "Exportar dados selecionados como pdf",
                    "clearAllFilters": "Limpar todos os filtros"
                },
                "importer": {
                    "noHeaders": "Nomes de colunas n\xe3o puderam ser derivados. O arquivo tem um cabe\xe7alho?",
                    "noObjects": "Objetos n\xe3o puderam ser derivados. Havia dados no arquivo, al\xe9m dos cabe\xe7alhos?",
                    "invalidCsv": "Arquivo n\xe3o pode ser processado. \xc9 um CSV v\xe1lido?",
                    "invalidJson": "Arquivo n\xe3o pode ser processado. \xc9 um Json v\xe1lido?",
                    "jsonNotArray": "Arquivo json importado tem que conter um array. Abortando."
                },
                "pagination": {
                    "aria": {
                        "pageToFirst": "Primeira p\xe1gina",
                        "pageBack": "P\xe1gina anterior",
                        "pageSelected": "P\xe1gina Selecionada",
                        "pageForward": "Proxima",
                        "pageToLast": "Anterior"
                    },
                    "sizes": "itens por p\xe1gina",
                    "totalItems": "itens",
                    "through": "atrav\xe9s dos",
                    "of": "de"
                },
                "grouping": {
                    "group": "Agrupar",
                    "ungroup": "Desagrupar",
                    "aggregate_count": "Agr: Contar",
                    "aggregate_sum": "Agr: Soma",
                    "aggregate_max": "Agr: Max",
                    "aggregate_min": "Agr: Min",
                    "aggregate_avg": "Agr: Med",
                    "aggregate_remove": "Agr: Remover"
                }
            });
            return $delegate;
        } ]);
    } ]);
})();

(function() {
    angular.module("ui.grid").config([ "$provide", function($provide) {
        $provide.decorator("i18nService", [ "$delegate", function($delegate) {
            $delegate.add("pt", {
                "headerCell": {
                    "aria": {
                        "defaultFilterLabel": "Filtro por coluna",
                        "removeFilter": "Remover filtro",
                        "columnMenuButtonLabel": "Menu coluna"
                    },
                    "priority": "Prioridade:",
                    "filterLabel": "Filtro por coluna: "
                },
                "aggregate": {
                    "label": "itens"
                },
                "groupPanel": {
                    "description": "Arraste e solte uma coluna aqui para agrupar por essa coluna"
                },
                "search": {
                    "placeholder": "Procurar...",
                    "showingItems": "Mostrando os Itens:",
                    "selectedItems": "Itens Selecionados:",
                    "totalItems": "Total de Itens:",
                    "size": "Tamanho da P\xe1gina:",
                    "first": "Primeira P\xe1gina",
                    "next": "Pr\xf3xima P\xe1gina",
                    "previous": "P\xe1gina Anterior",
                    "last": "\xdaltima P\xe1gina"
                },
                "menu": {
                    "text": "Selecione as colunas:"
                },
                "sort": {
                    "ascending": "Ordenar Ascendente",
                    "descending": "Ordenar Descendente",
                    "none": "Nenhuma Ordem",
                    "remove": "Remover Ordena\xe7\xe3o"
                },
                "column": {
                    "hide": "Esconder coluna"
                },
                "aggregation": {
                    "count": "total de linhas: ",
                    "sum": "total: ",
                    "avg": "med: ",
                    "min": "min: ",
                    "max": "max: "
                },
                "pinning": {
                    "pinLeft": "Fixar Esquerda",
                    "pinRight": "Fixar Direita",
                    "unpin": "Desprender"
                },
                "columnMenu": {
                    "close": "Fechar"
                },
                "gridMenu": {
                    "aria": {
                        "buttonLabel": "Menu Grid"
                    },
                    "columns": "Colunas:",
                    "importerTitle": "Importar ficheiro",
                    "exporterAllAsCsv": "Exportar todos os dados como csv",
                    "exporterVisibleAsCsv": "Exportar dados vis\xedveis como csv",
                    "exporterSelectedAsCsv": "Exportar dados selecionados como csv",
                    "exporterAllAsPdf": "Exportar todos os dados como pdf",
                    "exporterVisibleAsPdf": "Exportar dados vis\xedveis como pdf",
                    "exporterSelectedAsPdf": "Exportar dados selecionados como pdf",
                    "clearAllFilters": "Limpar todos os filtros"
                },
                "importer": {
                    "noHeaders": "Nomes de colunas n\xe3o puderam ser derivados. O ficheiro tem um cabe\xe7alho?",
                    "noObjects": "Objetos n\xe3o puderam ser derivados. Havia dados no ficheiro, al\xe9m dos cabe\xe7alhos?",
                    "invalidCsv": "Ficheiro n\xe3o pode ser processado. \xc9 um CSV v\xe1lido?",
                    "invalidJson": "Ficheiro n\xe3o pode ser processado. \xc9 um Json v\xe1lido?",
                    "jsonNotArray": "Ficheiro json importado tem que conter um array. Interrompendo."
                },
                "pagination": {
                    "aria": {
                        "pageToFirst": "Primeira p\xe1gina",
                        "pageBack": "P\xe1gina anterior",
                        "pageSelected": "P\xe1gina Selecionada",
                        "pageForward": "Pr\xf3xima",
                        "pageToLast": "Anterior"
                    },
                    "sizes": "itens por p\xe1gina",
                    "totalItems": "itens",
                    "through": "atrav\xe9s dos",
                    "of": "de"
                },
                "grouping": {
                    "group": "Agrupar",
                    "ungroup": "Desagrupar",
                    "aggregate_count": "Agr: Contar",
                    "aggregate_sum": "Agr: Soma",
                    "aggregate_max": "Agr: Max",
                    "aggregate_min": "Agr: Min",
                    "aggregate_avg": "Agr: Med",
                    "aggregate_remove": "Agr: Remover"
                }
            });
            return $delegate;
        } ]);
    } ]);
})();

(function() {
    angular.module("ui.grid").config([ "$provide", function($provide) {
        $provide.decorator("i18nService", [ "$delegate", function($delegate) {
            $delegate.add("ro", {
                "headerCell": {
                    "aria": {
                        "defaultFilterLabel": "Filtru pentru coloana",
                        "removeFilter": "Sterge filtru",
                        "columnMenuButtonLabel": "Column Menu"
                    },
                    "priority": "Prioritate:",
                    "filterLabel": "Filtru pentru coloana:"
                },
                "aggregate": {
                    "label": "Elemente"
                },
                "groupPanel": {
                    "description": "Trage un cap de coloana aici pentru a grupa elementele dupa coloana respectiva"
                },
                "search": {
                    "placeholder": "Cauta...",
                    "showingItems": "Arata elementele:",
                    "selectedItems": "Elementele selectate:",
                    "totalItems": "Total elemente:",
                    "size": "Marime pagina:",
                    "first": "Prima pagina",
                    "next": "Pagina urmatoare",
                    "previous": "Pagina anterioara",
                    "last": "Ultima pagina"
                },
                "menu": {
                    "text": "Alege coloane:"
                },
                "sort": {
                    "ascending": "Ordoneaza crescator",
                    "descending": "Ordoneaza descrescator",
                    "none": "Fara ordonare",
                    "remove": "Sterge ordonarea"
                },
                "column": {
                    "hide": "Ascunde coloana"
                },
                "aggregation": {
                    "count": "total linii: ",
                    "sum": "total: ",
                    "avg": "medie: ",
                    "min": "min: ",
                    "max": "max: "
                },
                "pinning": {
                    "pinLeft": "Pin la stanga",
                    "pinRight": "Pin la dreapta",
                    "unpin": "Sterge pinul"
                },
                "columnMenu": {
                    "close": "Inchide"
                },
                "gridMenu": {
                    "aria": {
                        "buttonLabel": "Grid Menu"
                    },
                    "columns": "Coloane:",
                    "importerTitle": "Incarca fisier",
                    "exporterAllAsCsv": "Exporta toate datele ca csv",
                    "exporterVisibleAsCsv": "Exporta datele vizibile ca csv",
                    "exporterSelectedAsCsv": "Exporta datele selectate ca csv",
                    "exporterAllAsPdf": "Exporta toate datele ca pdf",
                    "exporterVisibleAsPdf": "Exporta datele vizibile ca pdf",
                    "exporterSelectedAsPdf": "Exporta datele selectate ca csv pdf",
                    "clearAllFilters": "Sterge toate filtrele"
                },
                "importer": {
                    "noHeaders": "Numele coloanelor nu a putut fi incarcat, acest fisier are un header?",
                    "noObjects": "Datele nu au putut fi incarcate, exista date in fisier in afara numelor de coloane?",
                    "invalidCsv": "Fisierul nu a putut fi procesat, ati incarcat un CSV valid ?",
                    "invalidJson": "Fisierul nu a putut fi procesat, ati incarcat un Json valid?",
                    "jsonNotArray": "Json-ul incarcat trebuie sa contina un array, inchidere."
                },
                "pagination": {
                    "aria": {
                        "pageToFirst": "Prima pagina",
                        "pageBack": "O pagina inapoi",
                        "pageSelected": "Pagina selectata",
                        "pageForward": "O pagina inainte",
                        "pageToLast": "Ultima pagina"
                    },
                    "sizes": "Elemente per pagina",
                    "totalItems": "elemente",
                    "through": "prin",
                    "of": "of"
                },
                "grouping": {
                    "group": "Grupeaza",
                    "ungroup": "Opreste gruparea",
                    "aggregate_count": "Agg: Count",
                    "aggregate_sum": "Agg: Sum",
                    "aggregate_max": "Agg: Max",
                    "aggregate_min": "Agg: Min",
                    "aggregate_avg": "Agg: Avg",
                    "aggregate_remove": "Agg: Remove"
                }
            });
            return $delegate;
        } ]);
    } ]);
})();

(function() {
    angular.module("ui.grid").config([ "$provide", function($provide) {
        $provide.decorator("i18nService", [ "$delegate", function($delegate) {
            $delegate.add("ru", {
                "headerCell": {
                    "aria": {
                        "defaultFilterLabel": "\u0424\u0438\u043b\u044c\u0442\u0440 \u0441\u0442\u043e\u043b\u0431\u0446\u0430",
                        "removeFilter": "\u0423\u0434\u0430\u043b\u0438\u0442\u044c \u0444\u0438\u043b\u044c\u0442\u0440",
                        "columnMenuButtonLabel": "\u041c\u0435\u043d\u044e \u0441\u0442\u043e\u043b\u0431\u0446\u0430"
                    },
                    "priority": "\u041f\u0440\u0438\u043e\u0440\u0438\u0442\u0435\u0442:",
                    "filterLabel": "\u0424\u0438\u043b\u044c\u0442\u0440 \u0441\u0442\u043e\u043b\u0431\u0446\u0430: "
                },
                "aggregate": {
                    "label": "\u044d\u043b\u0435\u043c\u0435\u043d\u0442\u044b"
                },
                "groupPanel": {
                    "description": "\u0414\u043b\u044f \u0433\u0440\u0443\u043f\u043f\u0438\u0440\u043e\u0432\u043a\u0438 \u043f\u043e \u0441\u0442\u043e\u043b\u0431\u0446\u0443 \u043f\u0435\u0440\u0435\u0442\u0430\u0449\u0438\u0442\u0435 \u0441\u044e\u0434\u0430 \u0435\u0433\u043e \u043d\u0430\u0437\u0432\u0430\u043d\u0438\u0435."
                },
                "search": {
                    "placeholder": "\u041f\u043e\u0438\u0441\u043a...",
                    "showingItems": "\u041f\u043e\u043a\u0430\u0437\u0430\u0442\u044c \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u044b:",
                    "selectedItems": "\u0412\u044b\u0431\u0440\u0430\u043d\u043d\u044b\u0435 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u044b:",
                    "totalItems": "\u0412\u0441\u0435\u0433\u043e \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432:",
                    "size": "\u0420\u0430\u0437\u043c\u0435\u0440 \u0441\u0442\u0440\u0430\u043d\u0438\u0446\u044b:",
                    "first": "\u041f\u0435\u0440\u0432\u0430\u044f \u0441\u0442\u0440\u0430\u043d\u0438\u0446\u0430",
                    "next": "\u0421\u043b\u0435\u0434\u0443\u044e\u0449\u0430\u044f \u0441\u0442\u0440\u0430\u043d\u0438\u0446\u0430",
                    "previous": "\u041f\u0440\u0435\u0434\u044b\u0434\u0443\u0449\u0430\u044f \u0441\u0442\u0440\u0430\u043d\u0438\u0446\u0430",
                    "last": "\u041f\u043e\u0441\u043b\u0435\u0434\u043d\u044f\u044f \u0441\u0442\u0440\u0430\u043d\u0438\u0446\u0430"
                },
                "menu": {
                    "text": "\u0412\u044b\u0431\u0440\u0430\u0442\u044c \u0441\u0442\u043e\u043b\u0431\u0446\u044b:"
                },
                "sort": {
                    "ascending": "\u041f\u043e \u0432\u043e\u0437\u0440\u0430\u0441\u0442\u0430\u043d\u0438\u044e",
                    "descending": "\u041f\u043e \u0443\u0431\u044b\u0432\u0430\u043d\u0438\u044e",
                    "none": "\u0411\u0435\u0437 \u0441\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u043a\u0438",
                    "remove": "\u0423\u0431\u0440\u0430\u0442\u044c \u0441\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u043a\u0443"
                },
                "column": {
                    "hide": "\u0421\u043f\u0440\u044f\u0442\u0430\u0442\u044c \u0441\u0442\u043e\u043b\u0431\u0435\u0446"
                },
                "aggregation": {
                    "count": "\u0432\u0441\u0435\u0433\u043e \u0441\u0442\u0440\u043e\u043a: ",
                    "sum": "\u0438\u0442\u043e\u0433\u043e: ",
                    "avg": "\u0441\u0440\u0435\u0434\u043d\u0435\u0435: ",
                    "min": "\u043c\u0438\u043d: ",
                    "max": "\u043c\u0430\u043a\u0441: "
                },
                "pinning": {
                    "pinLeft": "\u0417\u0430\u043a\u0440\u0435\u043f\u0438\u0442\u044c \u0441\u043b\u0435\u0432\u0430",
                    "pinRight": "\u0417\u0430\u043a\u0440\u0435\u043f\u0438\u0442\u044c \u0441\u043f\u0440\u0430\u0432\u0430",
                    "unpin": "\u041e\u0442\u043a\u0440\u0435\u043f\u0438\u0442\u044c"
                },
                "columnMenu": {
                    "close": "\u0417\u0430\u043a\u0440\u044b\u0442\u044c"
                },
                "gridMenu": {
                    "aria": {
                        "buttonLabel": "\u041c\u0435\u043d\u044e"
                    },
                    "columns": "\u0421\u0442\u043e\u043b\u0431\u0446\u044b:",
                    "importerTitle": "\u0418\u043c\u043f\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u0444\u0430\u0439\u043b",
                    "exporterAllAsCsv": "\u042d\u043a\u0441\u043f\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u0432\u0441\u0451 \u0432 CSV",
                    "exporterVisibleAsCsv": "\u042d\u043a\u0441\u043f\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u0432\u0438\u0434\u0438\u043c\u044b\u0435 \u0434\u0430\u043d\u043d\u044b\u0435 \u0432 CSV",
                    "exporterSelectedAsCsv": "\u042d\u043a\u0441\u043f\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u0432\u044b\u0431\u0440\u0430\u043d\u043d\u044b\u0435 \u0434\u0430\u043d\u043d\u044b\u0435 \u0432 CSV",
                    "exporterAllAsPdf": "\u042d\u043a\u0441\u043f\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u0432\u0441\u0451 \u0432 PDF",
                    "exporterVisibleAsPdf": "\u042d\u043a\u0441\u043f\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u0432\u0438\u0434\u0438\u043c\u044b\u0435 \u0434\u0430\u043d\u043d\u044b\u0435 \u0432 PDF",
                    "exporterSelectedAsPdf": "\u042d\u043a\u0441\u043f\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u0432\u044b\u0431\u0440\u0430\u043d\u043d\u044b\u0435 \u0434\u0430\u043d\u043d\u044b\u0435 \u0432 PDF",
                    "clearAllFilters": "\u041e\u0447\u0438\u0441\u0442\u0438\u0442\u0435 \u0432\u0441\u0435 \u0444\u0438\u043b\u044c\u0442\u0440\u044b"
                },
                "importer": {
                    "noHeaders": "\u041d\u0435 \u0443\u0434\u0430\u043b\u043e\u0441\u044c \u043f\u043e\u043b\u0443\u0447\u0438\u0442\u044c \u043d\u0430\u0437\u0432\u0430\u043d\u0438\u044f \u0441\u0442\u043e\u043b\u0431\u0446\u043e\u0432, \u0435\u0441\u0442\u044c \u043b\u0438 \u0432 \u0444\u0430\u0439\u043b\u0435 \u0437\u0430\u0433\u043e\u043b\u043e\u0432\u043e\u043a?",
                    "noObjects": "\u041d\u0435 \u0443\u0434\u0430\u043b\u043e\u0441\u044c \u043f\u043e\u043b\u0443\u0447\u0438\u0442\u044c \u0434\u0430\u043d\u043d\u044b\u0435, \u0435\u0441\u0442\u044c \u043b\u0438 \u0432 \u0444\u0430\u0439\u043b\u0435 \u0441\u0442\u0440\u043e\u043a\u0438 \u043a\u0440\u043e\u043c\u0435 \u0437\u0430\u0433\u043e\u043b\u043e\u0432\u043a\u0430?",
                    "invalidCsv": "\u041d\u0435 \u0443\u0434\u0430\u043b\u043e\u0441\u044c \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u0430\u0442\u044c \u0444\u0430\u0439\u043b, \u044d\u0442\u043e \u043f\u0440\u0430\u0432\u0438\u043b\u044c\u043d\u044b\u0439 CSV-\u0444\u0430\u0439\u043b?",
                    "invalidJson": "\u041d\u0435 \u0443\u0434\u0430\u043b\u043e\u0441\u044c \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u0430\u0442\u044c \u0444\u0430\u0439\u043b, \u044d\u0442\u043e \u043f\u0440\u0430\u0432\u0438\u043b\u044c\u043d\u044b\u0439 JSON?",
                    "jsonNotArray": "\u0418\u043c\u043f\u043e\u0440\u0442\u0438\u0440\u0443\u0435\u043c\u044b\u0439 JSON-\u0444\u0430\u0439\u043b \u0434\u043e\u043b\u0436\u0435\u043d \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0442\u044c \u043c\u0430\u0441\u0441\u0438\u0432, \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u044f \u043e\u0442\u043c\u0435\u043d\u0435\u043d\u0430."
                },
                "pagination": {
                    "aria": {
                        "pageToFirst": "\u041f\u0435\u0440\u0432\u0430\u044f \u0441\u0442\u0440\u0430\u043d\u0438\u0446\u0430",
                        "pageBack": "\u041f\u0440\u0435\u0434\u044b\u0434\u0443\u0449\u0430\u044f \u0441\u0442\u0440\u0430\u043d\u0438\u0446\u0430",
                        "pageSelected": "\u0412\u044b\u0431\u0440\u0430\u043d\u043d\u0430\u044f \u0441\u0442\u0440\u0430\u043d\u0438\u0446\u0430",
                        "pageForward": "\u0421\u043b\u0435\u0434\u0443\u044e\u0449\u0430\u044f \u0441\u0442\u0440\u0430\u043d\u0438\u0446\u0430",
                        "pageToLast": "\u041f\u043e\u0441\u043b\u0435\u0434\u043d\u044f\u044f \u0441\u0442\u0440\u0430\u043d\u0438\u0446\u0430"
                    },
                    "sizes": "\u0441\u0442\u0440\u043e\u043a \u043d\u0430 \u0441\u0442\u0440\u0430\u043d\u0438\u0446\u0443",
                    "totalItems": "\u0441\u0442\u0440\u043e\u043a",
                    "through": "\u043f\u043e",
                    "of": "\u0438\u0437"
                },
                "grouping": {
                    "group": "\u0413\u0440\u0443\u043f\u043f\u0438\u0440\u043e\u0432\u0430\u0442\u044c",
                    "ungroup": "\u0420\u0430\u0437\u0433\u0440\u0443\u043f\u043f\u0438\u0440\u043e\u0432\u0430\u0442\u044c",
                    "aggregate_count": "\u0413\u0440\u0443\u043f\u043f\u0438\u0440\u043e\u0432\u0430\u0442\u044c: Count",
                    "aggregate_sum": "\u0414\u043b\u044f \u0433\u0440\u0443\u043f\u043f\u044b: \u0421\u0443\u043c\u043c\u0430",
                    "aggregate_max": "\u0414\u043b\u044f \u0433\u0440\u0443\u043f\u043f\u044b: \u041c\u0430\u043a\u0441\u0438\u043c\u0443\u043c",
                    "aggregate_min": "\u0414\u043b\u044f \u0433\u0440\u0443\u043f\u043f\u044b: \u041c\u0438\u043d\u0438\u043c\u0443\u043c",
                    "aggregate_avg": "\u0414\u043b\u044f \u0433\u0440\u0443\u043f\u043f\u044b: \u0421\u0440\u0435\u0434\u043d\u0435\u0435",
                    "aggregate_remove": "\u0414\u043b\u044f \u0433\u0440\u0443\u043f\u043f\u044b: \u041f\u0443\u0441\u0442\u043e"
                }
            });
            return $delegate;
        } ]);
    } ]);
})();

(function() {
    angular.module("ui.grid").config([ "$provide", function($provide) {
        $provide.decorator("i18nService", [ "$delegate", function($delegate) {
            $delegate.add("sk", {
                "aggregate": {
                    "label": "items"
                },
                "groupPanel": {
                    "description": "Pretiahni sem n\xe1zov st\u013apca pre zoskupenie pod\u013ea toho st\u013apca."
                },
                "search": {
                    "placeholder": "H\u013eadaj...",
                    "showingItems": "Zobrazujem polo\u017eky:",
                    "selectedItems": "Vybrat\xe9 polo\u017eky:",
                    "totalItems": "Po\u010det polo\u017eiek:",
                    "size": "Po\u010det:",
                    "first": "Prv\xe1 strana",
                    "next": "\u010eal\u0161ia strana",
                    "previous": "Predch\xe1dzaj\xfaca strana",
                    "last": "Posledn\xe1 strana"
                },
                "menu": {
                    "text": "Vyberte st\u013apce:"
                },
                "sort": {
                    "ascending": "Zotriedi\u0165 vzostupne",
                    "descending": "Zotriedi\u0165 zostupne",
                    "remove": "Vymaza\u0165 triedenie"
                },
                "aggregation": {
                    "count": "total rows: ",
                    "sum": "total: ",
                    "avg": "avg: ",
                    "min": "min: ",
                    "max": "max: "
                },
                "gridMenu": {
                    "columns": "Columns:",
                    "importerTitle": "Import file",
                    "exporterAllAsCsv": "Export all data as csv",
                    "exporterVisibleAsCsv": "Export visible data as csv",
                    "exporterSelectedAsCsv": "Export selected data as csv",
                    "exporterAllAsPdf": "Export all data as pdf",
                    "exporterVisibleAsPdf": "Export visible data as pdf",
                    "exporterSelectedAsPdf": "Export selected data as pdf",
                    "clearAllFilters": "Clear all filters"
                },
                "importer": {
                    "noHeaders": "Column names were unable to be derived, does the file have a header?",
                    "noObjects": "Objects were not able to be derived, was there data in the file other than headers?",
                    "invalidCsv": "File was unable to be processed, is it valid CSV?",
                    "invalidJson": "File was unable to be processed, is it valid Json?",
                    "jsonNotArray": "Imported json file must contain an array, aborting."
                }
            });
            return $delegate;
        } ]);
    } ]);
})();

(function() {
    angular.module("ui.grid").config([ "$provide", function($provide) {
        $provide.decorator("i18nService", [ "$delegate", function($delegate) {
            $delegate.add("sv", {
                "aggregate": {
                    "label": "Artiklar"
                },
                "groupPanel": {
                    "description": "Dra en kolumnrubrik hit och sl\xe4pp den f\xf6r att gruppera efter den kolumnen."
                },
                "search": {
                    "placeholder": "S\xf6k...",
                    "showingItems": "Visar artiklar:",
                    "selectedItems": "Valda artiklar:",
                    "totalItems": "Antal artiklar:",
                    "size": "Sidstorlek:",
                    "first": "F\xf6rsta sidan",
                    "next": "N\xe4sta sida",
                    "previous": "F\xf6reg\xe5ende sida",
                    "last": "Sista sidan"
                },
                "menu": {
                    "text": "V\xe4lj kolumner:"
                },
                "sort": {
                    "ascending": "Sortera stigande",
                    "descending": "Sortera fallande",
                    "remove": "Inaktivera sortering"
                },
                "column": {
                    "hide": "G\xf6m kolumn"
                },
                "aggregation": {
                    "count": "Antal rader: ",
                    "sum": "Summa: ",
                    "avg": "Genomsnitt: ",
                    "min": "Min: ",
                    "max": "Max: "
                },
                "pinning": {
                    "pinLeft": "F\xe4st v\xe4nster",
                    "pinRight": "F\xe4st h\xf6ger",
                    "unpin": "L\xf6sg\xf6r"
                },
                "gridMenu": {
                    "columns": "Kolumner:",
                    "importerTitle": "Importera fil",
                    "exporterAllAsCsv": "Exportera all data som CSV",
                    "exporterVisibleAsCsv": "Exportera synlig data som CSV",
                    "exporterSelectedAsCsv": "Exportera markerad data som CSV",
                    "exporterAllAsPdf": "Exportera all data som PDF",
                    "exporterVisibleAsPdf": "Exportera synlig data som PDF",
                    "exporterSelectedAsPdf": "Exportera markerad data som PDF",
                    "clearAllFilters": "Reng\xf6r alla filter"
                },
                "importer": {
                    "noHeaders": "Kolumnnamn kunde inte h\xe4rledas. Har filen ett sidhuvud?",
                    "noObjects": "Objekt kunde inte h\xe4rledas. Har filen data undantaget sidhuvud?",
                    "invalidCsv": "Filen kunde inte behandlas, \xe4r den en giltig CSV?",
                    "invalidJson": "Filen kunde inte behandlas, \xe4r den en giltig JSON?",
                    "jsonNotArray": "Importerad JSON-fil m\xe5ste inneh\xe5lla ett f\xe4lt. Import avbruten."
                },
                "pagination": {
                    "sizes": "Artiklar per sida",
                    "totalItems": "Artiklar"
                }
            });
            return $delegate;
        } ]);
    } ]);
})();

(function() {
    angular.module("ui.grid").config([ "$provide", function($provide) {
        $provide.decorator("i18nService", [ "$delegate", function($delegate) {
            $delegate.add("ta", {
                "aggregate": {
                    "label": "\u0b89\u0bb0\u0bc1\u0baa\u0bcd\u0baa\u0b9f\u0bbf\u0b95\u0bb3\u0bcd"
                },
                "groupPanel": {
                    "description": "\u0b92\u0bb0\u0bc1 \u0baa\u0ba4\u0bcd\u0ba4\u0bbf\u0baf\u0bc8 \u0b95\u0bc1\u0bb4\u0bc1\u0bb5\u0bbe\u0b95 \u0b85\u0bae\u0bc8\u0b95\u0bcd\u0b95 \u0b85\u0baa\u0bcd\u0baa\u0ba4\u0bcd\u0ba4\u0bbf\u0baf\u0bbf\u0ba9\u0bcd \u0ba4\u0bb2\u0bc8\u0baa\u0bcd\u0baa\u0bc8 \u0b87\u0b99\u0bcd\u0b95\u0bc7  \u0b87\u0bb4\u0bc1\u0ba4\u0bcd\u0ba4\u0bc1 \u0bb5\u0bb0\u0bb5\u0bc1\u0bae\u0bcd "
                },
                "search": {
                    "placeholder": "\u0ba4\u0bc7\u0b9f\u0bb2\u0bcd ...",
                    "showingItems": "\u0b89\u0bb0\u0bc1\u0baa\u0bcd\u0baa\u0b9f\u0bbf\u0b95\u0bb3\u0bc8 \u0b95\u0bbe\u0ba3\u0bcd\u0baa\u0bbf\u0ba4\u0bcd\u0ba4\u0bb2\u0bcd:",
                    "selectedItems": "\u0ba4\u0bc7\u0bb0\u0bcd\u0ba8\u0bcd\u0ba4\u0bc6\u0b9f\u0bc1\u0b95\u0bcd\u0b95\u0baa\u0bcd\u0baa\u0b9f\u0bcd\u0b9f  \u0b89\u0bb0\u0bc1\u0baa\u0bcd\u0baa\u0b9f\u0bbf\u0b95\u0bb3\u0bcd:",
                    "totalItems": "\u0bae\u0bca\u0ba4\u0bcd\u0ba4 \u0b89\u0bb0\u0bc1\u0baa\u0bcd\u0baa\u0b9f\u0bbf\u0b95\u0bb3\u0bcd:",
                    "size": "\u0baa\u0b95\u0bcd\u0b95 \u0b85\u0bb3\u0bb5\u0bc1: ",
                    "first": "\u0bae\u0bc1\u0ba4\u0bb2\u0bcd \u0baa\u0b95\u0bcd\u0b95\u0bae\u0bcd",
                    "next": "\u0b85\u0b9f\u0bc1\u0ba4\u0bcd\u0ba4 \u0baa\u0b95\u0bcd\u0b95\u0bae\u0bcd",
                    "previous": "\u0bae\u0bc1\u0ba8\u0bcd\u0ba4\u0bc8\u0baf \u0baa\u0b95\u0bcd\u0b95\u0bae\u0bcd ",
                    "last": "\u0b87\u0bb1\u0bc1\u0ba4\u0bbf \u0baa\u0b95\u0bcd\u0b95\u0bae\u0bcd"
                },
                "menu": {
                    "text": "\u0baa\u0ba4\u0bcd\u0ba4\u0bbf\u0b95\u0bb3\u0bc8 \u0ba4\u0bc7\u0bb0\u0bcd\u0ba8\u0bcd\u0ba4\u0bc6\u0b9f\u0bc1:"
                },
                "sort": {
                    "ascending": "\u0bae\u0bc7\u0bb2\u0bbf\u0bb0\u0bc1\u0ba8\u0bcd\u0ba4\u0bc1 \u0b95\u0bc0\u0bb4\u0bbe\u0b95",
                    "descending": "\u0b95\u0bc0\u0bb4\u0bbf\u0bb0\u0bc1\u0ba8\u0bcd\u0ba4\u0bc1 \u0bae\u0bc7\u0bb2\u0bbe\u0b95",
                    "remove": "\u0bb5\u0bb0\u0bbf\u0b9a\u0bc8\u0baf\u0bc8 \u0ba8\u0bc0\u0b95\u0bcd\u0b95\u0bc1"
                },
                "column": {
                    "hide": "\u0baa\u0ba4\u0bcd\u0ba4\u0bbf\u0baf\u0bc8 \u0bae\u0bb1\u0bc8\u0ba4\u0bcd\u0ba4\u0bc1 \u0bb5\u0bc8 "
                },
                "aggregation": {
                    "count": "\u0bae\u0bca\u0ba4\u0bcd\u0ba4 \u0bb5\u0bb0\u0bbf\u0b95\u0bb3\u0bcd:",
                    "sum": "\u0bae\u0bca\u0ba4\u0bcd\u0ba4\u0bae\u0bcd: ",
                    "avg": "\u0b9a\u0bb0\u0bbe\u0b9a\u0bb0\u0bbf: ",
                    "min": "\u0b95\u0bc1\u0bb1\u0bc8\u0ba8\u0bcd\u0ba4\u0baa\u0b9f\u0bcd\u0b9a: ",
                    "max": "\u0b85\u0ba4\u0bbf\u0b95\u0baa\u0b9f\u0bcd\u0b9a: "
                },
                "pinning": {
                    "pinLeft": "\u0b87\u0b9f\u0ba4\u0bc1\u0baa\u0bc1\u0bb1\u0bae\u0bbe\u0b95 \u0ba4\u0bc8\u0b95\u0bcd\u0b95 ",
                    "pinRight": "\u0bb5\u0bb2\u0ba4\u0bc1\u0baa\u0bc1\u0bb1\u0bae\u0bbe\u0b95 \u0ba4\u0bc8\u0b95\u0bcd\u0b95",
                    "unpin": "\u0baa\u0bbf\u0bb0\u0bbf"
                },
                "gridMenu": {
                    "columns": "\u0baa\u0ba4\u0bcd\u0ba4\u0bbf\u0b95\u0bb3\u0bcd:",
                    "importerTitle": "\u0b95\u0bcb\u0baa\u0bcd\u0baa\u0bc1 : \u0baa\u0b9f\u0bbf\u0ba4\u0bcd\u0ba4\u0bb2\u0bcd",
                    "exporterAllAsCsv": "\u0b8e\u0bb2\u0bcd\u0bb2\u0bbe \u0ba4\u0bb0\u0bb5\u0bc1\u0b95\u0bb3\u0bc8\u0baf\u0bc1\u0bae\u0bcd \u0b95\u0bcb\u0baa\u0bcd\u0baa\u0bbe\u0b95\u0bcd\u0b95\u0bc1: csv",
                    "exporterVisibleAsCsv": "\u0b87\u0bb0\u0bc1\u0b95\u0bcd\u0b95\u0bc1\u0bae\u0bcd \u0ba4\u0bb0\u0bb5\u0bc1\u0b95\u0bb3\u0bc8 \u0b95\u0bcb\u0baa\u0bcd\u0baa\u0bbe\u0b95\u0bcd\u0b95\u0bc1: csv",
                    "exporterSelectedAsCsv": "\u0ba4\u0bc7\u0bb0\u0bcd\u0ba8\u0bcd\u0ba4\u0bc6\u0b9f\u0bc1\u0ba4\u0bcd\u0ba4 \u0ba4\u0bb0\u0bb5\u0bc1\u0b95\u0bb3\u0bc8 \u0b95\u0bcb\u0baa\u0bcd\u0baa\u0bbe\u0b95\u0bcd\u0b95\u0bc1: csv",
                    "exporterAllAsPdf": "\u0b8e\u0bb2\u0bcd\u0bb2\u0bbe \u0ba4\u0bb0\u0bb5\u0bc1\u0b95\u0bb3\u0bc8\u0baf\u0bc1\u0bae\u0bcd \u0b95\u0bcb\u0baa\u0bcd\u0baa\u0bbe\u0b95\u0bcd\u0b95\u0bc1: pdf",
                    "exporterVisibleAsPdf": "\u0b87\u0bb0\u0bc1\u0b95\u0bcd\u0b95\u0bc1\u0bae\u0bcd \u0ba4\u0bb0\u0bb5\u0bc1\u0b95\u0bb3\u0bc8 \u0b95\u0bcb\u0baa\u0bcd\u0baa\u0bbe\u0b95\u0bcd\u0b95\u0bc1: pdf",
                    "exporterSelectedAsPdf": "\u0ba4\u0bc7\u0bb0\u0bcd\u0ba8\u0bcd\u0ba4\u0bc6\u0b9f\u0bc1\u0ba4\u0bcd\u0ba4 \u0ba4\u0bb0\u0bb5\u0bc1\u0b95\u0bb3\u0bc8 \u0b95\u0bcb\u0baa\u0bcd\u0baa\u0bbe\u0b95\u0bcd\u0b95\u0bc1: pdf",
                    "clearAllFilters": "Clear all filters"
                },
                "importer": {
                    "noHeaders": "\u0baa\u0ba4\u0bcd\u0ba4\u0bbf\u0baf\u0bbf\u0ba9\u0bcd \u0ba4\u0bb2\u0bc8\u0baa\u0bcd\u0baa\u0bc1\u0b95\u0bb3\u0bc8 \u0baa\u0bc6\u0bb1 \u0b87\u0baf\u0bb2\u0bb5\u0bbf\u0bb2\u0bcd\u0bb2\u0bc8, \u0b95\u0bcb\u0baa\u0bcd\u0baa\u0bbf\u0bb1\u0bcd\u0b95\u0bc1 \u0ba4\u0bb2\u0bc8\u0baa\u0bcd\u0baa\u0bc1 \u0b89\u0bb3\u0bcd\u0bb3\u0ba4\u0bbe?",
                    "noObjects": "\u0b87\u0bb2\u0b95\u0bcd\u0b95\u0bc1\u0b95\u0bb3\u0bc8 \u0b89\u0bb0\u0bc1\u0bb5\u0bbe\u0b95\u0bcd\u0b95 \u0bae\u0bc1\u0b9f\u0bbf\u0baf\u0bb5\u0bbf\u0bb2\u0bcd\u0bb2\u0bc8, \u0b95\u0bcb\u0baa\u0bcd\u0baa\u0bbf\u0bb2\u0bcd \u0ba4\u0bb2\u0bc8\u0baa\u0bcd\u0baa\u0bc1\u0b95\u0bb3\u0bc8 \u0ba4\u0bb5\u0bbf\u0bb0 \u0ba4\u0bb0\u0bb5\u0bc1 \u0b8f\u0ba4\u0bc7\u0ba9\u0bc1\u0bae\u0bcd \u0b89\u0bb3\u0bcd\u0bb3\u0ba4\u0bbe? ",
                    "invalidCsv": "\u0b9a\u0bb0\u0bbf\u0bb5\u0bb0 \u0ba8\u0b9f\u0bc8\u0bae\u0bc1\u0bb1\u0bc8 \u0baa\u0b9f\u0bc1\u0ba4\u0bcd\u0ba4 \u0b87\u0baf\u0bb2\u0bb5\u0bbf\u0bb2\u0bcd\u0bb2\u0bc8, \u0b95\u0bcb\u0baa\u0bcd\u0baa\u0bc1 \u0b9a\u0bb0\u0bbf\u0ba4\u0bbe\u0ba9\u0bbe? - csv",
                    "invalidJson": "\u0b9a\u0bb0\u0bbf\u0bb5\u0bb0 \u0ba8\u0b9f\u0bc8\u0bae\u0bc1\u0bb1\u0bc8 \u0baa\u0b9f\u0bc1\u0ba4\u0bcd\u0ba4 \u0b87\u0baf\u0bb2\u0bb5\u0bbf\u0bb2\u0bcd\u0bb2\u0bc8, \u0b95\u0bcb\u0baa\u0bcd\u0baa\u0bc1 \u0b9a\u0bb0\u0bbf\u0ba4\u0bbe\u0ba9\u0bbe? - json",
                    "jsonNotArray": "\u0baa\u0b9f\u0bbf\u0ba4\u0bcd\u0ba4 \u0b95\u0bcb\u0baa\u0bcd\u0baa\u0bbf\u0bb2\u0bcd \u0bb5\u0bb0\u0bbf\u0b9a\u0bc8\u0b95\u0bb3\u0bcd \u0b89\u0bb3\u0bcd\u0bb3\u0ba4\u0bc1, \u0ba8\u0b9f\u0bc8\u0bae\u0bc1\u0bb1\u0bc8 \u0bb0\u0ba4\u0bcd\u0ba4\u0bc1 \u0b9a\u0bc6\u0baf\u0bcd : json"
                },
                "pagination": {
                    "sizes": "\u0b89\u0bb0\u0bc1\u0baa\u0bcd\u0baa\u0b9f\u0bbf\u0b95\u0bb3\u0bcd / \u0baa\u0b95\u0bcd\u0b95\u0bae\u0bcd",
                    "totalItems": "\u0b89\u0bb0\u0bc1\u0baa\u0bcd\u0baa\u0b9f\u0bbf\u0b95\u0bb3\u0bcd "
                },
                "grouping": {
                    "group": "\u0b95\u0bc1\u0bb4\u0bc1",
                    "ungroup": "\u0baa\u0bbf\u0bb0\u0bbf",
                    "aggregate_count": "\u0bae\u0ba4\u0bbf\u0baa\u0bcd\u0baa\u0bc0\u0b9f\u0bcd\u0b9f\u0bc1 : \u0b8e\u0ba3\u0bcd\u0ba3\u0bc1",
                    "aggregate_sum": "\u0bae\u0ba4\u0bbf\u0baa\u0bcd\u0baa\u0bc0\u0b9f\u0bcd\u0b9f\u0bc1 : \u0b95\u0bc2\u0b9f\u0bcd\u0b9f\u0bb2\u0bcd",
                    "aggregate_max": "\u0bae\u0ba4\u0bbf\u0baa\u0bcd\u0baa\u0bc0\u0b9f\u0bcd\u0b9f\u0bc1 : \u0b85\u0ba4\u0bbf\u0b95\u0baa\u0b9f\u0bcd\u0b9a\u0bae\u0bcd",
                    "aggregate_min": "\u0bae\u0ba4\u0bbf\u0baa\u0bcd\u0baa\u0bc0\u0b9f\u0bcd\u0b9f\u0bc1 : \u0b95\u0bc1\u0bb1\u0bc8\u0ba8\u0bcd\u0ba4\u0baa\u0b9f\u0bcd\u0b9a\u0bae\u0bcd",
                    "aggregate_avg": "\u0bae\u0ba4\u0bbf\u0baa\u0bcd\u0baa\u0bc0\u0b9f\u0bcd\u0b9f\u0bc1 : \u0b9a\u0bb0\u0bbe\u0b9a\u0bb0\u0bbf",
                    "aggregate_remove": "\u0bae\u0ba4\u0bbf\u0baa\u0bcd\u0baa\u0bc0\u0b9f\u0bcd\u0b9f\u0bc1 : \u0ba8\u0bc0\u0b95\u0bcd\u0b95\u0bc1"
                }
            });
            return $delegate;
        } ]);
    } ]);
})();

(function() {
    angular.module("ui.grid").config([ "$provide", function($provide) {
        $provide.decorator("i18nService", [ "$delegate", function($delegate) {
            $delegate.add("tr", {
                "headerCell": {
                    "aria": {
                        "defaultFilterLabel": "S\xfctun i\xe7in filtre",
                        "removeFilter": "Filtreyi Kald\u0131r",
                        "columnMenuButtonLabel": "S\xfctun Men\xfcs\xfc"
                    },
                    "priority": "\xd6ncelik:",
                    "filterLabel": "S\xfctun i\xe7in filtre: "
                },
                "aggregate": {
                    "label": "kay\u0131tlar"
                },
                "groupPanel": {
                    "description": "S\xfctuna g\xf6re gruplamak i\xe7in s\xfctun ba\u015fl\u0131\u011f\u0131n\u0131 buraya s\xfcr\xfckleyin ve b\u0131rak\u0131n."
                },
                "search": {
                    "placeholder": "Arama...",
                    "showingItems": "G\xf6sterilen Kay\u0131t:",
                    "selectedItems": "Se\xe7ili Kay\u0131t:",
                    "totalItems": "Toplam Kay\u0131t:",
                    "size": "Sayfa Boyutu:",
                    "first": "\u0130lk Sayfa",
                    "next": "Sonraki Sayfa",
                    "previous": "\xd6nceki Sayfa",
                    "last": "Son Sayfa"
                },
                "menu": {
                    "text": "S\xfctunlar\u0131 Se\xe7:"
                },
                "sort": {
                    "ascending": "Artan S\u0131rada S\u0131rala",
                    "descending": "Azalan S\u0131rada S\u0131rala",
                    "none": "S\u0131ralama Yapma",
                    "remove": "S\u0131ralamay\u0131 Kald\u0131r"
                },
                "column": {
                    "hide": "S\xfctunu Gizle"
                },
                "aggregation": {
                    "count": "toplam sat\u0131r: ",
                    "sum": "toplam: ",
                    "avg": "ort: ",
                    "min": "min: ",
                    "max": "maks: "
                },
                "pinning": {
                    "pinLeft": "Sola Sabitle",
                    "pinRight": "Sa\u011fa Sabitle",
                    "unpin": "Sabitlemeyi Kald\u0131r"
                },
                "columnMenu": {
                    "close": "Kapat"
                },
                "gridMenu": {
                    "aria": {
                        "buttonLabel": "Tablo Men\xfc"
                    },
                    "columns": "S\xfctunlar:",
                    "importerTitle": "Dosya i\xe7eri aktar",
                    "exporterAllAsCsv": "B\xfct\xfcn veriyi CSV olarak d\u0131\u015far\u0131 aktar",
                    "exporterVisibleAsCsv": "G\xf6r\xfcnen veriyi CSV olarak d\u0131\u015far\u0131 aktar",
                    "exporterSelectedAsCsv": "Se\xe7ili veriyi CSV olarak d\u0131\u015far\u0131 aktar",
                    "exporterAllAsPdf": "B\xfct\xfcn veriyi PDF olarak d\u0131\u015far\u0131 aktar",
                    "exporterVisibleAsPdf": "G\xf6r\xfcnen veriyi PDF olarak d\u0131\u015far\u0131 aktar",
                    "exporterSelectedAsPdf": "Se\xe7ili veriyi PDF olarak d\u0131\u015far\u0131 aktar",
                    "clearAllFilters": "B\xfct\xfcn filtreleri kald\u0131r"
                },
                "importer": {
                    "noHeaders": "S\xfctun isimleri \xfcretilemiyor, dosyan\u0131n bir ba\u015fl\u0131\u011f\u0131 var m\u0131?",
                    "noObjects": "Nesneler \xfcretilemiyor, dosyada ba\u015fl\u0131ktan ba\u015fka bir veri var m\u0131?",
                    "invalidCsv": "Dosya i\u015flenemedi, ge\xe7erli bir CSV dosyas\u0131 m\u0131?",
                    "invalidJson": "Dosya i\u015flenemedi, ge\xe7erli bir Json dosyas\u0131 m\u0131?",
                    "jsonNotArray": "Al\u0131nan Json dosyas\u0131nda bir dizi bulunmal\u0131d\u0131r, i\u015flem iptal ediliyor."
                },
                "pagination": {
                    "aria": {
                        "pageToFirst": "\u0130lk sayfaya",
                        "pageBack": "Geri git",
                        "pageSelected": "Se\xe7ili sayfa",
                        "pageForward": "\u0130leri git",
                        "pageToLast": "Sona git"
                    },
                    "sizes": "Sayfadaki nesne say\u0131s\u0131",
                    "totalItems": "kay\u0131tlar",
                    "through": "",
                    "of": ""
                },
                "grouping": {
                    "group": "Grupla",
                    "ungroup": "Gruplama",
                    "aggregate_count": "Yekun: Say\u0131",
                    "aggregate_sum": "Yekun: Toplam",
                    "aggregate_max": "Yekun: Maks",
                    "aggregate_min": "Yekun: Min",
                    "aggregate_avg": "Yekun: Ort",
                    "aggregate_remove": "Yekun: Sil"
                }
            });
            return $delegate;
        } ]);
    } ]);
})();

(function() {
    var DIRECTIVE_ALIASES = [ "uiT", "uiTranslate" ];
    var FILTER_ALIASES = [ "t", "uiTranslate" ];
    var module = angular.module("ui.grid.i18n");
    module.constant("i18nConstants", {
        "MISSING": "[MISSING]",
        "UPDATE_EVENT": "$uiI18n",
        "LOCALE_DIRECTIVE_ALIAS": "uiI18n",
        "DEFAULT_LANG": "en"
    });
    module.service("i18nService", [ "$log", "i18nConstants", "$rootScope", function($log, i18nConstants, $rootScope) {
        var langCache = {
            "_langs": {},
            "current": null,
            "get": function(lang) {
                return this._langs[lang.toLowerCase()];
            },
            "add": function(lang, strings) {
                var lower = lang.toLowerCase();
                if (!this._langs[lower]) {
                    this._langs[lower] = {};
                }
                angular.extend(this._langs[lower], strings);
            },
            "getAllLangs": function() {
                var langs = [];
                if (!this._langs) {
                    return langs;
                }
                for (var key in this._langs) {
                    langs.push(key);
                }
                return langs;
            },
            "setCurrent": function(lang) {
                this.current = lang.toLowerCase();
            },
            "getCurrentLang": function() {
                return this.current;
            }
        };
        var service = {
            "add": function(langs, stringMaps) {
                if (typeof langs === "object") {
                    angular.forEach(langs, function(lang) {
                        if (lang) {
                            langCache.add(lang, stringMaps);
                        }
                    });
                } else {
                    langCache.add(langs, stringMaps);
                }
            },
            "getAllLangs": function() {
                return langCache.getAllLangs();
            },
            "get": function(lang) {
                var language = lang ? lang : service.getCurrentLang();
                return langCache.get(language);
            },
            "getSafeText": function(path, lang) {
                var language = lang ? lang : service.getCurrentLang();
                var trans = langCache.get(language);
                if (!trans) {
                    return i18nConstants.MISSING;
                }
                var paths = path.split(".");
                var current = trans;
                for (var i = 0; i < paths.length; ++i) {
                    if (current[paths[i]] === undefined || current[paths[i]] === null) {
                        return i18nConstants.MISSING;
                    } else {
                        current = current[paths[i]];
                    }
                }
                return current;
            },
            "setCurrentLang": function(lang) {
                if (lang) {
                    langCache.setCurrent(lang);
                    $rootScope.$broadcast(i18nConstants.UPDATE_EVENT);
                }
            },
            "getCurrentLang": function() {
                var lang = langCache.getCurrentLang();
                if (!lang) {
                    lang = i18nConstants.DEFAULT_LANG;
                    langCache.setCurrent(lang);
                }
                return lang;
            }
        };
        return service;
    } ]);
    var localeDirective = function(i18nService, i18nConstants) {
        return {
            "compile": function() {
                return {
                    "pre": function($scope, $elm, $attrs) {
                        var alias = i18nConstants.LOCALE_DIRECTIVE_ALIAS;
                        var lang = $scope.$eval($attrs[alias]);
                        if (lang) {
                            $scope.$watch($attrs[alias], function() {
                                i18nService.setCurrentLang(lang);
                            });
                        } else if ($attrs.$$observers) {
                            $attrs.$observe(alias, function() {
                                i18nService.setCurrentLang($attrs[alias] || i18nConstants.DEFAULT_LANG);
                            });
                        }
                    }
                };
            }
        };
    };
    module.directive("uiI18n", [ "i18nService", "i18nConstants", localeDirective ]);
    var uitDirective = function($parse, i18nService, i18nConstants) {
        return {
            "restrict": "EA",
            "compile": function() {
                return {
                    "pre": function($scope, $elm, $attrs) {
                        var alias1 = DIRECTIVE_ALIASES[0], alias2 = DIRECTIVE_ALIASES[1];
                        var token = $attrs[alias1] || $attrs[alias2] || $elm.html();
                        var missing = i18nConstants.MISSING + token;
                        var observer;
                        if ($attrs.$$observers) {
                            var prop = $attrs[alias1] ? alias1 : alias2;
                            observer = $attrs.$observe(prop, function(result) {
                                if (result) {
                                    $elm.html($parse(result)(i18nService.getCurrentLang()) || missing);
                                }
                            });
                        }
                        var getter = $parse(token);
                        var listener = $scope.$on(i18nConstants.UPDATE_EVENT, function(evt) {
                            if (observer) {
                                observer($attrs[alias1] || $attrs[alias2]);
                            } else {
                                $elm.html(getter(i18nService.get()) || missing);
                            }
                        });
                        $scope.$on("$destroy", listener);
                        $elm.html(getter(i18nService.get()) || missing);
                    }
                };
            }
        };
    };
    angular.forEach(DIRECTIVE_ALIASES, function(alias) {
        module.directive(alias, [ "$parse", "i18nService", "i18nConstants", uitDirective ]);
    });
    var uitFilter = function($parse, i18nService, i18nConstants) {
        return function(data) {
            var getter = $parse(data);
            return getter(i18nService.get()) || i18nConstants.MISSING + data;
        };
    };
    angular.forEach(FILTER_ALIASES, function(alias) {
        module.filter(alias, [ "$parse", "i18nService", "i18nConstants", uitFilter ]);
    });
})();

(function() {
    angular.module("ui.grid").config([ "$provide", function($provide) {
        $provide.decorator("i18nService", [ "$delegate", function($delegate) {
            $delegate.add("zh-cn", {
                "headerCell": {
                    "aria": {
                        "defaultFilterLabel": "\u5217\u8fc7\u6ee4\u5668",
                        "removeFilter": "\u79fb\u9664\u8fc7\u6ee4\u5668",
                        "columnMenuButtonLabel": "\u5217\u83dc\u5355"
                    },
                    "priority": "\u4f18\u5148\u7ea7:",
                    "filterLabel": "\u5217\u8fc7\u6ee4\u5668: "
                },
                "aggregate": {
                    "label": "\u884c"
                },
                "groupPanel": {
                    "description": "\u62d6\u66f3\u8868\u5934\u5230\u6b64\u5904\u8fdb\u884c\u5206\u7ec4"
                },
                "search": {
                    "placeholder": "\u67e5\u627e",
                    "showingItems": "\u5df2\u663e\u793a\u884c\u6570\uff1a",
                    "selectedItems": "\u5df2\u9009\u62e9\u884c\u6570\uff1a",
                    "totalItems": "\u603b\u884c\u6570\uff1a",
                    "size": "\u6bcf\u9875\u663e\u793a\u884c\u6570\uff1a",
                    "first": "\u9996\u9875",
                    "next": "\u4e0b\u4e00\u9875",
                    "previous": "\u4e0a\u4e00\u9875",
                    "last": "\u672b\u9875"
                },
                "menu": {
                    "text": "\u9009\u62e9\u5217\uff1a"
                },
                "sort": {
                    "ascending": "\u5347\u5e8f",
                    "descending": "\u964d\u5e8f",
                    "none": "\u65e0\u5e8f",
                    "remove": "\u53d6\u6d88\u6392\u5e8f"
                },
                "column": {
                    "hide": "\u9690\u85cf\u5217"
                },
                "aggregation": {
                    "count": "\u8ba1\u6570\uff1a",
                    "sum": "\u6c42\u548c\uff1a",
                    "avg": "\u5747\u503c\uff1a",
                    "min": "\u6700\u5c0f\u503c\uff1a",
                    "max": "\u6700\u5927\u503c\uff1a"
                },
                "pinning": {
                    "pinLeft": "\u5de6\u4fa7\u56fa\u5b9a",
                    "pinRight": "\u53f3\u4fa7\u56fa\u5b9a",
                    "unpin": "\u53d6\u6d88\u56fa\u5b9a"
                },
                "columnMenu": {
                    "close": "\u5173\u95ed"
                },
                "gridMenu": {
                    "aria": {
                        "buttonLabel": "\u8868\u683c\u83dc\u5355"
                    },
                    "columns": "\u5217\uff1a",
                    "importerTitle": "\u5bfc\u5165\u6587\u4ef6",
                    "exporterAllAsCsv": "\u5bfc\u51fa\u5168\u90e8\u6570\u636e\u5230CSV",
                    "exporterVisibleAsCsv": "\u5bfc\u51fa\u53ef\u89c1\u6570\u636e\u5230CSV",
                    "exporterSelectedAsCsv": "\u5bfc\u51fa\u5df2\u9009\u6570\u636e\u5230CSV",
                    "exporterAllAsPdf": "\u5bfc\u51fa\u5168\u90e8\u6570\u636e\u5230PDF",
                    "exporterVisibleAsPdf": "\u5bfc\u51fa\u53ef\u89c1\u6570\u636e\u5230PDF",
                    "exporterSelectedAsPdf": "\u5bfc\u51fa\u5df2\u9009\u6570\u636e\u5230PDF",
                    "clearAllFilters": "\u6e05\u9664\u6240\u6709\u8fc7\u6ee4\u5668"
                },
                "importer": {
                    "noHeaders": "\u65e0\u6cd5\u83b7\u53d6\u5217\u540d\uff0c\u786e\u5b9a\u6587\u4ef6\u5305\u542b\u8868\u5934\uff1f",
                    "noObjects": "\u65e0\u6cd5\u83b7\u53d6\u6570\u636e\uff0c\u786e\u5b9a\u6587\u4ef6\u5305\u542b\u6570\u636e\uff1f",
                    "invalidCsv": "\u65e0\u6cd5\u5904\u7406\u6587\u4ef6\uff0c\u786e\u5b9a\u662f\u5408\u6cd5\u7684CSV\u6587\u4ef6\uff1f",
                    "invalidJson": "\u65e0\u6cd5\u5904\u7406\u6587\u4ef6\uff0c\u786e\u5b9a\u662f\u5408\u6cd5\u7684JSON\u6587\u4ef6\uff1f",
                    "jsonNotArray": "\u5bfc\u5165\u7684\u6587\u4ef6\u4e0d\u662fJSON\u6570\u7ec4\uff01"
                },
                "pagination": {
                    "aria": {
                        "pageToFirst": "\u7b2c\u4e00\u9875",
                        "pageBack": "\u4e0a\u4e00\u9875",
                        "pageSelected": "\u5f53\u524d\u9875",
                        "pageForward": "\u4e0b\u4e00\u9875",
                        "pageToLast": "\u6700\u540e\u4e00\u9875"
                    },
                    "sizes": "\u884c\u6bcf\u9875",
                    "totalItems": "\u884c",
                    "through": "\u81f3",
                    "of": "\u5171"
                },
                "grouping": {
                    "group": "\u5206\u7ec4",
                    "ungroup": "\u53d6\u6d88\u5206\u7ec4",
                    "aggregate_count": "\u5408\u8ba1: \u8ba1\u6570",
                    "aggregate_sum": "\u5408\u8ba1: \u6c42\u548c",
                    "aggregate_max": "\u5408\u8ba1: \u6700\u5927",
                    "aggregate_min": "\u5408\u8ba1: \u6700\u5c0f",
                    "aggregate_avg": "\u5408\u8ba1: \u5e73\u5747",
                    "aggregate_remove": "\u5408\u8ba1: \u79fb\u9664"
                }
            });
            return $delegate;
        } ]);
    } ]);
})();

(function() {
    angular.module("ui.grid").config([ "$provide", function($provide) {
        $provide.decorator("i18nService", [ "$delegate", function($delegate) {
            $delegate.add("zh-tw", {
                "aggregate": {
                    "label": "\u884c"
                },
                "groupPanel": {
                    "description": "\u62d6\u66f3\u8868\u982d\u5230\u6b64\u8655\u9032\u884c\u5206\u7d44"
                },
                "search": {
                    "placeholder": "\u67e5\u627e",
                    "showingItems": "\u5df2\u986f\u793a\u884c\u6578\uff1a",
                    "selectedItems": "\u5df2\u9078\u64c7\u884c\u6578\uff1a",
                    "totalItems": "\u7e3d\u884c\u6578\uff1a",
                    "size": "\u6bcf\u9801\u986f\u793a\u884c\u6578\uff1a",
                    "first": "\u9996\u9801",
                    "next": "\u4e0b\u58f9\u9801",
                    "previous": "\u4e0a\u58f9\u9801",
                    "last": "\u672b\u9801"
                },
                "menu": {
                    "text": "\u9078\u64c7\u5217\uff1a"
                },
                "sort": {
                    "ascending": "\u5347\u5e8f",
                    "descending": "\u964d\u5e8f",
                    "remove": "\u53d6\u6d88\u6392\u5e8f"
                },
                "column": {
                    "hide": "\u96b1\u85cf\u5217"
                },
                "aggregation": {
                    "count": "\u8a08\u6578\uff1a",
                    "sum": "\u6c42\u548c\uff1a",
                    "avg": "\u5747\u503c\uff1a",
                    "min": "\u6700\u5c0f\u503c\uff1a",
                    "max": "\u6700\u5927\u503c\uff1a"
                },
                "pinning": {
                    "pinLeft": "\u5de6\u5074\u56fa\u5b9a",
                    "pinRight": "\u53f3\u5074\u56fa\u5b9a",
                    "unpin": "\u53d6\u6d88\u56fa\u5b9a"
                },
                "gridMenu": {
                    "columns": "\u5217\uff1a",
                    "importerTitle": "\u5c0e\u5165\u6587\u4ef6",
                    "exporterAllAsCsv": "\u5c0e\u51fa\u5168\u90e8\u6578\u64da\u5230CSV",
                    "exporterVisibleAsCsv": "\u5c0e\u51fa\u53ef\u898b\u6578\u64da\u5230CSV",
                    "exporterSelectedAsCsv": "\u5c0e\u51fa\u5df2\u9078\u6578\u64da\u5230CSV",
                    "exporterAllAsPdf": "\u5c0e\u51fa\u5168\u90e8\u6578\u64da\u5230PDF",
                    "exporterVisibleAsPdf": "\u5c0e\u51fa\u53ef\u898b\u6578\u64da\u5230PDF",
                    "exporterSelectedAsPdf": "\u5c0e\u51fa\u5df2\u9078\u6578\u64da\u5230PDF",
                    "clearAllFilters": "\u6e05\u9664\u6240\u6709\u8fc7\u6ee4\u5668"
                },
                "importer": {
                    "noHeaders": "\u7121\u6cd5\u7372\u53d6\u5217\u540d\uff0c\u78ba\u5b9a\u6587\u4ef6\u5305\u542b\u8868\u982d\uff1f",
                    "noObjects": "\u7121\u6cd5\u7372\u53d6\u6578\u64da\uff0c\u78ba\u5b9a\u6587\u4ef6\u5305\u542b\u6578\u64da\uff1f",
                    "invalidCsv": "\u7121\u6cd5\u8655\u7406\u6587\u4ef6\uff0c\u78ba\u5b9a\u662f\u5408\u6cd5\u7684CSV\u6587\u4ef6\uff1f",
                    "invalidJson": "\u7121\u6cd5\u8655\u7406\u6587\u4ef6\uff0c\u78ba\u5b9a\u662f\u5408\u6cd5\u7684JSON\u6587\u4ef6\uff1f",
                    "jsonNotArray": "\u5c0e\u5165\u7684\u6587\u4ef6\u4e0d\u662fJSON\u6578\u7d44\uff01"
                },
                "pagination": {
                    "sizes": "\u884c\u6bcf\u9801",
                    "totalItems": "\u884c"
                }
            });
            return $delegate;
        } ]);
    } ]);
})();

(function() {
    "use strict";
    var module = angular.module("ui.grid.autoResize", [ "ui.grid" ]);
    module.directive("uiGridAutoResize", [ "$timeout", "gridUtil", function($timeout, gridUtil) {
        return {
            "require": "uiGrid",
            "scope": false,
            "link": function($scope, $elm, $attrs, uiGridCtrl) {
                var prevGridWidth, prevGridHeight;
                function getDimensions() {
                    prevGridHeight = gridUtil.elementHeight($elm);
                    prevGridWidth = gridUtil.elementWidth($elm);
                }
                getDimensions();
                var resizeTimeoutId;
                function startTimeout() {
                    clearTimeout(resizeTimeoutId);
                    resizeTimeoutId = setTimeout(function() {
                        var newGridHeight = gridUtil.elementHeight($elm);
                        var newGridWidth = gridUtil.elementWidth($elm);
                        if (newGridHeight !== prevGridHeight || newGridWidth !== prevGridWidth) {
                            uiGridCtrl.grid.gridHeight = newGridHeight;
                            uiGridCtrl.grid.gridWidth = newGridWidth;
                            $scope.$apply(function() {
                                uiGridCtrl.grid.refresh().then(function() {
                                    getDimensions();
                                    startTimeout();
                                });
                            });
                        } else {
                            startTimeout();
                        }
                    }, 250);
                }
                startTimeout();
                $scope.$on("$destroy", function() {
                    clearTimeout(resizeTimeoutId);
                });
            }
        };
    } ]);
})();

(function() {
    "use strict";
    var module = angular.module("ui.grid.cellNav", [ "ui.grid" ]);
    module.constant("uiGridCellNavConstants", {
        "FEATURE_NAME": "gridCellNav",
        "CELL_NAV_EVENT": "cellNav",
        "direction": {
            "LEFT": 0,
            "RIGHT": 1,
            "UP": 2,
            "DOWN": 3,
            "PG_UP": 4,
            "PG_DOWN": 5
        },
        "EVENT_TYPE": {
            "KEYDOWN": 0,
            "CLICK": 1,
            "CLEAR": 2
        }
    });
    module.factory("uiGridCellNavFactory", [ "gridUtil", "uiGridConstants", "uiGridCellNavConstants", "GridRowColumn", "$q", function(gridUtil, uiGridConstants, uiGridCellNavConstants, GridRowColumn, $q) {
        var UiGridCellNav = function UiGridCellNav(rowContainer, colContainer, leftColContainer, rightColContainer) {
            this.rows = rowContainer.visibleRowCache;
            this.columns = colContainer.visibleColumnCache;
            this.leftColumns = leftColContainer ? leftColContainer.visibleColumnCache : [];
            this.rightColumns = rightColContainer ? rightColContainer.visibleColumnCache : [];
            this.bodyContainer = rowContainer;
        };
        UiGridCellNav.prototype.getFocusableCols = function() {
            var allColumns = this.leftColumns.concat(this.columns, this.rightColumns);
            return allColumns.filter(function(col) {
                return col.colDef.allowCellFocus;
            });
        };
        UiGridCellNav.prototype.getFocusableRows = function() {
            return this.rows.filter(function(row) {
                return row.allowCellFocus !== false;
            });
        };
        UiGridCellNav.prototype.getNextRowCol = function(direction, curRow, curCol) {
            switch (direction) {
              case uiGridCellNavConstants.direction.LEFT:
                return this.getRowColLeft(curRow, curCol);

              case uiGridCellNavConstants.direction.RIGHT:
                return this.getRowColRight(curRow, curCol);

              case uiGridCellNavConstants.direction.UP:
                return this.getRowColUp(curRow, curCol);

              case uiGridCellNavConstants.direction.DOWN:
                return this.getRowColDown(curRow, curCol);

              case uiGridCellNavConstants.direction.PG_UP:
                return this.getRowColPageUp(curRow, curCol);

              case uiGridCellNavConstants.direction.PG_DOWN:
                return this.getRowColPageDown(curRow, curCol);
            }
        };
        UiGridCellNav.prototype.initializeSelection = function() {
            var focusableCols = this.getFocusableCols();
            var focusableRows = this.getFocusableRows();
            if (focusableCols.length === 0 || focusableRows.length === 0) {
                return null;
            }
            var curRowIndex = 0;
            var curColIndex = 0;
            return new GridRowColumn(focusableRows[0], focusableCols[0]);
        };
        UiGridCellNav.prototype.getRowColLeft = function(curRow, curCol) {
            var focusableCols = this.getFocusableCols();
            var focusableRows = this.getFocusableRows();
            var curColIndex = focusableCols.indexOf(curCol);
            var curRowIndex = focusableRows.indexOf(curRow);
            if (curColIndex === -1) {
                curColIndex = 1;
            }
            var nextColIndex = curColIndex === 0 ? focusableCols.length - 1 : curColIndex - 1;
            if (nextColIndex > curColIndex) {
                if (curRowIndex === 0) {
                    return new GridRowColumn(curRow, focusableCols[nextColIndex]);
                } else {
                    return new GridRowColumn(focusableRows[curRowIndex - 1], focusableCols[nextColIndex]);
                }
            } else {
                return new GridRowColumn(curRow, focusableCols[nextColIndex]);
            }
        };
        UiGridCellNav.prototype.getRowColRight = function(curRow, curCol) {
            var focusableCols = this.getFocusableCols();
            var focusableRows = this.getFocusableRows();
            var curColIndex = focusableCols.indexOf(curCol);
            var curRowIndex = focusableRows.indexOf(curRow);
            if (curColIndex === -1) {
                curColIndex = 0;
            }
            var nextColIndex = curColIndex === focusableCols.length - 1 ? 0 : curColIndex + 1;
            if (nextColIndex < curColIndex) {
                if (curRowIndex === focusableRows.length - 1) {
                    return new GridRowColumn(curRow, focusableCols[nextColIndex]);
                } else {
                    return new GridRowColumn(focusableRows[curRowIndex + 1], focusableCols[nextColIndex]);
                }
            } else {
                return new GridRowColumn(curRow, focusableCols[nextColIndex]);
            }
        };
        UiGridCellNav.prototype.getRowColDown = function(curRow, curCol) {
            var focusableCols = this.getFocusableCols();
            var focusableRows = this.getFocusableRows();
            var curColIndex = focusableCols.indexOf(curCol);
            var curRowIndex = focusableRows.indexOf(curRow);
            if (curColIndex === -1) {
                curColIndex = 0;
            }
            if (curRowIndex === focusableRows.length - 1) {
                return new GridRowColumn(curRow, focusableCols[curColIndex]);
            } else {
                return new GridRowColumn(focusableRows[curRowIndex + 1], focusableCols[curColIndex]);
            }
        };
        UiGridCellNav.prototype.getRowColPageDown = function(curRow, curCol) {
            var focusableCols = this.getFocusableCols();
            var focusableRows = this.getFocusableRows();
            var curColIndex = focusableCols.indexOf(curCol);
            var curRowIndex = focusableRows.indexOf(curRow);
            if (curColIndex === -1) {
                curColIndex = 0;
            }
            var pageSize = this.bodyContainer.minRowsToRender();
            if (curRowIndex >= focusableRows.length - pageSize) {
                return new GridRowColumn(focusableRows[focusableRows.length - 1], focusableCols[curColIndex]);
            } else {
                return new GridRowColumn(focusableRows[curRowIndex + pageSize], focusableCols[curColIndex]);
            }
        };
        UiGridCellNav.prototype.getRowColUp = function(curRow, curCol) {
            var focusableCols = this.getFocusableCols();
            var focusableRows = this.getFocusableRows();
            var curColIndex = focusableCols.indexOf(curCol);
            var curRowIndex = focusableRows.indexOf(curRow);
            if (curColIndex === -1) {
                curColIndex = 0;
            }
            if (curRowIndex === 0) {
                return new GridRowColumn(curRow, focusableCols[curColIndex]);
            } else {
                return new GridRowColumn(focusableRows[curRowIndex - 1], focusableCols[curColIndex]);
            }
        };
        UiGridCellNav.prototype.getRowColPageUp = function(curRow, curCol) {
            var focusableCols = this.getFocusableCols();
            var focusableRows = this.getFocusableRows();
            var curColIndex = focusableCols.indexOf(curCol);
            var curRowIndex = focusableRows.indexOf(curRow);
            if (curColIndex === -1) {
                curColIndex = 0;
            }
            var pageSize = this.bodyContainer.minRowsToRender();
            if (curRowIndex - pageSize < 0) {
                return new GridRowColumn(focusableRows[0], focusableCols[curColIndex]);
            } else {
                return new GridRowColumn(focusableRows[curRowIndex - pageSize], focusableCols[curColIndex]);
            }
        };
        return UiGridCellNav;
    } ]);
    module.service("uiGridCellNavService", [ "gridUtil", "uiGridConstants", "uiGridCellNavConstants", "$q", "uiGridCellNavFactory", "GridRowColumn", "ScrollEvent", function(gridUtil, uiGridConstants, uiGridCellNavConstants, $q, UiGridCellNav, GridRowColumn, ScrollEvent) {
        var service = {
            "initializeGrid": function(grid) {
                grid.registerColumnBuilder(service.cellNavColumnBuilder);
                grid.cellNav = {};
                grid.cellNav.lastRowCol = null;
                grid.cellNav.focusedCells = [];
                service.defaultGridOptions(grid.options);
                var publicApi = {
                    "events": {
                        "cellNav": {
                            "navigate": function(newRowCol, oldRowCol) {},
                            "viewPortKeyDown": function(event, rowCol) {},
                            "viewPortKeyPress": function(event, rowCol) {}
                        }
                    },
                    "methods": {
                        "cellNav": {
                            "scrollToFocus": function(rowEntity, colDef) {
                                return service.scrollToFocus(grid, rowEntity, colDef);
                            },
                            "getFocusedCell": function() {
                                return grid.cellNav.lastRowCol;
                            },
                            "getCurrentSelection": function() {
                                return grid.cellNav.focusedCells;
                            },
                            "rowColSelectIndex": function(rowCol) {
                                var index = -1;
                                for (var i = 0; i < grid.cellNav.focusedCells.length; i++) {
                                    if (grid.cellNav.focusedCells[i].col.uid === rowCol.col.uid && grid.cellNav.focusedCells[i].row.uid === rowCol.row.uid) {
                                        index = i;
                                        break;
                                    }
                                }
                                return index;
                            }
                        }
                    }
                };
                grid.api.registerEventsFromObject(publicApi.events);
                grid.api.registerMethodsFromObject(publicApi.methods);
            },
            "defaultGridOptions": function(gridOptions) {
                gridOptions.modifierKeysToMultiSelectCells = gridOptions.modifierKeysToMultiSelectCells === true;
            },
            "decorateRenderContainers": function(grid) {
                var rightContainer = grid.hasRightContainer() ? grid.renderContainers.right : null;
                var leftContainer = grid.hasLeftContainer() ? grid.renderContainers.left : null;
                if (leftContainer !== null) {
                    grid.renderContainers.left.cellNav = new UiGridCellNav(grid.renderContainers.body, leftContainer, rightContainer, grid.renderContainers.body);
                }
                if (rightContainer !== null) {
                    grid.renderContainers.right.cellNav = new UiGridCellNav(grid.renderContainers.body, rightContainer, grid.renderContainers.body, leftContainer);
                }
                grid.renderContainers.body.cellNav = new UiGridCellNav(grid.renderContainers.body, grid.renderContainers.body, leftContainer, rightContainer);
            },
            "getDirection": function(evt) {
                if (evt.keyCode === uiGridConstants.keymap.LEFT || evt.keyCode === uiGridConstants.keymap.TAB && evt.shiftKey) {
                    return uiGridCellNavConstants.direction.LEFT;
                }
                if (evt.keyCode === uiGridConstants.keymap.RIGHT || evt.keyCode === uiGridConstants.keymap.TAB) {
                    return uiGridCellNavConstants.direction.RIGHT;
                }
                if (evt.keyCode === uiGridConstants.keymap.UP || evt.keyCode === uiGridConstants.keymap.ENTER && evt.shiftKey) {
                    return uiGridCellNavConstants.direction.UP;
                }
                if (evt.keyCode === uiGridConstants.keymap.PG_UP) {
                    return uiGridCellNavConstants.direction.PG_UP;
                }
                if (evt.keyCode === uiGridConstants.keymap.DOWN || evt.keyCode === uiGridConstants.keymap.ENTER && !(evt.ctrlKey || evt.altKey)) {
                    return uiGridCellNavConstants.direction.DOWN;
                }
                if (evt.keyCode === uiGridConstants.keymap.PG_DOWN) {
                    return uiGridCellNavConstants.direction.PG_DOWN;
                }
                return null;
            },
            "cellNavColumnBuilder": function(colDef, col, gridOptions) {
                var promises = [];
                colDef.allowCellFocus = colDef.allowCellFocus === undefined ? true : colDef.allowCellFocus;
                return $q.all(promises);
            },
            "scrollToFocus": function(grid, rowEntity, colDef) {
                var gridRow = null, gridCol = null;
                if (typeof rowEntity !== "undefined" && rowEntity !== null) {
                    gridRow = grid.getRow(rowEntity);
                }
                if (typeof colDef !== "undefined" && colDef !== null) {
                    gridCol = grid.getColumn(colDef.name ? colDef.name : colDef.field);
                }
                return grid.api.core.scrollToIfNecessary(gridRow, gridCol).then(function() {
                    var rowCol = {
                        "row": gridRow,
                        "col": gridCol
                    };
                    if (gridRow !== null && gridCol !== null) {
                        grid.cellNav.broadcastCellNav(rowCol);
                    }
                });
            },
            "getLeftWidth": function(grid, upToCol) {
                var width = 0;
                if (!upToCol) {
                    return width;
                }
                var lastIndex = grid.renderContainers.body.visibleColumnCache.indexOf(upToCol);
                grid.renderContainers.body.visibleColumnCache.forEach(function(col, index) {
                    if (index < lastIndex) {
                        width += col.drawnWidth;
                    }
                });
                var percentage = lastIndex === 0 ? 0 : (lastIndex + 1) / grid.renderContainers.body.visibleColumnCache.length;
                width += upToCol.drawnWidth * percentage;
                return width;
            }
        };
        return service;
    } ]);
    module.directive("uiGridCellnav", [ "gridUtil", "uiGridCellNavService", "uiGridCellNavConstants", "uiGridConstants", "GridRowColumn", "$timeout", "$compile", function(gridUtil, uiGridCellNavService, uiGridCellNavConstants, uiGridConstants, GridRowColumn, $timeout, $compile) {
        return {
            "replace": true,
            "priority": -150,
            "require": "^uiGrid",
            "scope": false,
            "controller": function() {},
            "compile": function() {
                return {
                    "pre": function($scope, $elm, $attrs, uiGridCtrl) {
                        var _scope = $scope;
                        var grid = uiGridCtrl.grid;
                        uiGridCellNavService.initializeGrid(grid);
                        uiGridCtrl.cellNav = {};
                        uiGridCtrl.cellNav.makeRowCol = function(obj) {
                            if (!(obj instanceof GridRowColumn)) {
                                obj = new GridRowColumn(obj.row, obj.col);
                            }
                            return obj;
                        };
                        uiGridCtrl.cellNav.getActiveCell = function() {
                            var elms = $elm[0].getElementsByClassName("ui-grid-cell-focus");
                            if (elms.length > 0) {
                                return elms[0];
                            }
                            return undefined;
                        };
                        uiGridCtrl.cellNav.broadcastCellNav = grid.cellNav.broadcastCellNav = function(newRowCol, modifierDown, originEvt) {
                            modifierDown = !(modifierDown === undefined || !modifierDown);
                            newRowCol = uiGridCtrl.cellNav.makeRowCol(newRowCol);
                            uiGridCtrl.cellNav.broadcastFocus(newRowCol, modifierDown, originEvt);
                            _scope.$broadcast(uiGridCellNavConstants.CELL_NAV_EVENT, newRowCol, modifierDown, originEvt);
                        };
                        uiGridCtrl.cellNav.clearFocus = grid.cellNav.clearFocus = function() {
                            grid.cellNav.focusedCells = [];
                            _scope.$broadcast(uiGridCellNavConstants.CELL_NAV_EVENT);
                        };
                        uiGridCtrl.cellNav.broadcastFocus = function(rowCol, modifierDown, originEvt) {
                            modifierDown = !(modifierDown === undefined || !modifierDown);
                            rowCol = uiGridCtrl.cellNav.makeRowCol(rowCol);
                            var row = rowCol.row, col = rowCol.col;
                            var rowColSelectIndex = uiGridCtrl.grid.api.cellNav.rowColSelectIndex(rowCol);
                            if (grid.cellNav.lastRowCol === null || rowColSelectIndex === -1) {
                                var newRowCol = new GridRowColumn(row, col);
                                if (grid.cellNav.lastRowCol === null || grid.cellNav.lastRowCol.row !== newRowCol.row || grid.cellNav.lastRowCol.col !== newRowCol.col) {
                                    grid.api.cellNav.raise.navigate(newRowCol, grid.cellNav.lastRowCol);
                                    grid.cellNav.lastRowCol = newRowCol;
                                }
                                if (uiGridCtrl.grid.options.modifierKeysToMultiSelectCells && modifierDown) {
                                    grid.cellNav.focusedCells.push(rowCol);
                                } else {
                                    grid.cellNav.focusedCells = [ rowCol ];
                                }
                            } else if (grid.options.modifierKeysToMultiSelectCells && modifierDown && rowColSelectIndex >= 0) {
                                grid.cellNav.focusedCells.splice(rowColSelectIndex, 1);
                            }
                        };
                        uiGridCtrl.cellNav.handleKeyDown = function(evt) {
                            var direction = uiGridCellNavService.getDirection(evt);
                            if (direction === null) {
                                return null;
                            }
                            var containerId = "body";
                            if (evt.uiGridTargetRenderContainerId) {
                                containerId = evt.uiGridTargetRenderContainerId;
                            }
                            var lastRowCol = uiGridCtrl.grid.api.cellNav.getFocusedCell();
                            if (lastRowCol) {
                                var rowCol = uiGridCtrl.grid.renderContainers[containerId].cellNav.getNextRowCol(direction, lastRowCol.row, lastRowCol.col);
                                var focusableCols = uiGridCtrl.grid.renderContainers[containerId].cellNav.getFocusableCols();
                                var rowColSelectIndex = uiGridCtrl.grid.api.cellNav.rowColSelectIndex(rowCol);
                                if (direction === uiGridCellNavConstants.direction.LEFT && rowCol.col === focusableCols[focusableCols.length - 1] && rowCol.row === lastRowCol.row && evt.keyCode === uiGridConstants.keymap.TAB && evt.shiftKey) {
                                    grid.cellNav.focusedCells.splice(rowColSelectIndex, 1);
                                    uiGridCtrl.cellNav.clearFocus();
                                    return true;
                                } else if (direction === uiGridCellNavConstants.direction.RIGHT && rowCol.col === focusableCols[0] && rowCol.row === lastRowCol.row && evt.keyCode === uiGridConstants.keymap.TAB && !evt.shiftKey) {
                                    grid.cellNav.focusedCells.splice(rowColSelectIndex, 1);
                                    uiGridCtrl.cellNav.clearFocus();
                                    return true;
                                }
                                grid.scrollToIfNecessary(rowCol.row, rowCol.col).then(function() {
                                    uiGridCtrl.cellNav.broadcastCellNav(rowCol);
                                });
                                evt.stopPropagation();
                                evt.preventDefault();
                                return false;
                            }
                        };
                    },
                    "post": function($scope, $elm, $attrs, uiGridCtrl) {
                        var _scope = $scope;
                        var grid = uiGridCtrl.grid;
                        function addAriaLiveRegion() {
                            var ariaNotifierDomElt = "<div " + 'id="' + grid.id + '-aria-speakable" ' + 'class="ui-grid-a11y-ariascreenreader-speakable ui-grid-offscreen" ' + 'aria-live="assertive" ' + 'role="region" ' + 'aria-atomic="true" ' + 'aria-hidden="false" ' + 'aria-relevant="additions" ' + ">" + "&nbsp;" + "</div>";
                            var ariaNotifier = $compile(ariaNotifierDomElt)($scope);
                            $elm.prepend(ariaNotifier);
                            $scope.$on(uiGridCellNavConstants.CELL_NAV_EVENT, function(evt, rowCol, modifierDown, originEvt) {
                                if (originEvt && originEvt.type === "focus") {
                                    return;
                                }
                                function setNotifyText(text) {
                                    if (text === ariaNotifier.text()) {
                                        return;
                                    }
                                    ariaNotifier[0].style.clip = "rect(0px,0px,0px,0px)";
                                    ariaNotifier[0].innerHTML = "";
                                    ariaNotifier[0].style.visibility = "hidden";
                                    ariaNotifier[0].style.visibility = "visible";
                                    if (text !== "") {
                                        ariaNotifier[0].style.clip = "auto";
                                        ariaNotifier[0].appendChild(document.createTextNode(text + " "));
                                        ariaNotifier[0].style.visibility = "hidden";
                                        ariaNotifier[0].style.visibility = "visible";
                                    }
                                }
                                var values = [];
                                var currentSelection = grid.api.cellNav.getCurrentSelection();
                                for (var i = 0; i < currentSelection.length; i++) {
                                    values.push(currentSelection[i].getIntersectionValueFiltered());
                                }
                                var cellText = values.toString();
                                setNotifyText(cellText);
                            });
                        }
                        addAriaLiveRegion();
                    }
                };
            }
        };
    } ]);
    module.directive("uiGridRenderContainer", [ "$timeout", "$document", "gridUtil", "uiGridConstants", "uiGridCellNavService", "$compile", "uiGridCellNavConstants", function($timeout, $document, gridUtil, uiGridConstants, uiGridCellNavService, $compile, uiGridCellNavConstants) {
        return {
            "replace": true,
            "priority": -99999,
            "require": [ "^uiGrid", "uiGridRenderContainer", "?^uiGridCellnav" ],
            "scope": false,
            "compile": function() {
                return {
                    "post": function($scope, $elm, $attrs, controllers) {
                        var uiGridCtrl = controllers[0], renderContainerCtrl = controllers[1], uiGridCellnavCtrl = controllers[2];
                        if (!uiGridCtrl.grid.api.cellNav) {
                            return;
                        }
                        var containerId = renderContainerCtrl.containerId;
                        var grid = uiGridCtrl.grid;
                        uiGridCellNavService.decorateRenderContainers(grid);
                        if (containerId !== "body") {
                            return;
                        }
                        if (uiGridCtrl.grid.options.modifierKeysToMultiSelectCells) {
                            $elm.attr("aria-multiselectable", true);
                        } else {
                            $elm.attr("aria-multiselectable", false);
                        }
                        var focuser = $compile('<div class="ui-grid-focuser" role="region" aria-live="assertive" aria-atomic="false" tabindex="0" aria-controls="' + grid.id + "-aria-speakable " + grid.id + "-grid-container" + '" aria-owns="' + grid.id + "-grid-container" + '"></div>')($scope);
                        $elm.append(focuser);
                        focuser.on("focus", function(evt) {
                            evt.uiGridTargetRenderContainerId = containerId;
                            var rowCol = uiGridCtrl.grid.api.cellNav.getFocusedCell();
                            if (rowCol === null) {
                                rowCol = uiGridCtrl.grid.renderContainers[containerId].cellNav.getNextRowCol(uiGridCellNavConstants.direction.DOWN, null, null);
                                if (rowCol.row && rowCol.col) {
                                    uiGridCtrl.cellNav.broadcastCellNav(rowCol);
                                }
                            }
                        });
                        uiGridCellnavCtrl.setAriaActivedescendant = function(id) {
                            $elm.attr("aria-activedescendant", id);
                        };
                        uiGridCellnavCtrl.removeAriaActivedescendant = function(id) {
                            if ($elm.attr("aria-activedescendant") === id) {
                                $elm.attr("aria-activedescendant", "");
                            }
                        };
                        uiGridCtrl.focus = function() {
                            gridUtil.focus.byElement(focuser[0]);
                        };
                        var viewPortKeyDownWasRaisedForRowCol = null;
                        focuser.on("keydown", function(evt) {
                            evt.uiGridTargetRenderContainerId = containerId;
                            var rowCol = uiGridCtrl.grid.api.cellNav.getFocusedCell();
                            var result = uiGridCtrl.cellNav.handleKeyDown(evt);
                            if (result === null) {
                                uiGridCtrl.grid.api.cellNav.raise.viewPortKeyDown(evt, rowCol);
                                viewPortKeyDownWasRaisedForRowCol = rowCol;
                            }
                        });
                        focuser.on("keypress", function(evt) {
                            if (viewPortKeyDownWasRaisedForRowCol) {
                                $timeout(function() {
                                    uiGridCtrl.grid.api.cellNav.raise.viewPortKeyPress(evt, viewPortKeyDownWasRaisedForRowCol);
                                }, 4);
                                viewPortKeyDownWasRaisedForRowCol = null;
                            }
                        });
                        $scope.$on("$destroy", function() {
                            focuser.off();
                        });
                    }
                };
            }
        };
    } ]);
    module.directive("uiGridViewport", [ "$timeout", "$document", "gridUtil", "uiGridConstants", "uiGridCellNavService", "uiGridCellNavConstants", "$log", "$compile", function($timeout, $document, gridUtil, uiGridConstants, uiGridCellNavService, uiGridCellNavConstants, $log, $compile) {
        return {
            "replace": true,
            "priority": -99999,
            "require": [ "^uiGrid", "^uiGridRenderContainer", "?^uiGridCellnav" ],
            "scope": false,
            "compile": function() {
                return {
                    "pre": function($scope, $elm, $attrs, uiGridCtrl) {},
                    "post": function($scope, $elm, $attrs, controllers) {
                        var uiGridCtrl = controllers[0], renderContainerCtrl = controllers[1];
                        if (!uiGridCtrl.grid.api.cellNav) {
                            return;
                        }
                        var containerId = renderContainerCtrl.containerId;
                        if (containerId !== "body") {
                            return;
                        }
                        var grid = uiGridCtrl.grid;
                        grid.api.core.on.scrollBegin($scope, function(args) {
                            var lastRowCol = uiGridCtrl.grid.api.cellNav.getFocusedCell();
                            if (lastRowCol === null) {
                                return;
                            }
                            if (!renderContainerCtrl.colContainer.containsColumn(lastRowCol.col)) {
                                return;
                            }
                            uiGridCtrl.cellNav.clearFocus();
                        });
                        grid.api.core.on.scrollEnd($scope, function(args) {
                            var lastRowCol = uiGridCtrl.grid.api.cellNav.getFocusedCell();
                            if (lastRowCol === null) {
                                return;
                            }
                            if (!renderContainerCtrl.colContainer.containsColumn(lastRowCol.col)) {
                                return;
                            }
                            uiGridCtrl.cellNav.broadcastCellNav(lastRowCol);
                        });
                        grid.api.cellNav.on.navigate($scope, function() {
                            uiGridCtrl.focus();
                        });
                    }
                };
            }
        };
    } ]);
    module.directive("uiGridCell", [ "$timeout", "$document", "uiGridCellNavService", "gridUtil", "uiGridCellNavConstants", "uiGridConstants", "GridRowColumn", function($timeout, $document, uiGridCellNavService, gridUtil, uiGridCellNavConstants, uiGridConstants, GridRowColumn) {
        return {
            "priority": -150,
            "restrict": "A",
            "require": [ "^uiGrid", "?^uiGridCellnav" ],
            "scope": false,
            "link": function($scope, $elm, $attrs, controllers) {
                var uiGridCtrl = controllers[0], uiGridCellnavCtrl = controllers[1];
                if (!uiGridCtrl.grid.api.cellNav) {
                    return;
                }
                if (!$scope.col.colDef.allowCellFocus) {
                    return;
                }
                var grid = uiGridCtrl.grid;
                $scope.focused = false;
                $elm.attr("tabindex", -1);
                $elm.find("div").on("click", function(evt) {
                    uiGridCtrl.cellNav.broadcastCellNav(new GridRowColumn($scope.row, $scope.col), evt.ctrlKey || evt.metaKey, evt);
                    evt.stopPropagation();
                    $scope.$apply();
                });
                $elm.on("mousedown", preventMouseDown);
                if (uiGridCtrl.grid.api.edit) {
                    uiGridCtrl.grid.api.edit.on.beginCellEdit($scope, function() {
                        $elm.off("mousedown", preventMouseDown);
                    });
                    uiGridCtrl.grid.api.edit.on.afterCellEdit($scope, function() {
                        $elm.on("mousedown", preventMouseDown);
                    });
                    uiGridCtrl.grid.api.edit.on.cancelCellEdit($scope, function() {
                        $elm.on("mousedown", preventMouseDown);
                    });
                }
                function preventMouseDown(evt) {
                    evt.preventDefault();
                }
                $elm.on("focus", function(evt) {
                    uiGridCtrl.cellNav.broadcastCellNav(new GridRowColumn($scope.row, $scope.col), false, evt);
                    evt.stopPropagation();
                    $scope.$apply();
                });
                $scope.$on(uiGridCellNavConstants.CELL_NAV_EVENT, function(evt, rowCol, modifierDown) {
                    var isFocused = grid.cellNav.focusedCells.some(function(focusedRowCol, index) {
                        return focusedRowCol.row === $scope.row && focusedRowCol.col === $scope.col;
                    });
                    if (isFocused) {
                        setFocused();
                    } else {
                        clearFocus();
                    }
                });
                function setFocused() {
                    if (!$scope.focused) {
                        var div = $elm.find("div");
                        div.addClass("ui-grid-cell-focus");
                        $elm.attr("aria-selected", true);
                        uiGridCellnavCtrl.setAriaActivedescendant($elm.attr("id"));
                        $scope.focused = true;
                    }
                }
                function clearFocus() {
                    if ($scope.focused) {
                        var div = $elm.find("div");
                        div.removeClass("ui-grid-cell-focus");
                        $elm.attr("aria-selected", false);
                        uiGridCellnavCtrl.removeAriaActivedescendant($elm.attr("id"));
                        $scope.focused = false;
                    }
                }
                $scope.$on("$destroy", function() {
                    $elm.find("div").off();
                    $elm.off();
                });
            }
        };
    } ]);
})();

(function() {
    "use strict";
    var module = angular.module("ui.grid.edit", [ "ui.grid" ]);
    module.constant("uiGridEditConstants", {
        "EDITABLE_CELL_TEMPLATE": /EDITABLE_CELL_TEMPLATE/g,
        "EDITABLE_CELL_DIRECTIVE": /editable_cell_directive/g,
        "events": {
            "BEGIN_CELL_EDIT": "uiGridEventBeginCellEdit",
            "END_CELL_EDIT": "uiGridEventEndCellEdit",
            "CANCEL_CELL_EDIT": "uiGridEventCancelCellEdit"
        }
    });
    module.service("uiGridEditService", [ "$q", "uiGridConstants", "gridUtil", function($q, uiGridConstants, gridUtil) {
        var service = {
            "initializeGrid": function(grid) {
                service.defaultGridOptions(grid.options);
                grid.registerColumnBuilder(service.editColumnBuilder);
                grid.edit = {};
                var publicApi = {
                    "events": {
                        "edit": {
                            "afterCellEdit": function(rowEntity, colDef, newValue, oldValue) {},
                            "beginCellEdit": function(rowEntity, colDef, triggerEvent) {},
                            "cancelCellEdit": function(rowEntity, colDef) {}
                        }
                    },
                    "methods": {
                        "edit": {}
                    }
                };
                grid.api.registerEventsFromObject(publicApi.events);
            },
            "defaultGridOptions": function(gridOptions) {
                gridOptions.cellEditableCondition = gridOptions.cellEditableCondition === undefined ? true : gridOptions.cellEditableCondition;
                gridOptions.enableCellEditOnFocus = gridOptions.enableCellEditOnFocus === undefined ? false : gridOptions.enableCellEditOnFocus;
            },
            "editColumnBuilder": function(colDef, col, gridOptions) {
                var promises = [];
                colDef.enableCellEdit = colDef.enableCellEdit === undefined ? gridOptions.enableCellEdit === undefined ? colDef.type !== "object" : gridOptions.enableCellEdit : colDef.enableCellEdit;
                colDef.cellEditableCondition = colDef.cellEditableCondition === undefined ? gridOptions.cellEditableCondition : colDef.cellEditableCondition;
                if (colDef.enableCellEdit) {
                    colDef.editableCellTemplate = colDef.editableCellTemplate || gridOptions.editableCellTemplate || "ui-grid/cellEditor";
                    promises.push(gridUtil.getTemplate(colDef.editableCellTemplate).then(function(template) {
                        col.editableCellTemplate = template;
                    }, function(res) {
                        throw new Error("Couldn't fetch/use colDef.editableCellTemplate '" + colDef.editableCellTemplate + "'");
                    }));
                }
                colDef.enableCellEditOnFocus = colDef.enableCellEditOnFocus === undefined ? gridOptions.enableCellEditOnFocus : colDef.enableCellEditOnFocus;
                return $q.all(promises);
            },
            "isStartEditKey": function(evt) {
                if (evt.metaKey || evt.keyCode === uiGridConstants.keymap.ESC || evt.keyCode === uiGridConstants.keymap.SHIFT || evt.keyCode === uiGridConstants.keymap.CTRL || evt.keyCode === uiGridConstants.keymap.ALT || evt.keyCode === uiGridConstants.keymap.WIN || evt.keyCode === uiGridConstants.keymap.CAPSLOCK || evt.keyCode === uiGridConstants.keymap.LEFT || evt.keyCode === uiGridConstants.keymap.TAB && evt.shiftKey || evt.keyCode === uiGridConstants.keymap.RIGHT || evt.keyCode === uiGridConstants.keymap.TAB || evt.keyCode === uiGridConstants.keymap.UP || evt.keyCode === uiGridConstants.keymap.ENTER && evt.shiftKey || evt.keyCode === uiGridConstants.keymap.DOWN || evt.keyCode === uiGridConstants.keymap.ENTER) {
                    return false;
                }
                return true;
            }
        };
        return service;
    } ]);
    module.directive("uiGridEdit", [ "gridUtil", "uiGridEditService", function(gridUtil, uiGridEditService) {
        return {
            "replace": true,
            "priority": 0,
            "require": "^uiGrid",
            "scope": false,
            "compile": function() {
                return {
                    "pre": function($scope, $elm, $attrs, uiGridCtrl) {
                        uiGridEditService.initializeGrid(uiGridCtrl.grid);
                    },
                    "post": function($scope, $elm, $attrs, uiGridCtrl) {}
                };
            }
        };
    } ]);
    module.directive("uiGridViewport", [ "uiGridEditConstants", function(uiGridEditConstants) {
        return {
            "replace": true,
            "priority": -99998,
            "require": [ "^uiGrid", "^uiGridRenderContainer" ],
            "scope": false,
            "compile": function() {
                return {
                    "post": function($scope, $elm, $attrs, controllers) {
                        var uiGridCtrl = controllers[0];
                        if (!uiGridCtrl.grid.api.edit || !uiGridCtrl.grid.api.cellNav) {
                            return;
                        }
                        var containerId = controllers[1].containerId;
                        if (containerId !== "body") {
                            return;
                        }
                        $scope.$on(uiGridEditConstants.events.CANCEL_CELL_EDIT, function() {
                            uiGridCtrl.focus();
                        });
                        $scope.$on(uiGridEditConstants.events.END_CELL_EDIT, function() {
                            uiGridCtrl.focus();
                        });
                    }
                };
            }
        };
    } ]);
    module.directive("uiGridCell", [ "$compile", "$injector", "$timeout", "uiGridConstants", "uiGridEditConstants", "gridUtil", "$parse", "uiGridEditService", "$rootScope", "$q", function($compile, $injector, $timeout, uiGridConstants, uiGridEditConstants, gridUtil, $parse, uiGridEditService, $rootScope, $q) {
        var touchstartTimeout = 500;
        if ($injector.has("uiGridCellNavService")) {
            var uiGridCellNavService = $injector.get("uiGridCellNavService");
        }
        return {
            "priority": -100,
            "restrict": "A",
            "scope": false,
            "require": "?^uiGrid",
            "link": function($scope, $elm, $attrs, uiGridCtrl) {
                var html;
                var origCellValue;
                var inEdit = false;
                var cellModel;
                var cancelTouchstartTimeout;
                var editCellScope;
                if (!$scope.col.colDef.enableCellEdit) {
                    return;
                }
                var cellNavNavigateDereg = function() {};
                var viewPortKeyDownDereg = function() {};
                var setEditable = function() {
                    if ($scope.col.colDef.enableCellEdit && $scope.row.enableCellEdit !== false) {
                        if (!$scope.beginEditEventsWired) {
                            registerBeginEditEvents();
                        }
                    } else {
                        if ($scope.beginEditEventsWired) {
                            cancelBeginEditEvents();
                        }
                    }
                };
                setEditable();
                var rowWatchDereg = $scope.$watch("row", function(n, o) {
                    if (n !== o) {
                        setEditable();
                    }
                });
                $scope.$on("$destroy", rowWatchDereg);
                function registerBeginEditEvents() {
                    $elm.on("dblclick", beginEdit);
                    $elm.on("touchstart", touchStart);
                    if (uiGridCtrl && uiGridCtrl.grid.api.cellNav) {
                        viewPortKeyDownDereg = uiGridCtrl.grid.api.cellNav.on.viewPortKeyDown($scope, function(evt, rowCol) {
                            if (rowCol === null) {
                                return;
                            }
                            if (rowCol.row === $scope.row && rowCol.col === $scope.col && !$scope.col.colDef.enableCellEditOnFocus) {
                                beginEditKeyDown(evt);
                            }
                        });
                        cellNavNavigateDereg = uiGridCtrl.grid.api.cellNav.on.navigate($scope, function(newRowCol, oldRowCol) {
                            if ($scope.col.colDef.enableCellEditOnFocus) {
                                if ((!oldRowCol || newRowCol.row !== oldRowCol.row || newRowCol.col !== oldRowCol.col) && newRowCol.row === $scope.row && newRowCol.col === $scope.col) {
                                    $timeout(function() {
                                        beginEdit();
                                    });
                                }
                            }
                        });
                    }
                    $scope.beginEditEventsWired = true;
                }
                function touchStart(event) {
                    if (typeof event.originalEvent !== "undefined" && event.originalEvent !== undefined) {
                        event = event.originalEvent;
                    }
                    $elm.on("touchend", touchEnd);
                    cancelTouchstartTimeout = $timeout(function() {}, touchstartTimeout);
                    cancelTouchstartTimeout.then(function() {
                        setTimeout(beginEdit, 0);
                        $elm.off("touchend", touchEnd);
                    });
                }
                function touchEnd(event) {
                    $timeout.cancel(cancelTouchstartTimeout);
                    $elm.off("touchend", touchEnd);
                }
                function cancelBeginEditEvents() {
                    $elm.off("dblclick", beginEdit);
                    $elm.off("keydown", beginEditKeyDown);
                    $elm.off("touchstart", touchStart);
                    cellNavNavigateDereg();
                    viewPortKeyDownDereg();
                    $scope.beginEditEventsWired = false;
                }
                function beginEditKeyDown(evt) {
                    if (uiGridEditService.isStartEditKey(evt)) {
                        beginEdit(evt);
                    }
                }
                function shouldEdit(col, row) {
                    return !row.isSaving && (angular.isFunction(col.colDef.cellEditableCondition) ? col.colDef.cellEditableCondition($scope) : col.colDef.cellEditableCondition);
                }
                function beginEdit(triggerEvent) {
                    $scope.grid.api.core.scrollToIfNecessary($scope.row, $scope.col).then(function() {
                        beginEditAfterScroll(triggerEvent);
                    });
                }
                function beginEditAfterScroll(triggerEvent) {
                    if (inEdit) {
                        return;
                    }
                    if (!shouldEdit($scope.col, $scope.row)) {
                        return;
                    }
                    cellModel = $parse($scope.row.getQualifiedColField($scope.col));
                    origCellValue = cellModel($scope);
                    html = $scope.col.editableCellTemplate;
                    if ($scope.col.colDef.editModelField) {
                        html = html.replace(uiGridConstants.MODEL_COL_FIELD, gridUtil.preEval("row.entity." + $scope.col.colDef.editModelField));
                    } else {
                        html = html.replace(uiGridConstants.MODEL_COL_FIELD, $scope.row.getQualifiedColField($scope.col));
                    }
                    html = html.replace(uiGridConstants.COL_FIELD, "grid.getCellValue(row, col)");
                    var optionFilter = $scope.col.colDef.editDropdownFilter ? "|" + $scope.col.colDef.editDropdownFilter : "";
                    html = html.replace(uiGridConstants.CUSTOM_FILTERS, optionFilter);
                    var inputType = "text";
                    switch ($scope.col.colDef.type) {
                      case "boolean":
                        inputType = "checkbox";
                        break;

                      case "number":
                        inputType = "number";
                        break;

                      case "date":
                        inputType = "date";
                        break;
                    }
                    html = html.replace("INPUT_TYPE", inputType);
                    var editDropdownOptionsFunction = $scope.col.colDef.editDropdownOptionsFunction;
                    if (editDropdownOptionsFunction) {
                        $q.when(editDropdownOptionsFunction($scope.row.entity, $scope.col.colDef)).then(function(result) {
                            $scope.editDropdownOptionsArray = result;
                        });
                    } else {
                        var editDropdownRowEntityOptionsArrayPath = $scope.col.colDef.editDropdownRowEntityOptionsArrayPath;
                        if (editDropdownRowEntityOptionsArrayPath) {
                            $scope.editDropdownOptionsArray = resolveObjectFromPath($scope.row.entity, editDropdownRowEntityOptionsArrayPath);
                        } else {
                            $scope.editDropdownOptionsArray = $scope.col.colDef.editDropdownOptionsArray;
                        }
                    }
                    $scope.editDropdownIdLabel = $scope.col.colDef.editDropdownIdLabel ? $scope.col.colDef.editDropdownIdLabel : "id";
                    $scope.editDropdownValueLabel = $scope.col.colDef.editDropdownValueLabel ? $scope.col.colDef.editDropdownValueLabel : "value";
                    var cellElement;
                    var createEditor = function() {
                        inEdit = true;
                        cancelBeginEditEvents();
                        var cellElement = angular.element(html);
                        $elm.append(cellElement);
                        editCellScope = $scope.$new();
                        $compile(cellElement)(editCellScope);
                        var gridCellContentsEl = angular.element($elm.children()[0]);
                        gridCellContentsEl.addClass("ui-grid-cell-contents-hidden");
                    };
                    if (!$rootScope.$$phase) {
                        $scope.$apply(createEditor);
                    } else {
                        createEditor();
                    }
                    var deregOnGridScroll = $scope.col.grid.api.core.on.scrollBegin($scope, function() {
                        if ($scope.grid.disableScrolling) {
                            return;
                        }
                        endEdit();
                        $scope.grid.api.edit.raise.afterCellEdit($scope.row.entity, $scope.col.colDef, cellModel($scope), origCellValue);
                        deregOnGridScroll();
                        deregOnEndCellEdit();
                        deregOnCancelCellEdit();
                    });
                    var deregOnEndCellEdit = $scope.$on(uiGridEditConstants.events.END_CELL_EDIT, function() {
                        endEdit();
                        $scope.grid.api.edit.raise.afterCellEdit($scope.row.entity, $scope.col.colDef, cellModel($scope), origCellValue);
                        deregOnEndCellEdit();
                        deregOnGridScroll();
                        deregOnCancelCellEdit();
                    });
                    var deregOnCancelCellEdit = $scope.$on(uiGridEditConstants.events.CANCEL_CELL_EDIT, function() {
                        cancelEdit();
                        deregOnCancelCellEdit();
                        deregOnGridScroll();
                        deregOnEndCellEdit();
                    });
                    $scope.$broadcast(uiGridEditConstants.events.BEGIN_CELL_EDIT, triggerEvent);
                    $timeout(function() {
                        $scope.grid.api.edit.raise.beginCellEdit($scope.row.entity, $scope.col.colDef, triggerEvent);
                    });
                }
                function endEdit() {
                    $scope.grid.disableScrolling = false;
                    if (!inEdit) {
                        return;
                    }
                    if (uiGridCtrl && uiGridCtrl.grid.api.cellNav) {
                        uiGridCtrl.focus();
                    }
                    var gridCellContentsEl = angular.element($elm.children()[0]);
                    editCellScope.$destroy();
                    angular.element($elm.children()[1]).remove();
                    gridCellContentsEl.removeClass("ui-grid-cell-contents-hidden");
                    inEdit = false;
                    registerBeginEditEvents();
                    $scope.grid.api.core.notifyDataChange(uiGridConstants.dataChange.EDIT);
                }
                function cancelEdit() {
                    $scope.grid.disableScrolling = false;
                    if (!inEdit) {
                        return;
                    }
                    cellModel.assign($scope, origCellValue);
                    $scope.$apply();
                    $scope.grid.api.edit.raise.cancelCellEdit($scope.row.entity, $scope.col.colDef);
                    endEdit();
                }
                function resolveObjectFromPath(object, path) {
                    path = path.replace(/\[(\w+)\]/g, ".$1");
                    path = path.replace(/^\./, "");
                    var a = path.split(".");
                    while (a.length) {
                        var n = a.shift();
                        if (n in object) {
                            object = object[n];
                        } else {
                            return;
                        }
                    }
                    return object;
                }
            }
        };
    } ]);
    module.directive("uiGridEditor", [ "gridUtil", "uiGridConstants", "uiGridEditConstants", "$timeout", "uiGridEditService", function(gridUtil, uiGridConstants, uiGridEditConstants, $timeout, uiGridEditService) {
        return {
            "scope": true,
            "require": [ "?^uiGrid", "?^uiGridRenderContainer", "ngModel" ],
            "compile": function() {
                return {
                    "pre": function($scope, $elm, $attrs) {},
                    "post": function($scope, $elm, $attrs, controllers) {
                        var uiGridCtrl, renderContainerCtrl, ngModel;
                        if (controllers[0]) {
                            uiGridCtrl = controllers[0];
                        }
                        if (controllers[1]) {
                            renderContainerCtrl = controllers[1];
                        }
                        if (controllers[2]) {
                            ngModel = controllers[2];
                        }
                        $scope.$on(uiGridEditConstants.events.BEGIN_CELL_EDIT, function(evt, triggerEvent) {
                            $timeout(function() {
                                $elm[0].focus();
                                if ($elm[0].select && $scope.col.colDef.enableCellEditOnFocus || !(uiGridCtrl && uiGridCtrl.grid.api.cellNav)) {
                                    $elm[0].select();
                                } else {
                                    try {
                                        $elm[0].setSelectionRange($elm[0].value.length, $elm[0].value.length);
                                    } catch (ex) {}
                                }
                            });
                            if (uiGridCtrl && uiGridCtrl.grid.api.cellNav) {
                                var viewPortKeyDownUnregister = uiGridCtrl.grid.api.cellNav.on.viewPortKeyPress($scope, function(evt, rowCol) {
                                    if (uiGridEditService.isStartEditKey(evt)) {
                                        ngModel.$setViewValue(String.fromCharCode(typeof evt.which === "number" ? evt.which : evt.keyCode), evt);
                                        ngModel.$render();
                                    }
                                    viewPortKeyDownUnregister();
                                });
                            }
                            $elm.on("blur", function(evt) {
                                $scope.stopEdit(evt);
                            });
                        });
                        $scope.deepEdit = false;
                        $scope.stopEdit = function(evt) {
                            if ($scope.inputForm && !$scope.inputForm.$valid) {
                                evt.stopPropagation();
                                $scope.$emit(uiGridEditConstants.events.CANCEL_CELL_EDIT);
                            } else {
                                $scope.$emit(uiGridEditConstants.events.END_CELL_EDIT);
                            }
                            $scope.deepEdit = false;
                        };
                        $elm.on("click", function(evt) {
                            if ($elm[0].type !== "checkbox") {
                                $scope.deepEdit = true;
                                $timeout(function() {
                                    $scope.grid.disableScrolling = true;
                                });
                            }
                        });
                        $elm.on("keydown", function(evt) {
                            switch (evt.keyCode) {
                              case uiGridConstants.keymap.ESC:
                                evt.stopPropagation();
                                $scope.$emit(uiGridEditConstants.events.CANCEL_CELL_EDIT);
                                break;
                            }
                            if ($scope.deepEdit && (evt.keyCode === uiGridConstants.keymap.LEFT || evt.keyCode === uiGridConstants.keymap.RIGHT || evt.keyCode === uiGridConstants.keymap.UP || evt.keyCode === uiGridConstants.keymap.DOWN)) {
                                evt.stopPropagation();
                            } else if (uiGridCtrl && uiGridCtrl.grid.api.cellNav) {
                                evt.uiGridTargetRenderContainerId = renderContainerCtrl.containerId;
                                if (uiGridCtrl.cellNav.handleKeyDown(evt) !== null) {
                                    $scope.stopEdit(evt);
                                }
                            } else {
                                switch (evt.keyCode) {
                                  case uiGridConstants.keymap.ENTER:
                                  case uiGridConstants.keymap.TAB:
                                    evt.stopPropagation();
                                    evt.preventDefault();
                                    $scope.stopEdit(evt);
                                    break;
                                }
                            }
                            return true;
                        });
                    }
                };
            }
        };
    } ]);
    module.directive("uiGridEditor", [ "$filter", function($filter) {
        function parseDateString(dateString) {
            if (typeof dateString === "undefined" || dateString === "") {
                return null;
            }
            var parts = dateString.split("-");
            if (parts.length !== 3) {
                return null;
            }
            var year = parseInt(parts[0], 10);
            var month = parseInt(parts[1], 10);
            var day = parseInt(parts[2], 10);
            if (month < 1 || year < 1 || day < 1) {
                return null;
            }
            return new Date(year, month - 1, day);
        }
        return {
            "priority": -100,
            "require": "?ngModel",
            "link": function(scope, element, attrs, ngModel) {
                if (angular.version.minor === 2 && attrs.type && attrs.type === "date" && ngModel) {
                    ngModel.$formatters.push(function(modelValue) {
                        ngModel.$setValidity(null, !modelValue || !isNaN(modelValue.getTime()));
                        return $filter("date")(modelValue, "yyyy-MM-dd");
                    });
                    ngModel.$parsers.push(function(viewValue) {
                        if (viewValue && viewValue.length > 0) {
                            var dateValue = parseDateString(viewValue);
                            ngModel.$setValidity(null, dateValue && !isNaN(dateValue.getTime()));
                            return dateValue;
                        } else {
                            ngModel.$setValidity(null, true);
                            return null;
                        }
                    });
                }
            }
        };
    } ]);
    module.directive("uiGridEditDropdown", [ "uiGridConstants", "uiGridEditConstants", function(uiGridConstants, uiGridEditConstants) {
        return {
            "require": [ "?^uiGrid", "?^uiGridRenderContainer" ],
            "scope": true,
            "compile": function() {
                return {
                    "pre": function($scope, $elm, $attrs) {},
                    "post": function($scope, $elm, $attrs, controllers) {
                        var uiGridCtrl = controllers[0];
                        var renderContainerCtrl = controllers[1];
                        $scope.$on(uiGridEditConstants.events.BEGIN_CELL_EDIT, function() {
                            $elm[0].focus();
                            $elm[0].style.width = $elm[0].parentElement.offsetWidth - 1 + "px";
                            $elm.on("blur", function(evt) {
                                $scope.stopEdit(evt);
                            });
                        });
                        $scope.stopEdit = function(evt) {
                            $scope.$emit(uiGridEditConstants.events.END_CELL_EDIT);
                        };
                        $elm.on("keydown", function(evt) {
                            switch (evt.keyCode) {
                              case uiGridConstants.keymap.ESC:
                                evt.stopPropagation();
                                $scope.$emit(uiGridEditConstants.events.CANCEL_CELL_EDIT);
                                break;
                            }
                            if (uiGridCtrl && uiGridCtrl.grid.api.cellNav) {
                                evt.uiGridTargetRenderContainerId = renderContainerCtrl.containerId;
                                if (uiGridCtrl.cellNav.handleKeyDown(evt) !== null) {
                                    $scope.stopEdit(evt);
                                }
                            } else {
                                switch (evt.keyCode) {
                                  case uiGridConstants.keymap.ENTER:
                                  case uiGridConstants.keymap.TAB:
                                    evt.stopPropagation();
                                    evt.preventDefault();
                                    $scope.stopEdit(evt);
                                    break;
                                }
                            }
                            return true;
                        });
                    }
                };
            }
        };
    } ]);
    module.directive("uiGridEditFileChooser", [ "gridUtil", "uiGridConstants", "uiGridEditConstants", "$timeout", function(gridUtil, uiGridConstants, uiGridEditConstants, $timeout) {
        return {
            "scope": true,
            "require": [ "?^uiGrid", "?^uiGridRenderContainer" ],
            "compile": function() {
                return {
                    "pre": function($scope, $elm, $attrs) {},
                    "post": function($scope, $elm, $attrs, controllers) {
                        var uiGridCtrl, renderContainerCtrl;
                        if (controllers[0]) {
                            uiGridCtrl = controllers[0];
                        }
                        if (controllers[1]) {
                            renderContainerCtrl = controllers[1];
                        }
                        var grid = uiGridCtrl.grid;
                        var handleFileSelect = function(event) {
                            var target = event.srcElement || event.target;
                            if (target && target.files && target.files.length > 0) {
                                if (typeof $scope.col.colDef.editFileChooserCallback === "function") {
                                    $scope.col.colDef.editFileChooserCallback($scope.row, $scope.col, target.files);
                                } else {
                                    gridUtil.logError("You need to set colDef.editFileChooserCallback to use the file chooser");
                                }
                                target.form.reset();
                                $scope.$emit(uiGridEditConstants.events.END_CELL_EDIT);
                            } else {
                                $scope.$emit(uiGridEditConstants.events.CANCEL_CELL_EDIT);
                            }
                        };
                        $elm[0].addEventListener("change", handleFileSelect, false);
                        $scope.$on(uiGridEditConstants.events.BEGIN_CELL_EDIT, function() {
                            $elm[0].focus();
                            $elm[0].select();
                            $elm.on("blur", function(evt) {
                                $scope.$emit(uiGridEditConstants.events.END_CELL_EDIT);
                            });
                        });
                    }
                };
            }
        };
    } ]);
})();

(function() {
    "use strict";
    var module = angular.module("ui.grid.expandable", [ "ui.grid" ]);
    module.service("uiGridExpandableService", [ "gridUtil", "$compile", function(gridUtil, $compile) {
        var service = {
            "initializeGrid": function(grid) {
                grid.expandable = {};
                grid.expandable.expandedAll = false;
                grid.options.enableExpandable = grid.options.enableExpandable !== false;
                grid.options.expandableRowHeight = grid.options.expandableRowHeight || 150;
                grid.options.expandableRowHeaderWidth = grid.options.expandableRowHeaderWidth || 40;
                if (grid.options.enableExpandable && !grid.options.expandableRowTemplate) {
                    gridUtil.logError("You have not set the expandableRowTemplate, disabling expandable module");
                    grid.options.enableExpandable = false;
                }
                var publicApi = {
                    "events": {
                        "expandable": {
                            "rowExpandedBeforeStateChanged": function(scope, row) {},
                            "rowExpandedStateChanged": function(scope, row) {}
                        }
                    },
                    "methods": {
                        "expandable": {
                            "toggleRowExpansion": function(rowEntity) {
                                var row = grid.getRow(rowEntity);
                                if (row !== null) {
                                    service.toggleRowExpansion(grid, row);
                                }
                            },
                            "expandAllRows": function() {
                                service.expandAllRows(grid);
                            },
                            "collapseAllRows": function() {
                                service.collapseAllRows(grid);
                            },
                            "toggleAllRows": function() {
                                service.toggleAllRows(grid);
                            },
                            "expandRow": function(rowEntity) {
                                var row = grid.getRow(rowEntity);
                                if (row !== null && !row.isExpanded) {
                                    service.toggleRowExpansion(grid, row);
                                }
                            },
                            "collapseRow": function(rowEntity) {
                                var row = grid.getRow(rowEntity);
                                if (row !== null && row.isExpanded) {
                                    service.toggleRowExpansion(grid, row);
                                }
                            },
                            "getExpandedRows": function() {
                                return service.getExpandedRows(grid).map(function(gridRow) {
                                    return gridRow.entity;
                                });
                            }
                        }
                    }
                };
                grid.api.registerEventsFromObject(publicApi.events);
                grid.api.registerMethodsFromObject(publicApi.methods);
            },
            "toggleRowExpansion": function(grid, row) {
                grid.api.expandable.raise.rowExpandedBeforeStateChanged(row);
                row.isExpanded = !row.isExpanded;
                if (angular.isUndefined(row.expandedRowHeight)) {
                    row.expandedRowHeight = grid.options.expandableRowHeight;
                }
                if (row.isExpanded) {
                    row.height = row.grid.options.rowHeight + row.expandedRowHeight;
                } else {
                    row.height = row.grid.options.rowHeight;
                    grid.expandable.expandedAll = false;
                }
                grid.api.expandable.raise.rowExpandedStateChanged(row);
            },
            "expandAllRows": function(grid, $scope) {
                grid.renderContainers.body.visibleRowCache.forEach(function(row) {
                    if (!row.isExpanded) {
                        service.toggleRowExpansion(grid, row);
                    }
                });
                grid.expandable.expandedAll = true;
                grid.queueGridRefresh();
            },
            "collapseAllRows": function(grid) {
                grid.renderContainers.body.visibleRowCache.forEach(function(row) {
                    if (row.isExpanded) {
                        service.toggleRowExpansion(grid, row);
                    }
                });
                grid.expandable.expandedAll = false;
                grid.queueGridRefresh();
            },
            "toggleAllRows": function(grid) {
                if (grid.expandable.expandedAll) {
                    service.collapseAllRows(grid);
                } else {
                    service.expandAllRows(grid);
                }
            },
            "getExpandedRows": function(grid) {
                return grid.rows.filter(function(row) {
                    return row.isExpanded;
                });
            }
        };
        return service;
    } ]);
    module.directive("uiGridExpandable", [ "uiGridExpandableService", "$templateCache", function(uiGridExpandableService, $templateCache) {
        return {
            "replace": true,
            "priority": 0,
            "require": "^uiGrid",
            "scope": false,
            "compile": function() {
                return {
                    "pre": function($scope, $elm, $attrs, uiGridCtrl) {
                        if (uiGridCtrl.grid.options.enableExpandableRowHeader !== false) {
                            var expandableRowHeaderColDef = {
                                "name": "expandableButtons",
                                "displayName": "",
                                "exporterSuppressExport": true,
                                "enableColumnResizing": false,
                                "enableColumnMenu": false,
                                "width": uiGridCtrl.grid.options.expandableRowHeaderWidth || 40
                            };
                            expandableRowHeaderColDef.cellTemplate = $templateCache.get("ui-grid/expandableRowHeader");
                            expandableRowHeaderColDef.headerCellTemplate = $templateCache.get("ui-grid/expandableTopRowHeader");
                            uiGridCtrl.grid.addRowHeaderColumn(expandableRowHeaderColDef);
                        }
                        uiGridExpandableService.initializeGrid(uiGridCtrl.grid);
                    },
                    "post": function($scope, $elm, $attrs, uiGridCtrl) {}
                };
            }
        };
    } ]);
    module.directive("uiGrid", [ "uiGridExpandableService", "$templateCache", function(uiGridExpandableService, $templateCache) {
        return {
            "replace": true,
            "priority": 599,
            "require": "^uiGrid",
            "scope": false,
            "compile": function() {
                return {
                    "pre": function($scope, $elm, $attrs, uiGridCtrl) {
                        uiGridCtrl.grid.api.core.on.renderingComplete($scope, function() {
                            if ($scope.row && $scope.row.grid && $scope.row.grid.options && $scope.row.grid.options.enableExpandable) {
                                uiGridCtrl.grid.parentRow = $scope.row;
                            }
                        });
                    },
                    "post": function($scope, $elm, $attrs, uiGridCtrl) {}
                };
            }
        };
    } ]);
    module.directive("uiGridExpandableRow", [ "uiGridExpandableService", "$timeout", "$compile", "uiGridConstants", "gridUtil", "$interval", "$log", function(uiGridExpandableService, $timeout, $compile, uiGridConstants, gridUtil, $interval, $log) {
        return {
            "replace": false,
            "priority": 0,
            "scope": false,
            "compile": function() {
                return {
                    "pre": function($scope, $elm, $attrs, uiGridCtrl) {
                        gridUtil.getTemplate($scope.grid.options.expandableRowTemplate).then(function(template) {
                            if ($scope.grid.options.expandableRowScope) {
                                var expandableRowScope = $scope.grid.options.expandableRowScope;
                                for (var property in expandableRowScope) {
                                    if (expandableRowScope.hasOwnProperty(property)) {
                                        $scope[property] = expandableRowScope[property];
                                    }
                                }
                            }
                            var expandedRowElement = $compile(template)($scope);
                            $elm.append(expandedRowElement);
                            $scope.row.expandedRendered = true;
                        });
                    },
                    "post": function($scope, $elm, $attrs, uiGridCtrl) {
                        $scope.$on("$destroy", function() {
                            $scope.row.expandedRendered = false;
                        });
                    }
                };
            }
        };
    } ]);
    module.directive("uiGridRow", [ "$compile", "gridUtil", "$templateCache", function($compile, gridUtil, $templateCache) {
        return {
            "priority": -200,
            "scope": false,
            "compile": function($elm, $attrs) {
                return {
                    "pre": function($scope, $elm, $attrs, controllers) {
                        $scope.expandableRow = {};
                        $scope.expandableRow.shouldRenderExpand = function() {
                            var ret = $scope.colContainer.name === "body" && $scope.grid.options.enableExpandable !== false && $scope.row.isExpanded && (!$scope.grid.isScrollingVertically || $scope.row.expandedRendered);
                            return ret;
                        };
                        $scope.expandableRow.shouldRenderFiller = function() {
                            var ret = $scope.row.isExpanded && ($scope.colContainer.name !== "body" || $scope.grid.isScrollingVertically && !$scope.row.expandedRendered);
                            return ret;
                        };
                    },
                    "post": function($scope, $elm, $attrs, controllers) {}
                };
            }
        };
    } ]);
    module.directive("uiGridViewport", [ "$compile", "gridUtil", "$templateCache", function($compile, gridUtil, $templateCache) {
        return {
            "priority": -200,
            "scope": false,
            "compile": function($elm, $attrs) {
                var rowRepeatDiv = angular.element($elm.children().children()[0]);
                var expandedRowFillerElement = $templateCache.get("ui-grid/expandableScrollFiller");
                var expandedRowElement = $templateCache.get("ui-grid/expandableRow");
                rowRepeatDiv.append(expandedRowElement);
                rowRepeatDiv.append(expandedRowFillerElement);
                return {
                    "pre": function($scope, $elm, $attrs, controllers) {},
                    "post": function($scope, $elm, $attrs, controllers) {}
                };
            }
        };
    } ]);
})();

(function() {
    "use strict";
    var module = angular.module("ui.grid.exporter", [ "ui.grid" ]);
    module.constant("uiGridExporterConstants", {
        "featureName": "exporter",
        "ALL": "all",
        "VISIBLE": "visible",
        "SELECTED": "selected",
        "CSV_CONTENT": "CSV_CONTENT",
        "BUTTON_LABEL": "BUTTON_LABEL",
        "FILE_NAME": "FILE_NAME"
    });
    module.service("uiGridExporterService", [ "$q", "uiGridExporterConstants", "gridUtil", "$compile", "$interval", "i18nService", function($q, uiGridExporterConstants, gridUtil, $compile, $interval, i18nService) {
        var service = {
            "delay": 100,
            "initializeGrid": function(grid) {
                grid.exporter = {};
                this.defaultGridOptions(grid.options);
                var publicApi = {
                    "events": {
                        "exporter": {}
                    },
                    "methods": {
                        "exporter": {
                            "csvExport": function(rowTypes, colTypes) {
                                service.csvExport(grid, rowTypes, colTypes);
                            },
                            "pdfExport": function(rowTypes, colTypes) {
                                service.pdfExport(grid, rowTypes, colTypes);
                            }
                        }
                    }
                };
                grid.api.registerEventsFromObject(publicApi.events);
                grid.api.registerMethodsFromObject(publicApi.methods);
                if (grid.api.core.addToGridMenu) {
                    service.addToMenu(grid);
                } else {
                    $interval(function() {
                        if (grid.api.core.addToGridMenu) {
                            service.addToMenu(grid);
                        }
                    }, this.delay, 1);
                }
            },
            "defaultGridOptions": function(gridOptions) {
                gridOptions.exporterSuppressMenu = gridOptions.exporterSuppressMenu === true;
                gridOptions.exporterMenuLabel = gridOptions.exporterMenuLabel ? gridOptions.exporterMenuLabel : "Export";
                gridOptions.exporterSuppressColumns = gridOptions.exporterSuppressColumns ? gridOptions.exporterSuppressColumns : [];
                gridOptions.exporterCsvColumnSeparator = gridOptions.exporterCsvColumnSeparator ? gridOptions.exporterCsvColumnSeparator : ",";
                gridOptions.exporterCsvFilename = gridOptions.exporterCsvFilename ? gridOptions.exporterCsvFilename : "download.csv";
                gridOptions.exporterPdfFilename = gridOptions.exporterPdfFilename ? gridOptions.exporterPdfFilename : "download.pdf";
                gridOptions.exporterOlderExcelCompatibility = gridOptions.exporterOlderExcelCompatibility === true;
                gridOptions.exporterPdfDefaultStyle = gridOptions.exporterPdfDefaultStyle ? gridOptions.exporterPdfDefaultStyle : {
                    "fontSize": 11
                };
                gridOptions.exporterPdfTableStyle = gridOptions.exporterPdfTableStyle ? gridOptions.exporterPdfTableStyle : {
                    "margin": [ 0, 5, 0, 15 ]
                };
                gridOptions.exporterPdfTableHeaderStyle = gridOptions.exporterPdfTableHeaderStyle ? gridOptions.exporterPdfTableHeaderStyle : {
                    "bold": true,
                    "fontSize": 12,
                    "color": "black"
                };
                gridOptions.exporterPdfHeader = gridOptions.exporterPdfHeader ? gridOptions.exporterPdfHeader : null;
                gridOptions.exporterPdfFooter = gridOptions.exporterPdfFooter ? gridOptions.exporterPdfFooter : null;
                gridOptions.exporterPdfOrientation = gridOptions.exporterPdfOrientation ? gridOptions.exporterPdfOrientation : "landscape";
                gridOptions.exporterPdfPageSize = gridOptions.exporterPdfPageSize ? gridOptions.exporterPdfPageSize : "A4";
                gridOptions.exporterPdfMaxGridWidth = gridOptions.exporterPdfMaxGridWidth ? gridOptions.exporterPdfMaxGridWidth : 720;
                gridOptions.exporterMenuAllData = gridOptions.exporterMenuAllData !== undefined ? gridOptions.exporterMenuAllData : true;
                gridOptions.exporterMenuVisibleData = gridOptions.exporterMenuVisibleData !== undefined ? gridOptions.exporterMenuVisibleData : true;
                gridOptions.exporterMenuSelectedData = gridOptions.exporterMenuSelectedData !== undefined ? gridOptions.exporterMenuSelectedData : true;
                gridOptions.exporterMenuCsv = gridOptions.exporterMenuCsv !== undefined ? gridOptions.exporterMenuCsv : true;
                gridOptions.exporterMenuPdf = gridOptions.exporterMenuPdf !== undefined ? gridOptions.exporterMenuPdf : true;
                gridOptions.exporterPdfCustomFormatter = gridOptions.exporterPdfCustomFormatter && typeof gridOptions.exporterPdfCustomFormatter === "function" ? gridOptions.exporterPdfCustomFormatter : function(docDef) {
                    return docDef;
                };
                gridOptions.exporterHeaderFilterUseName = gridOptions.exporterHeaderFilterUseName === true;
                gridOptions.exporterFieldCallback = gridOptions.exporterFieldCallback ? gridOptions.exporterFieldCallback : function(grid, row, col, value) {
                    return value;
                };
                gridOptions.exporterAllDataFn = gridOptions.exporterAllDataFn ? gridOptions.exporterAllDataFn : null;
                if (gridOptions.exporterAllDataFn == null && gridOptions.exporterAllDataPromise) {
                    gridOptions.exporterAllDataFn = gridOptions.exporterAllDataPromise;
                }
            },
            "addToMenu": function(grid) {
                grid.api.core.addToGridMenu(grid, [ {
                    "title": i18nService.getSafeText("gridMenu.exporterAllAsCsv"),
                    "action": function($event) {
                        this.grid.api.exporter.csvExport(uiGridExporterConstants.ALL, uiGridExporterConstants.ALL);
                    },
                    "shown": function() {
                        return this.grid.options.exporterMenuCsv && this.grid.options.exporterMenuAllData;
                    },
                    "order": 200
                }, {
                    "title": i18nService.getSafeText("gridMenu.exporterVisibleAsCsv"),
                    "action": function($event) {
                        this.grid.api.exporter.csvExport(uiGridExporterConstants.VISIBLE, uiGridExporterConstants.VISIBLE);
                    },
                    "shown": function() {
                        return this.grid.options.exporterMenuCsv && this.grid.options.exporterMenuVisibleData;
                    },
                    "order": 201
                }, {
                    "title": i18nService.getSafeText("gridMenu.exporterSelectedAsCsv"),
                    "action": function($event) {
                        this.grid.api.exporter.csvExport(uiGridExporterConstants.SELECTED, uiGridExporterConstants.VISIBLE);
                    },
                    "shown": function() {
                        return this.grid.options.exporterMenuCsv && this.grid.options.exporterMenuSelectedData && (this.grid.api.selection && this.grid.api.selection.getSelectedRows().length > 0);
                    },
                    "order": 202
                }, {
                    "title": i18nService.getSafeText("gridMenu.exporterAllAsPdf"),
                    "action": function($event) {
                        this.grid.api.exporter.pdfExport(uiGridExporterConstants.ALL, uiGridExporterConstants.ALL);
                    },
                    "shown": function() {
                        return this.grid.options.exporterMenuPdf && this.grid.options.exporterMenuAllData;
                    },
                    "order": 203
                }, {
                    "title": i18nService.getSafeText("gridMenu.exporterVisibleAsPdf"),
                    "action": function($event) {
                        this.grid.api.exporter.pdfExport(uiGridExporterConstants.VISIBLE, uiGridExporterConstants.VISIBLE);
                    },
                    "shown": function() {
                        return this.grid.options.exporterMenuPdf && this.grid.options.exporterMenuVisibleData;
                    },
                    "order": 204
                }, {
                    "title": i18nService.getSafeText("gridMenu.exporterSelectedAsPdf"),
                    "action": function($event) {
                        this.grid.api.exporter.pdfExport(uiGridExporterConstants.SELECTED, uiGridExporterConstants.VISIBLE);
                    },
                    "shown": function() {
                        return this.grid.options.exporterMenuPdf && this.grid.options.exporterMenuSelectedData && (this.grid.api.selection && this.grid.api.selection.getSelectedRows().length > 0);
                    },
                    "order": 205
                } ]);
            },
            "csvExport": function(grid, rowTypes, colTypes) {
                var self = this;
                this.loadAllDataIfNeeded(grid, rowTypes, colTypes).then(function() {
                    var exportColumnHeaders = grid.options.showHeader ? self.getColumnHeaders(grid, colTypes) : [];
                    var exportData = self.getData(grid, rowTypes, colTypes);
                    var csvContent = self.formatAsCsv(exportColumnHeaders, exportData, grid.options.exporterCsvColumnSeparator);
                    self.downloadFile(grid.options.exporterCsvFilename, csvContent, grid.options.exporterOlderExcelCompatibility);
                });
            },
            "loadAllDataIfNeeded": function(grid, rowTypes, colTypes) {
                if (rowTypes === uiGridExporterConstants.ALL && grid.rows.length !== grid.options.totalItems && grid.options.exporterAllDataFn) {
                    return grid.options.exporterAllDataFn().then(function() {
                        grid.modifyRows(grid.options.data);
                    });
                } else {
                    var deferred = $q.defer();
                    deferred.resolve();
                    return deferred.promise;
                }
            },
            "getColumnHeaders": function(grid, colTypes) {
                var headers = [];
                var columns;
                if (colTypes === uiGridExporterConstants.ALL) {
                    columns = grid.columns;
                } else {
                    var leftColumns = grid.renderContainers.left ? grid.renderContainers.left.visibleColumnCache.filter(function(column) {
                        return column.visible;
                    }) : [];
                    var bodyColumns = grid.renderContainers.body ? grid.renderContainers.body.visibleColumnCache.filter(function(column) {
                        return column.visible;
                    }) : [];
                    var rightColumns = grid.renderContainers.right ? grid.renderContainers.right.visibleColumnCache.filter(function(column) {
                        return column.visible;
                    }) : [];
                    columns = leftColumns.concat(bodyColumns, rightColumns);
                }
                columns.forEach(function(gridCol, index) {
                    if (gridCol.colDef.exporterSuppressExport !== true && grid.options.exporterSuppressColumns.indexOf(gridCol.name) === -1) {
                        headers.push({
                            "name": gridCol.field,
                            "displayName": grid.options.exporterHeaderFilter ? grid.options.exporterHeaderFilterUseName ? grid.options.exporterHeaderFilter(gridCol.name) : grid.options.exporterHeaderFilter(gridCol.displayName) : gridCol.displayName,
                            "width": gridCol.drawnWidth ? gridCol.drawnWidth : gridCol.width,
                            "align": gridCol.colDef.type === "number" ? "right" : "left"
                        });
                    }
                });
                return headers;
            },
            "getData": function(grid, rowTypes, colTypes, applyCellFilters) {
                var data = [];
                var rows;
                var columns;
                switch (rowTypes) {
                  case uiGridExporterConstants.ALL:
                    rows = grid.rows;
                    break;

                  case uiGridExporterConstants.VISIBLE:
                    rows = grid.getVisibleRows();
                    break;

                  case uiGridExporterConstants.SELECTED:
                    if (grid.api.selection) {
                        rows = grid.api.selection.getSelectedGridRows();
                    } else {
                        gridUtil.logError("selection feature must be enabled to allow selected rows to be exported");
                    }
                    break;
                }
                if (colTypes === uiGridExporterConstants.ALL) {
                    columns = grid.columns;
                } else {
                    var leftColumns = grid.renderContainers.left ? grid.renderContainers.left.visibleColumnCache.filter(function(column) {
                        return column.visible;
                    }) : [];
                    var bodyColumns = grid.renderContainers.body ? grid.renderContainers.body.visibleColumnCache.filter(function(column) {
                        return column.visible;
                    }) : [];
                    var rightColumns = grid.renderContainers.right ? grid.renderContainers.right.visibleColumnCache.filter(function(column) {
                        return column.visible;
                    }) : [];
                    columns = leftColumns.concat(bodyColumns, rightColumns);
                }
                rows.forEach(function(row, index) {
                    if (row.exporterEnableExporting !== false) {
                        var extractedRow = [];
                        columns.forEach(function(gridCol, index) {
                            if ((gridCol.visible || colTypes === uiGridExporterConstants.ALL) && gridCol.colDef.exporterSuppressExport !== true && grid.options.exporterSuppressColumns.indexOf(gridCol.name) === -1) {
                                var cellValue = applyCellFilters ? grid.getCellDisplayValue(row, gridCol) : grid.getCellValue(row, gridCol);
                                var extractedField = {
                                    "value": grid.options.exporterFieldCallback(grid, row, gridCol, cellValue)
                                };
                                if (gridCol.colDef.exporterPdfAlign) {
                                    extractedField.alignment = gridCol.colDef.exporterPdfAlign;
                                }
                                extractedRow.push(extractedField);
                            }
                        });
                        data.push(extractedRow);
                    }
                });
                return data;
            },
            "formatAsCsv": function(exportColumnHeaders, exportData, separator) {
                var self = this;
                var bareHeaders = exportColumnHeaders.map(function(header) {
                    return {
                        "value": header.displayName
                    };
                });
                var csv = bareHeaders.length > 0 ? self.formatRowAsCsv(this, separator)(bareHeaders) + "\n" : "";
                csv += exportData.map(this.formatRowAsCsv(this, separator)).join("\n");
                return csv;
            },
            "formatRowAsCsv": function(exporter, separator) {
                return function(row) {
                    return row.map(exporter.formatFieldAsCsv).join(separator);
                };
            },
            "formatFieldAsCsv": function(field) {
                if (field.value == null) {
                    return "";
                }
                if (typeof field.value === "number") {
                    return field.value;
                }
                if (typeof field.value === "boolean") {
                    return field.value ? "TRUE" : "FALSE";
                }
                if (typeof field.value === "string") {
                    return '"' + field.value.replace(/"/g, '""') + '"';
                }
                return JSON.stringify(field.value);
            },
            "isIE": function() {
                var match = navigator.userAgent.search(/(?:Edge|MSIE|Trident\/.*; rv:)/);
                var isIE = false;
                if (match !== -1) {
                    isIE = true;
                }
                return isIE;
            },
            "downloadFile": function(fileName, csvContent, exporterOlderExcelCompatibility) {
                var D = document;
                var a = D.createElement("a");
                var strMimeType = "application/octet-stream;charset=utf-8";
                var rawFile;
                var ieVersion;
                ieVersion = this.isIE();
                if (ieVersion && ieVersion < 10) {
                    var frame = D.createElement("iframe");
                    document.body.appendChild(frame);
                    frame.contentWindow.document.open("text/html", "replace");
                    frame.contentWindow.document.write("sep=,\r\n" + csvContent);
                    frame.contentWindow.document.close();
                    frame.contentWindow.focus();
                    frame.contentWindow.document.execCommand("SaveAs", true, fileName);
                    document.body.removeChild(frame);
                    return true;
                }
                if (navigator.msSaveBlob) {
                    return navigator.msSaveOrOpenBlob(new Blob([ exporterOlderExcelCompatibility ? "\ufeff" : "", csvContent ], {
                        "type": strMimeType
                    }), fileName);
                }
                if ("download" in a) {
                    var blob = new Blob([ exporterOlderExcelCompatibility ? "\ufeff" : "", csvContent ], {
                        "type": strMimeType
                    });
                    rawFile = URL.createObjectURL(blob);
                    a.setAttribute("download", fileName);
                } else {
                    rawFile = "data:" + strMimeType + "," + encodeURIComponent(csvContent);
                    a.setAttribute("target", "_blank");
                }
                a.href = rawFile;
                a.setAttribute("style", "display:none;");
                D.body.appendChild(a);
                setTimeout(function() {
                    if (a.click) {
                        a.click();
                    } else if (document.createEvent) {
                        var eventObj = document.createEvent("MouseEvents");
                        eventObj.initEvent("click", true, true);
                        a.dispatchEvent(eventObj);
                    }
                    D.body.removeChild(a);
                }, this.delay);
            },
            "pdfExport": function(grid, rowTypes, colTypes) {
                var self = this;
                this.loadAllDataIfNeeded(grid, rowTypes, colTypes).then(function() {
                    var exportColumnHeaders = self.getColumnHeaders(grid, colTypes);
                    var exportData = self.getData(grid, rowTypes, colTypes);
                    var docDefinition = self.prepareAsPdf(grid, exportColumnHeaders, exportData);
                    if (self.isIE() || navigator.appVersion.indexOf("Edge") !== -1) {
                        self.downloadPDF(grid.options.exporterPdfFilename, docDefinition);
                    } else {
                        pdfMake.createPdf(docDefinition).open();
                    }
                });
            },
            "downloadPDF": function(fileName, docDefinition) {
                var D = document;
                var a = D.createElement("a");
                var strMimeType = "application/octet-stream;charset=utf-8";
                var rawFile;
                var ieVersion;
                ieVersion = this.isIE();
                var doc = pdfMake.createPdf(docDefinition);
                var blob;
                doc.getBuffer(function(buffer) {
                    blob = new Blob([ buffer ]);
                    if (navigator.msSaveBlob) {
                        return navigator.msSaveBlob(blob, fileName);
                    }
                    if (ieVersion) {
                        var frame = D.createElement("iframe");
                        document.body.appendChild(frame);
                        frame.contentWindow.document.open("text/html", "replace");
                        frame.contentWindow.document.write(blob);
                        frame.contentWindow.document.close();
                        frame.contentWindow.focus();
                        frame.contentWindow.document.execCommand("SaveAs", true, fileName);
                        document.body.removeChild(frame);
                        return true;
                    }
                });
            },
            "prepareAsPdf": function(grid, exportColumnHeaders, exportData) {
                var headerWidths = this.calculatePdfHeaderWidths(grid, exportColumnHeaders);
                var headerColumns = exportColumnHeaders.map(function(header) {
                    return {
                        "text": header.displayName,
                        "style": "tableHeader"
                    };
                });
                var stringData = exportData.map(this.formatRowAsPdf(this));
                var allData = [ headerColumns ].concat(stringData);
                var docDefinition = {
                    "pageOrientation": grid.options.exporterPdfOrientation,
                    "pageSize": grid.options.exporterPdfPageSize,
                    "content": [ {
                        "style": "tableStyle",
                        "table": {
                            "headerRows": 1,
                            "widths": headerWidths,
                            "body": allData
                        }
                    } ],
                    "styles": {
                        "tableStyle": grid.options.exporterPdfTableStyle,
                        "tableHeader": grid.options.exporterPdfTableHeaderStyle
                    },
                    "defaultStyle": grid.options.exporterPdfDefaultStyle
                };
                if (grid.options.exporterPdfLayout) {
                    docDefinition.layout = grid.options.exporterPdfLayout;
                }
                if (grid.options.exporterPdfHeader) {
                    docDefinition.header = grid.options.exporterPdfHeader;
                }
                if (grid.options.exporterPdfFooter) {
                    docDefinition.footer = grid.options.exporterPdfFooter;
                }
                if (grid.options.exporterPdfCustomFormatter) {
                    docDefinition = grid.options.exporterPdfCustomFormatter(docDefinition);
                }
                return docDefinition;
            },
            "calculatePdfHeaderWidths": function(grid, exportHeaders) {
                var baseGridWidth = 0;
                exportHeaders.forEach(function(value) {
                    if (typeof value.width === "number") {
                        baseGridWidth += value.width;
                    }
                });
                var extraColumns = 0;
                exportHeaders.forEach(function(value) {
                    if (value.width === "*") {
                        extraColumns += 100;
                    }
                    if (typeof value.width === "string" && value.width.match(/(\d)*%/)) {
                        var percent = parseInt(value.width.match(/(\d)*%/)[0]);
                        value.width = baseGridWidth * percent / 100;
                        extraColumns += value.width;
                    }
                });
                var gridWidth = baseGridWidth + extraColumns;
                return exportHeaders.map(function(header) {
                    return header.width === "*" ? header.width : header.width * grid.options.exporterPdfMaxGridWidth / gridWidth;
                });
            },
            "formatRowAsPdf": function(exporter) {
                return function(row) {
                    return row.map(exporter.formatFieldAsPdfString);
                };
            },
            "formatFieldAsPdfString": function(field) {
                var returnVal;
                if (field.value == null) {
                    returnVal = "";
                } else if (typeof field.value === "number") {
                    returnVal = field.value.toString();
                } else if (typeof field.value === "boolean") {
                    returnVal = field.value ? "TRUE" : "FALSE";
                } else if (typeof field.value === "string") {
                    returnVal = field.value.replace(/"/g, '""');
                } else {
                    returnVal = JSON.stringify(field.value).replace(/^"/, "").replace(/"$/, "");
                }
                if (field.alignment && typeof field.alignment === "string") {
                    returnVal = {
                        "text": returnVal,
                        "alignment": field.alignment
                    };
                }
                return returnVal;
            }
        };
        return service;
    } ]);
    module.directive("uiGridExporter", [ "uiGridExporterConstants", "uiGridExporterService", "gridUtil", "$compile", function(uiGridExporterConstants, uiGridExporterService, gridUtil, $compile) {
        return {
            "replace": true,
            "priority": 0,
            "require": "^uiGrid",
            "scope": false,
            "link": function($scope, $elm, $attrs, uiGridCtrl) {
                uiGridExporterService.initializeGrid(uiGridCtrl.grid);
                uiGridCtrl.grid.exporter.$scope = $scope;
            }
        };
    } ]);
})();

(function() {
    "use strict";
    var module = angular.module("ui.grid.grouping", [ "ui.grid", "ui.grid.treeBase" ]);
    module.constant("uiGridGroupingConstants", {
        "featureName": "grouping",
        "rowHeaderColName": "treeBaseRowHeaderCol",
        "EXPANDED": "expanded",
        "COLLAPSED": "collapsed",
        "aggregation": {
            "COUNT": "count",
            "SUM": "sum",
            "MAX": "max",
            "MIN": "min",
            "AVG": "avg"
        }
    });
    module.service("uiGridGroupingService", [ "$q", "uiGridGroupingConstants", "gridUtil", "rowSorter", "GridRow", "gridClassFactory", "i18nService", "uiGridConstants", "uiGridTreeBaseService", function($q, uiGridGroupingConstants, gridUtil, rowSorter, GridRow, gridClassFactory, i18nService, uiGridConstants, uiGridTreeBaseService) {
        var service = {
            "initializeGrid": function(grid, $scope) {
                uiGridTreeBaseService.initializeGrid(grid, $scope);
                grid.grouping = {};
                grid.grouping.groupHeaderCache = {};
                service.defaultGridOptions(grid.options);
                grid.registerRowsProcessor(service.groupRows, 400);
                grid.registerColumnBuilder(service.groupingColumnBuilder);
                grid.registerColumnsProcessor(service.groupingColumnProcessor, 400);
                var publicApi = {
                    "events": {
                        "grouping": {
                            "aggregationChanged": {},
                            "groupingChanged": {}
                        }
                    },
                    "methods": {
                        "grouping": {
                            "getGrouping": function(getExpanded) {
                                var grouping = service.getGrouping(grid);
                                grouping.grouping.forEach(function(group) {
                                    group.colName = group.col.name;
                                    delete group.col;
                                });
                                grouping.aggregations.forEach(function(aggregation) {
                                    aggregation.colName = aggregation.col.name;
                                    delete aggregation.col;
                                });
                                grouping.aggregations = grouping.aggregations.filter(function(aggregation) {
                                    return !aggregation.aggregation.source || aggregation.aggregation.source !== "grouping";
                                });
                                if (getExpanded) {
                                    grouping.rowExpandedStates = service.getRowExpandedStates(grid.grouping.groupingHeaderCache);
                                }
                                return grouping;
                            },
                            "setGrouping": function(config) {
                                service.setGrouping(grid, config);
                            },
                            "groupColumn": function(columnName) {
                                var column = grid.getColumn(columnName);
                                service.groupColumn(grid, column);
                            },
                            "ungroupColumn": function(columnName) {
                                var column = grid.getColumn(columnName);
                                service.ungroupColumn(grid, column);
                            },
                            "clearGrouping": function() {
                                service.clearGrouping(grid);
                            },
                            "aggregateColumn": function(columnName, aggregationDef, aggregationLabel) {
                                var column = grid.getColumn(columnName);
                                service.aggregateColumn(grid, column, aggregationDef, aggregationLabel);
                            }
                        }
                    }
                };
                grid.api.registerEventsFromObject(publicApi.events);
                grid.api.registerMethodsFromObject(publicApi.methods);
                grid.api.core.on.sortChanged($scope, service.tidyPriorities);
            },
            "defaultGridOptions": function(gridOptions) {
                gridOptions.enableGrouping = gridOptions.enableGrouping !== false;
                gridOptions.groupingShowCounts = gridOptions.groupingShowCounts !== false;
                gridOptions.groupingNullLabel = typeof gridOptions.groupingNullLabel === "undefined" ? "Null" : gridOptions.groupingNullLabel;
                gridOptions.enableGroupHeaderSelection = gridOptions.enableGroupHeaderSelection === true;
            },
            "groupingColumnBuilder": function(colDef, col, gridOptions) {
                if (colDef.enableGrouping === false) {
                    return;
                }
                if (typeof col.grouping === "undefined" && typeof colDef.grouping !== "undefined") {
                    col.grouping = angular.copy(colDef.grouping);
                    if (typeof col.grouping.groupPriority !== "undefined" && col.grouping.groupPriority > -1) {
                        col.treeAggregationFn = uiGridTreeBaseService.nativeAggregations()[uiGridGroupingConstants.aggregation.COUNT].aggregationFn;
                        col.treeAggregationFinalizerFn = service.groupedFinalizerFn;
                    }
                } else if (typeof col.grouping === "undefined") {
                    col.grouping = {};
                }
                if (typeof col.grouping !== "undefined" && typeof col.grouping.groupPriority !== "undefined" && col.grouping.groupPriority >= 0) {
                    col.suppressRemoveSort = true;
                }
                var groupColumn = {
                    "name": "ui.grid.grouping.group",
                    "title": i18nService.get().grouping.group,
                    "icon": "ui-grid-icon-indent-right",
                    "shown": function() {
                        return typeof this.context.col.grouping === "undefined" || typeof this.context.col.grouping.groupPriority === "undefined" || this.context.col.grouping.groupPriority < 0;
                    },
                    "action": function() {
                        service.groupColumn(this.context.col.grid, this.context.col);
                    }
                };
                var ungroupColumn = {
                    "name": "ui.grid.grouping.ungroup",
                    "title": i18nService.get().grouping.ungroup,
                    "icon": "ui-grid-icon-indent-left",
                    "shown": function() {
                        return typeof this.context.col.grouping !== "undefined" && typeof this.context.col.grouping.groupPriority !== "undefined" && this.context.col.grouping.groupPriority >= 0;
                    },
                    "action": function() {
                        service.ungroupColumn(this.context.col.grid, this.context.col);
                    }
                };
                var aggregateRemove = {
                    "name": "ui.grid.grouping.aggregateRemove",
                    "title": i18nService.get().grouping.aggregate_remove,
                    "shown": function() {
                        return typeof this.context.col.treeAggregationFn !== "undefined";
                    },
                    "action": function() {
                        service.aggregateColumn(this.context.col.grid, this.context.col, null);
                    }
                };
                var addAggregationMenu = function(type, title) {
                    title = title || i18nService.get().grouping["aggregate_" + type] || type;
                    var menuItem = {
                        "name": "ui.grid.grouping.aggregate" + type,
                        "title": title,
                        "shown": function() {
                            return typeof this.context.col.treeAggregation === "undefined" || typeof this.context.col.treeAggregation.type === "undefined" || this.context.col.treeAggregation.type !== type;
                        },
                        "action": function() {
                            service.aggregateColumn(this.context.col.grid, this.context.col, type);
                        }
                    };
                    if (!gridUtil.arrayContainsObjectWithProperty(col.menuItems, "name", "ui.grid.grouping.aggregate" + type)) {
                        col.menuItems.push(menuItem);
                    }
                };
                if (col.colDef.groupingShowGroupingMenu !== false) {
                    if (!gridUtil.arrayContainsObjectWithProperty(col.menuItems, "name", "ui.grid.grouping.group")) {
                        col.menuItems.push(groupColumn);
                    }
                    if (!gridUtil.arrayContainsObjectWithProperty(col.menuItems, "name", "ui.grid.grouping.ungroup")) {
                        col.menuItems.push(ungroupColumn);
                    }
                }
                if (col.colDef.groupingShowAggregationMenu !== false) {
                    angular.forEach(uiGridTreeBaseService.nativeAggregations(), function(aggregationDef, name) {
                        addAggregationMenu(name);
                    });
                    angular.forEach(gridOptions.treeCustomAggregations, function(aggregationDef, name) {
                        addAggregationMenu(name, aggregationDef.menuTitle);
                    });
                    if (!gridUtil.arrayContainsObjectWithProperty(col.menuItems, "name", "ui.grid.grouping.aggregateRemove")) {
                        col.menuItems.push(aggregateRemove);
                    }
                }
            },
            "groupingColumnProcessor": function(columns, rows) {
                var grid = this;
                columns = service.moveGroupColumns(this, columns, rows);
                return columns;
            },
            "groupedFinalizerFn": function(aggregation) {
                var col = this;
                if (typeof aggregation.groupVal !== "undefined") {
                    aggregation.rendered = aggregation.groupVal;
                    if (col.grid.options.groupingShowCounts && col.colDef.type !== "date") {
                        aggregation.rendered += " (" + aggregation.value + ")";
                    }
                } else {
                    aggregation.rendered = null;
                }
            },
            "moveGroupColumns": function(grid, columns, rows) {
                if (grid.options.moveGroupColumns === false) {
                    return columns;
                }
                columns.forEach(function(column, index) {
                    column.groupingPosition = index;
                });
                columns.sort(function(a, b) {
                    var a_group, b_group;
                    if (a.isRowHeader) {
                        a_group = -1e3;
                    } else if (typeof a.grouping === "undefined" || typeof a.grouping.groupPriority === "undefined" || a.grouping.groupPriority < 0) {
                        a_group = null;
                    } else {
                        a_group = a.grouping.groupPriority;
                    }
                    if (b.isRowHeader) {
                        b_group = -1e3;
                    } else if (typeof b.grouping === "undefined" || typeof b.grouping.groupPriority === "undefined" || b.grouping.groupPriority < 0) {
                        b_group = null;
                    } else {
                        b_group = b.grouping.groupPriority;
                    }
                    if (a_group !== null && b_group === null) {
                        return -1;
                    }
                    if (b_group !== null && a_group === null) {
                        return 1;
                    }
                    if (a_group !== null && b_group !== null) {
                        return a_group - b_group;
                    }
                    return a.groupingPosition - b.groupingPosition;
                });
                columns.forEach(function(column, index) {
                    delete column.groupingPosition;
                });
                return columns;
            },
            "groupColumn": function(grid, column) {
                if (typeof column.grouping === "undefined") {
                    column.grouping = {};
                }
                var existingGrouping = service.getGrouping(grid);
                column.grouping.groupPriority = existingGrouping.grouping.length;
                if (!column.sort) {
                    column.sort = {
                        "direction": uiGridConstants.ASC
                    };
                } else if (typeof column.sort.direction === "undefined" || column.sort.direction === null) {
                    column.sort.direction = uiGridConstants.ASC;
                }
                column.treeAggregation = {
                    "type": uiGridGroupingConstants.aggregation.COUNT,
                    "source": "grouping"
                };
                column.treeAggregationFn = uiGridTreeBaseService.nativeAggregations()[uiGridGroupingConstants.aggregation.COUNT].aggregationFn;
                column.treeAggregationFinalizerFn = service.groupedFinalizerFn;
                grid.api.grouping.raise.groupingChanged(column);
                grid.api.core.raise.sortChanged(grid, grid.getColumnSorting());
                grid.queueGridRefresh();
            },
            "ungroupColumn": function(grid, column) {
                if (typeof column.grouping === "undefined") {
                    return;
                }
                delete column.grouping.groupPriority;
                delete column.treeAggregation;
                delete column.customTreeAggregationFinalizer;
                service.tidyPriorities(grid);
                grid.api.grouping.raise.groupingChanged(column);
                grid.queueGridRefresh();
            },
            "aggregateColumn": function(grid, column, aggregationType) {
                if (typeof column.grouping !== "undefined" && typeof column.grouping.groupPriority !== "undefined" && column.grouping.groupPriority >= 0) {
                    service.ungroupColumn(grid, column);
                }
                var aggregationDef = {};
                if (typeof grid.options.treeCustomAggregations[aggregationType] !== "undefined") {
                    aggregationDef = grid.options.treeCustomAggregations[aggregationType];
                } else if (typeof uiGridTreeBaseService.nativeAggregations()[aggregationType] !== "undefined") {
                    aggregationDef = uiGridTreeBaseService.nativeAggregations()[aggregationType];
                }
                column.treeAggregation = {
                    "type": aggregationType,
                    "label": i18nService.get().aggregation[aggregationDef.label] || aggregationDef.label
                };
                column.treeAggregationFn = aggregationDef.aggregationFn;
                column.treeAggregationFinalizerFn = aggregationDef.finalizerFn;
                grid.api.grouping.raise.aggregationChanged(column);
                grid.queueGridRefresh();
            },
            "setGrouping": function(grid, config) {
                if (typeof config === "undefined") {
                    return;
                }
                service.clearGrouping(grid);
                if (config.grouping && config.grouping.length && config.grouping.length > 0) {
                    config.grouping.forEach(function(group) {
                        var col = grid.getColumn(group.colName);
                        if (col) {
                            service.groupColumn(grid, col);
                        }
                    });
                }
                if (config.aggregations && config.aggregations.length) {
                    config.aggregations.forEach(function(aggregation) {
                        var col = grid.getColumn(aggregation.colName);
                        if (col) {
                            service.aggregateColumn(grid, col, aggregation.aggregation.type);
                        }
                    });
                }
                if (config.rowExpandedStates) {
                    service.applyRowExpandedStates(grid.grouping.groupingHeaderCache, config.rowExpandedStates);
                }
            },
            "clearGrouping": function(grid) {
                var currentGrouping = service.getGrouping(grid);
                if (currentGrouping.grouping.length > 0) {
                    currentGrouping.grouping.forEach(function(group) {
                        if (!group.col) {
                            group.col = grid.getColumn(group.colName);
                        }
                        service.ungroupColumn(grid, group.col);
                    });
                }
                if (currentGrouping.aggregations.length > 0) {
                    currentGrouping.aggregations.forEach(function(aggregation) {
                        if (!aggregation.col) {
                            aggregation.col = grid.getColumn(aggregation.colName);
                        }
                        service.aggregateColumn(grid, aggregation.col, null);
                    });
                }
            },
            "tidyPriorities": function(grid) {
                if ((typeof grid === "undefined" || typeof grid.grid !== "undefined") && typeof this.grid !== "undefined") {
                    grid = this.grid;
                }
                var groupArray = [];
                var sortArray = [];
                grid.columns.forEach(function(column, index) {
                    if (typeof column.grouping !== "undefined" && typeof column.grouping.groupPriority !== "undefined" && column.grouping.groupPriority >= 0) {
                        groupArray.push(column);
                    } else if (typeof column.sort !== "undefined" && typeof column.sort.priority !== "undefined" && column.sort.priority >= 0) {
                        sortArray.push(column);
                    }
                });
                groupArray.sort(function(a, b) {
                    return a.grouping.groupPriority - b.grouping.groupPriority;
                });
                groupArray.forEach(function(column, index) {
                    column.grouping.groupPriority = index;
                    column.suppressRemoveSort = true;
                    if (typeof column.sort === "undefined") {
                        column.sort = {};
                    }
                    column.sort.priority = index;
                });
                var i = groupArray.length;
                sortArray.sort(function(a, b) {
                    return a.sort.priority - b.sort.priority;
                });
                sortArray.forEach(function(column, index) {
                    column.sort.priority = i;
                    column.suppressRemoveSort = column.colDef.suppressRemoveSort;
                    i++;
                });
            },
            "groupRows": function(renderableRows) {
                if (renderableRows.length === 0) {
                    return renderableRows;
                }
                var grid = this;
                grid.grouping.oldGroupingHeaderCache = grid.grouping.groupingHeaderCache || {};
                grid.grouping.groupingHeaderCache = {};
                var processingState = service.initialiseProcessingState(grid);
                var updateProcessingState = function(groupFieldState, stateIndex) {
                    var fieldValue = grid.getCellValue(row, groupFieldState.col);
                    if (!groupFieldState.initialised || rowSorter.getSortFn(grid, groupFieldState.col, renderableRows)(fieldValue, groupFieldState.currentValue) !== 0) {
                        service.insertGroupHeader(grid, renderableRows, i, processingState, stateIndex);
                        i++;
                    }
                };
                for (var i = 0; i < renderableRows.length; i++) {
                    var row = renderableRows[i];
                    if (row.visible) {
                        processingState.forEach(updateProcessingState);
                    }
                }
                delete grid.grouping.oldGroupingHeaderCache;
                return renderableRows;
            },
            "initialiseProcessingState": function(grid) {
                var processingState = [];
                var columnSettings = service.getGrouping(grid);
                columnSettings.grouping.forEach(function(groupItem, index) {
                    processingState.push({
                        "fieldName": groupItem.field,
                        "col": groupItem.col,
                        "initialised": false,
                        "currentValue": null,
                        "currentRow": null
                    });
                });
                return processingState;
            },
            "getGrouping": function(grid) {
                var groupArray = [];
                var aggregateArray = [];
                grid.columns.forEach(function(column, columnIndex) {
                    if (column.grouping) {
                        if (typeof column.grouping.groupPriority !== "undefined" && column.grouping.groupPriority >= 0) {
                            groupArray.push({
                                "field": column.field,
                                "col": column,
                                "groupPriority": column.grouping.groupPriority,
                                "grouping": column.grouping
                            });
                        }
                    }
                    if (column.treeAggregation && column.treeAggregation.type) {
                        aggregateArray.push({
                            "field": column.field,
                            "col": column,
                            "aggregation": column.treeAggregation
                        });
                    }
                });
                groupArray.sort(function(a, b) {
                    return a.groupPriority - b.groupPriority;
                });
                groupArray.forEach(function(group, index) {
                    group.grouping.groupPriority = index;
                    group.groupPriority = index;
                    delete group.grouping;
                });
                return {
                    "grouping": groupArray,
                    "aggregations": aggregateArray
                };
            },
            "insertGroupHeader": function(grid, renderableRows, rowIndex, processingState, stateIndex) {
                var fieldName = processingState[stateIndex].fieldName;
                var col = processingState[stateIndex].col;
                var newValue = grid.getCellValue(renderableRows[rowIndex], col);
                var newDisplayValue = newValue;
                if (typeof newValue === "undefined" || newValue === null) {
                    newDisplayValue = grid.options.groupingNullLabel;
                }
                var getKeyAsValueForCacheMap = function(key) {
                    if (angular.isObject(key)) {
                        return JSON.stringify(key);
                    } else {
                        return key;
                    }
                };
                var cacheItem = grid.grouping.oldGroupingHeaderCache;
                for (var i = 0; i < stateIndex; i++) {
                    if (cacheItem && cacheItem[getKeyAsValueForCacheMap(processingState[i].currentValue)]) {
                        cacheItem = cacheItem[getKeyAsValueForCacheMap(processingState[i].currentValue)].children;
                    }
                }
                var headerRow;
                if (cacheItem && cacheItem[getKeyAsValueForCacheMap(newValue)]) {
                    headerRow = cacheItem[getKeyAsValueForCacheMap(newValue)].row;
                    headerRow.entity = {};
                } else {
                    headerRow = new GridRow({}, null, grid);
                    gridClassFactory.rowTemplateAssigner.call(grid, headerRow);
                }
                headerRow.entity["$$" + processingState[stateIndex].col.uid] = {
                    "groupVal": newDisplayValue
                };
                headerRow.treeLevel = stateIndex;
                headerRow.groupHeader = true;
                headerRow.internalRow = true;
                headerRow.enableCellEdit = false;
                headerRow.enableSelection = grid.options.enableGroupHeaderSelection;
                processingState[stateIndex].initialised = true;
                processingState[stateIndex].currentValue = newValue;
                processingState[stateIndex].currentRow = headerRow;
                service.finaliseProcessingState(processingState, stateIndex + 1);
                renderableRows.splice(rowIndex, 0, headerRow);
                cacheItem = grid.grouping.groupingHeaderCache;
                for (i = 0; i < stateIndex; i++) {
                    cacheItem = cacheItem[getKeyAsValueForCacheMap(processingState[i].currentValue)].children;
                }
                cacheItem[getKeyAsValueForCacheMap(newValue)] = {
                    "row": headerRow,
                    "children": {}
                };
            },
            "finaliseProcessingState": function(processingState, stateIndex) {
                for (var i = stateIndex; i < processingState.length; i++) {
                    processingState[i].initialised = false;
                    processingState[i].currentRow = null;
                    processingState[i].currentValue = null;
                }
            },
            "getRowExpandedStates": function(treeChildren) {
                if (typeof treeChildren === "undefined") {
                    return {};
                }
                var newChildren = {};
                angular.forEach(treeChildren, function(value, key) {
                    newChildren[key] = {
                        "state": value.row.treeNode.state
                    };
                    if (value.children) {
                        newChildren[key].children = service.getRowExpandedStates(value.children);
                    } else {
                        newChildren[key].children = {};
                    }
                });
                return newChildren;
            },
            "applyRowExpandedStates": function(currentNode, expandedStates) {
                if (typeof expandedStates === "undefined") {
                    return;
                }
                angular.forEach(expandedStates, function(value, key) {
                    if (currentNode[key]) {
                        currentNode[key].row.treeNode.state = value.state;
                        if (value.children && currentNode[key].children) {
                            service.applyRowExpandedStates(currentNode[key].children, value.children);
                        }
                    }
                });
            }
        };
        return service;
    } ]);
    module.directive("uiGridGrouping", [ "uiGridGroupingConstants", "uiGridGroupingService", "$templateCache", function(uiGridGroupingConstants, uiGridGroupingService, $templateCache) {
        return {
            "replace": true,
            "priority": 0,
            "require": "^uiGrid",
            "scope": false,
            "compile": function() {
                return {
                    "pre": function($scope, $elm, $attrs, uiGridCtrl) {
                        if (uiGridCtrl.grid.options.enableGrouping !== false) {
                            uiGridGroupingService.initializeGrid(uiGridCtrl.grid, $scope);
                        }
                    },
                    "post": function($scope, $elm, $attrs, uiGridCtrl) {}
                };
            }
        };
    } ]);
})();

(function() {
    "use strict";
    var module = angular.module("ui.grid.importer", [ "ui.grid" ]);
    module.constant("uiGridImporterConstants", {
        "featureName": "importer"
    });
    module.service("uiGridImporterService", [ "$q", "uiGridConstants", "uiGridImporterConstants", "gridUtil", "$compile", "$interval", "i18nService", "$window", function($q, uiGridConstants, uiGridImporterConstants, gridUtil, $compile, $interval, i18nService, $window) {
        var service = {
            "initializeGrid": function($scope, grid) {
                grid.importer = {
                    "$scope": $scope
                };
                this.defaultGridOptions(grid.options);
                var publicApi = {
                    "events": {
                        "importer": {}
                    },
                    "methods": {
                        "importer": {
                            "importFile": function(fileObject) {
                                service.importThisFile(grid, fileObject);
                            }
                        }
                    }
                };
                grid.api.registerEventsFromObject(publicApi.events);
                grid.api.registerMethodsFromObject(publicApi.methods);
                if (grid.options.enableImporter && grid.options.importerShowMenu) {
                    if (grid.api.core.addToGridMenu) {
                        service.addToMenu(grid);
                    } else {
                        $interval(function() {
                            if (grid.api.core.addToGridMenu) {
                                service.addToMenu(grid);
                            }
                        }, 100, 1);
                    }
                }
            },
            "defaultGridOptions": function(gridOptions) {
                if (gridOptions.enableImporter || gridOptions.enableImporter === undefined) {
                    if (!($window.hasOwnProperty("File") && $window.hasOwnProperty("FileReader") && $window.hasOwnProperty("FileList") && $window.hasOwnProperty("Blob"))) {
                        gridUtil.logError("The File APIs are not fully supported in this browser, grid importer cannot be used.");
                        gridOptions.enableImporter = false;
                    } else {
                        gridOptions.enableImporter = true;
                    }
                } else {
                    gridOptions.enableImporter = false;
                }
                gridOptions.importerProcessHeaders = gridOptions.importerProcessHeaders || service.processHeaders;
                gridOptions.importerHeaderFilter = gridOptions.importerHeaderFilter || function(displayName) {
                    return displayName;
                };
                if (!gridOptions.importerErrorCallback || typeof gridOptions.importerErrorCallback !== "function") {
                    delete gridOptions.importerErrorCallback;
                }
                if (gridOptions.enableImporter === true && !gridOptions.importerDataAddCallback) {
                    gridUtil.logError("You have not set an importerDataAddCallback, importer is disabled");
                    gridOptions.enableImporter = false;
                }
                gridOptions.importerShowMenu = gridOptions.importerShowMenu !== false;
                gridOptions.importerObjectCallback = gridOptions.importerObjectCallback || function(grid, newObject) {
                    return newObject;
                };
            },
            "addToMenu": function(grid) {
                grid.api.core.addToGridMenu(grid, [ {
                    "title": i18nService.getSafeText("gridMenu.importerTitle"),
                    "order": 150
                }, {
                    "templateUrl": "ui-grid/importerMenuItemContainer",
                    "action": function($event) {
                        this.grid.api.importer.importAFile(grid);
                    },
                    "order": 151
                } ]);
            },
            "importThisFile": function(grid, fileObject) {
                if (!fileObject) {
                    gridUtil.logError("No file object provided to importThisFile, should be impossible, aborting");
                    return;
                }
                var reader = new FileReader();
                switch (fileObject.type) {
                  case "application/json":
                    reader.onload = service.importJsonClosure(grid);
                    break;

                  default:
                    reader.onload = service.importCsvClosure(grid);
                    break;
                }
                reader.readAsText(fileObject);
            },
            "importJsonClosure": function(grid) {
                return function(importFile) {
                    var newObjects = [];
                    var newObject;
                    var importArray = service.parseJson(grid, importFile);
                    if (importArray === null) {
                        return;
                    }
                    importArray.forEach(function(value, index) {
                        newObject = service.newObject(grid);
                        angular.extend(newObject, value);
                        newObject = grid.options.importerObjectCallback(grid, newObject);
                        newObjects.push(newObject);
                    });
                    service.addObjects(grid, newObjects);
                };
            },
            "parseJson": function(grid, importFile) {
                var loadedObjects;
                try {
                    loadedObjects = JSON.parse(importFile.target.result);
                } catch (e) {
                    service.alertError(grid, "importer.invalidJson", "File could not be processed, is it valid json? Content was: ", importFile.target.result);
                    return;
                }
                if (!Array.isArray(loadedObjects)) {
                    service.alertError(grid, "importer.jsonNotarray", "Import failed, file is not an array, file was: ", importFile.target.result);
                    return [];
                } else {
                    return loadedObjects;
                }
            },
            "importCsvClosure": function(grid) {
                return function(importFile) {
                    var importArray = service.parseCsv(importFile);
                    if (!importArray || importArray.length < 1) {
                        service.alertError(grid, "importer.invalidCsv", "File could not be processed, is it valid csv? Content was: ", importFile.target.result);
                        return;
                    }
                    var newObjects = service.createCsvObjects(grid, importArray);
                    if (!newObjects || newObjects.length === 0) {
                        service.alertError(grid, "importer.noObjects", "Objects were not able to be derived, content was: ", importFile.target.result);
                        return;
                    }
                    service.addObjects(grid, newObjects);
                };
            },
            "parseCsv": function(importFile) {
                var csv = importFile.target.result;
                return CSV.parse(csv);
            },
            "createCsvObjects": function(grid, importArray) {
                var headerMapping = grid.options.importerProcessHeaders(grid, importArray.shift());
                if (!headerMapping || headerMapping.length === 0) {
                    service.alertError(grid, "importer.noHeaders", "Column names could not be derived, content was: ", importArray);
                    return [];
                }
                var newObjects = [];
                var newObject;
                importArray.forEach(function(row, index) {
                    newObject = service.newObject(grid);
                    if (row !== null) {
                        row.forEach(function(field, index) {
                            if (headerMapping[index] !== null) {
                                newObject[headerMapping[index]] = field;
                            }
                        });
                    }
                    newObject = grid.options.importerObjectCallback(grid, newObject);
                    newObjects.push(newObject);
                });
                return newObjects;
            },
            "processHeaders": function(grid, headerRow) {
                var headers = [];
                if (!grid.options.columnDefs || grid.options.columnDefs.length === 0) {
                    headerRow.forEach(function(value, index) {
                        headers.push(value.replace(/[^0-9a-zA-Z\-_]/g, "_"));
                    });
                    return headers;
                } else {
                    var lookupHash = service.flattenColumnDefs(grid, grid.options.columnDefs);
                    headerRow.forEach(function(value, index) {
                        if (lookupHash[value]) {
                            headers.push(lookupHash[value]);
                        } else if (lookupHash[value.toLowerCase()]) {
                            headers.push(lookupHash[value.toLowerCase()]);
                        } else {
                            headers.push(null);
                        }
                    });
                    return headers;
                }
            },
            "flattenColumnDefs": function(grid, columnDefs) {
                var flattenedHash = {};
                columnDefs.forEach(function(columnDef, index) {
                    if (columnDef.name) {
                        flattenedHash[columnDef.name] = columnDef.field || columnDef.name;
                        flattenedHash[columnDef.name.toLowerCase()] = columnDef.field || columnDef.name;
                    }
                    if (columnDef.field) {
                        flattenedHash[columnDef.field] = columnDef.field || columnDef.name;
                        flattenedHash[columnDef.field.toLowerCase()] = columnDef.field || columnDef.name;
                    }
                    if (columnDef.displayName) {
                        flattenedHash[columnDef.displayName] = columnDef.field || columnDef.name;
                        flattenedHash[columnDef.displayName.toLowerCase()] = columnDef.field || columnDef.name;
                    }
                    if (columnDef.displayName && grid.options.importerHeaderFilter) {
                        flattenedHash[grid.options.importerHeaderFilter(columnDef.displayName)] = columnDef.field || columnDef.name;
                        flattenedHash[grid.options.importerHeaderFilter(columnDef.displayName).toLowerCase()] = columnDef.field || columnDef.name;
                    }
                });
                return flattenedHash;
            },
            "addObjects": function(grid, newObjects, $scope) {
                if (grid.api.rowEdit) {
                    var dataChangeDereg = grid.registerDataChangeCallback(function() {
                        grid.api.rowEdit.setRowsDirty(newObjects);
                        dataChangeDereg();
                    }, [ uiGridConstants.dataChange.ROW ]);
                    grid.importer.$scope.$on("$destroy", dataChangeDereg);
                }
                grid.importer.$scope.$apply(grid.options.importerDataAddCallback(grid, newObjects));
            },
            "newObject": function(grid) {
                if (typeof grid.options !== "undefined" && typeof grid.options.importerNewObject !== "undefined") {
                    return new grid.options.importerNewObject();
                } else {
                    return {};
                }
            },
            "alertError": function(grid, alertI18nToken, consoleMessage, context) {
                if (grid.options.importerErrorCallback) {
                    grid.options.importerErrorCallback(grid, alertI18nToken, consoleMessage, context);
                } else {
                    $window.alert(i18nService.getSafeText(alertI18nToken));
                    gridUtil.logError(consoleMessage + context);
                }
            }
        };
        return service;
    } ]);
    module.directive("uiGridImporter", [ "uiGridImporterConstants", "uiGridImporterService", "gridUtil", "$compile", function(uiGridImporterConstants, uiGridImporterService, gridUtil, $compile) {
        return {
            "replace": true,
            "priority": 0,
            "require": "^uiGrid",
            "scope": false,
            "link": function($scope, $elm, $attrs, uiGridCtrl) {
                uiGridImporterService.initializeGrid($scope, uiGridCtrl.grid);
            }
        };
    } ]);
    module.directive("uiGridImporterMenuItem", [ "uiGridImporterConstants", "uiGridImporterService", "gridUtil", "$compile", function(uiGridImporterConstants, uiGridImporterService, gridUtil, $compile) {
        return {
            "replace": true,
            "priority": 0,
            "require": "^uiGrid",
            "scope": false,
            "templateUrl": "ui-grid/importerMenuItem",
            "link": function($scope, $elm, $attrs, uiGridCtrl) {
                var handleFileSelect = function(event) {
                    var target = event.srcElement || event.target;
                    if (target && target.files && target.files.length === 1) {
                        var fileObject = target.files[0];
                        uiGridImporterService.importThisFile(grid, fileObject);
                        target.form.reset();
                    }
                };
                var fileChooser = $elm[0].querySelectorAll(".ui-grid-importer-file-chooser");
                var grid = uiGridCtrl.grid;
                if (fileChooser.length !== 1) {
                    gridUtil.logError("Found > 1 or < 1 file choosers within the menu item, error, cannot continue");
                } else {
                    fileChooser[0].addEventListener("change", handleFileSelect, false);
                }
            }
        };
    } ]);
})();

(function() {
    "use strict";
    var module = angular.module("ui.grid.infiniteScroll", [ "ui.grid" ]);
    module.service("uiGridInfiniteScrollService", [ "gridUtil", "$compile", "$timeout", "uiGridConstants", "ScrollEvent", "$q", function(gridUtil, $compile, $timeout, uiGridConstants, ScrollEvent, $q) {
        var service = {
            "initializeGrid": function(grid, $scope) {
                service.defaultGridOptions(grid.options);
                if (!grid.options.enableInfiniteScroll) {
                    return;
                }
                grid.infiniteScroll = {
                    "dataLoading": false
                };
                service.setScrollDirections(grid, grid.options.infiniteScrollUp, grid.options.infiniteScrollDown);
                grid.api.core.on.scrollEnd($scope, service.handleScroll);
                var publicApi = {
                    "events": {
                        "infiniteScroll": {
                            "needLoadMoreData": function($scope, fn) {},
                            "needLoadMoreDataTop": function($scope, fn) {}
                        }
                    },
                    "methods": {
                        "infiniteScroll": {
                            "dataLoaded": function(scrollUp, scrollDown) {
                                service.setScrollDirections(grid, scrollUp, scrollDown);
                                var promise = service.adjustScroll(grid).then(function() {
                                    grid.infiniteScroll.dataLoading = false;
                                });
                                return promise;
                            },
                            "resetScroll": function(scrollUp, scrollDown) {
                                service.setScrollDirections(grid, scrollUp, scrollDown);
                                return service.adjustInfiniteScrollPosition(grid, 0);
                            },
                            "saveScrollPercentage": function() {
                                grid.infiniteScroll.prevScrollTop = grid.renderContainers.body.prevScrollTop;
                                grid.infiniteScroll.previousVisibleRows = grid.getVisibleRowCount();
                            },
                            "dataRemovedTop": function(scrollUp, scrollDown) {
                                service.dataRemovedTop(grid, scrollUp, scrollDown);
                            },
                            "dataRemovedBottom": function(scrollUp, scrollDown) {
                                service.dataRemovedBottom(grid, scrollUp, scrollDown);
                            },
                            "setScrollDirections": function(scrollUp, scrollDown) {
                                service.setScrollDirections(grid, scrollUp, scrollDown);
                            }
                        }
                    }
                };
                grid.api.registerEventsFromObject(publicApi.events);
                grid.api.registerMethodsFromObject(publicApi.methods);
            },
            "defaultGridOptions": function(gridOptions) {
                gridOptions.enableInfiniteScroll = gridOptions.enableInfiniteScroll !== false;
                gridOptions.infiniteScrollRowsFromEnd = gridOptions.infiniteScrollRowsFromEnd || 20;
                gridOptions.infiniteScrollUp = gridOptions.infiniteScrollUp === true;
                gridOptions.infiniteScrollDown = gridOptions.infiniteScrollDown !== false;
            },
            "setScrollDirections": function(grid, scrollUp, scrollDown) {
                grid.infiniteScroll.scrollUp = scrollUp === true;
                grid.suppressParentScrollUp = scrollUp === true;
                grid.infiniteScroll.scrollDown = scrollDown !== false;
                grid.suppressParentScrollDown = scrollDown !== false;
            },
            "handleScroll": function(args) {
                if (args.grid.infiniteScroll && args.grid.infiniteScroll.dataLoading || args.source === "ui.grid.adjustInfiniteScrollPosition") {
                    return;
                }
                if (args.y) {
                    var percentage;
                    var targetPercentage = args.grid.options.infiniteScrollRowsFromEnd / args.grid.renderContainers.body.visibleRowCache.length;
                    if (args.grid.scrollDirection === uiGridConstants.scrollDirection.UP) {
                        percentage = args.y.percentage;
                        if (percentage <= targetPercentage) {
                            service.loadData(args.grid);
                        }
                    } else if (args.grid.scrollDirection === uiGridConstants.scrollDirection.DOWN) {
                        percentage = 1 - args.y.percentage;
                        if (percentage <= targetPercentage) {
                            service.loadData(args.grid);
                        }
                    }
                }
            },
            "loadData": function(grid) {
                grid.infiniteScroll.previousVisibleRows = grid.renderContainers.body.visibleRowCache.length;
                grid.infiniteScroll.direction = grid.scrollDirection;
                delete grid.infiniteScroll.prevScrollTop;
                if (grid.scrollDirection === uiGridConstants.scrollDirection.UP && grid.infiniteScroll.scrollUp) {
                    grid.infiniteScroll.dataLoading = true;
                    grid.api.infiniteScroll.raise.needLoadMoreDataTop();
                } else if (grid.scrollDirection === uiGridConstants.scrollDirection.DOWN && grid.infiniteScroll.scrollDown) {
                    grid.infiniteScroll.dataLoading = true;
                    grid.api.infiniteScroll.raise.needLoadMoreData();
                }
            },
            "adjustScroll": function(grid) {
                var promise = $q.defer();
                $timeout(function() {
                    var newPercentage, viewportHeight, rowHeight, newVisibleRows, oldTop, newTop;
                    viewportHeight = grid.getViewportHeight() + grid.headerHeight - grid.renderContainers.body.headerHeight - grid.scrollbarHeight;
                    rowHeight = grid.options.rowHeight;
                    if (grid.infiniteScroll.direction === undefined) {
                        service.adjustInfiniteScrollPosition(grid, 0);
                    }
                    newVisibleRows = grid.getVisibleRowCount();
                    var canvasHeight = rowHeight * newVisibleRows;
                    if (grid.infiniteScroll.scrollDown && viewportHeight > canvasHeight) {
                        grid.api.infiniteScroll.raise.needLoadMoreData();
                    }
                    if (grid.infiniteScroll.direction === uiGridConstants.scrollDirection.UP) {
                        oldTop = grid.infiniteScroll.prevScrollTop || 0;
                        newTop = oldTop + (newVisibleRows - grid.infiniteScroll.previousVisibleRows) * rowHeight;
                        service.adjustInfiniteScrollPosition(grid, newTop);
                        $timeout(function() {
                            promise.resolve();
                        });
                    }
                    if (grid.infiniteScroll.direction === uiGridConstants.scrollDirection.DOWN) {
                        newTop = grid.infiniteScroll.prevScrollTop || grid.infiniteScroll.previousVisibleRows * rowHeight - viewportHeight;
                        service.adjustInfiniteScrollPosition(grid, newTop);
                        $timeout(function() {
                            promise.resolve();
                        });
                    }
                }, 0);
                return promise.promise;
            },
            "adjustInfiniteScrollPosition": function(grid, scrollTop) {
                var scrollEvent = new ScrollEvent(grid, null, null, "ui.grid.adjustInfiniteScrollPosition"), visibleRows = grid.getVisibleRowCount(), viewportHeight = grid.getViewportHeight() + grid.headerHeight - grid.renderContainers.body.headerHeight - grid.scrollbarHeight, rowHeight = grid.options.rowHeight, scrollHeight = visibleRows * rowHeight - viewportHeight;
                if (scrollTop === 0 && grid.infiniteScroll.scrollUp) {
                    scrollEvent.y = {
                        "percentage": 1 / scrollHeight
                    };
                } else {
                    scrollEvent.y = {
                        "percentage": scrollTop / scrollHeight
                    };
                }
                grid.scrollContainers("", scrollEvent);
            },
            "dataRemovedTop": function(grid, scrollUp, scrollDown) {
                var newVisibleRows, oldTop, newTop, rowHeight;
                service.setScrollDirections(grid, scrollUp, scrollDown);
                newVisibleRows = grid.renderContainers.body.visibleRowCache.length;
                oldTop = grid.infiniteScroll.prevScrollTop;
                rowHeight = grid.options.rowHeight;
                newTop = oldTop - (grid.infiniteScroll.previousVisibleRows - newVisibleRows) * rowHeight;
                return service.adjustInfiniteScrollPosition(grid, newTop);
            },
            "dataRemovedBottom": function(grid, scrollUp, scrollDown) {
                var newTop;
                service.setScrollDirections(grid, scrollUp, scrollDown);
                newTop = grid.infiniteScroll.prevScrollTop;
                return service.adjustInfiniteScrollPosition(grid, newTop);
            }
        };
        return service;
    } ]);
    module.directive("uiGridInfiniteScroll", [ "uiGridInfiniteScrollService", function(uiGridInfiniteScrollService) {
        return {
            "priority": -200,
            "scope": false,
            "require": "^uiGrid",
            "compile": function($scope, $elm, $attr) {
                return {
                    "pre": function($scope, $elm, $attr, uiGridCtrl) {
                        uiGridInfiniteScrollService.initializeGrid(uiGridCtrl.grid, $scope);
                    },
                    "post": function($scope, $elm, $attr) {}
                };
            }
        };
    } ]);
})();

(function() {
    "use strict";
    var module = angular.module("ui.grid.moveColumns", [ "ui.grid" ]);
    module.service("uiGridMoveColumnService", [ "$q", "$timeout", "$log", "ScrollEvent", "uiGridConstants", "gridUtil", function($q, $timeout, $log, ScrollEvent, uiGridConstants, gridUtil) {
        var service = {
            "initializeGrid": function(grid) {
                var self = this;
                this.registerPublicApi(grid);
                this.defaultGridOptions(grid.options);
                grid.moveColumns = {
                    "orderCache": []
                };
                grid.registerColumnBuilder(self.movableColumnBuilder);
                grid.registerDataChangeCallback(self.verifyColumnOrder, [ uiGridConstants.dataChange.COLUMN ]);
            },
            "registerPublicApi": function(grid) {
                var self = this;
                var publicApi = {
                    "events": {
                        "colMovable": {
                            "columnPositionChanged": function(colDef, originalPosition, newPosition) {}
                        }
                    },
                    "methods": {
                        "colMovable": {
                            "moveColumn": function(originalPosition, finalPosition) {
                                var columns = grid.columns;
                                if (!angular.isNumber(originalPosition) || !angular.isNumber(finalPosition)) {
                                    gridUtil.logError("MoveColumn: Please provide valid values for originalPosition and finalPosition");
                                    return;
                                }
                                var nonMovableColumns = 0;
                                for (var i = 0; i < columns.length; i++) {
                                    if (angular.isDefined(columns[i].colDef.visible) && columns[i].colDef.visible === false || columns[i].isRowHeader === true) {
                                        nonMovableColumns++;
                                    }
                                }
                                if (originalPosition >= columns.length - nonMovableColumns || finalPosition >= columns.length - nonMovableColumns) {
                                    gridUtil.logError("MoveColumn: Invalid values for originalPosition, finalPosition");
                                    return;
                                }
                                var findPositionForRenderIndex = function(index) {
                                    var position = index;
                                    for (var i = 0; i <= position; i++) {
                                        if (angular.isDefined(columns[i]) && (angular.isDefined(columns[i].colDef.visible) && columns[i].colDef.visible === false || columns[i].isRowHeader === true)) {
                                            position++;
                                        }
                                    }
                                    return position;
                                };
                                self.redrawColumnAtPosition(grid, findPositionForRenderIndex(originalPosition), findPositionForRenderIndex(finalPosition));
                            }
                        }
                    }
                };
                grid.api.registerEventsFromObject(publicApi.events);
                grid.api.registerMethodsFromObject(publicApi.methods);
            },
            "defaultGridOptions": function(gridOptions) {
                gridOptions.enableColumnMoving = gridOptions.enableColumnMoving !== false;
            },
            "movableColumnBuilder": function(colDef, col, gridOptions) {
                var promises = [];
                colDef.enableColumnMoving = colDef.enableColumnMoving === undefined ? gridOptions.enableColumnMoving : colDef.enableColumnMoving;
                return $q.all(promises);
            },
            "updateColumnCache": function(grid) {
                grid.moveColumns.orderCache = grid.getOnlyDataColumns();
            },
            "verifyColumnOrder": function(grid) {
                var headerRowOffset = grid.rowHeaderColumns.length;
                var newIndex;
                angular.forEach(grid.moveColumns.orderCache, function(cacheCol, cacheIndex) {
                    newIndex = grid.columns.indexOf(cacheCol);
                    if (newIndex !== -1 && newIndex - headerRowOffset !== cacheIndex) {
                        var column = grid.columns.splice(newIndex, 1)[0];
                        grid.columns.splice(cacheIndex + headerRowOffset, 0, column);
                    }
                });
            },
            "redrawColumnAtPosition": function(grid, originalPosition, newPosition) {
                if (originalPosition === newPosition) {
                    return;
                }
                var columns = grid.columns;
                var originalColumn = columns[originalPosition];
                if (originalColumn.colDef.enableColumnMoving) {
                    if (originalPosition > newPosition) {
                        for (var i1 = originalPosition; i1 > newPosition; i1--) {
                            columns[i1] = columns[i1 - 1];
                        }
                    } else if (newPosition > originalPosition) {
                        for (var i2 = originalPosition; i2 < newPosition; i2++) {
                            columns[i2] = columns[i2 + 1];
                        }
                    }
                    columns[newPosition] = originalColumn;
                    service.updateColumnCache(grid);
                    grid.queueGridRefresh();
                    $timeout(function() {
                        grid.api.core.notifyDataChange(uiGridConstants.dataChange.COLUMN);
                        grid.api.colMovable.raise.columnPositionChanged(originalColumn.colDef, originalPosition, newPosition);
                    });
                }
            }
        };
        return service;
    } ]);
    module.directive("uiGridMoveColumns", [ "uiGridMoveColumnService", function(uiGridMoveColumnService) {
        return {
            "replace": true,
            "priority": 0,
            "require": "^uiGrid",
            "scope": false,
            "compile": function() {
                return {
                    "pre": function($scope, $elm, $attrs, uiGridCtrl) {
                        uiGridMoveColumnService.initializeGrid(uiGridCtrl.grid);
                    },
                    "post": function($scope, $elm, $attrs, uiGridCtrl) {}
                };
            }
        };
    } ]);
    module.directive("uiGridHeaderCell", [ "$q", "gridUtil", "uiGridMoveColumnService", "$document", "$log", "uiGridConstants", "ScrollEvent", function($q, gridUtil, uiGridMoveColumnService, $document, $log, uiGridConstants, ScrollEvent) {
        return {
            "priority": -10,
            "require": "^uiGrid",
            "compile": function() {
                return {
                    "post": function($scope, $elm, $attrs, uiGridCtrl) {
                        if ($scope.col.colDef.enableColumnMoving) {
                            var $contentsElm = angular.element($elm[0].querySelectorAll(".ui-grid-cell-contents"));
                            var gridLeft;
                            var previousMouseX;
                            var totalMouseMovement;
                            var rightMoveLimit;
                            var elmCloned = false;
                            var movingElm;
                            var reducedWidth;
                            var moveOccurred = false;
                            var downFn = function(event) {
                                gridLeft = $scope.grid.element[0].getBoundingClientRect().left;
                                if ($scope.grid.hasLeftContainer()) {
                                    gridLeft += $scope.grid.renderContainers.left.header[0].getBoundingClientRect().width;
                                }
                                previousMouseX = event.pageX;
                                totalMouseMovement = 0;
                                rightMoveLimit = gridLeft + $scope.grid.getViewportWidth();
                                if (event.type === "mousedown") {
                                    $document.on("mousemove", moveFn);
                                    $document.on("mouseup", upFn);
                                } else if (event.type === "touchstart") {
                                    $document.on("touchmove", moveFn);
                                    $document.on("touchend", upFn);
                                }
                            };
                            var moveFn = function(event) {
                                var changeValue = event.pageX - previousMouseX;
                                if (changeValue === 0) {
                                    return;
                                }
                                document.onselectstart = function() {
                                    return false;
                                };
                                moveOccurred = true;
                                if (!elmCloned) {
                                    cloneElement();
                                } else if (elmCloned) {
                                    moveElement(changeValue);
                                    previousMouseX = event.pageX;
                                }
                            };
                            var upFn = function(event) {
                                document.onselectstart = null;
                                if (movingElm) {
                                    movingElm.remove();
                                    elmCloned = false;
                                }
                                offAllEvents();
                                onDownEvents();
                                if (!moveOccurred) {
                                    return;
                                }
                                var columns = $scope.grid.columns;
                                var columnIndex = 0;
                                for (var i = 0; i < columns.length; i++) {
                                    if (columns[i].colDef.name !== $scope.col.colDef.name) {
                                        columnIndex++;
                                    } else {
                                        break;
                                    }
                                }
                                var targetIndex;
                                if (totalMouseMovement < 0) {
                                    var totalColumnsLeftWidth = 0;
                                    var il;
                                    if ($scope.grid.isRTL()) {
                                        for (il = columnIndex + 1; il < columns.length; il++) {
                                            if (angular.isUndefined(columns[il].colDef.visible) || columns[il].colDef.visible === true) {
                                                totalColumnsLeftWidth += columns[il].drawnWidth || columns[il].width || columns[il].colDef.width;
                                                if (totalColumnsLeftWidth > Math.abs(totalMouseMovement)) {
                                                    uiGridMoveColumnService.redrawColumnAtPosition($scope.grid, columnIndex, il - 1);
                                                    break;
                                                }
                                            }
                                        }
                                    } else {
                                        for (il = columnIndex - 1; il >= 0; il--) {
                                            if (angular.isUndefined(columns[il].colDef.visible) || columns[il].colDef.visible === true) {
                                                totalColumnsLeftWidth += columns[il].drawnWidth || columns[il].width || columns[il].colDef.width;
                                                if (totalColumnsLeftWidth > Math.abs(totalMouseMovement)) {
                                                    uiGridMoveColumnService.redrawColumnAtPosition($scope.grid, columnIndex, il + 1);
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                    if (totalColumnsLeftWidth < Math.abs(totalMouseMovement)) {
                                        targetIndex = 0;
                                        if ($scope.grid.isRTL()) {
                                            targetIndex = columns.length - 1;
                                        }
                                        uiGridMoveColumnService.redrawColumnAtPosition($scope.grid, columnIndex, targetIndex);
                                    }
                                } else if (totalMouseMovement > 0) {
                                    var totalColumnsRightWidth = 0;
                                    var ir;
                                    if ($scope.grid.isRTL()) {
                                        for (ir = columnIndex - 1; ir > 0; ir--) {
                                            if (angular.isUndefined(columns[ir].colDef.visible) || columns[ir].colDef.visible === true) {
                                                totalColumnsRightWidth += columns[ir].drawnWidth || columns[ir].width || columns[ir].colDef.width;
                                                if (totalColumnsRightWidth > totalMouseMovement) {
                                                    uiGridMoveColumnService.redrawColumnAtPosition($scope.grid, columnIndex, ir);
                                                    break;
                                                }
                                            }
                                        }
                                    } else {
                                        for (ir = columnIndex + 1; ir < columns.length; ir++) {
                                            if (angular.isUndefined(columns[ir].colDef.visible) || columns[ir].colDef.visible === true) {
                                                totalColumnsRightWidth += columns[ir].drawnWidth || columns[ir].width || columns[ir].colDef.width;
                                                if (totalColumnsRightWidth > totalMouseMovement) {
                                                    uiGridMoveColumnService.redrawColumnAtPosition($scope.grid, columnIndex, ir - 1);
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                    if (totalColumnsRightWidth < totalMouseMovement) {
                                        targetIndex = columns.length - 1;
                                        if ($scope.grid.isRTL()) {
                                            targetIndex = 0;
                                        }
                                        uiGridMoveColumnService.redrawColumnAtPosition($scope.grid, columnIndex, targetIndex);
                                    }
                                }
                            };
                            var onDownEvents = function() {
                                $contentsElm.on("touchstart", downFn);
                                $contentsElm.on("mousedown", downFn);
                            };
                            var offAllEvents = function() {
                                $contentsElm.off("touchstart", downFn);
                                $contentsElm.off("mousedown", downFn);
                                $document.off("mousemove", moveFn);
                                $document.off("touchmove", moveFn);
                                $document.off("mouseup", upFn);
                                $document.off("touchend", upFn);
                            };
                            onDownEvents();
                            var cloneElement = function() {
                                elmCloned = true;
                                movingElm = $elm.clone();
                                $elm.parent().append(movingElm);
                                movingElm.addClass("movingColumn");
                                var movingElementStyles = {};
                                movingElementStyles.left = $elm[0].offsetLeft + "px";
                                var gridRight = $scope.grid.element[0].getBoundingClientRect().right;
                                var elmRight = $elm[0].getBoundingClientRect().right;
                                if (elmRight > gridRight) {
                                    reducedWidth = $scope.col.drawnWidth + (gridRight - elmRight);
                                    movingElementStyles.width = reducedWidth + "px";
                                }
                                movingElm.css(movingElementStyles);
                            };
                            var moveElement = function(changeValue) {
                                var columns = $scope.grid.columns;
                                var totalColumnWidth = 0;
                                for (var i = 0; i < columns.length; i++) {
                                    if (angular.isUndefined(columns[i].colDef.visible) || columns[i].colDef.visible === true) {
                                        totalColumnWidth += columns[i].drawnWidth || columns[i].width || columns[i].colDef.width;
                                    }
                                }
                                var currentElmLeft = movingElm[0].getBoundingClientRect().left - 1;
                                var currentElmRight = movingElm[0].getBoundingClientRect().right;
                                var newElementLeft;
                                newElementLeft = currentElmLeft - gridLeft + changeValue;
                                newElementLeft = newElementLeft < rightMoveLimit ? newElementLeft : rightMoveLimit;
                                if ((currentElmLeft >= gridLeft || changeValue > 0) && (currentElmRight <= rightMoveLimit || changeValue < 0)) {
                                    movingElm.css({
                                        "visibility": "visible",
                                        "left": movingElm[0].offsetLeft + (newElementLeft < rightMoveLimit ? changeValue : rightMoveLimit - currentElmLeft) + "px"
                                    });
                                } else if (totalColumnWidth > Math.ceil(uiGridCtrl.grid.gridWidth)) {
                                    changeValue *= 8;
                                    var scrollEvent = new ScrollEvent($scope.col.grid, null, null, "uiGridHeaderCell.moveElement");
                                    scrollEvent.x = {
                                        "pixels": changeValue
                                    };
                                    scrollEvent.grid.scrollContainers("", scrollEvent);
                                }
                                var totalColumnsLeftWidth = 0;
                                for (var il = 0; il < columns.length; il++) {
                                    if (angular.isUndefined(columns[il].colDef.visible) || columns[il].colDef.visible === true) {
                                        if (columns[il].colDef.name !== $scope.col.colDef.name) {
                                            totalColumnsLeftWidth += columns[il].drawnWidth || columns[il].width || columns[il].colDef.width;
                                        } else {
                                            break;
                                        }
                                    }
                                }
                                if ($scope.newScrollLeft === undefined) {
                                    totalMouseMovement += changeValue;
                                } else {
                                    totalMouseMovement = $scope.newScrollLeft + newElementLeft - totalColumnsLeftWidth;
                                }
                                if (reducedWidth < $scope.col.drawnWidth) {
                                    reducedWidth += Math.abs(changeValue);
                                    movingElm.css({
                                        "width": reducedWidth + "px"
                                    });
                                }
                            };
                        }
                    }
                };
            }
        };
    } ]);
})();

(function() {
    "use strict";
    var module = angular.module("ui.grid.pagination", [ "ng", "ui.grid" ]);
    module.service("uiGridPaginationService", [ "gridUtil", function(gridUtil) {
        var service = {
            "initializeGrid": function(grid) {
                service.defaultGridOptions(grid.options);
                var publicApi = {
                    "events": {
                        "pagination": {
                            "paginationChanged": function(currentPage, pageSize) {}
                        }
                    },
                    "methods": {
                        "pagination": {
                            "getPage": function() {
                                return grid.options.enablePagination ? grid.options.paginationCurrentPage : null;
                            },
                            "getTotalPages": function() {
                                if (!grid.options.enablePagination) {
                                    return null;
                                }
                                return grid.options.totalItems === 0 ? 1 : Math.ceil(grid.options.totalItems / grid.options.paginationPageSize);
                            },
                            "nextPage": function() {
                                if (!grid.options.enablePagination) {
                                    return;
                                }
                                if (grid.options.totalItems > 0) {
                                    grid.options.paginationCurrentPage = Math.min(grid.options.paginationCurrentPage + 1, publicApi.methods.pagination.getTotalPages());
                                } else {
                                    grid.options.paginationCurrentPage++;
                                }
                            },
                            "previousPage": function() {
                                if (!grid.options.enablePagination) {
                                    return;
                                }
                                grid.options.paginationCurrentPage = Math.max(grid.options.paginationCurrentPage - 1, 1);
                            },
                            "seek": function(page) {
                                if (!grid.options.enablePagination) {
                                    return;
                                }
                                if (!angular.isNumber(page) || page < 1) {
                                    throw "Invalid page number: " + page;
                                }
                                grid.options.paginationCurrentPage = Math.min(page, publicApi.methods.pagination.getTotalPages());
                            }
                        }
                    }
                };
                grid.api.registerEventsFromObject(publicApi.events);
                grid.api.registerMethodsFromObject(publicApi.methods);
                var processPagination = function(renderableRows) {
                    if (grid.options.useExternalPagination || !grid.options.enablePagination) {
                        return renderableRows;
                    }
                    var pageSize = parseInt(grid.options.paginationPageSize, 10);
                    var currentPage = parseInt(grid.options.paginationCurrentPage, 10);
                    var visibleRows = renderableRows.filter(function(row) {
                        return row.visible;
                    });
                    grid.options.totalItems = visibleRows.length;
                    var firstRow = (currentPage - 1) * pageSize;
                    if (firstRow > visibleRows.length) {
                        currentPage = grid.options.paginationCurrentPage = 1;
                        firstRow = (currentPage - 1) * pageSize;
                    }
                    return visibleRows.slice(firstRow, firstRow + pageSize);
                };
                grid.registerRowsProcessor(processPagination, 900);
            },
            "defaultGridOptions": function(gridOptions) {
                gridOptions.enablePagination = gridOptions.enablePagination !== false;
                gridOptions.enablePaginationControls = gridOptions.enablePaginationControls !== false;
                gridOptions.useExternalPagination = gridOptions.useExternalPagination === true;
                if (gridUtil.isNullOrUndefined(gridOptions.totalItems)) {
                    gridOptions.totalItems = 0;
                }
                if (gridUtil.isNullOrUndefined(gridOptions.paginationPageSizes)) {
                    gridOptions.paginationPageSizes = [ 250, 500, 1e3 ];
                }
                if (gridUtil.isNullOrUndefined(gridOptions.paginationPageSize)) {
                    if (gridOptions.paginationPageSizes.length > 0) {
                        gridOptions.paginationPageSize = gridOptions.paginationPageSizes[0];
                    } else {
                        gridOptions.paginationPageSize = 0;
                    }
                }
                if (gridUtil.isNullOrUndefined(gridOptions.paginationCurrentPage)) {
                    gridOptions.paginationCurrentPage = 1;
                }
                if (gridUtil.isNullOrUndefined(gridOptions.paginationTemplate)) {
                    gridOptions.paginationTemplate = "ui-grid/pagination";
                }
            },
            "onPaginationChanged": function(grid, currentPage, pageSize) {
                grid.api.pagination.raise.paginationChanged(currentPage, pageSize);
                if (!grid.options.useExternalPagination) {
                    grid.queueGridRefresh();
                }
            }
        };
        return service;
    } ]);
    module.directive("uiGridPagination", [ "gridUtil", "uiGridPaginationService", function(gridUtil, uiGridPaginationService) {
        return {
            "priority": -200,
            "scope": false,
            "require": "uiGrid",
            "link": {
                "pre": function($scope, $elm, $attr, uiGridCtrl) {
                    uiGridPaginationService.initializeGrid(uiGridCtrl.grid);
                    gridUtil.getTemplate(uiGridCtrl.grid.options.paginationTemplate).then(function(contents) {
                        var template = angular.element(contents);
                        $elm.append(template);
                        uiGridCtrl.innerCompile(template);
                    });
                }
            }
        };
    } ]);
    module.directive("uiGridPager", [ "uiGridPaginationService", "uiGridConstants", "gridUtil", "i18nService", function(uiGridPaginationService, uiGridConstants, gridUtil, i18nService) {
        return {
            "priority": -200,
            "scope": true,
            "require": "^uiGrid",
            "link": function($scope, $elm, $attr, uiGridCtrl) {
                var defaultFocusElementSelector = ".ui-grid-pager-control-input";
                $scope.aria = i18nService.getSafeText("pagination.aria");
                $scope.paginationApi = uiGridCtrl.grid.api.pagination;
                $scope.sizesLabel = i18nService.getSafeText("pagination.sizes");
                $scope.totalItemsLabel = i18nService.getSafeText("pagination.totalItems");
                $scope.paginationOf = i18nService.getSafeText("pagination.of");
                $scope.paginationThrough = i18nService.getSafeText("pagination.through");
                var options = uiGridCtrl.grid.options;
                uiGridCtrl.grid.renderContainers.body.registerViewportAdjuster(function(adjustment) {
                    adjustment.height = adjustment.height - gridUtil.elementHeight($elm, "padding");
                    return adjustment;
                });
                var dataChangeDereg = uiGridCtrl.grid.registerDataChangeCallback(function(grid) {
                    if (!grid.options.useExternalPagination) {
                        grid.options.totalItems = grid.rows.length;
                    }
                }, [ uiGridConstants.dataChange.ROW ]);
                $scope.$on("$destroy", dataChangeDereg);
                var setShowing = function() {
                    $scope.showingLow = (options.paginationCurrentPage - 1) * options.paginationPageSize + 1;
                    $scope.showingHigh = Math.min(options.paginationCurrentPage * options.paginationPageSize, options.totalItems);
                };
                var deregT = $scope.$watch("grid.options.totalItems + grid.options.paginationPageSize", setShowing);
                var deregP = $scope.$watch("grid.options.paginationCurrentPage + grid.options.paginationPageSize", function(newValues, oldValues) {
                    if (newValues === oldValues || oldValues === undefined) {
                        return;
                    }
                    if (!angular.isNumber(options.paginationCurrentPage) || options.paginationCurrentPage < 1) {
                        options.paginationCurrentPage = 1;
                        return;
                    }
                    if (options.totalItems > 0 && options.paginationCurrentPage > $scope.paginationApi.getTotalPages()) {
                        options.paginationCurrentPage = $scope.paginationApi.getTotalPages();
                        return;
                    }
                    setShowing();
                    uiGridPaginationService.onPaginationChanged($scope.grid, options.paginationCurrentPage, options.paginationPageSize);
                });
                $scope.$on("$destroy", function() {
                    deregT();
                    deregP();
                });
                $scope.cantPageForward = function() {
                    if (options.totalItems > 0) {
                        return options.paginationCurrentPage >= $scope.paginationApi.getTotalPages();
                    } else {
                        return options.data.length < 1;
                    }
                };
                $scope.cantPageToLast = function() {
                    if (options.totalItems > 0) {
                        return $scope.cantPageForward();
                    } else {
                        return true;
                    }
                };
                $scope.cantPageBackward = function() {
                    return options.paginationCurrentPage <= 1;
                };
                var focusToInputIf = function(condition) {
                    if (condition) {
                        gridUtil.focus.bySelector($elm, defaultFocusElementSelector);
                    }
                };
                $scope.pageFirstPageClick = function() {
                    $scope.paginationApi.seek(1);
                    focusToInputIf($scope.cantPageBackward());
                };
                $scope.pagePreviousPageClick = function() {
                    $scope.paginationApi.previousPage();
                    focusToInputIf($scope.cantPageBackward());
                };
                $scope.pageNextPageClick = function() {
                    $scope.paginationApi.nextPage();
                    focusToInputIf($scope.cantPageForward());
                };
                $scope.pageLastPageClick = function() {
                    $scope.paginationApi.seek($scope.paginationApi.getTotalPages());
                    focusToInputIf($scope.cantPageToLast());
                };
            }
        };
    } ]);
})();

(function() {
    "use strict";
    var module = angular.module("ui.grid.pinning", [ "ui.grid" ]);
    module.constant("uiGridPinningConstants", {
        "container": {
            "LEFT": "left",
            "RIGHT": "right",
            "NONE": ""
        }
    });
    module.service("uiGridPinningService", [ "gridUtil", "GridRenderContainer", "i18nService", "uiGridPinningConstants", function(gridUtil, GridRenderContainer, i18nService, uiGridPinningConstants) {
        var service = {
            "initializeGrid": function(grid) {
                service.defaultGridOptions(grid.options);
                grid.registerColumnBuilder(service.pinningColumnBuilder);
                var publicApi = {
                    "events": {
                        "pinning": {
                            "columnPinned": function(colDef, container) {}
                        }
                    },
                    "methods": {
                        "pinning": {
                            "pinColumn": function(col, container) {
                                service.pinColumn(grid, col, container);
                            }
                        }
                    }
                };
                grid.api.registerEventsFromObject(publicApi.events);
                grid.api.registerMethodsFromObject(publicApi.methods);
            },
            "defaultGridOptions": function(gridOptions) {
                gridOptions.enablePinning = gridOptions.enablePinning !== false;
            },
            "pinningColumnBuilder": function(colDef, col, gridOptions) {
                colDef.enablePinning = colDef.enablePinning === undefined ? gridOptions.enablePinning : colDef.enablePinning;
                if (colDef.pinnedLeft) {
                    col.renderContainer = "left";
                    col.grid.createLeftContainer();
                } else if (colDef.pinnedRight) {
                    col.renderContainer = "right";
                    col.grid.createRightContainer();
                }
                if (!colDef.enablePinning) {
                    return;
                }
                var pinColumnLeftAction = {
                    "name": "ui.grid.pinning.pinLeft",
                    "title": i18nService.get().pinning.pinLeft,
                    "icon": "ui-grid-icon-left-open",
                    "shown": function() {
                        return typeof this.context.col.renderContainer === "undefined" || !this.context.col.renderContainer || this.context.col.renderContainer !== "left";
                    },
                    "action": function() {
                        service.pinColumn(this.context.col.grid, this.context.col, uiGridPinningConstants.container.LEFT);
                    }
                };
                var pinColumnRightAction = {
                    "name": "ui.grid.pinning.pinRight",
                    "title": i18nService.get().pinning.pinRight,
                    "icon": "ui-grid-icon-right-open",
                    "shown": function() {
                        return typeof this.context.col.renderContainer === "undefined" || !this.context.col.renderContainer || this.context.col.renderContainer !== "right";
                    },
                    "action": function() {
                        service.pinColumn(this.context.col.grid, this.context.col, uiGridPinningConstants.container.RIGHT);
                    }
                };
                var removePinAction = {
                    "name": "ui.grid.pinning.unpin",
                    "title": i18nService.get().pinning.unpin,
                    "icon": "ui-grid-icon-cancel",
                    "shown": function() {
                        return typeof this.context.col.renderContainer !== "undefined" && this.context.col.renderContainer !== null && this.context.col.renderContainer !== "body";
                    },
                    "action": function() {
                        service.pinColumn(this.context.col.grid, this.context.col, uiGridPinningConstants.container.NONE);
                    }
                };
                if (!gridUtil.arrayContainsObjectWithProperty(col.menuItems, "name", "ui.grid.pinning.pinLeft")) {
                    col.menuItems.push(pinColumnLeftAction);
                }
                if (!gridUtil.arrayContainsObjectWithProperty(col.menuItems, "name", "ui.grid.pinning.pinRight")) {
                    col.menuItems.push(pinColumnRightAction);
                }
                if (!gridUtil.arrayContainsObjectWithProperty(col.menuItems, "name", "ui.grid.pinning.unpin")) {
                    col.menuItems.push(removePinAction);
                }
            },
            "pinColumn": function(grid, col, container) {
                if (container === uiGridPinningConstants.container.NONE) {
                    col.renderContainer = null;
                    col.colDef.pinnedLeft = col.colDef.pinnedRight = false;
                } else {
                    col.renderContainer = container;
                    if (container === uiGridPinningConstants.container.LEFT) {
                        grid.createLeftContainer();
                    } else if (container === uiGridPinningConstants.container.RIGHT) {
                        grid.createRightContainer();
                    }
                }
                grid.refresh().then(function() {
                    grid.api.pinning.raise.columnPinned(col.colDef, container);
                });
            }
        };
        return service;
    } ]);
    module.directive("uiGridPinning", [ "gridUtil", "uiGridPinningService", function(gridUtil, uiGridPinningService) {
        return {
            "require": "uiGrid",
            "scope": false,
            "compile": function() {
                return {
                    "pre": function($scope, $elm, $attrs, uiGridCtrl) {
                        uiGridPinningService.initializeGrid(uiGridCtrl.grid);
                    },
                    "post": function($scope, $elm, $attrs, uiGridCtrl) {}
                };
            }
        };
    } ]);
})();

(function() {
    "use strict";
    var module = angular.module("ui.grid.resizeColumns", [ "ui.grid" ]);
    module.service("uiGridResizeColumnsService", [ "gridUtil", "$q", "$timeout", function(gridUtil, $q, $timeout) {
        var service = {
            "defaultGridOptions": function(gridOptions) {
                gridOptions.enableColumnResizing = gridOptions.enableColumnResizing !== false;
                if (gridOptions.enableColumnResize === false) {
                    gridOptions.enableColumnResizing = false;
                }
            },
            "colResizerColumnBuilder": function(colDef, col, gridOptions) {
                var promises = [];
                colDef.enableColumnResizing = colDef.enableColumnResizing === undefined ? gridOptions.enableColumnResizing : colDef.enableColumnResizing;
                if (colDef.enableColumnResize === false) {
                    colDef.enableColumnResizing = false;
                }
                return $q.all(promises);
            },
            "registerPublicApi": function(grid) {
                var publicApi = {
                    "events": {
                        "colResizable": {
                            "columnSizeChanged": function(colDef, deltaChange) {}
                        }
                    }
                };
                grid.api.registerEventsFromObject(publicApi.events);
            },
            "fireColumnSizeChanged": function(grid, colDef, deltaChange) {
                $timeout(function() {
                    if (grid.api.colResizable) {
                        grid.api.colResizable.raise.columnSizeChanged(colDef, deltaChange);
                    } else {
                        gridUtil.logError("The resizeable api is not registered, this may indicate that you've included the module but not added the 'ui-grid-resize-columns' directive to your grid definition.  Cannot raise any events.");
                    }
                });
            },
            "findTargetCol": function(col, position, rtlMultiplier) {
                var renderContainer = col.getRenderContainer();
                if (position === "left") {
                    var colIndex = renderContainer.visibleColumnCache.indexOf(col);
                    return renderContainer.visibleColumnCache[colIndex - 1 * rtlMultiplier];
                } else {
                    return col;
                }
            }
        };
        return service;
    } ]);
    module.directive("uiGridResizeColumns", [ "gridUtil", "uiGridResizeColumnsService", function(gridUtil, uiGridResizeColumnsService) {
        return {
            "replace": true,
            "priority": 0,
            "require": "^uiGrid",
            "scope": false,
            "compile": function() {
                return {
                    "pre": function($scope, $elm, $attrs, uiGridCtrl) {
                        uiGridResizeColumnsService.defaultGridOptions(uiGridCtrl.grid.options);
                        uiGridCtrl.grid.registerColumnBuilder(uiGridResizeColumnsService.colResizerColumnBuilder);
                        uiGridResizeColumnsService.registerPublicApi(uiGridCtrl.grid);
                    },
                    "post": function($scope, $elm, $attrs, uiGridCtrl) {}
                };
            }
        };
    } ]);
    module.directive("uiGridHeaderCell", [ "gridUtil", "$templateCache", "$compile", "$q", "uiGridResizeColumnsService", "uiGridConstants", "$timeout", function(gridUtil, $templateCache, $compile, $q, uiGridResizeColumnsService, uiGridConstants, $timeout) {
        return {
            "priority": -10,
            "require": "^uiGrid",
            "compile": function() {
                return {
                    "post": function($scope, $elm, $attrs, uiGridCtrl) {
                        var grid = uiGridCtrl.grid;
                        if (grid.options.enableColumnResizing) {
                            var columnResizerElm = $templateCache.get("ui-grid/columnResizer");
                            var rtlMultiplier = 1;
                            if (grid.isRTL()) {
                                $scope.position = "left";
                                rtlMultiplier = -1;
                            }
                            var displayResizers = function() {
                                var resizers = $elm[0].getElementsByClassName("ui-grid-column-resizer");
                                for (var i = 0; i < resizers.length; i++) {
                                    angular.element(resizers[i]).remove();
                                }
                                var otherCol = uiGridResizeColumnsService.findTargetCol($scope.col, "left", rtlMultiplier);
                                var renderContainer = $scope.col.getRenderContainer();
                                if (otherCol && renderContainer.visibleColumnCache.indexOf($scope.col) !== 0 && otherCol.colDef.enableColumnResizing !== false) {
                                    var resizerLeft = angular.element(columnResizerElm).clone();
                                    resizerLeft.attr("position", "left");
                                    $elm.prepend(resizerLeft);
                                    $compile(resizerLeft)($scope);
                                }
                                if ($scope.col.colDef.enableColumnResizing !== false) {
                                    var resizerRight = angular.element(columnResizerElm).clone();
                                    resizerRight.attr("position", "right");
                                    $elm.append(resizerRight);
                                    $compile(resizerRight)($scope);
                                }
                            };
                            displayResizers();
                            var waitDisplay = function() {
                                $timeout(displayResizers);
                            };
                            var dataChangeDereg = grid.registerDataChangeCallback(waitDisplay, [ uiGridConstants.dataChange.COLUMN ]);
                            $scope.$on("$destroy", dataChangeDereg);
                        }
                    }
                };
            }
        };
    } ]);
    module.directive("uiGridColumnResizer", [ "$document", "gridUtil", "uiGridConstants", "uiGridResizeColumnsService", function($document, gridUtil, uiGridConstants, uiGridResizeColumnsService) {
        var resizeOverlay = angular.element('<div class="ui-grid-resize-overlay"></div>');
        var resizer = {
            "priority": 0,
            "scope": {
                "col": "=",
                "position": "@",
                "renderIndex": "="
            },
            "require": "?^uiGrid",
            "link": function($scope, $elm, $attrs, uiGridCtrl) {
                var startX = 0, x = 0, gridLeft = 0, rtlMultiplier = 1;
                if (uiGridCtrl.grid.isRTL()) {
                    $scope.position = "left";
                    rtlMultiplier = -1;
                }
                if ($scope.position === "left") {
                    $elm.addClass("left");
                } else if ($scope.position === "right") {
                    $elm.addClass("right");
                }
                function refreshCanvas(xDiff) {
                    uiGridCtrl.grid.refreshCanvas(true).then(function() {
                        uiGridCtrl.grid.queueGridRefresh();
                    });
                }
                function constrainWidth(col, width) {
                    var newWidth = width;
                    if (col.minWidth && newWidth < col.minWidth) {
                        newWidth = col.minWidth;
                    } else if (col.maxWidth && newWidth > col.maxWidth) {
                        newWidth = col.maxWidth;
                    }
                    return newWidth;
                }
                function moveFunction(event, args) {
                    if (event.originalEvent) {
                        event = event.originalEvent;
                    }
                    event.preventDefault();
                    x = (event.targetTouches ? event.targetTouches[0] : event).clientX - gridLeft;
                    if (x < 0) {
                        x = 0;
                    } else if (x > uiGridCtrl.grid.gridWidth) {
                        x = uiGridCtrl.grid.gridWidth;
                    }
                    var col = uiGridResizeColumnsService.findTargetCol($scope.col, $scope.position, rtlMultiplier);
                    if (col.colDef.enableColumnResizing === false) {
                        return;
                    }
                    if (!uiGridCtrl.grid.element.hasClass("column-resizing")) {
                        uiGridCtrl.grid.element.addClass("column-resizing");
                    }
                    var xDiff = x - startX;
                    var newWidth = parseInt(col.drawnWidth + xDiff * rtlMultiplier, 10);
                    x = x + (constrainWidth(col, newWidth) - newWidth) * rtlMultiplier;
                    resizeOverlay.css({
                        "left": x + "px"
                    });
                    uiGridCtrl.fireEvent(uiGridConstants.events.ITEM_DRAGGING);
                }
                function upFunction(event, args) {
                    if (event.originalEvent) {
                        event = event.originalEvent;
                    }
                    event.preventDefault();
                    uiGridCtrl.grid.element.removeClass("column-resizing");
                    resizeOverlay.remove();
                    x = (event.changedTouches ? event.changedTouches[0] : event).clientX - gridLeft;
                    var xDiff = x - startX;
                    if (xDiff === 0) {
                        offAllEvents();
                        onDownEvents();
                        return;
                    }
                    var col = uiGridResizeColumnsService.findTargetCol($scope.col, $scope.position, rtlMultiplier);
                    if (col.colDef.enableColumnResizing === false) {
                        return;
                    }
                    var newWidth = parseInt(col.drawnWidth + xDiff * rtlMultiplier, 10);
                    col.width = constrainWidth(col, newWidth);
                    col.hasCustomWidth = true;
                    refreshCanvas(xDiff);
                    uiGridResizeColumnsService.fireColumnSizeChanged(uiGridCtrl.grid, col.colDef, xDiff);
                    offAllEvents();
                    onDownEvents();
                }
                var downFunction = function(event, args) {
                    if (event.originalEvent) {
                        event = event.originalEvent;
                    }
                    event.stopPropagation();
                    gridLeft = uiGridCtrl.grid.element[0].getBoundingClientRect().left;
                    startX = (event.targetTouches ? event.targetTouches[0] : event).clientX - gridLeft;
                    uiGridCtrl.grid.element.append(resizeOverlay);
                    resizeOverlay.css({
                        "left": startX
                    });
                    if (event.type === "touchstart") {
                        $document.on("touchend", upFunction);
                        $document.on("touchmove", moveFunction);
                        $elm.off("mousedown", downFunction);
                    } else {
                        $document.on("mouseup", upFunction);
                        $document.on("mousemove", moveFunction);
                        $elm.off("touchstart", downFunction);
                    }
                };
                var onDownEvents = function() {
                    $elm.on("mousedown", downFunction);
                    $elm.on("touchstart", downFunction);
                };
                var offAllEvents = function() {
                    $document.off("mouseup", upFunction);
                    $document.off("touchend", upFunction);
                    $document.off("mousemove", moveFunction);
                    $document.off("touchmove", moveFunction);
                    $elm.off("mousedown", downFunction);
                    $elm.off("touchstart", downFunction);
                };
                onDownEvents();
                var dblClickFn = function(event, args) {
                    event.stopPropagation();
                    var col = uiGridResizeColumnsService.findTargetCol($scope.col, $scope.position, rtlMultiplier);
                    if (col.colDef.enableColumnResizing === false) {
                        return;
                    }
                    var maxWidth = 0;
                    var xDiff = 0;
                    var renderContainerElm = gridUtil.closestElm($elm, ".ui-grid-render-container");
                    var cells = renderContainerElm.querySelectorAll("." + uiGridConstants.COL_CLASS_PREFIX + col.uid + " .ui-grid-cell-contents");
                    Array.prototype.forEach.call(cells, function(cell) {
                        var menuButton;
                        if (angular.element(cell).parent().hasClass("ui-grid-header-cell")) {
                            menuButton = angular.element(cell).parent()[0].querySelectorAll(".ui-grid-column-menu-button");
                        }
                        gridUtil.fakeElement(cell, {}, function(newElm) {
                            var e = angular.element(newElm);
                            e.attr("style", "float: left");
                            var width = gridUtil.elementWidth(e);
                            if (menuButton) {
                                var menuButtonWidth = gridUtil.elementWidth(menuButton);
                                width = width + menuButtonWidth;
                            }
                            if (width > maxWidth) {
                                maxWidth = width;
                                xDiff = maxWidth - width;
                            }
                        });
                    });
                    col.width = constrainWidth(col, maxWidth);
                    col.hasCustomWidth = true;
                    refreshCanvas(xDiff);
                    uiGridResizeColumnsService.fireColumnSizeChanged(uiGridCtrl.grid, col.colDef, xDiff);
                };
                $elm.on("dblclick", dblClickFn);
                $elm.on("$destroy", function() {
                    $elm.off("dblclick", dblClickFn);
                    offAllEvents();
                });
            }
        };
        return resizer;
    } ]);
})();

(function() {
    "use strict";
    var module = angular.module("ui.grid.rowEdit", [ "ui.grid", "ui.grid.edit", "ui.grid.cellNav" ]);
    module.constant("uiGridRowEditConstants", {});
    module.service("uiGridRowEditService", [ "$interval", "$q", "uiGridConstants", "uiGridRowEditConstants", "gridUtil", function($interval, $q, uiGridConstants, uiGridRowEditConstants, gridUtil) {
        var service = {
            "initializeGrid": function(scope, grid) {
                grid.rowEdit = {};
                var publicApi = {
                    "events": {
                        "rowEdit": {
                            "saveRow": function(rowEntity) {}
                        }
                    },
                    "methods": {
                        "rowEdit": {
                            "setSavePromise": function(rowEntity, savePromise) {
                                service.setSavePromise(grid, rowEntity, savePromise);
                            },
                            "getDirtyRows": function() {
                                return grid.rowEdit.dirtyRows ? grid.rowEdit.dirtyRows : [];
                            },
                            "getErrorRows": function() {
                                return grid.rowEdit.errorRows ? grid.rowEdit.errorRows : [];
                            },
                            "flushDirtyRows": function() {
                                return service.flushDirtyRows(grid);
                            },
                            "setRowsDirty": function(dataRows) {
                                service.setRowsDirty(grid, dataRows);
                            },
                            "setRowsClean": function(dataRows) {
                                service.setRowsClean(grid, dataRows);
                            }
                        }
                    }
                };
                grid.api.registerEventsFromObject(publicApi.events);
                grid.api.registerMethodsFromObject(publicApi.methods);
                grid.api.core.on.renderingComplete(scope, function(gridApi) {
                    grid.api.edit.on.afterCellEdit(scope, service.endEditCell);
                    grid.api.edit.on.beginCellEdit(scope, service.beginEditCell);
                    grid.api.edit.on.cancelCellEdit(scope, service.cancelEditCell);
                    if (grid.api.cellNav) {
                        grid.api.cellNav.on.navigate(scope, service.navigate);
                    }
                });
            },
            "defaultGridOptions": function(gridOptions) {},
            "saveRow": function(grid, gridRow) {
                var self = this;
                return function() {
                    gridRow.isSaving = true;
                    if (gridRow.rowEditSavePromise) {
                        return gridRow.rowEditSavePromise;
                    }
                    var promise = grid.api.rowEdit.raise.saveRow(gridRow.entity);
                    if (gridRow.rowEditSavePromise) {
                        gridRow.rowEditSavePromise.then(self.processSuccessPromise(grid, gridRow), self.processErrorPromise(grid, gridRow));
                    } else {
                        gridUtil.logError("A promise was not returned when saveRow event was raised, either nobody is listening to event, or event handler did not return a promise");
                    }
                    return promise;
                };
            },
            "setSavePromise": function(grid, rowEntity, savePromise) {
                var gridRow = grid.getRow(rowEntity);
                gridRow.rowEditSavePromise = savePromise;
            },
            "processSuccessPromise": function(grid, gridRow) {
                var self = this;
                return function() {
                    delete gridRow.isSaving;
                    delete gridRow.isDirty;
                    delete gridRow.isError;
                    delete gridRow.rowEditSaveTimer;
                    delete gridRow.rowEditSavePromise;
                    self.removeRow(grid.rowEdit.errorRows, gridRow);
                    self.removeRow(grid.rowEdit.dirtyRows, gridRow);
                };
            },
            "processErrorPromise": function(grid, gridRow) {
                return function() {
                    delete gridRow.isSaving;
                    delete gridRow.rowEditSaveTimer;
                    delete gridRow.rowEditSavePromise;
                    gridRow.isError = true;
                    if (!grid.rowEdit.errorRows) {
                        grid.rowEdit.errorRows = [];
                    }
                    if (!service.isRowPresent(grid.rowEdit.errorRows, gridRow)) {
                        grid.rowEdit.errorRows.push(gridRow);
                    }
                };
            },
            "removeRow": function(rowArray, removeGridRow) {
                if (typeof rowArray === "undefined" || rowArray === null) {
                    return;
                }
                rowArray.forEach(function(gridRow, index) {
                    if (gridRow.uid === removeGridRow.uid) {
                        rowArray.splice(index, 1);
                    }
                });
            },
            "isRowPresent": function(rowArray, removeGridRow) {
                var present = false;
                rowArray.forEach(function(gridRow, index) {
                    if (gridRow.uid === removeGridRow.uid) {
                        present = true;
                    }
                });
                return present;
            },
            "flushDirtyRows": function(grid) {
                var promises = [];
                grid.api.rowEdit.getDirtyRows().forEach(function(gridRow) {
                    service.saveRow(grid, gridRow)();
                    promises.push(gridRow.rowEditSavePromise);
                });
                return $q.all(promises);
            },
            "endEditCell": function(rowEntity, colDef, newValue, previousValue) {
                var grid = this.grid;
                var gridRow = grid.getRow(rowEntity);
                if (!gridRow) {
                    gridUtil.logError("Unable to find rowEntity in grid data, dirty flag cannot be set");
                    return;
                }
                if (newValue !== previousValue || gridRow.isDirty) {
                    if (!grid.rowEdit.dirtyRows) {
                        grid.rowEdit.dirtyRows = [];
                    }
                    if (!gridRow.isDirty) {
                        gridRow.isDirty = true;
                        grid.rowEdit.dirtyRows.push(gridRow);
                    }
                    delete gridRow.isError;
                    service.considerSetTimer(grid, gridRow);
                }
            },
            "beginEditCell": function(rowEntity, colDef) {
                var grid = this.grid;
                var gridRow = grid.getRow(rowEntity);
                if (!gridRow) {
                    gridUtil.logError("Unable to find rowEntity in grid data, timer cannot be cancelled");
                    return;
                }
                service.cancelTimer(grid, gridRow);
            },
            "cancelEditCell": function(rowEntity, colDef) {
                var grid = this.grid;
                var gridRow = grid.getRow(rowEntity);
                if (!gridRow) {
                    gridUtil.logError("Unable to find rowEntity in grid data, timer cannot be set");
                    return;
                }
                service.considerSetTimer(grid, gridRow);
            },
            "navigate": function(newRowCol, oldRowCol) {
                var grid = this.grid;
                if (newRowCol.row.rowEditSaveTimer) {
                    service.cancelTimer(grid, newRowCol.row);
                }
                if (oldRowCol && oldRowCol.row && oldRowCol.row !== newRowCol.row) {
                    service.considerSetTimer(grid, oldRowCol.row);
                }
            },
            "considerSetTimer": function(grid, gridRow) {
                service.cancelTimer(grid, gridRow);
                if (gridRow.isDirty && !gridRow.isSaving) {
                    if (grid.options.rowEditWaitInterval !== -1) {
                        var waitTime = grid.options.rowEditWaitInterval ? grid.options.rowEditWaitInterval : 2e3;
                        gridRow.rowEditSaveTimer = $interval(service.saveRow(grid, gridRow), waitTime, 1);
                    }
                }
            },
            "cancelTimer": function(grid, gridRow) {
                if (gridRow.rowEditSaveTimer && !gridRow.isSaving) {
                    $interval.cancel(gridRow.rowEditSaveTimer);
                    delete gridRow.rowEditSaveTimer;
                }
            },
            "setRowsDirty": function(grid, myDataRows) {
                var gridRow;
                myDataRows.forEach(function(value, index) {
                    gridRow = grid.getRow(value);
                    if (gridRow) {
                        if (!grid.rowEdit.dirtyRows) {
                            grid.rowEdit.dirtyRows = [];
                        }
                        if (!gridRow.isDirty) {
                            gridRow.isDirty = true;
                            grid.rowEdit.dirtyRows.push(gridRow);
                        }
                        delete gridRow.isError;
                        service.considerSetTimer(grid, gridRow);
                    } else {
                        gridUtil.logError("requested row not found in rowEdit.setRowsDirty, row was: " + value);
                    }
                });
            },
            "setRowsClean": function(grid, myDataRows) {
                var gridRow;
                myDataRows.forEach(function(value, index) {
                    gridRow = grid.getRow(value);
                    if (gridRow) {
                        delete gridRow.isDirty;
                        service.removeRow(grid.rowEdit.dirtyRows, gridRow);
                        service.cancelTimer(grid, gridRow);
                        delete gridRow.isError;
                        service.removeRow(grid.rowEdit.errorRows, gridRow);
                    } else {
                        gridUtil.logError("requested row not found in rowEdit.setRowsClean, row was: " + value);
                    }
                });
            }
        };
        return service;
    } ]);
    module.directive("uiGridRowEdit", [ "gridUtil", "uiGridRowEditService", "uiGridEditConstants", function(gridUtil, uiGridRowEditService, uiGridEditConstants) {
        return {
            "replace": true,
            "priority": 0,
            "require": "^uiGrid",
            "scope": false,
            "compile": function() {
                return {
                    "pre": function($scope, $elm, $attrs, uiGridCtrl) {
                        uiGridRowEditService.initializeGrid($scope, uiGridCtrl.grid);
                    },
                    "post": function($scope, $elm, $attrs, uiGridCtrl) {}
                };
            }
        };
    } ]);
    module.directive("uiGridViewport", [ "$compile", "uiGridConstants", "gridUtil", "$parse", function($compile, uiGridConstants, gridUtil, $parse) {
        return {
            "priority": -200,
            "scope": false,
            "compile": function($elm, $attrs) {
                var rowRepeatDiv = angular.element($elm.children().children()[0]);
                var existingNgClass = rowRepeatDiv.attr("ng-class");
                var newNgClass = "";
                if (existingNgClass) {
                    newNgClass = existingNgClass.slice(0, -1) + ", 'ui-grid-row-dirty': row.isDirty, 'ui-grid-row-saving': row.isSaving, 'ui-grid-row-error': row.isError}";
                } else {
                    newNgClass = "{'ui-grid-row-dirty': row.isDirty, 'ui-grid-row-saving': row.isSaving, 'ui-grid-row-error': row.isError}";
                }
                rowRepeatDiv.attr("ng-class", newNgClass);
                return {
                    "pre": function($scope, $elm, $attrs, controllers) {},
                    "post": function($scope, $elm, $attrs, controllers) {}
                };
            }
        };
    } ]);
})();

(function() {
    "use strict";
    var module = angular.module("ui.grid.saveState", [ "ui.grid", "ui.grid.selection", "ui.grid.cellNav", "ui.grid.grouping", "ui.grid.pinning", "ui.grid.treeView" ]);
    module.constant("uiGridSaveStateConstants", {
        "featureName": "saveState"
    });
    module.service("uiGridSaveStateService", [ "$q", "uiGridSaveStateConstants", "gridUtil", "$compile", "$interval", "uiGridConstants", function($q, uiGridSaveStateConstants, gridUtil, $compile, $interval, uiGridConstants) {
        var service = {
            "initializeGrid": function(grid) {
                grid.saveState = {};
                this.defaultGridOptions(grid.options);
                var publicApi = {
                    "events": {
                        "saveState": {}
                    },
                    "methods": {
                        "saveState": {
                            "save": function() {
                                return service.save(grid);
                            },
                            "restore": function($scope, state) {
                                service.restore(grid, $scope, state);
                            }
                        }
                    }
                };
                grid.api.registerEventsFromObject(publicApi.events);
                grid.api.registerMethodsFromObject(publicApi.methods);
            },
            "defaultGridOptions": function(gridOptions) {
                gridOptions.saveWidths = gridOptions.saveWidths !== false;
                gridOptions.saveOrder = gridOptions.saveOrder !== false;
                gridOptions.saveScroll = gridOptions.saveScroll === true;
                gridOptions.saveFocus = gridOptions.saveScroll !== true && gridOptions.saveFocus !== false;
                gridOptions.saveVisible = gridOptions.saveVisible !== false;
                gridOptions.saveSort = gridOptions.saveSort !== false;
                gridOptions.saveFilter = gridOptions.saveFilter !== false;
                gridOptions.saveSelection = gridOptions.saveSelection !== false;
                gridOptions.saveGrouping = gridOptions.saveGrouping !== false;
                gridOptions.saveGroupingExpandedStates = gridOptions.saveGroupingExpandedStates === true;
                gridOptions.savePinning = gridOptions.savePinning !== false;
                gridOptions.saveTreeView = gridOptions.saveTreeView !== false;
            },
            "save": function(grid) {
                var savedState = {};
                savedState.columns = service.saveColumns(grid);
                savedState.scrollFocus = service.saveScrollFocus(grid);
                savedState.selection = service.saveSelection(grid);
                savedState.grouping = service.saveGrouping(grid);
                savedState.treeView = service.saveTreeView(grid);
                savedState.pagination = service.savePagination(grid);
                return savedState;
            },
            "restore": function(grid, $scope, state) {
                if (state.columns) {
                    service.restoreColumns(grid, state.columns);
                }
                if (state.scrollFocus) {
                    service.restoreScrollFocus(grid, $scope, state.scrollFocus);
                }
                if (state.selection) {
                    service.restoreSelection(grid, state.selection);
                }
                if (state.grouping) {
                    service.restoreGrouping(grid, state.grouping);
                }
                if (state.treeView) {
                    service.restoreTreeView(grid, state.treeView);
                }
                if (state.pagination) {
                    service.restorePagination(grid, state.pagination);
                }
                grid.refresh();
            },
            "saveColumns": function(grid) {
                var columns = [];
                grid.getOnlyDataColumns().forEach(function(column) {
                    var savedColumn = {};
                    savedColumn.name = column.name;
                    if (grid.options.saveVisible) {
                        savedColumn.visible = column.visible;
                    }
                    if (grid.options.saveWidths) {
                        savedColumn.width = column.width;
                    }
                    if (grid.options.saveSort) {
                        savedColumn.sort = angular.copy(column.sort);
                    }
                    if (grid.options.saveFilter) {
                        savedColumn.filters = [];
                        column.filters.forEach(function(filter) {
                            var copiedFilter = {};
                            angular.forEach(filter, function(value, key) {
                                if (key !== "condition" && key !== "$$hashKey" && key !== "placeholder") {
                                    copiedFilter[key] = value;
                                }
                            });
                            savedColumn.filters.push(copiedFilter);
                        });
                    }
                    if (!!grid.api.pinning && grid.options.savePinning) {
                        savedColumn.pinned = column.renderContainer ? column.renderContainer : "";
                    }
                    columns.push(savedColumn);
                });
                return columns;
            },
            "saveScrollFocus": function(grid) {
                if (!grid.api.cellNav) {
                    return {};
                }
                var scrollFocus = {};
                if (grid.options.saveFocus) {
                    scrollFocus.focus = true;
                    var rowCol = grid.api.cellNav.getFocusedCell();
                    if (rowCol !== null) {
                        if (rowCol.col !== null) {
                            scrollFocus.colName = rowCol.col.colDef.name;
                        }
                        if (rowCol.row !== null) {
                            scrollFocus.rowVal = service.getRowVal(grid, rowCol.row);
                        }
                    }
                }
                if (grid.options.saveScroll || grid.options.saveFocus && !scrollFocus.colName && !scrollFocus.rowVal) {
                    scrollFocus.focus = false;
                    if (grid.renderContainers.body.prevRowScrollIndex) {
                        scrollFocus.rowVal = service.getRowVal(grid, grid.renderContainers.body.visibleRowCache[grid.renderContainers.body.prevRowScrollIndex]);
                    }
                    if (grid.renderContainers.body.prevColScrollIndex) {
                        scrollFocus.colName = grid.renderContainers.body.visibleColumnCache[grid.renderContainers.body.prevColScrollIndex].name;
                    }
                }
                return scrollFocus;
            },
            "saveSelection": function(grid) {
                if (!grid.api.selection || !grid.options.saveSelection) {
                    return [];
                }
                var selection = grid.api.selection.getSelectedGridRows().map(function(gridRow) {
                    return service.getRowVal(grid, gridRow);
                });
                return selection;
            },
            "saveGrouping": function(grid) {
                if (!grid.api.grouping || !grid.options.saveGrouping) {
                    return {};
                }
                return grid.api.grouping.getGrouping(grid.options.saveGroupingExpandedStates);
            },
            "savePagination": function(grid) {
                if (!grid.api.pagination || !grid.options.paginationPageSize) {
                    return {};
                }
                return {
                    "paginationCurrentPage": grid.options.paginationCurrentPage,
                    "paginationPageSize": grid.options.paginationPageSize
                };
            },
            "saveTreeView": function(grid) {
                if (!grid.api.treeView || !grid.options.saveTreeView) {
                    return {};
                }
                return grid.api.treeView.getTreeView();
            },
            "getRowVal": function(grid, gridRow) {
                if (!gridRow) {
                    return null;
                }
                var rowVal = {};
                if (grid.options.saveRowIdentity) {
                    rowVal.identity = true;
                    rowVal.row = grid.options.saveRowIdentity(gridRow.entity);
                } else {
                    rowVal.identity = false;
                    rowVal.row = grid.renderContainers.body.visibleRowCache.indexOf(gridRow);
                }
                return rowVal;
            },
            "restoreColumns": function(grid, columnsState) {
                var isSortChanged = false;
                columnsState.forEach(function(columnState, index) {
                    var currentCol = grid.getColumn(columnState.name);
                    if (currentCol && !grid.isRowHeaderColumn(currentCol)) {
                        if (grid.options.saveVisible && (currentCol.visible !== columnState.visible || currentCol.colDef.visible !== columnState.visible)) {
                            currentCol.visible = columnState.visible;
                            currentCol.colDef.visible = columnState.visible;
                            grid.api.core.raise.columnVisibilityChanged(currentCol);
                        }
                        if (grid.options.saveWidths && currentCol.width !== columnState.width) {
                            currentCol.width = columnState.width;
                            currentCol.hasCustomWidth = true;
                        }
                        if (grid.options.saveSort && !angular.equals(currentCol.sort, columnState.sort) && !(currentCol.sort === undefined && angular.isEmpty(columnState.sort))) {
                            currentCol.sort = angular.copy(columnState.sort);
                            isSortChanged = true;
                        }
                        if (grid.options.saveFilter && !angular.equals(currentCol.filters, columnState.filters)) {
                            columnState.filters.forEach(function(filter, index) {
                                angular.extend(currentCol.filters[index], filter);
                                if (typeof filter.term === "undefined" || filter.term === null) {
                                    delete currentCol.filters[index].term;
                                }
                            });
                            grid.api.core.raise.filterChanged();
                        }
                        if (!!grid.api.pinning && grid.options.savePinning && currentCol.renderContainer !== columnState.pinned) {
                            grid.api.pinning.pinColumn(currentCol, columnState.pinned);
                        }
                        var currentIndex = grid.getOnlyDataColumns().indexOf(currentCol);
                        if (currentIndex !== -1) {
                            if (grid.options.saveOrder && currentIndex !== index) {
                                var column = grid.columns.splice(currentIndex + grid.rowHeaderColumns.length, 1)[0];
                                grid.columns.splice(index + grid.rowHeaderColumns.length, 0, column);
                            }
                        }
                    }
                });
                if (isSortChanged) {
                    grid.api.core.raise.sortChanged(grid, grid.getColumnSorting());
                }
            },
            "restoreScrollFocus": function(grid, $scope, scrollFocusState) {
                if (!grid.api.cellNav) {
                    return;
                }
                var colDef, row;
                if (scrollFocusState.colName) {
                    var colDefs = grid.options.columnDefs.filter(function(colDef) {
                        return colDef.name === scrollFocusState.colName;
                    });
                    if (colDefs.length > 0) {
                        colDef = colDefs[0];
                    }
                }
                if (scrollFocusState.rowVal && scrollFocusState.rowVal.row) {
                    if (scrollFocusState.rowVal.identity) {
                        row = service.findRowByIdentity(grid, scrollFocusState.rowVal);
                    } else {
                        row = grid.renderContainers.body.visibleRowCache[scrollFocusState.rowVal.row];
                    }
                }
                var entity = row && row.entity ? row.entity : null;
                if (colDef || entity) {
                    if (scrollFocusState.focus) {
                        grid.api.cellNav.scrollToFocus(entity, colDef);
                    } else {
                        grid.scrollTo(entity, colDef);
                    }
                }
            },
            "restoreSelection": function(grid, selectionState) {
                if (!grid.api.selection) {
                    return;
                }
                grid.api.selection.clearSelectedRows();
                selectionState.forEach(function(rowVal) {
                    if (rowVal.identity) {
                        var foundRow = service.findRowByIdentity(grid, rowVal);
                        if (foundRow) {
                            grid.api.selection.selectRow(foundRow.entity);
                        }
                    } else {
                        grid.api.selection.selectRowByVisibleIndex(rowVal.row);
                    }
                });
            },
            "restoreGrouping": function(grid, groupingState) {
                if (!grid.api.grouping || typeof groupingState === "undefined" || groupingState === null || angular.equals(groupingState, {})) {
                    return;
                }
                grid.api.grouping.setGrouping(groupingState);
            },
            "restoreTreeView": function(grid, treeViewState) {
                if (!grid.api.treeView || typeof treeViewState === "undefined" || treeViewState === null || angular.equals(treeViewState, {})) {
                    return;
                }
                grid.api.treeView.setTreeView(treeViewState);
            },
            "restorePagination": function(grid, pagination) {
                if (!grid.api.pagination || !grid.options.paginationPageSize) {
                    return;
                }
                grid.options.paginationCurrentPage = pagination.paginationCurrentPage;
                grid.options.paginationPageSize = pagination.paginationPageSize;
            },
            "findRowByIdentity": function(grid, rowVal) {
                if (!grid.options.saveRowIdentity) {
                    return null;
                }
                var filteredRows = grid.rows.filter(function(gridRow) {
                    if (grid.options.saveRowIdentity(gridRow.entity) === rowVal.row) {
                        return true;
                    } else {
                        return false;
                    }
                });
                if (filteredRows.length > 0) {
                    return filteredRows[0];
                } else {
                    return null;
                }
            }
        };
        return service;
    } ]);
    module.directive("uiGridSaveState", [ "uiGridSaveStateConstants", "uiGridSaveStateService", "gridUtil", "$compile", function(uiGridSaveStateConstants, uiGridSaveStateService, gridUtil, $compile) {
        return {
            "replace": true,
            "priority": 0,
            "require": "^uiGrid",
            "scope": false,
            "link": function($scope, $elm, $attrs, uiGridCtrl) {
                uiGridSaveStateService.initializeGrid(uiGridCtrl.grid);
            }
        };
    } ]);
})();

(function() {
    "use strict";
    var module = angular.module("ui.grid.selection", [ "ui.grid" ]);
    module.constant("uiGridSelectionConstants", {
        "featureName": "selection",
        "selectionRowHeaderColName": "selectionRowHeaderCol"
    });
    angular.module("ui.grid").config([ "$provide", function($provide) {
        $provide.decorator("GridRow", [ "$delegate", function($delegate) {
            $delegate.prototype.setSelected = function(selected) {
                this.isSelected = selected;
                if (selected) {
                    this.grid.selection.selectedCount++;
                } else {
                    this.grid.selection.selectedCount--;
                }
            };
            return $delegate;
        } ]);
    } ]);
    module.service("uiGridSelectionService", [ "$q", "$templateCache", "uiGridSelectionConstants", "gridUtil", function($q, $templateCache, uiGridSelectionConstants, gridUtil) {
        var service = {
            "initializeGrid": function(grid) {
                grid.selection = {};
                grid.selection.lastSelectedRow = null;
                grid.selection.selectAll = false;
                grid.selection.selectedCount = 0;
                service.defaultGridOptions(grid.options);
                var publicApi = {
                    "events": {
                        "selection": {
                            "rowSelectionChanged": function(scope, row, evt) {},
                            "rowSelectionChangedBatch": function(scope, rows, evt) {}
                        }
                    },
                    "methods": {
                        "selection": {
                            "toggleRowSelection": function(rowEntity, evt) {
                                var row = grid.getRow(rowEntity);
                                if (row !== null) {
                                    service.toggleRowSelection(grid, row, evt, grid.options.multiSelect, grid.options.noUnselect);
                                }
                            },
                            "selectRow": function(rowEntity, evt) {
                                var row = grid.getRow(rowEntity);
                                if (row !== null && !row.isSelected) {
                                    service.toggleRowSelection(grid, row, evt, grid.options.multiSelect, grid.options.noUnselect);
                                }
                            },
                            "selectRowByVisibleIndex": function(rowNum, evt) {
                                var row = grid.renderContainers.body.visibleRowCache[rowNum];
                                if (row !== null && typeof row !== "undefined" && !row.isSelected) {
                                    service.toggleRowSelection(grid, row, evt, grid.options.multiSelect, grid.options.noUnselect);
                                }
                            },
                            "unSelectRow": function(rowEntity, evt) {
                                var row = grid.getRow(rowEntity);
                                if (row !== null && row.isSelected) {
                                    service.toggleRowSelection(grid, row, evt, grid.options.multiSelect, grid.options.noUnselect);
                                }
                            },
                            "selectAllRows": function(evt) {
                                if (grid.options.multiSelect === false) {
                                    return;
                                }
                                var changedRows = [];
                                grid.rows.forEach(function(row) {
                                    if (!row.isSelected && row.enableSelection !== false) {
                                        row.setSelected(true);
                                        service.decideRaiseSelectionEvent(grid, row, changedRows, evt);
                                    }
                                });
                                service.decideRaiseSelectionBatchEvent(grid, changedRows, evt);
                                grid.selection.selectAll = true;
                            },
                            "selectAllVisibleRows": function(evt) {
                                if (grid.options.multiSelect === false) {
                                    return;
                                }
                                var changedRows = [];
                                grid.rows.forEach(function(row) {
                                    if (row.visible) {
                                        if (!row.isSelected && row.enableSelection !== false) {
                                            row.setSelected(true);
                                            service.decideRaiseSelectionEvent(grid, row, changedRows, evt);
                                        }
                                    } else {
                                        if (row.isSelected) {
                                            row.setSelected(false);
                                            service.decideRaiseSelectionEvent(grid, row, changedRows, evt);
                                        }
                                    }
                                });
                                service.decideRaiseSelectionBatchEvent(grid, changedRows, evt);
                                grid.selection.selectAll = true;
                            },
                            "clearSelectedRows": function(evt) {
                                service.clearSelectedRows(grid, evt);
                            },
                            "getSelectedRows": function() {
                                return service.getSelectedRows(grid).map(function(gridRow) {
                                    return gridRow.entity;
                                });
                            },
                            "getSelectedGridRows": function() {
                                return service.getSelectedRows(grid);
                            },
                            "getSelectedCount": function() {
                                return grid.selection.selectedCount;
                            },
                            "setMultiSelect": function(multiSelect) {
                                grid.options.multiSelect = multiSelect;
                            },
                            "setModifierKeysToMultiSelect": function(modifierKeysToMultiSelect) {
                                grid.options.modifierKeysToMultiSelect = modifierKeysToMultiSelect;
                            },
                            "getSelectAllState": function() {
                                return grid.selection.selectAll;
                            }
                        }
                    }
                };
                grid.api.registerEventsFromObject(publicApi.events);
                grid.api.registerMethodsFromObject(publicApi.methods);
            },
            "defaultGridOptions": function(gridOptions) {
                gridOptions.enableRowSelection = gridOptions.enableRowSelection !== false;
                gridOptions.multiSelect = gridOptions.multiSelect !== false;
                gridOptions.noUnselect = gridOptions.noUnselect === true;
                gridOptions.modifierKeysToMultiSelect = gridOptions.modifierKeysToMultiSelect === true;
                gridOptions.enableRowHeaderSelection = gridOptions.enableRowHeaderSelection !== false;
                if (typeof gridOptions.enableFullRowSelection === "undefined") {
                    gridOptions.enableFullRowSelection = !gridOptions.enableRowHeaderSelection;
                }
                gridOptions.enableSelectAll = gridOptions.enableSelectAll !== false;
                gridOptions.enableSelectionBatchEvent = gridOptions.enableSelectionBatchEvent !== false;
                gridOptions.selectionRowHeaderWidth = angular.isDefined(gridOptions.selectionRowHeaderWidth) ? gridOptions.selectionRowHeaderWidth : 30;
                gridOptions.enableFooterTotalSelected = gridOptions.enableFooterTotalSelected !== false;
                gridOptions.isRowSelectable = angular.isDefined(gridOptions.isRowSelectable) ? gridOptions.isRowSelectable : angular.noop;
            },
            "toggleRowSelection": function(grid, row, evt, multiSelect, noUnselect) {
                var selected = row.isSelected;
                if (row.enableSelection === false && !selected) {
                    return;
                }
                var selectedRows;
                if (!multiSelect && !selected) {
                    service.clearSelectedRows(grid, evt);
                } else if (!multiSelect && selected) {
                    selectedRows = service.getSelectedRows(grid);
                    if (selectedRows.length > 1) {
                        selected = false;
                        service.clearSelectedRows(grid, evt);
                    }
                }
                if (selected && noUnselect) {} else {
                    row.setSelected(!selected);
                    if (row.isSelected === true) {
                        grid.selection.lastSelectedRow = row;
                    }
                    selectedRows = service.getSelectedRows(grid);
                    grid.selection.selectAll = grid.rows.length === selectedRows.length;
                    grid.api.selection.raise.rowSelectionChanged(row, evt);
                }
            },
            "shiftSelect": function(grid, row, evt, multiSelect) {
                if (!multiSelect) {
                    return;
                }
                var selectedRows = service.getSelectedRows(grid);
                var fromRow = selectedRows.length > 0 ? grid.renderContainers.body.visibleRowCache.indexOf(grid.selection.lastSelectedRow) : 0;
                var toRow = grid.renderContainers.body.visibleRowCache.indexOf(row);
                if (fromRow > toRow) {
                    var tmp = fromRow;
                    fromRow = toRow;
                    toRow = tmp;
                }
                var changedRows = [];
                for (var i = fromRow; i <= toRow; i++) {
                    var rowToSelect = grid.renderContainers.body.visibleRowCache[i];
                    if (rowToSelect) {
                        if (!rowToSelect.isSelected && rowToSelect.enableSelection !== false) {
                            rowToSelect.setSelected(true);
                            grid.selection.lastSelectedRow = rowToSelect;
                            service.decideRaiseSelectionEvent(grid, rowToSelect, changedRows, evt);
                        }
                    }
                }
                service.decideRaiseSelectionBatchEvent(grid, changedRows, evt);
            },
            "getSelectedRows": function(grid) {
                return grid.rows.filter(function(row) {
                    return row.isSelected;
                });
            },
            "clearSelectedRows": function(grid, evt) {
                var changedRows = [];
                service.getSelectedRows(grid).forEach(function(row) {
                    if (row.isSelected) {
                        row.setSelected(false);
                        service.decideRaiseSelectionEvent(grid, row, changedRows, evt);
                    }
                });
                service.decideRaiseSelectionBatchEvent(grid, changedRows, evt);
                grid.selection.selectAll = false;
                grid.selection.selectedCount = 0;
            },
            "decideRaiseSelectionEvent": function(grid, row, changedRows, evt) {
                if (!grid.options.enableSelectionBatchEvent) {
                    grid.api.selection.raise.rowSelectionChanged(row, evt);
                } else {
                    changedRows.push(row);
                }
            },
            "decideRaiseSelectionBatchEvent": function(grid, changedRows, evt) {
                if (changedRows.length > 0) {
                    grid.api.selection.raise.rowSelectionChangedBatch(changedRows, evt);
                }
            }
        };
        return service;
    } ]);
    module.directive("uiGridSelection", [ "uiGridSelectionConstants", "uiGridSelectionService", "$templateCache", "uiGridConstants", function(uiGridSelectionConstants, uiGridSelectionService, $templateCache, uiGridConstants) {
        return {
            "replace": true,
            "priority": 0,
            "require": "^uiGrid",
            "scope": false,
            "compile": function() {
                return {
                    "pre": function($scope, $elm, $attrs, uiGridCtrl) {
                        uiGridSelectionService.initializeGrid(uiGridCtrl.grid);
                        if (uiGridCtrl.grid.options.enableRowHeaderSelection) {
                            var selectionRowHeaderDef = {
                                "name": uiGridSelectionConstants.selectionRowHeaderColName,
                                "displayName": "",
                                "width": uiGridCtrl.grid.options.selectionRowHeaderWidth,
                                "minWidth": 10,
                                "cellTemplate": "ui-grid/selectionRowHeader",
                                "headerCellTemplate": "ui-grid/selectionHeaderCell",
                                "enableColumnResizing": false,
                                "enableColumnMenu": false,
                                "exporterSuppressExport": true,
                                "allowCellFocus": true
                            };
                            uiGridCtrl.grid.addRowHeaderColumn(selectionRowHeaderDef);
                        }
                        var processorSet = false;
                        var processSelectableRows = function(rows) {
                            rows.forEach(function(row) {
                                row.enableSelection = uiGridCtrl.grid.options.isRowSelectable(row);
                            });
                            return rows;
                        };
                        var updateOptions = function() {
                            if (uiGridCtrl.grid.options.isRowSelectable !== angular.noop && processorSet !== true) {
                                uiGridCtrl.grid.registerRowsProcessor(processSelectableRows, 500);
                                processorSet = true;
                            }
                        };
                        updateOptions();
                        var dataChangeDereg = uiGridCtrl.grid.registerDataChangeCallback(updateOptions, [ uiGridConstants.dataChange.OPTIONS ]);
                        $scope.$on("$destroy", dataChangeDereg);
                    },
                    "post": function($scope, $elm, $attrs, uiGridCtrl) {}
                };
            }
        };
    } ]);
    module.directive("uiGridSelectionRowHeaderButtons", [ "$templateCache", "uiGridSelectionService", "gridUtil", function($templateCache, uiGridSelectionService, gridUtil) {
        return {
            "replace": true,
            "restrict": "E",
            "template": $templateCache.get("ui-grid/selectionRowHeaderButtons"),
            "scope": true,
            "require": "^uiGrid",
            "link": function($scope, $elm, $attrs, uiGridCtrl) {
                var self = uiGridCtrl.grid;
                $scope.selectButtonClick = selectButtonClick;
                if (gridUtil.detectBrowser() === "ie") {
                    $elm.on("mousedown", selectButtonMouseDown);
                }
                function selectButtonClick(row, evt) {
                    evt.stopPropagation();
                    if (evt.shiftKey) {
                        uiGridSelectionService.shiftSelect(self, row, evt, self.options.multiSelect);
                    } else if (evt.ctrlKey || evt.metaKey) {
                        uiGridSelectionService.toggleRowSelection(self, row, evt, self.options.multiSelect, self.options.noUnselect);
                    } else {
                        uiGridSelectionService.toggleRowSelection(self, row, evt, self.options.multiSelect && !self.options.modifierKeysToMultiSelect, self.options.noUnselect);
                    }
                }
                function selectButtonMouseDown(evt) {
                    if (evt.ctrlKey || evt.shiftKey) {
                        evt.target.onselectstart = function() {
                            return false;
                        };
                        window.setTimeout(function() {
                            evt.target.onselectstart = null;
                        }, 0);
                    }
                }
            }
        };
    } ]);
    module.directive("uiGridSelectionSelectAllButtons", [ "$templateCache", "uiGridSelectionService", function($templateCache, uiGridSelectionService) {
        return {
            "replace": true,
            "restrict": "E",
            "template": $templateCache.get("ui-grid/selectionSelectAllButtons"),
            "scope": false,
            "link": function($scope, $elm, $attrs, uiGridCtrl) {
                var self = $scope.col.grid;
                $scope.headerButtonClick = function(row, evt) {
                    if (self.selection.selectAll) {
                        uiGridSelectionService.clearSelectedRows(self, evt);
                        if (self.options.noUnselect) {
                            self.api.selection.selectRowByVisibleIndex(0, evt);
                        }
                        self.selection.selectAll = false;
                    } else {
                        if (self.options.multiSelect) {
                            self.api.selection.selectAllVisibleRows(evt);
                            self.selection.selectAll = true;
                        }
                    }
                };
            }
        };
    } ]);
    module.directive("uiGridViewport", [ "$compile", "uiGridConstants", "uiGridSelectionConstants", "gridUtil", "$parse", "uiGridSelectionService", function($compile, uiGridConstants, uiGridSelectionConstants, gridUtil, $parse, uiGridSelectionService) {
        return {
            "priority": -200,
            "scope": false,
            "compile": function($elm, $attrs) {
                var rowRepeatDiv = angular.element($elm.children().children()[0]);
                var existingNgClass = rowRepeatDiv.attr("ng-class");
                var newNgClass = "";
                if (existingNgClass) {
                    newNgClass = existingNgClass.slice(0, -1) + ",'ui-grid-row-selected': row.isSelected}";
                } else {
                    newNgClass = "{'ui-grid-row-selected': row.isSelected}";
                }
                rowRepeatDiv.attr("ng-class", newNgClass);
                return {
                    "pre": function($scope, $elm, $attrs, controllers) {},
                    "post": function($scope, $elm, $attrs, controllers) {}
                };
            }
        };
    } ]);
    module.directive("uiGridCell", [ "$compile", "uiGridConstants", "uiGridSelectionConstants", "gridUtil", "$parse", "uiGridSelectionService", "$timeout", function($compile, uiGridConstants, uiGridSelectionConstants, gridUtil, $parse, uiGridSelectionService, $timeout) {
        return {
            "priority": -200,
            "restrict": "A",
            "require": "?^uiGrid",
            "scope": false,
            "link": function($scope, $elm, $attrs, uiGridCtrl) {
                var touchStartTime = 0;
                var touchTimeout = 300;
                if (uiGridCtrl.grid.api.cellNav) {
                    uiGridCtrl.grid.api.cellNav.on.viewPortKeyDown($scope, function(evt, rowCol) {
                        if (rowCol === null || rowCol.row !== $scope.row || rowCol.col !== $scope.col) {
                            return;
                        }
                        if (evt.keyCode === 32 && $scope.col.colDef.name === "selectionRowHeaderCol") {
                            uiGridSelectionService.toggleRowSelection($scope.grid, $scope.row, evt, $scope.grid.options.multiSelect && !$scope.grid.options.modifierKeysToMultiSelect, $scope.grid.options.noUnselect);
                            $scope.$apply();
                        }
                    });
                }
                var selectCells = function(evt) {
                    $elm.off("touchend", touchEnd);
                    if (evt.shiftKey) {
                        uiGridSelectionService.shiftSelect($scope.grid, $scope.row, evt, $scope.grid.options.multiSelect);
                    } else if (evt.ctrlKey || evt.metaKey) {
                        uiGridSelectionService.toggleRowSelection($scope.grid, $scope.row, evt, $scope.grid.options.multiSelect, $scope.grid.options.noUnselect);
                    } else {
                        uiGridSelectionService.toggleRowSelection($scope.grid, $scope.row, evt, $scope.grid.options.multiSelect && !$scope.grid.options.modifierKeysToMultiSelect, $scope.grid.options.noUnselect);
                    }
                    $scope.$apply();
                    $timeout(function() {
                        $elm.on("touchend", touchEnd);
                    }, touchTimeout);
                };
                var touchStart = function(evt) {
                    touchStartTime = new Date().getTime();
                    $elm.off("click", selectCells);
                };
                var touchEnd = function(evt) {
                    var touchEndTime = new Date().getTime();
                    var touchTime = touchEndTime - touchStartTime;
                    if (touchTime < touchTimeout) {
                        selectCells(evt);
                    }
                    $timeout(function() {
                        $elm.on("click", selectCells);
                    }, touchTimeout);
                };
                function registerRowSelectionEvents() {
                    if ($scope.grid.options.enableRowSelection && $scope.grid.options.enableFullRowSelection) {
                        $elm.addClass("ui-grid-disable-selection");
                        $elm.on("touchstart", touchStart);
                        $elm.on("touchend", touchEnd);
                        $elm.on("click", selectCells);
                        $scope.registered = true;
                    }
                }
                function deregisterRowSelectionEvents() {
                    if ($scope.registered) {
                        $elm.removeClass("ui-grid-disable-selection");
                        $elm.off("touchstart", touchStart);
                        $elm.off("touchend", touchEnd);
                        $elm.off("click", selectCells);
                        $scope.registered = false;
                    }
                }
                registerRowSelectionEvents();
                var dataChangeDereg = $scope.grid.registerDataChangeCallback(function() {
                    if ($scope.grid.options.enableRowSelection && $scope.grid.options.enableFullRowSelection && !$scope.registered) {
                        registerRowSelectionEvents();
                    } else if ((!$scope.grid.options.enableRowSelection || !$scope.grid.options.enableFullRowSelection) && $scope.registered) {
                        deregisterRowSelectionEvents();
                    }
                }, [ uiGridConstants.dataChange.OPTIONS ]);
                $elm.on("$destroy", dataChangeDereg);
            }
        };
    } ]);
    module.directive("uiGridGridFooter", [ "$compile", "uiGridConstants", "gridUtil", function($compile, uiGridConstants, gridUtil) {
        return {
            "restrict": "EA",
            "replace": true,
            "priority": -1e3,
            "require": "^uiGrid",
            "scope": true,
            "compile": function($elm, $attrs) {
                return {
                    "pre": function($scope, $elm, $attrs, uiGridCtrl) {
                        if (!uiGridCtrl.grid.options.showGridFooter) {
                            return;
                        }
                        gridUtil.getTemplate("ui-grid/gridFooterSelectedItems").then(function(contents) {
                            var template = angular.element(contents);
                            var newElm = $compile(template)($scope);
                            angular.element($elm[0].getElementsByClassName("ui-grid-grid-footer")[0]).append(newElm);
                        });
                    },
                    "post": function($scope, $elm, $attrs, controllers) {}
                };
            }
        };
    } ]);
})();

(function() {
    "use strict";
    var module = angular.module("ui.grid.treeBase", [ "ui.grid" ]);
    module.constant("uiGridTreeBaseConstants", {
        "featureName": "treeBase",
        "rowHeaderColName": "treeBaseRowHeaderCol",
        "EXPANDED": "expanded",
        "COLLAPSED": "collapsed",
        "aggregation": {
            "COUNT": "count",
            "SUM": "sum",
            "MAX": "max",
            "MIN": "min",
            "AVG": "avg"
        }
    });
    module.service("uiGridTreeBaseService", [ "$q", "uiGridTreeBaseConstants", "gridUtil", "GridRow", "gridClassFactory", "i18nService", "uiGridConstants", "rowSorter", function($q, uiGridTreeBaseConstants, gridUtil, GridRow, gridClassFactory, i18nService, uiGridConstants, rowSorter) {
        var service = {
            "initializeGrid": function(grid, $scope) {
                grid.treeBase = {};
                grid.treeBase.numberLevels = 0;
                grid.treeBase.expandAll = false;
                grid.treeBase.tree = [];
                service.defaultGridOptions(grid.options);
                grid.registerRowsProcessor(service.treeRows, 410);
                grid.registerColumnBuilder(service.treeBaseColumnBuilder);
                service.createRowHeader(grid);
                var publicApi = {
                    "events": {
                        "treeBase": {
                            "rowExpanded": {},
                            "rowCollapsed": {}
                        }
                    },
                    "methods": {
                        "treeBase": {
                            "expandAllRows": function() {
                                service.expandAllRows(grid);
                            },
                            "collapseAllRows": function() {
                                service.collapseAllRows(grid);
                            },
                            "toggleRowTreeState": function(row) {
                                service.toggleRowTreeState(grid, row);
                            },
                            "expandRow": function(row) {
                                service.expandRow(grid, row);
                            },
                            "expandRowChildren": function(row) {
                                service.expandRowChildren(grid, row);
                            },
                            "collapseRow": function(row) {
                                service.collapseRow(grid, row);
                            },
                            "collapseRowChildren": function(row) {
                                service.collapseRowChildren(grid, row);
                            },
                            "getTreeExpandedState": function() {
                                return {
                                    "expandedState": service.getTreeState(grid)
                                };
                            },
                            "setTreeState": function(config) {
                                service.setTreeState(grid, config);
                            },
                            "getRowChildren": function(row) {
                                return row.treeNode.children.map(function(childNode) {
                                    return childNode.row;
                                });
                            }
                        }
                    }
                };
                grid.api.registerEventsFromObject(publicApi.events);
                grid.api.registerMethodsFromObject(publicApi.methods);
            },
            "defaultGridOptions": function(gridOptions) {
                gridOptions.treeRowHeaderBaseWidth = gridOptions.treeRowHeaderBaseWidth || 30;
                gridOptions.treeIndent = gridOptions.treeIndent || 10;
                gridOptions.showTreeRowHeader = gridOptions.showTreeRowHeader !== false;
                gridOptions.showTreeExpandNoChildren = gridOptions.showTreeExpandNoChildren !== false;
                gridOptions.treeRowHeaderAlwaysVisible = gridOptions.treeRowHeaderAlwaysVisible !== false;
                gridOptions.treeCustomAggregations = gridOptions.treeCustomAggregations || {};
                gridOptions.enableExpandAll = gridOptions.enableExpandAll !== false;
            },
            "treeBaseColumnBuilder": function(colDef, col, gridOptions) {
                if (typeof colDef.customTreeAggregationFn !== "undefined") {
                    col.treeAggregationFn = colDef.customTreeAggregationFn;
                }
                if (typeof colDef.treeAggregationType !== "undefined") {
                    col.treeAggregation = {
                        "type": colDef.treeAggregationType
                    };
                    if (typeof gridOptions.treeCustomAggregations[colDef.treeAggregationType] !== "undefined") {
                        col.treeAggregationFn = gridOptions.treeCustomAggregations[colDef.treeAggregationType].aggregationFn;
                        col.treeAggregationFinalizerFn = gridOptions.treeCustomAggregations[colDef.treeAggregationType].finalizerFn;
                        col.treeAggregation.label = gridOptions.treeCustomAggregations[colDef.treeAggregationType].label;
                    } else if (typeof service.nativeAggregations()[colDef.treeAggregationType] !== "undefined") {
                        col.treeAggregationFn = service.nativeAggregations()[colDef.treeAggregationType].aggregationFn;
                        col.treeAggregation.label = service.nativeAggregations()[colDef.treeAggregationType].label;
                    }
                }
                if (typeof colDef.treeAggregationLabel !== "undefined") {
                    if (typeof col.treeAggregation === "undefined") {
                        col.treeAggregation = {};
                    }
                    col.treeAggregation.label = colDef.treeAggregationLabel;
                }
                col.treeAggregationUpdateEntity = colDef.treeAggregationUpdateEntity !== false;
                if (typeof col.customTreeAggregationFinalizerFn === "undefined") {
                    col.customTreeAggregationFinalizerFn = colDef.customTreeAggregationFinalizerFn;
                }
            },
            "createRowHeader": function(grid) {
                var rowHeaderColumnDef = {
                    "name": uiGridTreeBaseConstants.rowHeaderColName,
                    "displayName": "",
                    "width": grid.options.treeRowHeaderBaseWidth,
                    "minWidth": 10,
                    "cellTemplate": "ui-grid/treeBaseRowHeader",
                    "headerCellTemplate": "ui-grid/treeBaseHeaderCell",
                    "enableColumnResizing": false,
                    "enableColumnMenu": false,
                    "exporterSuppressExport": true,
                    "allowCellFocus": true
                };
                rowHeaderColumnDef.visible = grid.options.treeRowHeaderAlwaysVisible;
                grid.addRowHeaderColumn(rowHeaderColumnDef);
            },
            "expandAllRows": function(grid) {
                grid.treeBase.tree.forEach(function(node) {
                    service.setAllNodes(grid, node, uiGridTreeBaseConstants.EXPANDED);
                });
                grid.treeBase.expandAll = true;
                grid.queueGridRefresh();
            },
            "collapseAllRows": function(grid) {
                grid.treeBase.tree.forEach(function(node) {
                    service.setAllNodes(grid, node, uiGridTreeBaseConstants.COLLAPSED);
                });
                grid.treeBase.expandAll = false;
                grid.queueGridRefresh();
            },
            "setAllNodes": function(grid, treeNode, targetState) {
                if (typeof treeNode.state !== "undefined" && treeNode.state !== targetState) {
                    treeNode.state = targetState;
                    if (targetState === uiGridTreeBaseConstants.EXPANDED) {
                        grid.api.treeBase.raise.rowExpanded(treeNode.row);
                    } else {
                        grid.api.treeBase.raise.rowCollapsed(treeNode.row);
                    }
                }
                if (treeNode.children) {
                    treeNode.children.forEach(function(childNode) {
                        service.setAllNodes(grid, childNode, targetState);
                    });
                }
            },
            "toggleRowTreeState": function(grid, row) {
                if (typeof row.treeLevel === "undefined" || row.treeLevel === null || row.treeLevel < 0) {
                    return;
                }
                if (row.treeNode.state === uiGridTreeBaseConstants.EXPANDED) {
                    service.collapseRow(grid, row);
                } else {
                    service.expandRow(grid, row);
                }
                grid.queueGridRefresh();
            },
            "expandRow": function(grid, row) {
                if (typeof row.treeLevel === "undefined" || row.treeLevel === null || row.treeLevel < 0) {
                    return;
                }
                if (row.treeNode.state !== uiGridTreeBaseConstants.EXPANDED) {
                    row.treeNode.state = uiGridTreeBaseConstants.EXPANDED;
                    grid.api.treeBase.raise.rowExpanded(row);
                    grid.treeBase.expandAll = service.allExpanded(grid.treeBase.tree);
                    grid.queueGridRefresh();
                }
            },
            "expandRowChildren": function(grid, row) {
                if (typeof row.treeLevel === "undefined" || row.treeLevel === null || row.treeLevel < 0) {
                    return;
                }
                service.setAllNodes(grid, row.treeNode, uiGridTreeBaseConstants.EXPANDED);
                grid.treeBase.expandAll = service.allExpanded(grid.treeBase.tree);
                grid.queueGridRefresh();
            },
            "collapseRow": function(grid, row) {
                if (typeof row.treeLevel === "undefined" || row.treeLevel === null || row.treeLevel < 0) {
                    return;
                }
                if (row.treeNode.state !== uiGridTreeBaseConstants.COLLAPSED) {
                    row.treeNode.state = uiGridTreeBaseConstants.COLLAPSED;
                    grid.treeBase.expandAll = false;
                    grid.api.treeBase.raise.rowCollapsed(row);
                    grid.queueGridRefresh();
                }
            },
            "collapseRowChildren": function(grid, row) {
                if (typeof row.treeLevel === "undefined" || row.treeLevel === null || row.treeLevel < 0) {
                    return;
                }
                service.setAllNodes(grid, row.treeNode, uiGridTreeBaseConstants.COLLAPSED);
                grid.treeBase.expandAll = false;
                grid.queueGridRefresh();
            },
            "allExpanded": function(tree) {
                var allExpanded = true;
                tree.forEach(function(node) {
                    if (!service.allExpandedInternal(node)) {
                        allExpanded = false;
                    }
                });
                return allExpanded;
            },
            "allExpandedInternal": function(treeNode) {
                if (treeNode.children && treeNode.children.length > 0) {
                    if (treeNode.state === uiGridTreeBaseConstants.COLLAPSED) {
                        return false;
                    }
                    var allExpanded = true;
                    treeNode.children.forEach(function(node) {
                        if (!service.allExpandedInternal(node)) {
                            allExpanded = false;
                        }
                    });
                    return allExpanded;
                } else {
                    return true;
                }
            },
            "treeRows": function(renderableRows) {
                if (renderableRows.length === 0) {
                    return renderableRows;
                }
                var grid = this;
                var currentLevel = 0;
                var currentState = uiGridTreeBaseConstants.EXPANDED;
                var parents = [];
                grid.treeBase.tree = service.createTree(grid, renderableRows);
                service.updateRowHeaderWidth(grid);
                service.sortTree(grid);
                service.fixFilter(grid);
                return service.renderTree(grid.treeBase.tree);
            },
            "updateRowHeaderWidth": function(grid) {
                var rowHeader = grid.getColumn(uiGridTreeBaseConstants.rowHeaderColName);
                var newWidth = grid.options.treeRowHeaderBaseWidth + grid.options.treeIndent * Math.max(grid.treeBase.numberLevels - 1, 0);
                if (rowHeader && newWidth !== rowHeader.width) {
                    rowHeader.width = newWidth;
                    grid.queueRefresh();
                }
                var newVisibility = true;
                if (grid.options.showTreeRowHeader === false) {
                    newVisibility = false;
                }
                if (grid.options.treeRowHeaderAlwaysVisible === false && grid.treeBase.numberLevels <= 0) {
                    newVisibility = false;
                }
                if (rowHeader.visible !== newVisibility) {
                    rowHeader.visible = newVisibility;
                    rowHeader.colDef.visible = newVisibility;
                    grid.queueGridRefresh();
                }
            },
            "renderTree": function(nodeList) {
                var renderableRows = [];
                nodeList.forEach(function(node) {
                    if (node.row.visible) {
                        renderableRows.push(node.row);
                    }
                    if (node.state === uiGridTreeBaseConstants.EXPANDED && node.children && node.children.length > 0) {
                        renderableRows = renderableRows.concat(service.renderTree(node.children));
                    }
                });
                return renderableRows;
            },
            "createTree": function(grid, renderableRows) {
                var currentLevel = -1;
                var parents = [];
                var currentState;
                grid.treeBase.tree = [];
                grid.treeBase.numberLevels = 0;
                var aggregations = service.getAggregations(grid);
                var createNode = function(row) {
                    if (typeof row.entity.$$treeLevel !== "undefined" && row.treeLevel !== row.entity.$$treeLevel) {
                        row.treeLevel = row.entity.$$treeLevel;
                    }
                    if (row.treeLevel <= currentLevel) {
                        while (row.treeLevel <= currentLevel) {
                            var lastParent = parents.pop();
                            service.finaliseAggregations(lastParent);
                            currentLevel--;
                        }
                        if (parents.length > 0) {
                            currentState = service.setCurrentState(parents);
                        } else {
                            currentState = uiGridTreeBaseConstants.EXPANDED;
                        }
                    }
                    if ((typeof row.treeLevel === "undefined" || row.treeLevel === null || row.treeLevel < 0) && row.visible) {
                        service.aggregate(grid, row, parents);
                    }
                    service.addOrUseNode(grid, row, parents, aggregations);
                    if (typeof row.treeLevel !== "undefined" && row.treeLevel !== null && row.treeLevel >= 0) {
                        parents.push(row);
                        currentLevel++;
                        currentState = service.setCurrentState(parents);
                    }
                    if (grid.treeBase.numberLevels < row.treeLevel + 1) {
                        grid.treeBase.numberLevels = row.treeLevel + 1;
                    }
                };
                renderableRows.forEach(createNode);
                while (parents.length > 0) {
                    var lastParent = parents.pop();
                    service.finaliseAggregations(lastParent);
                }
                return grid.treeBase.tree;
            },
            "addOrUseNode": function(grid, row, parents, aggregationBase) {
                var newAggregations = [];
                aggregationBase.forEach(function(aggregation) {
                    newAggregations.push(service.buildAggregationObject(aggregation.col));
                });
                var newNode = {
                    "state": uiGridTreeBaseConstants.COLLAPSED,
                    "row": row,
                    "parentRow": null,
                    "aggregations": newAggregations,
                    "children": []
                };
                if (row.treeNode) {
                    newNode.state = row.treeNode.state;
                }
                if (parents.length > 0) {
                    newNode.parentRow = parents[parents.length - 1];
                }
                row.treeNode = newNode;
                if (parents.length === 0) {
                    grid.treeBase.tree.push(newNode);
                } else {
                    parents[parents.length - 1].treeNode.children.push(newNode);
                }
            },
            "setCurrentState": function(parents) {
                var currentState = uiGridTreeBaseConstants.EXPANDED;
                parents.forEach(function(parent) {
                    if (parent.treeNode.state === uiGridTreeBaseConstants.COLLAPSED) {
                        currentState = uiGridTreeBaseConstants.COLLAPSED;
                    }
                });
                return currentState;
            },
            "sortTree": function(grid) {
                grid.columns.forEach(function(column) {
                    if (column.sort && column.sort.ignoreSort) {
                        delete column.sort.ignoreSort;
                    }
                });
                grid.treeBase.tree = service.sortInternal(grid, grid.treeBase.tree);
            },
            "sortInternal": function(grid, treeList) {
                var rows = treeList.map(function(node) {
                    return node.row;
                });
                rows = rowSorter.sort(grid, rows, grid.columns);
                var treeNodes = rows.map(function(row) {
                    return row.treeNode;
                });
                treeNodes.forEach(function(node) {
                    if (node.state === uiGridTreeBaseConstants.EXPANDED && node.children && node.children.length > 0) {
                        node.children = service.sortInternal(grid, node.children);
                    }
                });
                return treeNodes;
            },
            "fixFilter": function(grid) {
                var parentsVisible;
                grid.treeBase.tree.forEach(function(node) {
                    if (node.children && node.children.length > 0) {
                        parentsVisible = node.row.visible;
                        service.fixFilterInternal(node.children, parentsVisible);
                    }
                });
            },
            "fixFilterInternal": function(nodes, parentsVisible) {
                nodes.forEach(function(node) {
                    if (node.row.visible && !parentsVisible) {
                        service.setParentsVisible(node);
                        parentsVisible = true;
                    }
                    if (node.children && node.children.length > 0) {
                        if (service.fixFilterInternal(node.children, parentsVisible && node.row.visible)) {
                            parentsVisible = true;
                        }
                    }
                });
                return parentsVisible;
            },
            "setParentsVisible": function(node) {
                while (node.parentRow) {
                    node.parentRow.visible = true;
                    node = node.parentRow.treeNode;
                }
            },
            "buildAggregationObject": function(column) {
                var newAggregation = {
                    "col": column
                };
                if (column.treeAggregation && column.treeAggregation.type) {
                    newAggregation.type = column.treeAggregation.type;
                }
                if (column.treeAggregation && column.treeAggregation.label) {
                    newAggregation.label = column.treeAggregation.label;
                }
                return newAggregation;
            },
            "getAggregations": function(grid) {
                var aggregateArray = [];
                grid.columns.forEach(function(column) {
                    if (typeof column.treeAggregationFn !== "undefined") {
                        aggregateArray.push(service.buildAggregationObject(column));
                        if (grid.options.showColumnFooter && typeof column.colDef.aggregationType === "undefined" && column.treeAggregation) {
                            column.treeFooterAggregation = service.buildAggregationObject(column);
                            column.aggregationType = service.treeFooterAggregationType;
                        }
                    }
                });
                return aggregateArray;
            },
            "aggregate": function(grid, row, parents) {
                if (parents.length === 0 && row.treeNode && row.treeNode.aggregations) {
                    row.treeNode.aggregations.forEach(function(aggregation) {
                        if (typeof aggregation.col.treeFooterAggregation !== "undefined") {
                            var fieldValue = grid.getCellValue(row, aggregation.col);
                            var numValue = Number(fieldValue);
                            aggregation.col.treeAggregationFn(aggregation.col.treeFooterAggregation, fieldValue, numValue, row);
                        }
                    });
                }
                parents.forEach(function(parent, index) {
                    if (parent.treeNode.aggregations) {
                        parent.treeNode.aggregations.forEach(function(aggregation) {
                            var fieldValue = grid.getCellValue(row, aggregation.col);
                            var numValue = Number(fieldValue);
                            aggregation.col.treeAggregationFn(aggregation, fieldValue, numValue, row);
                            if (index === 0 && typeof aggregation.col.treeFooterAggregation !== "undefined") {
                                aggregation.col.treeAggregationFn(aggregation.col.treeFooterAggregation, fieldValue, numValue, row);
                            }
                        });
                    }
                });
            },
            "nativeAggregations": function() {
                var nativeAggregations = {
                    "count": {
                        "label": i18nService.get().aggregation.count,
                        "menuTitle": i18nService.get().grouping.aggregate_count,
                        "aggregationFn": function(aggregation, fieldValue, numValue) {
                            if (typeof aggregation.value === "undefined") {
                                aggregation.value = 1;
                            } else {
                                aggregation.value++;
                            }
                        }
                    },
                    "sum": {
                        "label": i18nService.get().aggregation.sum,
                        "menuTitle": i18nService.get().grouping.aggregate_sum,
                        "aggregationFn": function(aggregation, fieldValue, numValue) {
                            if (!isNaN(numValue)) {
                                if (typeof aggregation.value === "undefined") {
                                    aggregation.value = numValue;
                                } else {
                                    aggregation.value += numValue;
                                }
                            }
                        }
                    },
                    "min": {
                        "label": i18nService.get().aggregation.min,
                        "menuTitle": i18nService.get().grouping.aggregate_min,
                        "aggregationFn": function(aggregation, fieldValue, numValue) {
                            if (typeof aggregation.value === "undefined") {
                                aggregation.value = fieldValue;
                            } else {
                                if (typeof fieldValue !== "undefined" && fieldValue !== null && (fieldValue < aggregation.value || aggregation.value === null)) {
                                    aggregation.value = fieldValue;
                                }
                            }
                        }
                    },
                    "max": {
                        "label": i18nService.get().aggregation.max,
                        "menuTitle": i18nService.get().grouping.aggregate_max,
                        "aggregationFn": function(aggregation, fieldValue, numValue) {
                            if (typeof aggregation.value === "undefined") {
                                aggregation.value = fieldValue;
                            } else {
                                if (typeof fieldValue !== "undefined" && fieldValue !== null && (fieldValue > aggregation.value || aggregation.value === null)) {
                                    aggregation.value = fieldValue;
                                }
                            }
                        }
                    },
                    "avg": {
                        "label": i18nService.get().aggregation.avg,
                        "menuTitle": i18nService.get().grouping.aggregate_avg,
                        "aggregationFn": function(aggregation, fieldValue, numValue) {
                            if (typeof aggregation.count === "undefined") {
                                aggregation.count = 1;
                            } else {
                                aggregation.count++;
                            }
                            if (isNaN(numValue)) {
                                return;
                            }
                            if (typeof aggregation.value === "undefined" || typeof aggregation.sum === "undefined") {
                                aggregation.value = numValue;
                                aggregation.sum = numValue;
                            } else {
                                aggregation.sum += numValue;
                                aggregation.value = aggregation.sum / aggregation.count;
                            }
                        }
                    }
                };
                return nativeAggregations;
            },
            "finaliseAggregation": function(row, aggregation) {
                if (aggregation.col.treeAggregationUpdateEntity && typeof row !== "undefined" && typeof row.entity["$$" + aggregation.col.uid] !== "undefined") {
                    angular.extend(aggregation, row.entity["$$" + aggregation.col.uid]);
                }
                if (typeof aggregation.col.treeAggregationFinalizerFn === "function") {
                    aggregation.col.treeAggregationFinalizerFn(aggregation);
                }
                if (typeof aggregation.col.customTreeAggregationFinalizerFn === "function") {
                    aggregation.col.customTreeAggregationFinalizerFn(aggregation);
                }
                if (typeof aggregation.rendered === "undefined") {
                    aggregation.rendered = aggregation.label ? aggregation.label + aggregation.value : aggregation.value;
                }
            },
            "finaliseAggregations": function(row) {
                if (typeof row.treeNode.aggregations === "undefined") {
                    return;
                }
                row.treeNode.aggregations.forEach(function(aggregation) {
                    service.finaliseAggregation(row, aggregation);
                    if (aggregation.col.treeAggregationUpdateEntity) {
                        var aggregationCopy = {};
                        angular.forEach(aggregation, function(value, key) {
                            if (aggregation.hasOwnProperty(key) && key !== "col") {
                                aggregationCopy[key] = value;
                            }
                        });
                        row.entity["$$" + aggregation.col.uid] = aggregationCopy;
                    }
                });
            },
            "treeFooterAggregationType": function(rows, column) {
                service.finaliseAggregation(undefined, column.treeFooterAggregation);
                if (typeof column.treeFooterAggregation.value === "undefined" || column.treeFooterAggregation.rendered === null) {
                    return "";
                }
                return column.treeFooterAggregation.rendered;
            }
        };
        return service;
    } ]);
    module.directive("uiGridTreeBaseRowHeaderButtons", [ "$templateCache", "uiGridTreeBaseService", function($templateCache, uiGridTreeBaseService) {
        return {
            "replace": true,
            "restrict": "E",
            "template": $templateCache.get("ui-grid/treeBaseRowHeaderButtons"),
            "scope": true,
            "require": "^uiGrid",
            "link": function($scope, $elm, $attrs, uiGridCtrl) {
                var self = uiGridCtrl.grid;
                $scope.treeButtonClick = function(row, evt) {
                    uiGridTreeBaseService.toggleRowTreeState(self, row, evt);
                };
            }
        };
    } ]);
    module.directive("uiGridTreeBaseExpandAllButtons", [ "$templateCache", "uiGridTreeBaseService", function($templateCache, uiGridTreeBaseService) {
        return {
            "replace": true,
            "restrict": "E",
            "template": $templateCache.get("ui-grid/treeBaseExpandAllButtons"),
            "scope": false,
            "link": function($scope, $elm, $attrs, uiGridCtrl) {
                var self = $scope.col.grid;
                $scope.headerButtonClick = function(row, evt) {
                    if (self.treeBase.expandAll) {
                        uiGridTreeBaseService.collapseAllRows(self, evt);
                    } else {
                        uiGridTreeBaseService.expandAllRows(self, evt);
                    }
                };
            }
        };
    } ]);
    module.directive("uiGridViewport", [ "$compile", "uiGridConstants", "gridUtil", "$parse", function($compile, uiGridConstants, gridUtil, $parse) {
        return {
            "priority": -200,
            "scope": false,
            "compile": function($elm, $attrs) {
                var rowRepeatDiv = angular.element($elm.children().children()[0]);
                var existingNgClass = rowRepeatDiv.attr("ng-class");
                var newNgClass = "";
                if (existingNgClass) {
                    newNgClass = existingNgClass.slice(0, -1) + ",'ui-grid-tree-header-row': row.treeLevel > -1}";
                } else {
                    newNgClass = "{'ui-grid-tree-header-row': row.treeLevel > -1}";
                }
                rowRepeatDiv.attr("ng-class", newNgClass);
                return {
                    "pre": function($scope, $elm, $attrs, controllers) {},
                    "post": function($scope, $elm, $attrs, controllers) {}
                };
            }
        };
    } ]);
})();

(function() {
    "use strict";
    var module = angular.module("ui.grid.treeView", [ "ui.grid", "ui.grid.treeBase" ]);
    module.constant("uiGridTreeViewConstants", {
        "featureName": "treeView",
        "rowHeaderColName": "treeBaseRowHeaderCol",
        "EXPANDED": "expanded",
        "COLLAPSED": "collapsed",
        "aggregation": {
            "COUNT": "count",
            "SUM": "sum",
            "MAX": "max",
            "MIN": "min",
            "AVG": "avg"
        }
    });
    module.service("uiGridTreeViewService", [ "$q", "uiGridTreeViewConstants", "uiGridTreeBaseConstants", "uiGridTreeBaseService", "gridUtil", "GridRow", "gridClassFactory", "i18nService", "uiGridConstants", function($q, uiGridTreeViewConstants, uiGridTreeBaseConstants, uiGridTreeBaseService, gridUtil, GridRow, gridClassFactory, i18nService, uiGridConstants) {
        var service = {
            "initializeGrid": function(grid, $scope) {
                uiGridTreeBaseService.initializeGrid(grid, $scope);
                grid.treeView = {};
                grid.registerRowsProcessor(service.adjustSorting, 60);
                var publicApi = {
                    "events": {
                        "treeView": {}
                    },
                    "methods": {
                        "treeView": {}
                    }
                };
                grid.api.registerEventsFromObject(publicApi.events);
                grid.api.registerMethodsFromObject(publicApi.methods);
            },
            "defaultGridOptions": function(gridOptions) {
                gridOptions.enableTreeView = gridOptions.enableTreeView !== false;
            },
            "adjustSorting": function(renderableRows) {
                var grid = this;
                grid.columns.forEach(function(column) {
                    if (column.sort) {
                        column.sort.ignoreSort = true;
                    }
                });
                return renderableRows;
            }
        };
        return service;
    } ]);
    module.directive("uiGridTreeView", [ "uiGridTreeViewConstants", "uiGridTreeViewService", "$templateCache", function(uiGridTreeViewConstants, uiGridTreeViewService, $templateCache) {
        return {
            "replace": true,
            "priority": 0,
            "require": "^uiGrid",
            "scope": false,
            "compile": function() {
                return {
                    "pre": function($scope, $elm, $attrs, uiGridCtrl) {
                        if (uiGridCtrl.grid.options.enableTreeView !== false) {
                            uiGridTreeViewService.initializeGrid(uiGridCtrl.grid, $scope);
                        }
                    },
                    "post": function($scope, $elm, $attrs, uiGridCtrl) {}
                };
            }
        };
    } ]);
})();

(function() {
    "use strict";
    var module = angular.module("ui.grid.validate", [ "ui.grid" ]);
    module.service("uiGridValidateService", [ "$sce", "$q", "$http", "i18nService", "uiGridConstants", function($sce, $q, $http, i18nService, uiGridConstants) {
        var service = {
            "validatorFactories": {},
            "setExternalFactoryFunction": function(externalFactoryFunction) {
                service.externalFactoryFunction = externalFactoryFunction;
            },
            "clearExternalFactory": function() {
                delete service.externalFactoryFunction;
            },
            "getValidatorFromExternalFactory": function(name, argument) {
                return service.externalFactoryFunction(name, argument).validatorFactory(argument);
            },
            "getMessageFromExternalFactory": function(name, argument) {
                return service.externalFactoryFunction(name, argument).messageFunction(argument);
            },
            "setValidator": function(name, validatorFactory, messageFunction) {
                service.validatorFactories[name] = {
                    "validatorFactory": validatorFactory,
                    "messageFunction": messageFunction
                };
            },
            "getValidator": function(name, argument) {
                if (service.externalFactoryFunction) {
                    var validator = service.getValidatorFromExternalFactory(name, argument);
                    if (validator) {
                        return validator;
                    }
                }
                if (!service.validatorFactories[name]) {
                    throw "Invalid validator name: " + name;
                }
                return service.validatorFactories[name].validatorFactory(argument);
            },
            "getMessage": function(name, argument) {
                if (service.externalFactoryFunction) {
                    var message = service.getMessageFromExternalFactory(name, argument);
                    if (message) {
                        return message;
                    }
                }
                return service.validatorFactories[name].messageFunction(argument);
            },
            "isInvalid": function(rowEntity, colDef) {
                return rowEntity["$$invalid" + colDef.name];
            },
            "setInvalid": function(rowEntity, colDef) {
                rowEntity["$$invalid" + colDef.name] = true;
            },
            "setValid": function(rowEntity, colDef) {
                delete rowEntity["$$invalid" + colDef.name];
            },
            "setError": function(rowEntity, colDef, validatorName) {
                if (!rowEntity["$$errors" + colDef.name]) {
                    rowEntity["$$errors" + colDef.name] = {};
                }
                rowEntity["$$errors" + colDef.name][validatorName] = true;
            },
            "clearError": function(rowEntity, colDef, validatorName) {
                if (!rowEntity["$$errors" + colDef.name]) {
                    return;
                }
                if (validatorName in rowEntity["$$errors" + colDef.name]) {
                    delete rowEntity["$$errors" + colDef.name][validatorName];
                }
            },
            "getErrorMessages": function(rowEntity, colDef) {
                var errors = [];
                if (!rowEntity["$$errors" + colDef.name] || Object.keys(rowEntity["$$errors" + colDef.name]).length === 0) {
                    return errors;
                }
                Object.keys(rowEntity["$$errors" + colDef.name]).sort().forEach(function(validatorName) {
                    errors.push(service.getMessage(validatorName, colDef.validators[validatorName]));
                });
                return errors;
            },
            "getFormattedErrors": function(rowEntity, colDef) {
                var msgString = "";
                var errors = service.getErrorMessages(rowEntity, colDef);
                if (!errors.length) {
                    return;
                }
                errors.forEach(function(errorMsg) {
                    msgString += errorMsg + "<br/>";
                });
                return $sce.trustAsHtml("<p><b>" + i18nService.getSafeText("validate.error") + "</b></p>" + msgString);
            },
            "getTitleFormattedErrors": function(rowEntity, colDef) {
                var newLine = "\n";
                var msgString = "";
                var errors = service.getErrorMessages(rowEntity, colDef);
                if (!errors.length) {
                    return;
                }
                errors.forEach(function(errorMsg) {
                    msgString += errorMsg + newLine;
                });
                return $sce.trustAsHtml(i18nService.getSafeText("validate.error") + newLine + msgString);
            },
            "runValidators": function(rowEntity, colDef, newValue, oldValue, grid) {
                if (newValue === oldValue) {
                    return;
                }
                if (typeof colDef.name === "undefined" || !colDef.name) {
                    throw new Error("colDef.name is required to perform validation");
                }
                service.setValid(rowEntity, colDef);
                var validateClosureFactory = function(rowEntity, colDef, validatorName) {
                    return function(value) {
                        if (!value) {
                            service.setInvalid(rowEntity, colDef);
                            service.setError(rowEntity, colDef, validatorName);
                            if (grid) {
                                grid.api.validate.raise.validationFailed(rowEntity, colDef, newValue, oldValue);
                            }
                        }
                    };
                };
                for (var validatorName in colDef.validators) {
                    service.clearError(rowEntity, colDef, validatorName);
                    var msg;
                    var validatorFunction = service.getValidator(validatorName, colDef.validators[validatorName]);
                    $q.when(validatorFunction(oldValue, newValue, rowEntity, colDef)).then(validateClosureFactory(rowEntity, colDef, validatorName));
                }
            },
            "createDefaultValidators": function() {
                service.setValidator("minLength", function(argument) {
                    return function(oldValue, newValue, rowEntity, colDef) {
                        if (newValue === undefined || newValue === null || newValue === "") {
                            return true;
                        }
                        return newValue.length >= argument;
                    };
                }, function(argument) {
                    return i18nService.getSafeText("validate.minLength").replace("THRESHOLD", argument);
                });
                service.setValidator("maxLength", function(argument) {
                    return function(oldValue, newValue, rowEntity, colDef) {
                        if (newValue === undefined || newValue === null || newValue === "") {
                            return true;
                        }
                        return newValue.length <= argument;
                    };
                }, function(threshold) {
                    return i18nService.getSafeText("validate.maxLength").replace("THRESHOLD", threshold);
                });
                service.setValidator("required", function(argument) {
                    return function(oldValue, newValue, rowEntity, colDef) {
                        if (argument) {
                            return !(newValue === undefined || newValue === null || newValue === "");
                        }
                        return true;
                    };
                }, function(argument) {
                    return i18nService.getSafeText("validate.required");
                });
            },
            "initializeGrid": function(scope, grid) {
                grid.validate = {
                    "isInvalid": service.isInvalid,
                    "getFormattedErrors": service.getFormattedErrors,
                    "getTitleFormattedErrors": service.getTitleFormattedErrors,
                    "runValidators": service.runValidators
                };
                var publicApi = {
                    "events": {
                        "validate": {
                            "validationFailed": function(rowEntity, colDef, newValue, oldValue) {}
                        }
                    },
                    "methods": {
                        "validate": {
                            "isInvalid": function(rowEntity, colDef) {
                                return grid.validate.isInvalid(rowEntity, colDef);
                            },
                            "getErrorMessages": function(rowEntity, colDef) {
                                return grid.validate.getErrorMessages(rowEntity, colDef);
                            },
                            "getFormattedErrors": function(rowEntity, colDef) {
                                return grid.validate.getFormattedErrors(rowEntity, colDef);
                            },
                            "getTitleFormattedErrors": function(rowEntity, colDef) {
                                return grid.validate.getTitleFormattedErrors(rowEntity, colDef);
                            }
                        }
                    }
                };
                grid.api.registerEventsFromObject(publicApi.events);
                grid.api.registerMethodsFromObject(publicApi.methods);
                if (grid.edit) {
                    grid.api.edit.on.afterCellEdit(scope, function(rowEntity, colDef, newValue, oldValue) {
                        grid.validate.runValidators(rowEntity, colDef, newValue, oldValue, grid);
                    });
                }
                service.createDefaultValidators();
            }
        };
        return service;
    } ]);
    module.directive("uiGridValidate", [ "gridUtil", "uiGridValidateService", function(gridUtil, uiGridValidateService) {
        return {
            "priority": 0,
            "replace": true,
            "require": "^uiGrid",
            "scope": false,
            "compile": function() {
                return {
                    "pre": function($scope, $elm, $attrs, uiGridCtrl) {
                        uiGridValidateService.initializeGrid($scope, uiGridCtrl.grid);
                    },
                    "post": function($scope, $elm, $attrs, uiGridCtrl) {}
                };
            }
        };
    } ]);
})();

angular.module("ui.grid").run([ "$templateCache", function($templateCache) {
    "use strict";
    $templateCache.put("ui-grid/ui-grid-filter", '<div class="ui-grid-filter-container" ng-repeat="colFilter in col.filters" ng-class="{\'ui-grid-filter-cancel-button-hidden\' : colFilter.disableCancelFilterButton === true }"><div ng-if="colFilter.type !== \'select\'"><input type="text" class="ui-grid-filter-input ui-grid-filter-input-{{$index}}" ng-model="colFilter.term" ng-attr-placeholder="{{colFilter.placeholder || \'\'}}" aria-label="{{colFilter.ariaLabel || aria.defaultFilterLabel}}"><div role="button" class="ui-grid-filter-button" ng-click="removeFilter(colFilter, $index)" ng-if="!colFilter.disableCancelFilterButton" ng-disabled="colFilter.term === undefined || colFilter.term === null || colFilter.term === \'\'" ng-show="colFilter.term !== undefined && colFilter.term !== null && colFilter.term !== \'\'"><i class="ui-grid-icon-cancel" ui-grid-one-bind-aria-label="aria.removeFilter">&nbsp;</i></div></div><div ng-if="colFilter.type === \'select\'"><select class="ui-grid-filter-select ui-grid-filter-input-{{$index}}" ng-model="colFilter.term" ng-attr-placeholder="{{colFilter.placeholder || aria.defaultFilterLabel}}" aria-label="{{colFilter.ariaLabel || \'\'}}" ng-options="option.value as option.label for option in colFilter.selectOptions"><option value=""></option></select><div role="button" class="ui-grid-filter-button-select" ng-click="removeFilter(colFilter, $index)" ng-if="!colFilter.disableCancelFilterButton" ng-disabled="colFilter.term === undefined || colFilter.term === null || colFilter.term === \'\'" ng-show="colFilter.term !== undefined && colFilter.term != null"><i class="ui-grid-icon-cancel" ui-grid-one-bind-aria-label="aria.removeFilter">&nbsp;</i></div></div></div>');
    $templateCache.put("ui-grid/ui-grid-footer", '<div class="ui-grid-footer-panel ui-grid-footer-aggregates-row"><!-- tfooter --><div class="ui-grid-footer ui-grid-footer-viewport"><div class="ui-grid-footer-canvas"><div class="ui-grid-footer-cell-wrapper" ng-style="colContainer.headerCellWrapperStyle()"><div role="row" class="ui-grid-footer-cell-row"><div ui-grid-footer-cell role="gridcell" ng-repeat="col in colContainer.renderedColumns track by col.uid" col="col" render-index="$index" class="ui-grid-footer-cell ui-grid-clearfix"></div></div></div></div></div></div>');
    $templateCache.put("ui-grid/ui-grid-grid-footer", '<div class="ui-grid-footer-info ui-grid-grid-footer"><span>{{\'search.totalItems\' | t}} {{grid.rows.length}}</span> <span ng-if="grid.renderContainers.body.visibleRowCache.length !== grid.rows.length" class="ngLabel">({{"search.showingItems" | t}} {{grid.renderContainers.body.visibleRowCache.length}})</span></div>');
    $templateCache.put("ui-grid/ui-grid-group-panel", '<div class="ui-grid-group-panel"><div ui-t="groupPanel.description" class="description" ng-show="groupings.length == 0"></div><ul ng-show="groupings.length > 0" class="ngGroupList"><li class="ngGroupItem" ng-repeat="group in configGroups"><span class="ngGroupElement"><span class="ngGroupName">{{group.displayName}} <span ng-click="removeGroup($index)" class="ngRemoveGroup">x</span></span> <span ng-hide="$last" class="ngGroupArrow"></span></span></li></ul></div>');
    $templateCache.put("ui-grid/ui-grid-header", '<div role="rowgroup" class="ui-grid-header"><!-- theader --><div class="ui-grid-top-panel"><div class="ui-grid-header-viewport"><div class="ui-grid-header-canvas"><div class="ui-grid-header-cell-wrapper" ng-style="colContainer.headerCellWrapperStyle()"><div role="row" class="ui-grid-header-cell-row"><div class="ui-grid-header-cell ui-grid-clearfix" ng-repeat="col in colContainer.renderedColumns track by col.uid" ui-grid-header-cell col="col" render-index="$index"></div></div></div></div></div></div></div>');
    $templateCache.put("ui-grid/ui-grid-menu-button", '<div class="ui-grid-menu-button"><div role="button" ui-grid-one-bind-id-grid="\'grid-menu\'" class="ui-grid-icon-container" ng-click="toggleMenu()" aria-haspopup="true"><i class="ui-grid-icon-menu" ui-grid-one-bind-aria-label="i18n.aria.buttonLabel">&nbsp;</i></div><div ui-grid-menu menu-items="menuItems"></div></div>');
    $templateCache.put("ui-grid/ui-grid-no-header", '<div class="ui-grid-top-panel"></div>');
    $templateCache.put("ui-grid/ui-grid-row", "<div ng-repeat=\"(colRenderIndex, col) in colContainer.renderedColumns track by col.uid\" ui-grid-one-bind-id-grid=\"rowRenderIndex + '-' + col.uid + '-cell'\" class=\"ui-grid-cell\" ng-class=\"{ 'ui-grid-row-header-cell': col.isRowHeader }\" role=\"{{col.isRowHeader ? 'rowheader' : 'gridcell'}}\" ui-grid-cell></div>");
    $templateCache.put("ui-grid/ui-grid", '<div ui-i18n="en" class="ui-grid"><!-- TODO (c0bra): add "scoped" attr here, eventually? --><style ui-grid-style>.grid{{ grid.id }} {\n' + "      /* Styles for the grid */\n" + "    }\n" + "\n" + "    .grid{{ grid.id }} .ui-grid-row, .grid{{ grid.id }} .ui-grid-cell, .grid{{ grid.id }} .ui-grid-cell .ui-grid-vertical-bar {\n" + "      height: {{ grid.options.rowHeight }}px;\n" + "    }\n" + "\n" + "    .grid{{ grid.id }} .ui-grid-row:last-child .ui-grid-cell {\n" + "      border-bottom-width: {{ ((grid.getTotalRowHeight() < grid.getViewportHeight()) && '1') || '0' }}px;\n" + "    }\n" + "\n" + "    {{ grid.verticalScrollbarStyles }}\n" + "    {{ grid.horizontalScrollbarStyles }}\n" + "\n" + "    /*\n" + "    .ui-grid[dir=rtl] .ui-grid-viewport {\n" + "      padding-left: {{ grid.verticalScrollbarWidth }}px;\n" + "    }\n" + "    */\n" + "\n" + '    {{ grid.customStyles }}</style><div class="ui-grid-contents-wrapper"><div ui-grid-menu-button ng-if="grid.options.enableGridMenu"></div><div ng-if="grid.hasLeftContainer()" style="width: 0" ui-grid-pinned-container="\'left\'"></div><div ui-grid-render-container container-id="\'body\'" col-container-name="\'body\'" row-container-name="\'body\'" bind-scroll-horizontal="true" bind-scroll-vertical="true" enable-horizontal-scrollbar="grid.options.enableHorizontalScrollbar" enable-vertical-scrollbar="grid.options.enableVerticalScrollbar"></div><div ng-if="grid.hasRightContainer()" style="width: 0" ui-grid-pinned-container="\'right\'"></div><div ui-grid-grid-footer ng-if="grid.options.showGridFooter"></div><div ui-grid-column-menu ng-if="grid.options.enableColumnMenus"></div><div ng-transclude></div></div></div>');
    $templateCache.put("ui-grid/uiGridCell", '<div class="ui-grid-cell-contents" title="TOOLTIP">{{COL_FIELD CUSTOM_FILTERS}}</div>');
    $templateCache.put("ui-grid/uiGridColumnMenu", '<div class="ui-grid-column-menu"><div ui-grid-menu menu-items="menuItems"><!-- <div class="ui-grid-column-menu">\n' + '    <div class="inner" ng-show="menuShown">\n' + "      <ul>\n" + '        <div ng-show="grid.options.enableSorting">\n' + '          <li ng-click="sortColumn($event, asc)" ng-class="{ \'selected\' : col.sort.direction == asc }"><i class="ui-grid-icon-sort-alt-up"></i> Sort Ascending</li>\n' + '          <li ng-click="sortColumn($event, desc)" ng-class="{ \'selected\' : col.sort.direction == desc }"><i class="ui-grid-icon-sort-alt-down"></i> Sort Descending</li>\n' + '          <li ng-show="col.sort.direction" ng-click="unsortColumn()"><i class="ui-grid-icon-cancel"></i> Remove Sort</li>\n' + "        </div>\n" + "      </ul>\n" + "    </div>\n" + "  </div> --></div></div>");
    $templateCache.put("ui-grid/uiGridFooterCell", '<div class="ui-grid-cell-contents" col-index="renderIndex"><div>{{ col.getAggregationText() + ( col.getAggregationValue() CUSTOM_FILTERS ) }}</div></div>');
    $templateCache.put("ui-grid/uiGridHeaderCell", '<div role="columnheader" ng-class="{ \'sortable\': sortable }" ui-grid-one-bind-aria-labelledby-grid="col.uid + \'-header-text \' + col.uid + \'-sortdir-text\'" aria-sort="{{col.sort.direction == asc ? \'ascending\' : ( col.sort.direction == desc ? \'descending\' : (!col.sort.direction ? \'none\' : \'other\'))}}"><div role="button" tabindex="0" class="ui-grid-cell-contents ui-grid-header-cell-primary-focus" col-index="renderIndex" title="TOOLTIP"><span class="ui-grid-header-cell-label" ui-grid-one-bind-id-grid="col.uid + \'-header-text\'">{{ col.displayName CUSTOM_FILTERS }}</span> <span ui-grid-one-bind-id-grid="col.uid + \'-sortdir-text\'" ui-grid-visible="col.sort.direction" aria-label="{{getSortDirectionAriaLabel()}}"><i ng-class="{ \'ui-grid-icon-up-dir\': col.sort.direction == asc, \'ui-grid-icon-down-dir\': col.sort.direction == desc, \'ui-grid-icon-blank\': !col.sort.direction }" title="{{isSortPriorityVisible() ? i18n.headerCell.priority + \' \' + ( col.sort.priority + 1 )  : null}}" aria-hidden="true"></i> <sub ui-grid-visible="isSortPriorityVisible()" class="ui-grid-sort-priority-number">{{col.sort.priority + 1}}</sub></span></div><div role="button" tabindex="0" ui-grid-one-bind-id-grid="col.uid + \'-menu-button\'" class="ui-grid-column-menu-button" ng-if="grid.options.enableColumnMenus && !col.isRowHeader  && col.colDef.enableColumnMenu !== false" ng-click="toggleMenu($event)" ng-class="{\'ui-grid-column-menu-button-last-col\': isLastCol}" ui-grid-one-bind-aria-label="i18n.headerCell.aria.columnMenuButtonLabel" aria-haspopup="true"><i class="ui-grid-icon-angle-down" aria-hidden="true">&nbsp;</i></div><div ui-grid-filter></div></div>');
    $templateCache.put("ui-grid/uiGridMenu", '<div class="ui-grid-menu" ng-if="shown"><style ui-grid-style>{{dynamicStyles}}</style><div class="ui-grid-menu-mid" ng-show="shownMid"><div class="ui-grid-menu-inner"><ul role="menu" class="ui-grid-menu-items"><li ng-repeat="item in menuItems" role="menuitem" ui-grid-menu-item ui-grid-one-bind-id="\'menuitem-\'+$index" action="item.action" name="item.title" active="item.active" icon="item.icon" shown="item.shown" context="item.context" template-url="item.templateUrl" leave-open="item.leaveOpen" screen-reader-only="item.screenReaderOnly"></li></ul></div></div></div>');
    $templateCache.put("ui-grid/uiGridMenuItem", '<button type="button" class="ui-grid-menu-item" ng-click="itemAction($event, title)" ng-show="itemShown()" ng-class="{ \'ui-grid-menu-item-active\': active(), \'ui-grid-sr-only\': (!focus && screenReaderOnly) }" aria-pressed="{{active()}}" tabindex="0" ng-focus="focus=true" ng-blur="focus=false"><i ng-class="icon" aria-hidden="true">&nbsp;</i> {{ name }}</button>');
    $templateCache.put("ui-grid/uiGridRenderContainer", "<div role=\"grid\" ui-grid-one-bind-id-grid=\"'grid-container'\" class=\"ui-grid-render-container\" ng-style=\"{ 'margin-left': colContainer.getMargin('left') + 'px', 'margin-right': colContainer.getMargin('right') + 'px' }\"><!-- All of these dom elements are replaced in place --><div ui-grid-header></div><div ui-grid-viewport></div><div ng-if=\"colContainer.needsHScrollbarPlaceholder()\" class=\"ui-grid-scrollbar-placeholder\" ng-style=\"{height:colContainer.grid.scrollbarHeight + 'px'}\"></div><ui-grid-footer ng-if=\"grid.options.showColumnFooter\"></ui-grid-footer></div>");
    $templateCache.put("ui-grid/uiGridViewport", '<div role="rowgroup" class="ui-grid-viewport" ng-style="colContainer.getViewportStyle()"><!-- tbody --><div class="ui-grid-canvas"><div ng-repeat="(rowRenderIndex, row) in rowContainer.renderedRows track by $index" class="ui-grid-row" ng-style="Viewport.rowStyle(rowRenderIndex)"><div role="row" ui-grid-row="row" row-render-index="rowRenderIndex"></div></div></div></div>');
    $templateCache.put("ui-grid/cellEditor", '<div><form name="inputForm"><input type="INPUT_TYPE" ng-class="\'colt\' + col.uid" ui-grid-editor ng-model="MODEL_COL_FIELD"></form></div>');
    $templateCache.put("ui-grid/dropdownEditor", '<div><form name="inputForm"><select ng-class="\'colt\' + col.uid" ui-grid-edit-dropdown ng-model="MODEL_COL_FIELD" ng-options="field[editDropdownIdLabel] as field[editDropdownValueLabel] CUSTOM_FILTERS for field in editDropdownOptionsArray"></select></form></div>');
    $templateCache.put("ui-grid/fileChooserEditor", '<div><form name="inputForm"><input ng-class="\'colt\' + col.uid" ui-grid-edit-file-chooser type="file" id="files" name="files[]" ng-model="MODEL_COL_FIELD"></form></div>');
    $templateCache.put("ui-grid/expandableRow", '<div ui-grid-expandable-row ng-if="expandableRow.shouldRenderExpand()" class="expandableRow" style="float:left; margin-top: 1px; margin-bottom: 1px" ng-style="{width: (grid.renderContainers.body.getCanvasWidth()) + \'px\', height: row.expandedRowHeight + \'px\'}"></div>');
    $templateCache.put("ui-grid/expandableRowHeader", '<div class="ui-grid-row-header-cell ui-grid-expandable-buttons-cell"><div class="ui-grid-cell-contents"><i ng-class="{ \'ui-grid-icon-plus-squared\' : !row.isExpanded, \'ui-grid-icon-minus-squared\' : row.isExpanded }" ng-click="grid.api.expandable.toggleRowExpansion(row.entity)"></i></div></div>');
    $templateCache.put("ui-grid/expandableScrollFiller", "<div ng-if=\"expandableRow.shouldRenderFiller()\" ng-class=\"{scrollFiller:true, scrollFillerClass:(colContainer.name === 'body')}\" ng-style=\"{ width: (grid.getViewportWidth()) + 'px', height: row.expandedRowHeight + 2 + 'px', 'margin-left': grid.options.rowHeader.rowHeaderWidth + 'px' }\"><i class=\"ui-grid-icon-spin5 ui-grid-animate-spin\" ng-style=\"{'margin-top': ( row.expandedRowHeight/2 - 5) + 'px', 'margin-left' : ((grid.getViewportWidth() - grid.options.rowHeader.rowHeaderWidth)/2 - 5) + 'px'}\"></i></div>");
    $templateCache.put("ui-grid/expandableTopRowHeader", '<div class="ui-grid-row-header-cell ui-grid-expandable-buttons-cell"><div class="ui-grid-cell-contents"><i ng-class="{ \'ui-grid-icon-plus-squared\' : !grid.expandable.expandedAll, \'ui-grid-icon-minus-squared\' : grid.expandable.expandedAll }" ng-click="grid.api.expandable.toggleAllRows()"></i></div></div>');
    $templateCache.put("ui-grid/csvLink", '<span class="ui-grid-exporter-csv-link-span"><a href="data:text/csv;charset=UTF-8,CSV_CONTENT" download="FILE_NAME">LINK_LABEL</a></span>');
    $templateCache.put("ui-grid/importerMenuItem", '<li class="ui-grid-menu-item"><form><input class="ui-grid-importer-file-chooser" type="file" id="files" name="files[]"></form></li>');
    $templateCache.put("ui-grid/importerMenuItemContainer", "<div ui-grid-importer-menu-item></div>");
    $templateCache.put("ui-grid/pagination", '<div role="contentinfo" class="ui-grid-pager-panel" ui-grid-pager ng-show="grid.options.enablePaginationControls"><div role="navigation" class="ui-grid-pager-container"><div role="menubar" class="ui-grid-pager-control"><button type="button" role="menuitem" class="ui-grid-pager-first" ui-grid-one-bind-title="aria.pageToFirst" ui-grid-one-bind-aria-label="aria.pageToFirst" ng-click="pageFirstPageClick()" ng-disabled="cantPageBackward()"><div ng-class="grid.isRTL() ? \'last-triangle\' : \'first-triangle\'"><div ng-class="grid.isRTL() ? \'last-bar-rtl\' : \'first-bar\'"></div></div></button> <button type="button" role="menuitem" class="ui-grid-pager-previous" ui-grid-one-bind-title="aria.pageBack" ui-grid-one-bind-aria-label="aria.pageBack" ng-click="pagePreviousPageClick()" ng-disabled="cantPageBackward()"><div ng-class="grid.isRTL() ? \'last-triangle prev-triangle\' : \'first-triangle prev-triangle\'"></div></button> <input type="number" ui-grid-one-bind-title="aria.pageSelected" ui-grid-one-bind-aria-label="aria.pageSelected" class="ui-grid-pager-control-input" ng-model="grid.options.paginationCurrentPage" min="1" max="{{ paginationApi.getTotalPages() }}" required> <span class="ui-grid-pager-max-pages-number" ng-show="paginationApi.getTotalPages() > 0"><abbr ui-grid-one-bind-title="paginationOf">/</abbr> {{ paginationApi.getTotalPages() }}</span> <button type="button" role="menuitem" class="ui-grid-pager-next" ui-grid-one-bind-title="aria.pageForward" ui-grid-one-bind-aria-label="aria.pageForward" ng-click="pageNextPageClick()" ng-disabled="cantPageForward()"><div ng-class="grid.isRTL() ? \'first-triangle next-triangle\' : \'last-triangle next-triangle\'"></div></button> <button type="button" role="menuitem" class="ui-grid-pager-last" ui-grid-one-bind-title="aria.pageToLast" ui-grid-one-bind-aria-label="aria.pageToLast" ng-click="pageLastPageClick()" ng-disabled="cantPageToLast()"><div ng-class="grid.isRTL() ? \'first-triangle\' : \'last-triangle\'"><div ng-class="grid.isRTL() ? \'first-bar-rtl\' : \'last-bar\'"></div></div></button></div><div class="ui-grid-pager-row-count-picker" ng-if="grid.options.paginationPageSizes.length > 1"><select ui-grid-one-bind-aria-labelledby-grid="\'items-per-page-label\'" ng-model="grid.options.paginationPageSize" ng-options="o as o for o in grid.options.paginationPageSizes"></select><span ui-grid-one-bind-id-grid="\'items-per-page-label\'" class="ui-grid-pager-row-count-label">&nbsp;{{sizesLabel}}</span></div><span ng-if="grid.options.paginationPageSizes.length <= 1" class="ui-grid-pager-row-count-label">{{grid.options.paginationPageSize}}&nbsp;{{sizesLabel}}</span></div><div class="ui-grid-pager-count-container"><div class="ui-grid-pager-count"><span ng-show="grid.options.totalItems > 0">{{showingLow}} <abbr ui-grid-one-bind-title="paginationThrough">-</abbr> {{showingHigh}} {{paginationOf}} {{grid.options.totalItems}} {{totalItemsLabel}}</span></div></div></div>');
    $templateCache.put("ui-grid/columnResizer", '<div ui-grid-column-resizer ng-if="grid.options.enableColumnResizing" class="ui-grid-column-resizer" col="col" position="right" render-index="renderIndex" unselectable="on"></div>');
    $templateCache.put("ui-grid/gridFooterSelectedItems", '<span ng-if="grid.selection.selectedCount !== 0 && grid.options.enableFooterTotalSelected">({{"search.selectedItems" | t}} {{grid.selection.selectedCount}})</span>');
    $templateCache.put("ui-grid/selectionHeaderCell", '<div><!-- <div class="ui-grid-vertical-bar">&nbsp;</div> --><div class="ui-grid-cell-contents" col-index="renderIndex"><ui-grid-selection-select-all-buttons ng-if="grid.options.enableSelectAll"></ui-grid-selection-select-all-buttons></div></div>');
    $templateCache.put("ui-grid/selectionRowHeader", '<div class="ui-grid-disable-selection"><div class="ui-grid-cell-contents"><ui-grid-selection-row-header-buttons></ui-grid-selection-row-header-buttons></div></div>');
    $templateCache.put("ui-grid/selectionRowHeaderButtons", '<div class="ui-grid-selection-row-header-buttons ui-grid-icon-ok" ng-class="{\'ui-grid-row-selected\': row.isSelected}" ng-click="selectButtonClick(row, $event)">&nbsp;</div>');
    $templateCache.put("ui-grid/selectionSelectAllButtons", '<div class="ui-grid-selection-row-header-buttons ui-grid-icon-ok" ng-class="{\'ui-grid-all-selected\': grid.selection.selectAll}" ng-click="headerButtonClick($event)"></div>');
    $templateCache.put("ui-grid/treeBaseExpandAllButtons", '<div class="ui-grid-tree-base-row-header-buttons" ng-class="{\'ui-grid-icon-minus-squared\': grid.treeBase.numberLevels > 0 && grid.treeBase.expandAll, \'ui-grid-icon-plus-squared\': grid.treeBase.numberLevels > 0 && !grid.treeBase.expandAll}" ng-click="headerButtonClick($event)"></div>');
    $templateCache.put("ui-grid/treeBaseHeaderCell", '<div><div class="ui-grid-cell-contents" col-index="renderIndex"><ui-grid-tree-base-expand-all-buttons ng-if="grid.options.enableExpandAll"></ui-grid-tree-base-expand-all-buttons></div></div>');
    $templateCache.put("ui-grid/treeBaseRowHeader", '<div class="ui-grid-cell-contents"><ui-grid-tree-base-row-header-buttons></ui-grid-tree-base-row-header-buttons></div>');
    $templateCache.put("ui-grid/treeBaseRowHeaderButtons", "<div class=\"ui-grid-tree-base-row-header-buttons\" ng-class=\"{'ui-grid-tree-base-header': row.treeLevel > -1 }\" ng-click=\"treeButtonClick(row, $event)\"><i ng-class=\"{'ui-grid-icon-minus-squared': ( ( grid.options.showTreeExpandNoChildren && row.treeLevel > -1 ) || ( row.treeNode.children && row.treeNode.children.length > 0 ) ) && row.treeNode.state === 'expanded', 'ui-grid-icon-plus-squared': ( ( grid.options.showTreeExpandNoChildren && row.treeLevel > -1 ) || ( row.treeNode.children && row.treeNode.children.length > 0 ) ) && row.treeNode.state === 'collapsed'}\" ng-style=\"{'padding-left': grid.options.treeIndent * row.treeLevel + 'px'}\"></i> &nbsp;</div>");
    $templateCache.put("ui-grid/cellTitleValidator", '<div class="ui-grid-cell-contents" ng-class="{invalid:grid.validate.isInvalid(row.entity,col.colDef)}" title="{{grid.validate.getTitleFormattedErrors(row.entity,col.colDef)}}">{{COL_FIELD CUSTOM_FILTERS}}</div>');
    $templateCache.put("ui-grid/cellTooltipValidator", '<div class="ui-grid-cell-contents" ng-class="{invalid:grid.validate.isInvalid(row.entity,col.colDef)}" tooltip-html-unsafe="{{grid.validate.getFormattedErrors(row.entity,col.colDef)}}" tooltip-enable="grid.validate.isInvalid(row.entity,col.colDef)" tooltip-append-to-body="true" tooltip-placement="top" title="TOOLTIP">{{COL_FIELD CUSTOM_FILTERS}}</div>');
} ]);

(function(e) {
    if ("object" == typeof exports && "undefined" != typeof module && "undefined" == typeof DO_NOT_EXPORT_JSZIP) module.exports = e(); else if ("function" == typeof define && define.amd && "undefined" == typeof DO_NOT_EXPORT_JSZIP) {
        JSZipSync = e();
        define([], e);
    } else {
        var f;
        "undefined" != typeof window ? f = window : "undefined" != typeof global ? f = global : "undefined" != typeof $ && $.global ? f = $.global : "undefined" != typeof self && (f = self), 
        f.JSZipSync = e();
    }
})(function() {
    var define, module, exports;
    return function e(t, n, r) {
        function s(o, u) {
            if (!n[o]) {
                if (!t[o]) {
                    var a = typeof require == "function" && require;
                    if (!u && a) return a(o, !0);
                    if (i) return i(o, !0);
                    throw new Error("Cannot find module '" + o + "'");
                }
                var f = n[o] = {
                    "exports": {}
                };
                t[o][0].call(f.exports, function(e) {
                    var n = t[o][1][e];
                    return s(n ? n : e);
                }, f, f.exports, e, t, n, r);
            }
            return n[o].exports;
        }
        var i = typeof require == "function" && require;
        for (var o = 0; o < r.length; o++) s(r[o]);
        return s;
    }({
        "1": [ function(_dereq_, module, exports) {
            "use strict";
            var _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
            exports.encode = function(input, utf8) {
                var output = "";
                var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
                var i = 0;
                while (i < input.length) {
                    chr1 = input.charCodeAt(i++);
                    chr2 = input.charCodeAt(i++);
                    chr3 = input.charCodeAt(i++);
                    enc1 = chr1 >> 2;
                    enc2 = (chr1 & 3) << 4 | chr2 >> 4;
                    enc3 = (chr2 & 15) << 2 | chr3 >> 6;
                    enc4 = chr3 & 63;
                    if (isNaN(chr2)) {
                        enc3 = enc4 = 64;
                    } else if (isNaN(chr3)) {
                        enc4 = 64;
                    }
                    output = output + _keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4);
                }
                return output;
            };
            exports.decode = function(input, utf8) {
                var output = "";
                var chr1, chr2, chr3;
                var enc1, enc2, enc3, enc4;
                var i = 0;
                input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
                while (i < input.length) {
                    enc1 = _keyStr.indexOf(input.charAt(i++));
                    enc2 = _keyStr.indexOf(input.charAt(i++));
                    enc3 = _keyStr.indexOf(input.charAt(i++));
                    enc4 = _keyStr.indexOf(input.charAt(i++));
                    chr1 = enc1 << 2 | enc2 >> 4;
                    chr2 = (enc2 & 15) << 4 | enc3 >> 2;
                    chr3 = (enc3 & 3) << 6 | enc4;
                    output = output + String.fromCharCode(chr1);
                    if (enc3 != 64) {
                        output = output + String.fromCharCode(chr2);
                    }
                    if (enc4 != 64) {
                        output = output + String.fromCharCode(chr3);
                    }
                }
                return output;
            };
        }, {} ],
        "2": [ function(_dereq_, module, exports) {
            "use strict";
            function CompressedObject() {
                this.compressedSize = 0;
                this.uncompressedSize = 0;
                this.crc32 = 0;
                this.compressionMethod = null;
                this.compressedContent = null;
            }
            CompressedObject.prototype = {
                "getContent": function() {
                    return null;
                },
                "getCompressedContent": function() {
                    return null;
                }
            };
            module.exports = CompressedObject;
        }, {} ],
        "3": [ function(_dereq_, module, exports) {
            "use strict";
            exports.STORE = {
                "magic": "\0\0",
                "compress": function(content) {
                    return content;
                },
                "uncompress": function(content) {
                    return content;
                },
                "compressInputType": null,
                "uncompressInputType": null
            };
            exports.DEFLATE = _dereq_("./flate");
        }, {
            "./flate": 8
        } ],
        "4": [ function(_dereq_, module, exports) {
            "use strict";
            var utils = _dereq_("./utils");
            var table = [ 0, 1996959894, 3993919788, 2567524794, 124634137, 1886057615, 3915621685, 2657392035, 249268274, 2044508324, 3772115230, 2547177864, 162941995, 2125561021, 3887607047, 2428444049, 498536548, 1789927666, 4089016648, 2227061214, 450548861, 1843258603, 4107580753, 2211677639, 325883990, 1684777152, 4251122042, 2321926636, 335633487, 1661365465, 4195302755, 2366115317, 997073096, 1281953886, 3579855332, 2724688242, 1006888145, 1258607687, 3524101629, 2768942443, 901097722, 1119000684, 3686517206, 2898065728, 853044451, 1172266101, 3705015759, 2882616665, 651767980, 1373503546, 3369554304, 3218104598, 565507253, 1454621731, 3485111705, 3099436303, 671266974, 1594198024, 3322730930, 2970347812, 795835527, 1483230225, 3244367275, 3060149565, 1994146192, 31158534, 2563907772, 4023717930, 1907459465, 112637215, 2680153253, 3904427059, 2013776290, 251722036, 2517215374, 3775830040, 2137656763, 141376813, 2439277719, 3865271297, 1802195444, 476864866, 2238001368, 4066508878, 1812370925, 453092731, 2181625025, 4111451223, 1706088902, 314042704, 2344532202, 4240017532, 1658658271, 366619977, 2362670323, 4224994405, 1303535960, 984961486, 2747007092, 3569037538, 1256170817, 1037604311, 2765210733, 3554079995, 1131014506, 879679996, 2909243462, 3663771856, 1141124467, 855842277, 2852801631, 3708648649, 1342533948, 654459306, 3188396048, 3373015174, 1466479909, 544179635, 3110523913, 3462522015, 1591671054, 702138776, 2966460450, 3352799412, 1504918807, 783551873, 3082640443, 3233442989, 3988292384, 2596254646, 62317068, 1957810842, 3939845945, 2647816111, 81470997, 1943803523, 3814918930, 2489596804, 225274430, 2053790376, 3826175755, 2466906013, 167816743, 2097651377, 4027552580, 2265490386, 503444072, 1762050814, 4150417245, 2154129355, 426522225, 1852507879, 4275313526, 2312317920, 282753626, 1742555852, 4189708143, 2394877945, 397917763, 1622183637, 3604390888, 2714866558, 953729732, 1340076626, 3518719985, 2797360999, 1068828381, 1219638859, 3624741850, 2936675148, 906185462, 1090812512, 3747672003, 2825379669, 829329135, 1181335161, 3412177804, 3160834842, 628085408, 1382605366, 3423369109, 3138078467, 570562233, 1426400815, 3317316542, 2998733608, 733239954, 1555261956, 3268935591, 3050360625, 752459403, 1541320221, 2607071920, 3965973030, 1969922972, 40735498, 2617837225, 3943577151, 1913087877, 83908371, 2512341634, 3803740692, 2075208622, 213261112, 2463272603, 3855990285, 2094854071, 198958881, 2262029012, 4057260610, 1759359992, 534414190, 2176718541, 4139329115, 1873836001, 414664567, 2282248934, 4279200368, 1711684554, 285281116, 2405801727, 4167216745, 1634467795, 376229701, 2685067896, 3608007406, 1308918612, 956543938, 2808555105, 3495958263, 1231636301, 1047427035, 2932959818, 3654703836, 1088359270, 936918e3, 2847714899, 3736837829, 1202900863, 817233897, 3183342108, 3401237130, 1404277552, 615818150, 3134207493, 3453421203, 1423857449, 601450431, 3009837614, 3294710456, 1567103746, 711928724, 3020668471, 3272380065, 1510334235, 755167117 ];
            module.exports = function crc32(input, crc) {
                if (typeof input === "undefined" || !input.length) {
                    return 0;
                }
                var isArray = utils.getTypeOf(input) !== "string";
                if (typeof crc == "undefined") {
                    crc = 0;
                }
                var x = 0;
                var y = 0;
                var b = 0;
                crc = crc ^ -1;
                for (var i = 0, iTop = input.length; i < iTop; i++) {
                    b = isArray ? input[i] : input.charCodeAt(i);
                    y = (crc ^ b) & 255;
                    x = table[y];
                    crc = crc >>> 8 ^ x;
                }
                return crc ^ -1;
            };
        }, {
            "./utils": 21
        } ],
        "5": [ function(_dereq_, module, exports) {
            "use strict";
            var utils = _dereq_("./utils");
            function DataReader(data) {
                this.data = null;
                this.length = 0;
                this.index = 0;
            }
            DataReader.prototype = {
                "checkOffset": function(offset) {
                    this.checkIndex(this.index + offset);
                },
                "checkIndex": function(newIndex) {
                    if (this.length < newIndex || newIndex < 0) {
                        throw new Error("End of data reached (data length = " + this.length + ", asked index = " + newIndex + "). Corrupted zip ?");
                    }
                },
                "setIndex": function(newIndex) {
                    this.checkIndex(newIndex);
                    this.index = newIndex;
                },
                "skip": function(n) {
                    this.setIndex(this.index + n);
                },
                "byteAt": function(i) {},
                "readInt": function(size) {
                    var result = 0, i;
                    this.checkOffset(size);
                    for (i = this.index + size - 1; i >= this.index; i--) {
                        result = (result << 8) + this.byteAt(i);
                    }
                    this.index += size;
                    return result;
                },
                "readString": function(size) {
                    return utils.transformTo("string", this.readData(size));
                },
                "readData": function(size) {},
                "lastIndexOfSignature": function(sig) {},
                "readDate": function() {
                    var dostime = this.readInt(4);
                    return new Date((dostime >> 25 & 127) + 1980, (dostime >> 21 & 15) - 1, dostime >> 16 & 31, dostime >> 11 & 31, dostime >> 5 & 63, (dostime & 31) << 1);
                }
            };
            module.exports = DataReader;
        }, {
            "./utils": 21
        } ],
        "6": [ function(_dereq_, module, exports) {
            "use strict";
            exports.base64 = false;
            exports.binary = false;
            exports.dir = false;
            exports.createFolders = false;
            exports.date = null;
            exports.compression = null;
            exports.comment = null;
        }, {} ],
        "7": [ function(_dereq_, module, exports) {
            "use strict";
            var utils = _dereq_("./utils");
            exports.string2binary = function(str) {
                return utils.string2binary(str);
            };
            exports.string2Uint8Array = function(str) {
                return utils.transformTo("uint8array", str);
            };
            exports.uint8Array2String = function(array) {
                return utils.transformTo("string", array);
            };
            exports.string2Blob = function(str) {
                var buffer = utils.transformTo("arraybuffer", str);
                return utils.arrayBuffer2Blob(buffer);
            };
            exports.arrayBuffer2Blob = function(buffer) {
                return utils.arrayBuffer2Blob(buffer);
            };
            exports.transformTo = function(outputType, input) {
                return utils.transformTo(outputType, input);
            };
            exports.getTypeOf = function(input) {
                return utils.getTypeOf(input);
            };
            exports.checkSupport = function(type) {
                return utils.checkSupport(type);
            };
            exports.MAX_VALUE_16BITS = utils.MAX_VALUE_16BITS;
            exports.MAX_VALUE_32BITS = utils.MAX_VALUE_32BITS;
            exports.pretty = function(str) {
                return utils.pretty(str);
            };
            exports.findCompression = function(compressionMethod) {
                return utils.findCompression(compressionMethod);
            };
            exports.isRegExp = function(object) {
                return utils.isRegExp(object);
            };
        }, {
            "./utils": 21
        } ],
        "8": [ function(_dereq_, module, exports) {
            "use strict";
            var USE_TYPEDARRAY = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Uint32Array !== "undefined";
            var pako = _dereq_("pako");
            exports.uncompressInputType = USE_TYPEDARRAY ? "uint8array" : "array";
            exports.compressInputType = USE_TYPEDARRAY ? "uint8array" : "array";
            exports.magic = "\b\0";
            exports.compress = function(input) {
                return pako.deflateRaw(input);
            };
            exports.uncompress = function(input) {
                return pako.inflateRaw(input);
            };
        }, {
            "pako": 24
        } ],
        "9": [ function(_dereq_, module, exports) {
            "use strict";
            var base64 = _dereq_("./base64");
            function JSZipSync(data, options) {
                if (!(this instanceof JSZipSync)) return new JSZipSync(data, options);
                this.files = {};
                this.comment = null;
                this.root = "";
                if (data) {
                    this.load(data, options);
                }
                this.clone = function() {
                    var newObj = new JSZipSync();
                    for (var i in this) {
                        if (typeof this[i] !== "function") {
                            newObj[i] = this[i];
                        }
                    }
                    return newObj;
                };
            }
            JSZipSync.prototype = _dereq_("./object");
            JSZipSync.prototype.load = _dereq_("./load");
            JSZipSync.support = _dereq_("./support");
            JSZipSync.defaults = _dereq_("./defaults");
            JSZipSync.utils = _dereq_("./deprecatedPublicUtils");
            JSZipSync.base64 = {
                "encode": function(input) {
                    return base64.encode(input);
                },
                "decode": function(input) {
                    return base64.decode(input);
                }
            };
            JSZipSync.compressions = _dereq_("./compressions");
            module.exports = JSZipSync;
        }, {
            "./base64": 1,
            "./compressions": 3,
            "./defaults": 6,
            "./deprecatedPublicUtils": 7,
            "./load": 10,
            "./object": 13,
            "./support": 17
        } ],
        "10": [ function(_dereq_, module, exports) {
            "use strict";
            var base64 = _dereq_("./base64");
            var ZipEntries = _dereq_("./zipEntries");
            module.exports = function(data, options) {
                var files, zipEntries, i, input;
                options = options || {};
                if (options.base64) {
                    data = base64.decode(data);
                }
                zipEntries = new ZipEntries(data, options);
                files = zipEntries.files;
                for (i = 0; i < files.length; i++) {
                    input = files[i];
                    this.file(input.fileName, input.decompressed, {
                        "binary": true,
                        "optimizedBinaryString": true,
                        "date": input.date,
                        "dir": input.dir,
                        "comment": input.fileComment.length ? input.fileComment : null,
                        "createFolders": options.createFolders
                    });
                }
                if (zipEntries.zipComment.length) {
                    this.comment = zipEntries.zipComment;
                }
                return this;
            };
        }, {
            "./base64": 1,
            "./zipEntries": 22
        } ],
        "11": [ function(_dereq_, module, exports) {
            (function(Buffer) {
                "use strict";
                var Buffer_from = function() {};
                if (typeof Buffer !== "undefined") {
                    var nbfs = !Buffer.from;
                    if (!nbfs) try {
                        Buffer.from("foo", "utf8");
                    } catch (e) {
                        nbfs = true;
                    }
                    Buffer_from = nbfs ? function(buf, enc) {
                        return enc ? new Buffer(buf, enc) : new Buffer(buf);
                    } : Buffer.from.bind(Buffer);
                    if (!Buffer.alloc) Buffer.alloc = function(n) {
                        return new Buffer(n);
                    };
                }
                module.exports = function(data, encoding) {
                    return typeof data == "number" ? Buffer.alloc(data) : Buffer_from(data, encoding);
                };
                module.exports.test = function(b) {
                    return Buffer.isBuffer(b);
                };
            }).call(this, typeof Buffer !== "undefined" ? Buffer : undefined);
        }, {} ],
        "12": [ function(_dereq_, module, exports) {
            "use strict";
            var Uint8ArrayReader = _dereq_("./uint8ArrayReader");
            function NodeBufferReader(data) {
                this.data = data;
                this.length = this.data.length;
                this.index = 0;
            }
            NodeBufferReader.prototype = new Uint8ArrayReader();
            NodeBufferReader.prototype.readData = function(size) {
                this.checkOffset(size);
                var result = this.data.slice(this.index, this.index + size);
                this.index += size;
                return result;
            };
            module.exports = NodeBufferReader;
        }, {
            "./uint8ArrayReader": 18
        } ],
        "13": [ function(_dereq_, module, exports) {
            "use strict";
            var support = _dereq_("./support");
            var utils = _dereq_("./utils");
            var crc32 = _dereq_("./crc32");
            var signature = _dereq_("./signature");
            var defaults = _dereq_("./defaults");
            var base64 = _dereq_("./base64");
            var compressions = _dereq_("./compressions");
            var CompressedObject = _dereq_("./compressedObject");
            var nodeBuffer = _dereq_("./nodeBuffer");
            var utf8 = _dereq_("./utf8");
            var StringWriter = _dereq_("./stringWriter");
            var Uint8ArrayWriter = _dereq_("./uint8ArrayWriter");
            var getRawData = function(file) {
                if (file._data instanceof CompressedObject) {
                    file._data = file._data.getContent();
                    file.options.binary = true;
                    file.options.base64 = false;
                    if (utils.getTypeOf(file._data) === "uint8array") {
                        var copy = file._data;
                        file._data = new Uint8Array(copy.length);
                        if (copy.length !== 0) {
                            file._data.set(copy, 0);
                        }
                    }
                }
                return file._data;
            };
            var getBinaryData = function(file) {
                var result = getRawData(file), type = utils.getTypeOf(result);
                if (type === "string") {
                    if (!file.options.binary) {
                        if (support.nodebuffer) {
                            return nodeBuffer(result, "utf-8");
                        }
                    }
                    return file.asBinary();
                }
                return result;
            };
            var dataToString = function(asUTF8) {
                var result = getRawData(this);
                if (result === null || typeof result === "undefined") {
                    return "";
                }
                if (this.options.base64) {
                    result = base64.decode(result);
                }
                if (asUTF8 && this.options.binary) {
                    result = out.utf8decode(result);
                } else {
                    result = utils.transformTo("string", result);
                }
                if (!asUTF8 && !this.options.binary) {
                    result = utils.transformTo("string", out.utf8encode(result));
                }
                return result;
            };
            var ZipObject = function(name, data, options) {
                this.name = name;
                this.dir = options.dir;
                this.date = options.date;
                this.comment = options.comment;
                this._data = data;
                this.options = options;
                this._initialMetadata = {
                    "dir": options.dir,
                    "date": options.date
                };
            };
            ZipObject.prototype = {
                "asText": function() {
                    return dataToString.call(this, true);
                },
                "asBinary": function() {
                    return dataToString.call(this, false);
                },
                "asNodeBuffer": function() {
                    var result = getBinaryData(this);
                    return utils.transformTo("nodebuffer", result);
                },
                "asUint8Array": function() {
                    var result = getBinaryData(this);
                    return utils.transformTo("uint8array", result);
                },
                "asArrayBuffer": function() {
                    return this.asUint8Array().buffer;
                }
            };
            var decToHex = function(dec, bytes) {
                var hex = "", i;
                for (i = 0; i < bytes; i++) {
                    hex += String.fromCharCode(dec & 255);
                    dec = dec >>> 8;
                }
                return hex;
            };
            var extend = function() {
                var result = {}, i, attr;
                for (i = 0; i < arguments.length; i++) {
                    for (attr in arguments[i]) {
                        if (arguments[i].hasOwnProperty(attr) && typeof result[attr] === "undefined") {
                            result[attr] = arguments[i][attr];
                        }
                    }
                }
                return result;
            };
            var prepareFileAttrs = function(o) {
                o = o || {};
                if (o.base64 === true && (o.binary === null || o.binary === undefined)) {
                    o.binary = true;
                }
                o = extend(o, defaults);
                o.date = o.date || new Date();
                if (o.compression !== null) o.compression = o.compression.toUpperCase();
                return o;
            };
            var fileAdd = function(name, data, o) {
                var dataType = utils.getTypeOf(data), parent;
                o = prepareFileAttrs(o);
                if (o.createFolders && (parent = parentFolder(name))) {
                    folderAdd.call(this, parent, true);
                }
                if (o.dir || data === null || typeof data === "undefined") {
                    o.base64 = false;
                    o.binary = false;
                    data = null;
                } else if (dataType === "string") {
                    if (o.binary && !o.base64) {
                        if (o.optimizedBinaryString !== true) {
                            data = utils.string2binary(data);
                        }
                    }
                } else {
                    o.base64 = false;
                    o.binary = true;
                    if (!dataType && !(data instanceof CompressedObject)) {
                        throw new Error("The data of '" + name + "' is in an unsupported format !");
                    }
                    if (dataType === "arraybuffer") {
                        data = utils.transformTo("uint8array", data);
                    }
                }
                var object = new ZipObject(name, data, o);
                this.files[name] = object;
                return object;
            };
            var parentFolder = function(path) {
                if (path.slice(-1) == "/") {
                    path = path.substring(0, path.length - 1);
                }
                var lastSlash = path.lastIndexOf("/");
                return lastSlash > 0 ? path.substring(0, lastSlash) : "";
            };
            var folderAdd = function(name, createFolders) {
                if (name.slice(-1) != "/") {
                    name += "/";
                }
                createFolders = typeof createFolders !== "undefined" ? createFolders : false;
                if (!this.files[name]) {
                    fileAdd.call(this, name, null, {
                        "dir": true,
                        "createFolders": createFolders
                    });
                }
                return this.files[name];
            };
            var generateCompressedObjectFrom = function(file, compression) {
                var result = new CompressedObject(), content;
                if (file._data instanceof CompressedObject) {
                    result.uncompressedSize = file._data.uncompressedSize;
                    result.crc32 = file._data.crc32;
                    if (result.uncompressedSize === 0 || file.dir) {
                        compression = compressions["STORE"];
                        result.compressedContent = "";
                        result.crc32 = 0;
                    } else if (file._data.compressionMethod === compression.magic) {
                        result.compressedContent = file._data.getCompressedContent();
                    } else {
                        content = file._data.getContent();
                        result.compressedContent = compression.compress(utils.transformTo(compression.compressInputType, content));
                    }
                } else {
                    content = getBinaryData(file);
                    if (!content || content.length === 0 || file.dir) {
                        compression = compressions["STORE"];
                        content = "";
                    }
                    result.uncompressedSize = content.length;
                    result.crc32 = crc32(content);
                    result.compressedContent = compression.compress(utils.transformTo(compression.compressInputType, content));
                }
                result.compressedSize = result.compressedContent.length;
                result.compressionMethod = compression.magic;
                return result;
            };
            var generateZipParts = function(name, file, compressedObject, offset) {
                var data = compressedObject.compressedContent, utfEncodedFileName = utils.transformTo("string", utf8.utf8encode(file.name)), comment = file.comment || "", utfEncodedComment = utils.transformTo("string", utf8.utf8encode(comment)), useUTF8ForFileName = utfEncodedFileName.length !== file.name.length, useUTF8ForComment = utfEncodedComment.length !== comment.length, o = file.options, dosTime, dosDate, extraFields = "", unicodePathExtraField = "", unicodeCommentExtraField = "", dir, date;
                if (file._initialMetadata.dir !== file.dir) {
                    dir = file.dir;
                } else {
                    dir = o.dir;
                }
                if (file._initialMetadata.date !== file.date) {
                    date = file.date;
                } else {
                    date = o.date;
                }
                dosTime = date.getHours();
                dosTime = dosTime << 6;
                dosTime = dosTime | date.getMinutes();
                dosTime = dosTime << 5;
                dosTime = dosTime | date.getSeconds() / 2;
                dosDate = date.getFullYear() - 1980;
                dosDate = dosDate << 4;
                dosDate = dosDate | date.getMonth() + 1;
                dosDate = dosDate << 5;
                dosDate = dosDate | date.getDate();
                if (useUTF8ForFileName) {
                    unicodePathExtraField = decToHex(1, 1) + decToHex(crc32(utfEncodedFileName), 4) + utfEncodedFileName;
                    extraFields += "up" + decToHex(unicodePathExtraField.length, 2) + unicodePathExtraField;
                }
                if (useUTF8ForComment) {
                    unicodeCommentExtraField = decToHex(1, 1) + decToHex(this.crc32(utfEncodedComment), 4) + utfEncodedComment;
                    extraFields += "uc" + decToHex(unicodeCommentExtraField.length, 2) + unicodeCommentExtraField;
                }
                var header = "";
                header += "\n\0";
                header += useUTF8ForFileName || useUTF8ForComment ? "\0\b" : "\0\0";
                header += compressedObject.compressionMethod;
                header += decToHex(dosTime, 2);
                header += decToHex(dosDate, 2);
                header += decToHex(compressedObject.crc32, 4);
                header += decToHex(compressedObject.compressedSize, 4);
                header += decToHex(compressedObject.uncompressedSize, 4);
                header += decToHex(utfEncodedFileName.length, 2);
                header += decToHex(extraFields.length, 2);
                var fileRecord = signature.LOCAL_FILE_HEADER + header + utfEncodedFileName + extraFields;
                var dirRecord = signature.CENTRAL_FILE_HEADER + "\x14\0" + header + decToHex(utfEncodedComment.length, 2) + "\0\0" + "\0\0" + (dir === true ? "\x10\0\0\0" : "\0\0\0\0") + decToHex(offset, 4) + utfEncodedFileName + extraFields + utfEncodedComment;
                return {
                    "fileRecord": fileRecord,
                    "dirRecord": dirRecord,
                    "compressedObject": compressedObject
                };
            };
            var out = {
                "load": function(stream, options) {
                    throw new Error("Load method is not defined. Is the file jszip-load.js included ?");
                },
                "filter": function(search) {
                    var result = [], filename, relativePath, file, fileClone;
                    for (filename in this.files) {
                        if (!this.files.hasOwnProperty(filename)) {
                            continue;
                        }
                        file = this.files[filename];
                        fileClone = new ZipObject(file.name, file._data, extend(file.options));
                        relativePath = filename.slice(this.root.length, filename.length);
                        if (filename.slice(0, this.root.length) === this.root && search(relativePath, fileClone)) {
                            result.push(fileClone);
                        }
                    }
                    return result;
                },
                "file": function(name, data, o) {
                    if (arguments.length === 1) {
                        if (utils.isRegExp(name)) {
                            var regexp = name;
                            return this.filter(function(relativePath, file) {
                                return !file.dir && regexp.test(relativePath);
                            });
                        } else {
                            return this.filter(function(relativePath, file) {
                                return !file.dir && relativePath === name;
                            })[0] || null;
                        }
                    } else {
                        name = this.root + name;
                        fileAdd.call(this, name, data, o);
                    }
                    return this;
                },
                "folder": function(arg) {
                    if (!arg) {
                        return this;
                    }
                    if (utils.isRegExp(arg)) {
                        return this.filter(function(relativePath, file) {
                            return file.dir && arg.test(relativePath);
                        });
                    }
                    var name = this.root + arg;
                    var newFolder = folderAdd.call(this, name);
                    var ret = this.clone();
                    ret.root = newFolder.name;
                    return ret;
                },
                "remove": function(name) {
                    name = this.root + name;
                    var file = this.files[name];
                    if (!file) {
                        if (name.slice(-1) != "/") {
                            name += "/";
                        }
                        file = this.files[name];
                    }
                    if (file && !file.dir) {
                        delete this.files[name];
                    } else {
                        var kids = this.filter(function(relativePath, file) {
                            return file.name.slice(0, name.length) === name;
                        });
                        for (var i = 0; i < kids.length; i++) {
                            delete this.files[kids[i].name];
                        }
                    }
                    return this;
                },
                "generate": function(options) {
                    options = extend(options || {}, {
                        "base64": true,
                        "compression": "STORE",
                        "type": "base64",
                        "comment": null
                    });
                    utils.checkSupport(options.type);
                    var zipData = [], localDirLength = 0, centralDirLength = 0, writer, i, utfEncodedComment = utils.transformTo("string", this.utf8encode(options.comment || this.comment || ""));
                    for (var name in this.files) {
                        if (!this.files.hasOwnProperty(name)) {
                            continue;
                        }
                        var file = this.files[name];
                        var compressionName = file.options.compression || options.compression.toUpperCase();
                        var compression = compressions[compressionName];
                        if (!compression) {
                            throw new Error(compressionName + " is not a valid compression method !");
                        }
                        var compressedObject = generateCompressedObjectFrom.call(this, file, compression);
                        var zipPart = generateZipParts.call(this, name, file, compressedObject, localDirLength);
                        localDirLength += zipPart.fileRecord.length + compressedObject.compressedSize;
                        centralDirLength += zipPart.dirRecord.length;
                        zipData.push(zipPart);
                    }
                    var dirEnd = "";
                    dirEnd = signature.CENTRAL_DIRECTORY_END + "\0\0" + "\0\0" + decToHex(zipData.length, 2) + decToHex(zipData.length, 2) + decToHex(centralDirLength, 4) + decToHex(localDirLength, 4) + decToHex(utfEncodedComment.length, 2) + utfEncodedComment;
                    var typeName = options.type.toLowerCase();
                    if (typeName === "uint8array" || typeName === "arraybuffer" || typeName === "blob" || typeName === "nodebuffer") {
                        writer = new Uint8ArrayWriter(localDirLength + centralDirLength + dirEnd.length);
                    } else {
                        writer = new StringWriter(localDirLength + centralDirLength + dirEnd.length);
                    }
                    for (i = 0; i < zipData.length; i++) {
                        writer.append(zipData[i].fileRecord);
                        writer.append(zipData[i].compressedObject.compressedContent);
                    }
                    for (i = 0; i < zipData.length; i++) {
                        writer.append(zipData[i].dirRecord);
                    }
                    writer.append(dirEnd);
                    var zip = writer.finalize();
                    switch (options.type.toLowerCase()) {
                      case "uint8array":
                      case "arraybuffer":
                      case "nodebuffer":
                        return utils.transformTo(options.type.toLowerCase(), zip);

                      case "blob":
                        return utils.arrayBuffer2Blob(utils.transformTo("arraybuffer", zip));

                      case "base64":
                        return options.base64 ? base64.encode(zip) : zip;

                      default:
                        return zip;
                    }
                },
                "crc32": function(input, crc) {
                    return crc32(input, crc);
                },
                "utf8encode": function(string) {
                    return utils.transformTo("string", utf8.utf8encode(string));
                },
                "utf8decode": function(input) {
                    return utf8.utf8decode(input);
                }
            };
            module.exports = out;
        }, {
            "./base64": 1,
            "./compressedObject": 2,
            "./compressions": 3,
            "./crc32": 4,
            "./defaults": 6,
            "./nodeBuffer": 11,
            "./signature": 14,
            "./stringWriter": 16,
            "./support": 17,
            "./uint8ArrayWriter": 19,
            "./utf8": 20,
            "./utils": 21
        } ],
        "14": [ function(_dereq_, module, exports) {
            "use strict";
            exports.LOCAL_FILE_HEADER = "PK\x03\x04";
            exports.CENTRAL_FILE_HEADER = "PK\x01\x02";
            exports.CENTRAL_DIRECTORY_END = "PK\x05\x06";
            exports.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x06\x07";
            exports.ZIP64_CENTRAL_DIRECTORY_END = "PK\x06\x06";
            exports.DATA_DESCRIPTOR = "PK\x07\b";
        }, {} ],
        "15": [ function(_dereq_, module, exports) {
            "use strict";
            var DataReader = _dereq_("./dataReader");
            var utils = _dereq_("./utils");
            function StringReader(data, optimizedBinaryString) {
                this.data = data;
                if (!optimizedBinaryString) {
                    this.data = utils.string2binary(this.data);
                }
                this.length = this.data.length;
                this.index = 0;
            }
            StringReader.prototype = new DataReader();
            StringReader.prototype.byteAt = function(i) {
                return this.data.charCodeAt(i);
            };
            StringReader.prototype.lastIndexOfSignature = function(sig) {
                return this.data.lastIndexOf(sig);
            };
            StringReader.prototype.readData = function(size) {
                this.checkOffset(size);
                var result = this.data.slice(this.index, this.index + size);
                this.index += size;
                return result;
            };
            module.exports = StringReader;
        }, {
            "./dataReader": 5,
            "./utils": 21
        } ],
        "16": [ function(_dereq_, module, exports) {
            "use strict";
            var utils = _dereq_("./utils");
            var StringWriter = function() {
                this.data = [];
            };
            StringWriter.prototype = {
                "append": function(input) {
                    input = utils.transformTo("string", input);
                    this.data.push(input);
                },
                "finalize": function() {
                    return this.data.join("");
                }
            };
            module.exports = StringWriter;
        }, {
            "./utils": 21
        } ],
        "17": [ function(_dereq_, module, exports) {
            (function(Buffer) {
                "use strict";
                exports.base64 = true;
                exports.array = true;
                exports.string = true;
                exports.arraybuffer = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined";
                exports.nodebuffer = typeof Buffer !== "undefined";
                exports.uint8array = typeof Uint8Array !== "undefined";
                if (typeof ArrayBuffer === "undefined") {
                    exports.blob = false;
                } else {
                    var buffer = new ArrayBuffer(0);
                    try {
                        exports.blob = new Blob([ buffer ], {
                            "type": "application/zip"
                        }).size === 0;
                    } catch (e) {
                        try {
                            var Builder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;
                            var builder = new Builder();
                            builder.append(buffer);
                            exports.blob = builder.getBlob("application/zip").size === 0;
                        } catch (e) {
                            exports.blob = false;
                        }
                    }
                }
            }).call(this, typeof Buffer !== "undefined" ? Buffer : undefined);
        }, {} ],
        "18": [ function(_dereq_, module, exports) {
            "use strict";
            var DataReader = _dereq_("./dataReader");
            function Uint8ArrayReader(data) {
                if (data) {
                    this.data = data;
                    this.length = this.data.length;
                    this.index = 0;
                }
            }
            Uint8ArrayReader.prototype = new DataReader();
            Uint8ArrayReader.prototype.byteAt = function(i) {
                return this.data[i];
            };
            Uint8ArrayReader.prototype.lastIndexOfSignature = function(sig) {
                var sig0 = sig.charCodeAt(0), sig1 = sig.charCodeAt(1), sig2 = sig.charCodeAt(2), sig3 = sig.charCodeAt(3);
                for (var i = this.length - 4; i >= 0; --i) {
                    if (this.data[i] === sig0 && this.data[i + 1] === sig1 && this.data[i + 2] === sig2 && this.data[i + 3] === sig3) {
                        return i;
                    }
                }
                return -1;
            };
            Uint8ArrayReader.prototype.readData = function(size) {
                this.checkOffset(size);
                if (size === 0) {
                    return new Uint8Array(0);
                }
                var result = this.data.subarray(this.index, this.index + size);
                this.index += size;
                return result;
            };
            module.exports = Uint8ArrayReader;
        }, {
            "./dataReader": 5
        } ],
        "19": [ function(_dereq_, module, exports) {
            "use strict";
            var utils = _dereq_("./utils");
            var Uint8ArrayWriter = function(length) {
                this.data = new Uint8Array(length);
                this.index = 0;
            };
            Uint8ArrayWriter.prototype = {
                "append": function(input) {
                    if (input.length !== 0) {
                        input = utils.transformTo("uint8array", input);
                        this.data.set(input, this.index);
                        this.index += input.length;
                    }
                },
                "finalize": function() {
                    return this.data;
                }
            };
            module.exports = Uint8ArrayWriter;
        }, {
            "./utils": 21
        } ],
        "20": [ function(_dereq_, module, exports) {
            "use strict";
            var utils = _dereq_("./utils");
            var support = _dereq_("./support");
            var nodeBuffer = _dereq_("./nodeBuffer");
            var _utf8len = new Array(256);
            for (var i = 0; i < 256; i++) {
                _utf8len[i] = i >= 252 ? 6 : i >= 248 ? 5 : i >= 240 ? 4 : i >= 224 ? 3 : i >= 192 ? 2 : 1;
            }
            _utf8len[254] = _utf8len[254] = 1;
            var string2buf = function(str) {
                var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;
                for (m_pos = 0; m_pos < str_len; m_pos++) {
                    c = str.charCodeAt(m_pos);
                    if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
                        c2 = str.charCodeAt(m_pos + 1);
                        if ((c2 & 64512) === 56320) {
                            c = 65536 + (c - 55296 << 10) + (c2 - 56320);
                            m_pos++;
                        }
                    }
                    buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
                }
                if (support.uint8array) {
                    buf = new Uint8Array(buf_len);
                } else {
                    buf = new Array(buf_len);
                }
                for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
                    c = str.charCodeAt(m_pos);
                    if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
                        c2 = str.charCodeAt(m_pos + 1);
                        if ((c2 & 64512) === 56320) {
                            c = 65536 + (c - 55296 << 10) + (c2 - 56320);
                            m_pos++;
                        }
                    }
                    if (c < 128) {
                        buf[i++] = c;
                    } else if (c < 2048) {
                        buf[i++] = 192 | c >>> 6;
                        buf[i++] = 128 | c & 63;
                    } else if (c < 65536) {
                        buf[i++] = 224 | c >>> 12;
                        buf[i++] = 128 | c >>> 6 & 63;
                        buf[i++] = 128 | c & 63;
                    } else {
                        buf[i++] = 240 | c >>> 18;
                        buf[i++] = 128 | c >>> 12 & 63;
                        buf[i++] = 128 | c >>> 6 & 63;
                        buf[i++] = 128 | c & 63;
                    }
                }
                return buf;
            };
            var utf8border = function(buf, max) {
                var pos;
                max = max || buf.length;
                if (max > buf.length) {
                    max = buf.length;
                }
                pos = max - 1;
                while (pos >= 0 && (buf[pos] & 192) === 128) {
                    pos--;
                }
                if (pos < 0) {
                    return max;
                }
                if (pos === 0) {
                    return max;
                }
                return pos + _utf8len[buf[pos]] > max ? pos : max;
            };
            var buf2string = function(buf) {
                var str, i, out, c, c_len;
                var len = buf.length;
                var utf16buf = new Array(len * 2);
                for (out = 0, i = 0; i < len; ) {
                    c = buf[i++];
                    if (c < 128) {
                        utf16buf[out++] = c;
                        continue;
                    }
                    c_len = _utf8len[c];
                    if (c_len > 4) {
                        utf16buf[out++] = 65533;
                        i += c_len - 1;
                        continue;
                    }
                    c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
                    while (c_len > 1 && i < len) {
                        c = c << 6 | buf[i++] & 63;
                        c_len--;
                    }
                    if (c_len > 1) {
                        utf16buf[out++] = 65533;
                        continue;
                    }
                    if (c < 65536) {
                        utf16buf[out++] = c;
                    } else {
                        c -= 65536;
                        utf16buf[out++] = 55296 | c >> 10 & 1023;
                        utf16buf[out++] = 56320 | c & 1023;
                    }
                }
                if (utf16buf.length !== out) {
                    if (utf16buf.subarray) {
                        utf16buf = utf16buf.subarray(0, out);
                    } else {
                        utf16buf.length = out;
                    }
                }
                return utils.applyFromCharCode(utf16buf);
            };
            exports.utf8encode = function utf8encode(str) {
                if (support.nodebuffer) {
                    return nodeBuffer(str, "utf-8");
                }
                return string2buf(str);
            };
            exports.utf8decode = function utf8decode(buf) {
                if (support.nodebuffer) {
                    return utils.transformTo("nodebuffer", buf).toString("utf-8");
                }
                buf = utils.transformTo(support.uint8array ? "uint8array" : "array", buf);
                var result = [], k = 0, len = buf.length, chunk = 65536;
                while (k < len) {
                    var nextBoundary = utf8border(buf, Math.min(k + chunk, len));
                    if (support.uint8array) {
                        result.push(buf2string(buf.subarray(k, nextBoundary)));
                    } else {
                        result.push(buf2string(buf.slice(k, nextBoundary)));
                    }
                    k = nextBoundary;
                }
                return result.join("");
            };
        }, {
            "./nodeBuffer": 11,
            "./support": 17,
            "./utils": 21
        } ],
        "21": [ function(_dereq_, module, exports) {
            "use strict";
            var support = _dereq_("./support");
            var compressions = _dereq_("./compressions");
            var nodeBuffer = _dereq_("./nodeBuffer");
            exports.string2binary = function(str) {
                var result = "";
                for (var i = 0; i < str.length; i++) {
                    result += String.fromCharCode(str.charCodeAt(i) & 255);
                }
                return result;
            };
            exports.arrayBuffer2Blob = function(buffer) {
                exports.checkSupport("blob");
                try {
                    return new Blob([ buffer ], {
                        "type": "application/zip"
                    });
                } catch (e) {
                    try {
                        var Builder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;
                        var builder = new Builder();
                        builder.append(buffer);
                        return builder.getBlob("application/zip");
                    } catch (e) {
                        throw new Error("Bug : can't construct the Blob.");
                    }
                }
            };
            function identity(input) {
                return input;
            }
            function stringToArrayLike(str, array) {
                for (var i = 0; i < str.length; ++i) {
                    array[i] = str.charCodeAt(i) & 255;
                }
                return array;
            }
            function arrayLikeToString(array) {
                var chunk = 65536;
                var result = [], len = array.length, type = exports.getTypeOf(array), k = 0, canUseApply = true;
                try {
                    switch (type) {
                      case "uint8array":
                        String.fromCharCode.apply(null, new Uint8Array(0));
                        break;

                      case "nodebuffer":
                        String.fromCharCode.apply(null, nodeBuffer(0));
                        break;
                    }
                } catch (e) {
                    canUseApply = false;
                }
                if (!canUseApply) {
                    var resultStr = "";
                    for (var i = 0; i < array.length; i++) {
                        resultStr += String.fromCharCode(array[i]);
                    }
                    return resultStr;
                }
                while (k < len && chunk > 1) {
                    try {
                        if (type === "array" || type === "nodebuffer") {
                            result.push(String.fromCharCode.apply(null, array.slice(k, Math.min(k + chunk, len))));
                        } else {
                            result.push(String.fromCharCode.apply(null, array.subarray(k, Math.min(k + chunk, len))));
                        }
                        k += chunk;
                    } catch (e) {
                        chunk = Math.floor(chunk / 2);
                    }
                }
                return result.join("");
            }
            exports.applyFromCharCode = arrayLikeToString;
            function arrayLikeToArrayLike(arrayFrom, arrayTo) {
                for (var i = 0; i < arrayFrom.length; i++) {
                    arrayTo[i] = arrayFrom[i];
                }
                return arrayTo;
            }
            var transform = {};
            transform["string"] = {
                "string": identity,
                "array": function(input) {
                    return stringToArrayLike(input, new Array(input.length));
                },
                "arraybuffer": function(input) {
                    return transform["string"]["uint8array"](input).buffer;
                },
                "uint8array": function(input) {
                    return stringToArrayLike(input, new Uint8Array(input.length));
                },
                "nodebuffer": function(input) {
                    return stringToArrayLike(input, nodeBuffer(input.length));
                }
            };
            transform["array"] = {
                "string": arrayLikeToString,
                "array": identity,
                "arraybuffer": function(input) {
                    return new Uint8Array(input).buffer;
                },
                "uint8array": function(input) {
                    return new Uint8Array(input);
                },
                "nodebuffer": function(input) {
                    return nodeBuffer(input);
                }
            };
            transform["arraybuffer"] = {
                "string": function(input) {
                    return arrayLikeToString(new Uint8Array(input));
                },
                "array": function(input) {
                    return arrayLikeToArrayLike(new Uint8Array(input), new Array(input.byteLength));
                },
                "arraybuffer": identity,
                "uint8array": function(input) {
                    return new Uint8Array(input);
                },
                "nodebuffer": function(input) {
                    return nodeBuffer(new Uint8Array(input));
                }
            };
            transform["uint8array"] = {
                "string": arrayLikeToString,
                "array": function(input) {
                    return arrayLikeToArrayLike(input, new Array(input.length));
                },
                "arraybuffer": function(input) {
                    return input.buffer;
                },
                "uint8array": identity,
                "nodebuffer": function(input) {
                    return nodeBuffer(input);
                }
            };
            transform["nodebuffer"] = {
                "string": arrayLikeToString,
                "array": function(input) {
                    return arrayLikeToArrayLike(input, new Array(input.length));
                },
                "arraybuffer": function(input) {
                    return transform["nodebuffer"]["uint8array"](input).buffer;
                },
                "uint8array": function(input) {
                    return arrayLikeToArrayLike(input, new Uint8Array(input.length));
                },
                "nodebuffer": identity
            };
            exports.transformTo = function(outputType, input) {
                if (!input) {
                    input = "";
                }
                if (!outputType) {
                    return input;
                }
                exports.checkSupport(outputType);
                var inputType = exports.getTypeOf(input);
                var result = transform[inputType][outputType](input);
                return result;
            };
            exports.getTypeOf = function(input) {
                if (typeof input === "string") {
                    return "string";
                }
                if (Object.prototype.toString.call(input) === "[object Array]") {
                    return "array";
                }
                if (support.nodebuffer && nodeBuffer.test(input)) {
                    return "nodebuffer";
                }
                if (support.uint8array && input instanceof Uint8Array) {
                    return "uint8array";
                }
                if (support.arraybuffer && input instanceof ArrayBuffer) {
                    return "arraybuffer";
                }
            };
            exports.checkSupport = function(type) {
                var supported = support[type.toLowerCase()];
                if (!supported) {
                    throw new Error(type + " is not supported by this browser");
                }
            };
            exports.MAX_VALUE_16BITS = 65535;
            exports.MAX_VALUE_32BITS = -1;
            exports.pretty = function(str) {
                var res = "", code, i;
                for (i = 0; i < (str || "").length; i++) {
                    code = str.charCodeAt(i);
                    res += "\\x" + (code < 16 ? "0" : "") + code.toString(16).toUpperCase();
                }
                return res;
            };
            exports.findCompression = function(compressionMethod) {
                for (var method in compressions) {
                    if (!compressions.hasOwnProperty(method)) {
                        continue;
                    }
                    if (compressions[method].magic === compressionMethod) {
                        return compressions[method];
                    }
                }
                return null;
            };
            exports.isRegExp = function(object) {
                return Object.prototype.toString.call(object) === "[object RegExp]";
            };
        }, {
            "./compressions": 3,
            "./nodeBuffer": 11,
            "./support": 17
        } ],
        "22": [ function(_dereq_, module, exports) {
            "use strict";
            var StringReader = _dereq_("./stringReader");
            var NodeBufferReader = _dereq_("./nodeBufferReader");
            var Uint8ArrayReader = _dereq_("./uint8ArrayReader");
            var utils = _dereq_("./utils");
            var sig = _dereq_("./signature");
            var ZipEntry = _dereq_("./zipEntry");
            var support = _dereq_("./support");
            var jszipProto = _dereq_("./object");
            function ZipEntries(data, loadOptions) {
                this.files = [];
                this.loadOptions = loadOptions;
                if (data) {
                    this.load(data);
                }
            }
            ZipEntries.prototype = {
                "checkSignature": function(expectedSignature) {
                    var signature = this.reader.readString(4);
                    if (signature !== expectedSignature) {
                        throw new Error("Corrupted zip or bug : unexpected signature " + "(" + utils.pretty(signature) + ", expected " + utils.pretty(expectedSignature) + ")");
                    }
                },
                "readBlockEndOfCentral": function() {
                    this.diskNumber = this.reader.readInt(2);
                    this.diskWithCentralDirStart = this.reader.readInt(2);
                    this.centralDirRecordsOnThisDisk = this.reader.readInt(2);
                    this.centralDirRecords = this.reader.readInt(2);
                    this.centralDirSize = this.reader.readInt(4);
                    this.centralDirOffset = this.reader.readInt(4);
                    this.zipCommentLength = this.reader.readInt(2);
                    this.zipComment = this.reader.readString(this.zipCommentLength);
                    this.zipComment = jszipProto.utf8decode(this.zipComment);
                },
                "readBlockZip64EndOfCentral": function() {
                    this.zip64EndOfCentralSize = this.reader.readInt(8);
                    this.versionMadeBy = this.reader.readString(2);
                    this.versionNeeded = this.reader.readInt(2);
                    this.diskNumber = this.reader.readInt(4);
                    this.diskWithCentralDirStart = this.reader.readInt(4);
                    this.centralDirRecordsOnThisDisk = this.reader.readInt(8);
                    this.centralDirRecords = this.reader.readInt(8);
                    this.centralDirSize = this.reader.readInt(8);
                    this.centralDirOffset = this.reader.readInt(8);
                    this.zip64ExtensibleData = {};
                    var extraDataSize = this.zip64EndOfCentralSize - 44, index = 0, extraFieldId, extraFieldLength, extraFieldValue;
                    while (index < extraDataSize) {
                        extraFieldId = this.reader.readInt(2);
                        extraFieldLength = this.reader.readInt(4);
                        extraFieldValue = this.reader.readString(extraFieldLength);
                        this.zip64ExtensibleData[extraFieldId] = {
                            "id": extraFieldId,
                            "length": extraFieldLength,
                            "value": extraFieldValue
                        };
                    }
                },
                "readBlockZip64EndOfCentralLocator": function() {
                    this.diskWithZip64CentralDirStart = this.reader.readInt(4);
                    this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8);
                    this.disksCount = this.reader.readInt(4);
                    if (this.disksCount > 1) {
                        throw new Error("Multi-volumes zip are not supported");
                    }
                },
                "readLocalFiles": function() {
                    var i, file;
                    for (i = 0; i < this.files.length; i++) {
                        file = this.files[i];
                        this.reader.setIndex(file.localHeaderOffset);
                        this.checkSignature(sig.LOCAL_FILE_HEADER);
                        file.readLocalPart(this.reader);
                        file.handleUTF8();
                    }
                },
                "readCentralDir": function() {
                    var file;
                    this.reader.setIndex(this.centralDirOffset);
                    while (this.reader.readString(4) === sig.CENTRAL_FILE_HEADER) {
                        file = new ZipEntry({
                            "zip64": this.zip64
                        }, this.loadOptions);
                        file.readCentralPart(this.reader);
                        this.files.push(file);
                    }
                },
                "readEndOfCentral": function() {
                    var offset = this.reader.lastIndexOfSignature(sig.CENTRAL_DIRECTORY_END);
                    if (offset === -1) {
                        throw new Error("Corrupted zip : can't find end of central directory");
                    }
                    this.reader.setIndex(offset);
                    this.checkSignature(sig.CENTRAL_DIRECTORY_END);
                    this.readBlockEndOfCentral();
                    if (this.diskNumber === utils.MAX_VALUE_16BITS || this.diskWithCentralDirStart === utils.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === utils.MAX_VALUE_16BITS || this.centralDirRecords === utils.MAX_VALUE_16BITS || this.centralDirSize === utils.MAX_VALUE_32BITS || this.centralDirOffset === utils.MAX_VALUE_32BITS) {
                        this.zip64 = true;
                        offset = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
                        if (offset === -1) {
                            throw new Error("Corrupted zip : can't find the ZIP64 end of central directory locator");
                        }
                        this.reader.setIndex(offset);
                        this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
                        this.readBlockZip64EndOfCentralLocator();
                        this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir);
                        this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);
                        this.readBlockZip64EndOfCentral();
                    }
                },
                "prepareReader": function(data) {
                    var type = utils.getTypeOf(data);
                    if (type === "string" && !support.uint8array) {
                        this.reader = new StringReader(data, this.loadOptions.optimizedBinaryString);
                    } else if (type === "nodebuffer") {
                        this.reader = new NodeBufferReader(data);
                    } else {
                        this.reader = new Uint8ArrayReader(utils.transformTo("uint8array", data));
                    }
                },
                "load": function(data) {
                    this.prepareReader(data);
                    this.readEndOfCentral();
                    this.readCentralDir();
                    this.readLocalFiles();
                }
            };
            module.exports = ZipEntries;
        }, {
            "./nodeBufferReader": 12,
            "./object": 13,
            "./signature": 14,
            "./stringReader": 15,
            "./support": 17,
            "./uint8ArrayReader": 18,
            "./utils": 21,
            "./zipEntry": 23
        } ],
        "23": [ function(_dereq_, module, exports) {
            "use strict";
            var StringReader = _dereq_("./stringReader");
            var utils = _dereq_("./utils");
            var CompressedObject = _dereq_("./compressedObject");
            var jszipProto = _dereq_("./object");
            function ZipEntry(options, loadOptions) {
                this.options = options;
                this.loadOptions = loadOptions;
            }
            ZipEntry.prototype = {
                "isEncrypted": function() {
                    return (this.bitFlag & 1) === 1;
                },
                "useUTF8": function() {
                    return (this.bitFlag & 2048) === 2048;
                },
                "prepareCompressedContent": function(reader, from, length) {
                    return function() {
                        var previousIndex = reader.index;
                        reader.setIndex(from);
                        var compressedFileData = reader.readData(length);
                        reader.setIndex(previousIndex);
                        return compressedFileData;
                    };
                },
                "prepareContent": function(reader, from, length, compression, uncompressedSize) {
                    return function() {
                        var compressedFileData = utils.transformTo(compression.uncompressInputType, this.getCompressedContent());
                        var uncompressedFileData = compression.uncompress(compressedFileData);
                        if (uncompressedFileData.length !== uncompressedSize) {
                            throw new Error("Bug : uncompressed data size mismatch");
                        }
                        return uncompressedFileData;
                    };
                },
                "readLocalPart": function(reader) {
                    var compression, localExtraFieldsLength;
                    reader.skip(22);
                    this.fileNameLength = reader.readInt(2);
                    localExtraFieldsLength = reader.readInt(2);
                    this.fileName = reader.readString(this.fileNameLength);
                    reader.skip(localExtraFieldsLength);
                    if (this.compressedSize == -1 || this.uncompressedSize == -1) {
                        throw new Error("Bug or corrupted zip : didn't get enough informations from the central directory " + "(compressedSize == -1 || uncompressedSize == -1)");
                    }
                    compression = utils.findCompression(this.compressionMethod);
                    if (compression === null) {
                        throw new Error("Corrupted zip : compression " + utils.pretty(this.compressionMethod) + " unknown (inner file : " + this.fileName + ")");
                    }
                    this.decompressed = new CompressedObject();
                    this.decompressed.compressedSize = this.compressedSize;
                    this.decompressed.uncompressedSize = this.uncompressedSize;
                    this.decompressed.crc32 = this.crc32;
                    this.decompressed.compressionMethod = this.compressionMethod;
                    this.decompressed.getCompressedContent = this.prepareCompressedContent(reader, reader.index, this.compressedSize, compression);
                    this.decompressed.getContent = this.prepareContent(reader, reader.index, this.compressedSize, compression, this.uncompressedSize);
                    if (this.loadOptions.checkCRC32) {
                        this.decompressed = utils.transformTo("string", this.decompressed.getContent());
                        if (jszipProto.crc32(this.decompressed) !== this.crc32) {
                            throw new Error("Corrupted zip : CRC32 mismatch");
                        }
                    }
                },
                "readCentralPart": function(reader) {
                    this.versionMadeBy = reader.readString(2);
                    this.versionNeeded = reader.readInt(2);
                    this.bitFlag = reader.readInt(2);
                    this.compressionMethod = reader.readString(2);
                    this.date = reader.readDate();
                    this.crc32 = reader.readInt(4);
                    this.compressedSize = reader.readInt(4);
                    this.uncompressedSize = reader.readInt(4);
                    this.fileNameLength = reader.readInt(2);
                    this.extraFieldsLength = reader.readInt(2);
                    this.fileCommentLength = reader.readInt(2);
                    this.diskNumberStart = reader.readInt(2);
                    this.internalFileAttributes = reader.readInt(2);
                    this.externalFileAttributes = reader.readInt(4);
                    this.localHeaderOffset = reader.readInt(4);
                    if (this.isEncrypted()) {
                        throw new Error("Encrypted zip are not supported");
                    }
                    this.fileName = reader.readString(this.fileNameLength);
                    this.readExtraFields(reader);
                    this.parseZIP64ExtraField(reader);
                    this.fileComment = reader.readString(this.fileCommentLength);
                    this.dir = this.externalFileAttributes & 16 ? true : false;
                },
                "parseZIP64ExtraField": function(reader) {
                    if (!this.extraFields[1]) {
                        return;
                    }
                    var extraReader = new StringReader(this.extraFields[1].value);
                    if (this.uncompressedSize === utils.MAX_VALUE_32BITS) {
                        this.uncompressedSize = extraReader.readInt(8);
                    }
                    if (this.compressedSize === utils.MAX_VALUE_32BITS) {
                        this.compressedSize = extraReader.readInt(8);
                    }
                    if (this.localHeaderOffset === utils.MAX_VALUE_32BITS) {
                        this.localHeaderOffset = extraReader.readInt(8);
                    }
                    if (this.diskNumberStart === utils.MAX_VALUE_32BITS) {
                        this.diskNumberStart = extraReader.readInt(4);
                    }
                },
                "readExtraFields": function(reader) {
                    var start = reader.index, extraFieldId, extraFieldLength, extraFieldValue;
                    this.extraFields = this.extraFields || {};
                    while (reader.index < start + this.extraFieldsLength) {
                        extraFieldId = reader.readInt(2);
                        extraFieldLength = reader.readInt(2);
                        extraFieldValue = reader.readString(extraFieldLength);
                        this.extraFields[extraFieldId] = {
                            "id": extraFieldId,
                            "length": extraFieldLength,
                            "value": extraFieldValue
                        };
                    }
                },
                "handleUTF8": function() {
                    if (this.useUTF8()) {
                        this.fileName = jszipProto.utf8decode(this.fileName);
                        this.fileComment = jszipProto.utf8decode(this.fileComment);
                    } else {
                        var upath = this.findExtraFieldUnicodePath();
                        if (upath !== null) {
                            this.fileName = upath;
                        }
                        var ucomment = this.findExtraFieldUnicodeComment();
                        if (ucomment !== null) {
                            this.fileComment = ucomment;
                        }
                    }
                },
                "findExtraFieldUnicodePath": function() {
                    var upathField = this.extraFields[28789];
                    if (upathField) {
                        var extraReader = new StringReader(upathField.value);
                        if (extraReader.readInt(1) !== 1) {
                            return null;
                        }
                        if (jszipProto.crc32(this.fileName) !== extraReader.readInt(4)) {
                            return null;
                        }
                        return jszipProto.utf8decode(extraReader.readString(upathField.length - 5));
                    }
                    return null;
                },
                "findExtraFieldUnicodeComment": function() {
                    var ucommentField = this.extraFields[25461];
                    if (ucommentField) {
                        var extraReader = new StringReader(ucommentField.value);
                        if (extraReader.readInt(1) !== 1) {
                            return null;
                        }
                        if (jszipProto.crc32(this.fileComment) !== extraReader.readInt(4)) {
                            return null;
                        }
                        return jszipProto.utf8decode(extraReader.readString(ucommentField.length - 5));
                    }
                    return null;
                }
            };
            module.exports = ZipEntry;
        }, {
            "./compressedObject": 2,
            "./object": 13,
            "./stringReader": 15,
            "./utils": 21
        } ],
        "24": [ function(_dereq_, module, exports) {
            "use strict";
            var assign = _dereq_("./lib/utils/common").assign;
            var deflate = _dereq_("./lib/deflate");
            var inflate = _dereq_("./lib/inflate");
            var constants = _dereq_("./lib/zlib/constants");
            var pako = {};
            assign(pako, deflate, inflate, constants);
            module.exports = pako;
        }, {
            "./lib/deflate": 25,
            "./lib/inflate": 26,
            "./lib/utils/common": 27,
            "./lib/zlib/constants": 30
        } ],
        "25": [ function(_dereq_, module, exports) {
            "use strict";
            var zlib_deflate = _dereq_("./zlib/deflate.js");
            var utils = _dereq_("./utils/common");
            var strings = _dereq_("./utils/strings");
            var msg = _dereq_("./zlib/messages");
            var zstream = _dereq_("./zlib/zstream");
            var Z_NO_FLUSH = 0;
            var Z_FINISH = 4;
            var Z_OK = 0;
            var Z_STREAM_END = 1;
            var Z_DEFAULT_COMPRESSION = -1;
            var Z_DEFAULT_STRATEGY = 0;
            var Z_DEFLATED = 8;
            var Deflate = function(options) {
                this.options = utils.assign({
                    "level": Z_DEFAULT_COMPRESSION,
                    "method": Z_DEFLATED,
                    "chunkSize": 16384,
                    "windowBits": 15,
                    "memLevel": 8,
                    "strategy": Z_DEFAULT_STRATEGY,
                    "to": ""
                }, options || {});
                var opt = this.options;
                if (opt.raw && opt.windowBits > 0) {
                    opt.windowBits = -opt.windowBits;
                } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
                    opt.windowBits += 16;
                }
                this.err = 0;
                this.msg = "";
                this.ended = false;
                this.chunks = [];
                this.strm = new zstream();
                this.strm.avail_out = 0;
                var status = zlib_deflate.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);
                if (status !== Z_OK) {
                    throw new Error(msg[status]);
                }
                if (opt.header) {
                    zlib_deflate.deflateSetHeader(this.strm, opt.header);
                }
            };
            Deflate.prototype.push = function(data, mode) {
                var strm = this.strm;
                var chunkSize = this.options.chunkSize;
                var status, _mode;
                if (this.ended) {
                    return false;
                }
                _mode = mode === ~~mode ? mode : mode === true ? Z_FINISH : Z_NO_FLUSH;
                if (typeof data === "string") {
                    strm.input = strings.string2buf(data);
                } else {
                    strm.input = data;
                }
                strm.next_in = 0;
                strm.avail_in = strm.input.length;
                do {
                    if (strm.avail_out === 0) {
                        strm.output = new utils.Buf8(chunkSize);
                        strm.next_out = 0;
                        strm.avail_out = chunkSize;
                    }
                    status = zlib_deflate.deflate(strm, _mode);
                    if (status !== Z_STREAM_END && status !== Z_OK) {
                        this.onEnd(status);
                        this.ended = true;
                        return false;
                    }
                    if (strm.avail_out === 0 || strm.avail_in === 0 && _mode === Z_FINISH) {
                        if (this.options.to === "string") {
                            this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));
                        } else {
                            this.onData(utils.shrinkBuf(strm.output, strm.next_out));
                        }
                    }
                } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);
                if (_mode === Z_FINISH) {
                    status = zlib_deflate.deflateEnd(this.strm);
                    this.onEnd(status);
                    this.ended = true;
                    return status === Z_OK;
                }
                return true;
            };
            Deflate.prototype.onData = function(chunk) {
                this.chunks.push(chunk);
            };
            Deflate.prototype.onEnd = function(status) {
                if (status === Z_OK) {
                    if (this.options.to === "string") {
                        this.result = this.chunks.join("");
                    } else {
                        this.result = utils.flattenChunks(this.chunks);
                    }
                }
                this.chunks = [];
                this.err = status;
                this.msg = this.strm.msg;
            };
            function deflate(input, options) {
                var deflator = new Deflate(options);
                deflator.push(input, true);
                if (deflator.err) {
                    throw deflator.msg;
                }
                return deflator.result;
            }
            function deflateRaw(input, options) {
                options = options || {};
                options.raw = true;
                return deflate(input, options);
            }
            function gzip(input, options) {
                options = options || {};
                options.gzip = true;
                return deflate(input, options);
            }
            exports.Deflate = Deflate;
            exports.deflate = deflate;
            exports.deflateRaw = deflateRaw;
            exports.gzip = gzip;
        }, {
            "./utils/common": 27,
            "./utils/strings": 28,
            "./zlib/deflate.js": 32,
            "./zlib/messages": 37,
            "./zlib/zstream": 39
        } ],
        "26": [ function(_dereq_, module, exports) {
            "use strict";
            var zlib_inflate = _dereq_("./zlib/inflate.js");
            var utils = _dereq_("./utils/common");
            var strings = _dereq_("./utils/strings");
            var c = _dereq_("./zlib/constants");
            var msg = _dereq_("./zlib/messages");
            var zstream = _dereq_("./zlib/zstream");
            var gzheader = _dereq_("./zlib/gzheader");
            var Inflate = function(options) {
                this.options = utils.assign({
                    "chunkSize": 16384,
                    "windowBits": 0,
                    "to": ""
                }, options || {});
                var opt = this.options;
                if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
                    opt.windowBits = -opt.windowBits;
                    if (opt.windowBits === 0) {
                        opt.windowBits = -15;
                    }
                }
                if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
                    opt.windowBits += 32;
                }
                if (opt.windowBits > 15 && opt.windowBits < 48) {
                    if ((opt.windowBits & 15) === 0) {
                        opt.windowBits |= 15;
                    }
                }
                this.err = 0;
                this.msg = "";
                this.ended = false;
                this.chunks = [];
                this.strm = new zstream();
                this.strm.avail_out = 0;
                var status = zlib_inflate.inflateInit2(this.strm, opt.windowBits);
                if (status !== c.Z_OK) {
                    throw new Error(msg[status]);
                }
                this.header = new gzheader();
                zlib_inflate.inflateGetHeader(this.strm, this.header);
            };
            Inflate.prototype.push = function(data, mode) {
                var strm = this.strm;
                var chunkSize = this.options.chunkSize;
                var status, _mode;
                var next_out_utf8, tail, utf8str;
                if (this.ended) {
                    return false;
                }
                _mode = mode === ~~mode ? mode : mode === true ? c.Z_FINISH : c.Z_NO_FLUSH;
                if (typeof data === "string") {
                    strm.input = strings.binstring2buf(data);
                } else {
                    strm.input = data;
                }
                strm.next_in = 0;
                strm.avail_in = strm.input.length;
                do {
                    if (strm.avail_out === 0) {
                        strm.output = new utils.Buf8(chunkSize);
                        strm.next_out = 0;
                        strm.avail_out = chunkSize;
                    }
                    status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);
                    if (status !== c.Z_STREAM_END && status !== c.Z_OK) {
                        this.onEnd(status);
                        this.ended = true;
                        return false;
                    }
                    if (strm.next_out) {
                        if (strm.avail_out === 0 || status === c.Z_STREAM_END || strm.avail_in === 0 && _mode === c.Z_FINISH) {
                            if (this.options.to === "string") {
                                next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
                                tail = strm.next_out - next_out_utf8;
                                utf8str = strings.buf2string(strm.output, next_out_utf8);
                                strm.next_out = tail;
                                strm.avail_out = chunkSize - tail;
                                if (tail) {
                                    utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0);
                                }
                                this.onData(utf8str);
                            } else {
                                this.onData(utils.shrinkBuf(strm.output, strm.next_out));
                            }
                        }
                    }
                } while (strm.avail_in > 0 && status !== c.Z_STREAM_END);
                if (status === c.Z_STREAM_END) {
                    _mode = c.Z_FINISH;
                }
                if (_mode === c.Z_FINISH) {
                    status = zlib_inflate.inflateEnd(this.strm);
                    this.onEnd(status);
                    this.ended = true;
                    return status === c.Z_OK;
                }
                return true;
            };
            Inflate.prototype.onData = function(chunk) {
                this.chunks.push(chunk);
            };
            Inflate.prototype.onEnd = function(status) {
                if (status === c.Z_OK) {
                    if (this.options.to === "string") {
                        this.result = this.chunks.join("");
                    } else {
                        this.result = utils.flattenChunks(this.chunks);
                    }
                }
                this.chunks = [];
                this.err = status;
                this.msg = this.strm.msg;
            };
            function inflate(input, options) {
                var inflator = new Inflate(options);
                inflator.push(input, true);
                if (inflator.err) {
                    throw inflator.msg;
                }
                return inflator.result;
            }
            function inflateRaw(input, options) {
                options = options || {};
                options.raw = true;
                return inflate(input, options);
            }
            exports.Inflate = Inflate;
            exports.inflate = inflate;
            exports.inflateRaw = inflateRaw;
            exports.ungzip = inflate;
        }, {
            "./utils/common": 27,
            "./utils/strings": 28,
            "./zlib/constants": 30,
            "./zlib/gzheader": 33,
            "./zlib/inflate.js": 35,
            "./zlib/messages": 37,
            "./zlib/zstream": 39
        } ],
        "27": [ function(_dereq_, module, exports) {
            "use strict";
            var TYPED_OK = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Int32Array !== "undefined";
            exports.assign = function(obj) {
                var sources = Array.prototype.slice.call(arguments, 1);
                while (sources.length) {
                    var source = sources.shift();
                    if (!source) {
                        continue;
                    }
                    if (typeof source !== "object") {
                        throw new TypeError(source + "must be non-object");
                    }
                    for (var p in source) {
                        if (source.hasOwnProperty(p)) {
                            obj[p] = source[p];
                        }
                    }
                }
                return obj;
            };
            exports.shrinkBuf = function(buf, size) {
                if (buf.length === size) {
                    return buf;
                }
                if (buf.subarray) {
                    return buf.subarray(0, size);
                }
                buf.length = size;
                return buf;
            };
            var fnTyped = {
                "arraySet": function(dest, src, src_offs, len, dest_offs) {
                    if (src.subarray && dest.subarray) {
                        dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
                        return;
                    }
                    for (var i = 0; i < len; i++) {
                        dest[dest_offs + i] = src[src_offs + i];
                    }
                },
                "flattenChunks": function(chunks) {
                    var i, l, len, pos, chunk, result;
                    len = 0;
                    for (i = 0, l = chunks.length; i < l; i++) {
                        len += chunks[i].length;
                    }
                    result = new Uint8Array(len);
                    pos = 0;
                    for (i = 0, l = chunks.length; i < l; i++) {
                        chunk = chunks[i];
                        result.set(chunk, pos);
                        pos += chunk.length;
                    }
                    return result;
                }
            };
            var fnUntyped = {
                "arraySet": function(dest, src, src_offs, len, dest_offs) {
                    for (var i = 0; i < len; i++) {
                        dest[dest_offs + i] = src[src_offs + i];
                    }
                },
                "flattenChunks": function(chunks) {
                    return [].concat.apply([], chunks);
                }
            };
            exports.setTyped = function(on) {
                if (on) {
                    exports.Buf8 = Uint8Array;
                    exports.Buf16 = Uint16Array;
                    exports.Buf32 = Int32Array;
                    exports.assign(exports, fnTyped);
                } else {
                    exports.Buf8 = Array;
                    exports.Buf16 = Array;
                    exports.Buf32 = Array;
                    exports.assign(exports, fnUntyped);
                }
            };
            exports.setTyped(TYPED_OK);
        }, {} ],
        "28": [ function(_dereq_, module, exports) {
            "use strict";
            var utils = _dereq_("./common");
            var STR_APPLY_OK = true;
            var STR_APPLY_UIA_OK = true;
            try {
                String.fromCharCode.apply(null, [ 0 ]);
            } catch (__) {
                STR_APPLY_OK = false;
            }
            try {
                String.fromCharCode.apply(null, new Uint8Array(1));
            } catch (__) {
                STR_APPLY_UIA_OK = false;
            }
            var _utf8len = new utils.Buf8(256);
            for (var i = 0; i < 256; i++) {
                _utf8len[i] = i >= 252 ? 6 : i >= 248 ? 5 : i >= 240 ? 4 : i >= 224 ? 3 : i >= 192 ? 2 : 1;
            }
            _utf8len[254] = _utf8len[254] = 1;
            exports.string2buf = function(str) {
                var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;
                for (m_pos = 0; m_pos < str_len; m_pos++) {
                    c = str.charCodeAt(m_pos);
                    if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
                        c2 = str.charCodeAt(m_pos + 1);
                        if ((c2 & 64512) === 56320) {
                            c = 65536 + (c - 55296 << 10) + (c2 - 56320);
                            m_pos++;
                        }
                    }
                    buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
                }
                buf = new utils.Buf8(buf_len);
                for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
                    c = str.charCodeAt(m_pos);
                    if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
                        c2 = str.charCodeAt(m_pos + 1);
                        if ((c2 & 64512) === 56320) {
                            c = 65536 + (c - 55296 << 10) + (c2 - 56320);
                            m_pos++;
                        }
                    }
                    if (c < 128) {
                        buf[i++] = c;
                    } else if (c < 2048) {
                        buf[i++] = 192 | c >>> 6;
                        buf[i++] = 128 | c & 63;
                    } else if (c < 65536) {
                        buf[i++] = 224 | c >>> 12;
                        buf[i++] = 128 | c >>> 6 & 63;
                        buf[i++] = 128 | c & 63;
                    } else {
                        buf[i++] = 240 | c >>> 18;
                        buf[i++] = 128 | c >>> 12 & 63;
                        buf[i++] = 128 | c >>> 6 & 63;
                        buf[i++] = 128 | c & 63;
                    }
                }
                return buf;
            };
            function buf2binstring(buf, len) {
                if (len < 65537) {
                    if (buf.subarray && STR_APPLY_UIA_OK || !buf.subarray && STR_APPLY_OK) {
                        return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
                    }
                }
                var result = "";
                for (var i = 0; i < len; i++) {
                    result += String.fromCharCode(buf[i]);
                }
                return result;
            }
            exports.buf2binstring = function(buf) {
                return buf2binstring(buf, buf.length);
            };
            exports.binstring2buf = function(str) {
                var buf = new utils.Buf8(str.length);
                for (var i = 0, len = buf.length; i < len; i++) {
                    buf[i] = str.charCodeAt(i);
                }
                return buf;
            };
            exports.buf2string = function(buf, max) {
                var i, out, c, c_len;
                var len = max || buf.length;
                var utf16buf = new Array(len * 2);
                for (out = 0, i = 0; i < len; ) {
                    c = buf[i++];
                    if (c < 128) {
                        utf16buf[out++] = c;
                        continue;
                    }
                    c_len = _utf8len[c];
                    if (c_len > 4) {
                        utf16buf[out++] = 65533;
                        i += c_len - 1;
                        continue;
                    }
                    c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
                    while (c_len > 1 && i < len) {
                        c = c << 6 | buf[i++] & 63;
                        c_len--;
                    }
                    if (c_len > 1) {
                        utf16buf[out++] = 65533;
                        continue;
                    }
                    if (c < 65536) {
                        utf16buf[out++] = c;
                    } else {
                        c -= 65536;
                        utf16buf[out++] = 55296 | c >> 10 & 1023;
                        utf16buf[out++] = 56320 | c & 1023;
                    }
                }
                return buf2binstring(utf16buf, out);
            };
            exports.utf8border = function(buf, max) {
                var pos;
                max = max || buf.length;
                if (max > buf.length) {
                    max = buf.length;
                }
                pos = max - 1;
                while (pos >= 0 && (buf[pos] & 192) === 128) {
                    pos--;
                }
                if (pos < 0) {
                    return max;
                }
                if (pos === 0) {
                    return max;
                }
                return pos + _utf8len[buf[pos]] > max ? pos : max;
            };
        }, {
            "./common": 27
        } ],
        "29": [ function(_dereq_, module, exports) {
            "use strict";
            function adler32(adler, buf, len, pos) {
                var s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
                while (len !== 0) {
                    n = len > 2e3 ? 2e3 : len;
                    len -= n;
                    do {
                        s1 = s1 + buf[pos++] | 0;
                        s2 = s2 + s1 | 0;
                    } while (--n);
                    s1 %= 65521;
                    s2 %= 65521;
                }
                return s1 | s2 << 16 | 0;
            }
            module.exports = adler32;
        }, {} ],
        "30": [ function(_dereq_, module, exports) {
            module.exports = {
                "Z_NO_FLUSH": 0,
                "Z_PARTIAL_FLUSH": 1,
                "Z_SYNC_FLUSH": 2,
                "Z_FULL_FLUSH": 3,
                "Z_FINISH": 4,
                "Z_BLOCK": 5,
                "Z_TREES": 6,
                "Z_OK": 0,
                "Z_STREAM_END": 1,
                "Z_NEED_DICT": 2,
                "Z_ERRNO": -1,
                "Z_STREAM_ERROR": -2,
                "Z_DATA_ERROR": -3,
                "Z_BUF_ERROR": -5,
                "Z_NO_COMPRESSION": 0,
                "Z_BEST_SPEED": 1,
                "Z_BEST_COMPRESSION": 9,
                "Z_DEFAULT_COMPRESSION": -1,
                "Z_FILTERED": 1,
                "Z_HUFFMAN_ONLY": 2,
                "Z_RLE": 3,
                "Z_FIXED": 4,
                "Z_DEFAULT_STRATEGY": 0,
                "Z_BINARY": 0,
                "Z_TEXT": 1,
                "Z_UNKNOWN": 2,
                "Z_DEFLATED": 8
            };
        }, {} ],
        "31": [ function(_dereq_, module, exports) {
            "use strict";
            function makeTable() {
                var c, table = [];
                for (var n = 0; n < 256; n++) {
                    c = n;
                    for (var k = 0; k < 8; k++) {
                        c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
                    }
                    table[n] = c;
                }
                return table;
            }
            var crcTable = makeTable();
            function crc32(crc, buf, len, pos) {
                var t = crcTable, end = pos + len;
                crc = crc ^ -1;
                for (var i = pos; i < end; i++) {
                    crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
                }
                return crc ^ -1;
            }
            module.exports = crc32;
        }, {} ],
        "32": [ function(_dereq_, module, exports) {
            "use strict";
            var utils = _dereq_("../utils/common");
            var trees = _dereq_("./trees");
            var adler32 = _dereq_("./adler32");
            var crc32 = _dereq_("./crc32");
            var msg = _dereq_("./messages");
            var Z_NO_FLUSH = 0;
            var Z_PARTIAL_FLUSH = 1;
            var Z_FULL_FLUSH = 3;
            var Z_FINISH = 4;
            var Z_BLOCK = 5;
            var Z_OK = 0;
            var Z_STREAM_END = 1;
            var Z_STREAM_ERROR = -2;
            var Z_DATA_ERROR = -3;
            var Z_BUF_ERROR = -5;
            var Z_DEFAULT_COMPRESSION = -1;
            var Z_FILTERED = 1;
            var Z_HUFFMAN_ONLY = 2;
            var Z_RLE = 3;
            var Z_FIXED = 4;
            var Z_DEFAULT_STRATEGY = 0;
            var Z_UNKNOWN = 2;
            var Z_DEFLATED = 8;
            var MAX_MEM_LEVEL = 9;
            var MAX_WBITS = 15;
            var DEF_MEM_LEVEL = 8;
            var LENGTH_CODES = 29;
            var LITERALS = 256;
            var L_CODES = LITERALS + 1 + LENGTH_CODES;
            var D_CODES = 30;
            var BL_CODES = 19;
            var HEAP_SIZE = 2 * L_CODES + 1;
            var MAX_BITS = 15;
            var MIN_MATCH = 3;
            var MAX_MATCH = 258;
            var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
            var PRESET_DICT = 32;
            var INIT_STATE = 42;
            var EXTRA_STATE = 69;
            var NAME_STATE = 73;
            var COMMENT_STATE = 91;
            var HCRC_STATE = 103;
            var BUSY_STATE = 113;
            var FINISH_STATE = 666;
            var BS_NEED_MORE = 1;
            var BS_BLOCK_DONE = 2;
            var BS_FINISH_STARTED = 3;
            var BS_FINISH_DONE = 4;
            var OS_CODE = 3;
            function err(strm, errorCode) {
                strm.msg = msg[errorCode];
                return errorCode;
            }
            function rank(f) {
                return (f << 1) - (f > 4 ? 9 : 0);
            }
            function zero(buf) {
                var len = buf.length;
                while (--len >= 0) {
                    buf[len] = 0;
                }
            }
            function flush_pending(strm) {
                var s = strm.state;
                var len = s.pending;
                if (len > strm.avail_out) {
                    len = strm.avail_out;
                }
                if (len === 0) {
                    return;
                }
                utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
                strm.next_out += len;
                s.pending_out += len;
                strm.total_out += len;
                strm.avail_out -= len;
                s.pending -= len;
                if (s.pending === 0) {
                    s.pending_out = 0;
                }
            }
            function flush_block_only(s, last) {
                trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
                s.block_start = s.strstart;
                flush_pending(s.strm);
            }
            function put_byte(s, b) {
                s.pending_buf[s.pending++] = b;
            }
            function putShortMSB(s, b) {
                s.pending_buf[s.pending++] = b >>> 8 & 255;
                s.pending_buf[s.pending++] = b & 255;
            }
            function read_buf(strm, buf, start, size) {
                var len = strm.avail_in;
                if (len > size) {
                    len = size;
                }
                if (len === 0) {
                    return 0;
                }
                strm.avail_in -= len;
                utils.arraySet(buf, strm.input, strm.next_in, len, start);
                if (strm.state.wrap === 1) {
                    strm.adler = adler32(strm.adler, buf, len, start);
                } else if (strm.state.wrap === 2) {
                    strm.adler = crc32(strm.adler, buf, len, start);
                }
                strm.next_in += len;
                strm.total_in += len;
                return len;
            }
            function longest_match(s, cur_match) {
                var chain_length = s.max_chain_length;
                var scan = s.strstart;
                var match;
                var len;
                var best_len = s.prev_length;
                var nice_match = s.nice_match;
                var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
                var _win = s.window;
                var wmask = s.w_mask;
                var prev = s.prev;
                var strend = s.strstart + MAX_MATCH;
                var scan_end1 = _win[scan + best_len - 1];
                var scan_end = _win[scan + best_len];
                if (s.prev_length >= s.good_match) {
                    chain_length >>= 2;
                }
                if (nice_match > s.lookahead) {
                    nice_match = s.lookahead;
                }
                do {
                    match = cur_match;
                    if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
                        continue;
                    }
                    scan += 2;
                    match++;
                    do {} while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
                    len = MAX_MATCH - (strend - scan);
                    scan = strend - MAX_MATCH;
                    if (len > best_len) {
                        s.match_start = cur_match;
                        best_len = len;
                        if (len >= nice_match) {
                            break;
                        }
                        scan_end1 = _win[scan + best_len - 1];
                        scan_end = _win[scan + best_len];
                    }
                } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
                if (best_len <= s.lookahead) {
                    return best_len;
                }
                return s.lookahead;
            }
            function fill_window(s) {
                var _w_size = s.w_size;
                var p, n, m, more, str;
                do {
                    more = s.window_size - s.lookahead - s.strstart;
                    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
                        utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
                        s.match_start -= _w_size;
                        s.strstart -= _w_size;
                        s.block_start -= _w_size;
                        n = s.hash_size;
                        p = n;
                        do {
                            m = s.head[--p];
                            s.head[p] = m >= _w_size ? m - _w_size : 0;
                        } while (--n);
                        n = _w_size;
                        p = n;
                        do {
                            m = s.prev[--p];
                            s.prev[p] = m >= _w_size ? m - _w_size : 0;
                        } while (--n);
                        more += _w_size;
                    }
                    if (s.strm.avail_in === 0) {
                        break;
                    }
                    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
                    s.lookahead += n;
                    if (s.lookahead + s.insert >= MIN_MATCH) {
                        str = s.strstart - s.insert;
                        s.ins_h = s.window[str];
                        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask;
                        while (s.insert) {
                            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
                            s.prev[str & s.w_mask] = s.head[s.ins_h];
                            s.head[s.ins_h] = str;
                            str++;
                            s.insert--;
                            if (s.lookahead + s.insert < MIN_MATCH) {
                                break;
                            }
                        }
                    }
                } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
            }
            function deflate_stored(s, flush) {
                var max_block_size = 65535;
                if (max_block_size > s.pending_buf_size - 5) {
                    max_block_size = s.pending_buf_size - 5;
                }
                for (;;) {
                    if (s.lookahead <= 1) {
                        fill_window(s);
                        if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
                            return BS_NEED_MORE;
                        }
                        if (s.lookahead === 0) {
                            break;
                        }
                    }
                    s.strstart += s.lookahead;
                    s.lookahead = 0;
                    var max_start = s.block_start + max_block_size;
                    if (s.strstart === 0 || s.strstart >= max_start) {
                        s.lookahead = s.strstart - max_start;
                        s.strstart = max_start;
                        flush_block_only(s, false);
                        if (s.strm.avail_out === 0) {
                            return BS_NEED_MORE;
                        }
                    }
                    if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {
                        flush_block_only(s, false);
                        if (s.strm.avail_out === 0) {
                            return BS_NEED_MORE;
                        }
                    }
                }
                s.insert = 0;
                if (flush === Z_FINISH) {
                    flush_block_only(s, true);
                    if (s.strm.avail_out === 0) {
                        return BS_FINISH_STARTED;
                    }
                    return BS_FINISH_DONE;
                }
                if (s.strstart > s.block_start) {
                    flush_block_only(s, false);
                    if (s.strm.avail_out === 0) {
                        return BS_NEED_MORE;
                    }
                }
                return BS_NEED_MORE;
            }
            function deflate_fast(s, flush) {
                var hash_head;
                var bflush;
                for (;;) {
                    if (s.lookahead < MIN_LOOKAHEAD) {
                        fill_window(s);
                        if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
                            return BS_NEED_MORE;
                        }
                        if (s.lookahead === 0) {
                            break;
                        }
                    }
                    hash_head = 0;
                    if (s.lookahead >= MIN_MATCH) {
                        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
                        hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                        s.head[s.ins_h] = s.strstart;
                    }
                    if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
                        s.match_length = longest_match(s, hash_head);
                    }
                    if (s.match_length >= MIN_MATCH) {
                        bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
                        s.lookahead -= s.match_length;
                        if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
                            s.match_length--;
                            do {
                                s.strstart++;
                                s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
                                hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                                s.head[s.ins_h] = s.strstart;
                            } while (--s.match_length !== 0);
                            s.strstart++;
                        } else {
                            s.strstart += s.match_length;
                            s.match_length = 0;
                            s.ins_h = s.window[s.strstart];
                            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask;
                        }
                    } else {
                        bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
                        s.lookahead--;
                        s.strstart++;
                    }
                    if (bflush) {
                        flush_block_only(s, false);
                        if (s.strm.avail_out === 0) {
                            return BS_NEED_MORE;
                        }
                    }
                }
                s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
                if (flush === Z_FINISH) {
                    flush_block_only(s, true);
                    if (s.strm.avail_out === 0) {
                        return BS_FINISH_STARTED;
                    }
                    return BS_FINISH_DONE;
                }
                if (s.last_lit) {
                    flush_block_only(s, false);
                    if (s.strm.avail_out === 0) {
                        return BS_NEED_MORE;
                    }
                }
                return BS_BLOCK_DONE;
            }
            function deflate_slow(s, flush) {
                var hash_head;
                var bflush;
                var max_insert;
                for (;;) {
                    if (s.lookahead < MIN_LOOKAHEAD) {
                        fill_window(s);
                        if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
                            return BS_NEED_MORE;
                        }
                        if (s.lookahead === 0) {
                            break;
                        }
                    }
                    hash_head = 0;
                    if (s.lookahead >= MIN_MATCH) {
                        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
                        hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                        s.head[s.ins_h] = s.strstart;
                    }
                    s.prev_length = s.match_length;
                    s.prev_match = s.match_start;
                    s.match_length = MIN_MATCH - 1;
                    if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
                        s.match_length = longest_match(s, hash_head);
                        if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
                            s.match_length = MIN_MATCH - 1;
                        }
                    }
                    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
                        max_insert = s.strstart + s.lookahead - MIN_MATCH;
                        bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
                        s.lookahead -= s.prev_length - 1;
                        s.prev_length -= 2;
                        do {
                            if (++s.strstart <= max_insert) {
                                s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
                                hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                                s.head[s.ins_h] = s.strstart;
                            }
                        } while (--s.prev_length !== 0);
                        s.match_available = 0;
                        s.match_length = MIN_MATCH - 1;
                        s.strstart++;
                        if (bflush) {
                            flush_block_only(s, false);
                            if (s.strm.avail_out === 0) {
                                return BS_NEED_MORE;
                            }
                        }
                    } else if (s.match_available) {
                        bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
                        if (bflush) {
                            flush_block_only(s, false);
                        }
                        s.strstart++;
                        s.lookahead--;
                        if (s.strm.avail_out === 0) {
                            return BS_NEED_MORE;
                        }
                    } else {
                        s.match_available = 1;
                        s.strstart++;
                        s.lookahead--;
                    }
                }
                if (s.match_available) {
                    bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
                    s.match_available = 0;
                }
                s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
                if (flush === Z_FINISH) {
                    flush_block_only(s, true);
                    if (s.strm.avail_out === 0) {
                        return BS_FINISH_STARTED;
                    }
                    return BS_FINISH_DONE;
                }
                if (s.last_lit) {
                    flush_block_only(s, false);
                    if (s.strm.avail_out === 0) {
                        return BS_NEED_MORE;
                    }
                }
                return BS_BLOCK_DONE;
            }
            function deflate_rle(s, flush) {
                var bflush;
                var prev;
                var scan, strend;
                var _win = s.window;
                for (;;) {
                    if (s.lookahead <= MAX_MATCH) {
                        fill_window(s);
                        if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
                            return BS_NEED_MORE;
                        }
                        if (s.lookahead === 0) {
                            break;
                        }
                    }
                    s.match_length = 0;
                    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
                        scan = s.strstart - 1;
                        prev = _win[scan];
                        if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
                            strend = s.strstart + MAX_MATCH;
                            do {} while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
                            s.match_length = MAX_MATCH - (strend - scan);
                            if (s.match_length > s.lookahead) {
                                s.match_length = s.lookahead;
                            }
                        }
                    }
                    if (s.match_length >= MIN_MATCH) {
                        bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);
                        s.lookahead -= s.match_length;
                        s.strstart += s.match_length;
                        s.match_length = 0;
                    } else {
                        bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
                        s.lookahead--;
                        s.strstart++;
                    }
                    if (bflush) {
                        flush_block_only(s, false);
                        if (s.strm.avail_out === 0) {
                            return BS_NEED_MORE;
                        }
                    }
                }
                s.insert = 0;
                if (flush === Z_FINISH) {
                    flush_block_only(s, true);
                    if (s.strm.avail_out === 0) {
                        return BS_FINISH_STARTED;
                    }
                    return BS_FINISH_DONE;
                }
                if (s.last_lit) {
                    flush_block_only(s, false);
                    if (s.strm.avail_out === 0) {
                        return BS_NEED_MORE;
                    }
                }
                return BS_BLOCK_DONE;
            }
            function deflate_huff(s, flush) {
                var bflush;
                for (;;) {
                    if (s.lookahead === 0) {
                        fill_window(s);
                        if (s.lookahead === 0) {
                            if (flush === Z_NO_FLUSH) {
                                return BS_NEED_MORE;
                            }
                            break;
                        }
                    }
                    s.match_length = 0;
                    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
                    s.lookahead--;
                    s.strstart++;
                    if (bflush) {
                        flush_block_only(s, false);
                        if (s.strm.avail_out === 0) {
                            return BS_NEED_MORE;
                        }
                    }
                }
                s.insert = 0;
                if (flush === Z_FINISH) {
                    flush_block_only(s, true);
                    if (s.strm.avail_out === 0) {
                        return BS_FINISH_STARTED;
                    }
                    return BS_FINISH_DONE;
                }
                if (s.last_lit) {
                    flush_block_only(s, false);
                    if (s.strm.avail_out === 0) {
                        return BS_NEED_MORE;
                    }
                }
                return BS_BLOCK_DONE;
            }
            var Config = function(good_length, max_lazy, nice_length, max_chain, func) {
                this.good_length = good_length;
                this.max_lazy = max_lazy;
                this.nice_length = nice_length;
                this.max_chain = max_chain;
                this.func = func;
            };
            var configuration_table;
            configuration_table = [ new Config(0, 0, 0, 0, deflate_stored), new Config(4, 4, 8, 4, deflate_fast), new Config(4, 5, 16, 8, deflate_fast), new Config(4, 6, 32, 32, deflate_fast), new Config(4, 4, 16, 16, deflate_slow), new Config(8, 16, 32, 32, deflate_slow), new Config(8, 16, 128, 128, deflate_slow), new Config(8, 32, 128, 256, deflate_slow), new Config(32, 128, 258, 1024, deflate_slow), new Config(32, 258, 258, 4096, deflate_slow) ];
            function lm_init(s) {
                s.window_size = 2 * s.w_size;
                zero(s.head);
                s.max_lazy_match = configuration_table[s.level].max_lazy;
                s.good_match = configuration_table[s.level].good_length;
                s.nice_match = configuration_table[s.level].nice_length;
                s.max_chain_length = configuration_table[s.level].max_chain;
                s.strstart = 0;
                s.block_start = 0;
                s.lookahead = 0;
                s.insert = 0;
                s.match_length = s.prev_length = MIN_MATCH - 1;
                s.match_available = 0;
                s.ins_h = 0;
            }
            function DeflateState() {
                this.strm = null;
                this.status = 0;
                this.pending_buf = null;
                this.pending_buf_size = 0;
                this.pending_out = 0;
                this.pending = 0;
                this.wrap = 0;
                this.gzhead = null;
                this.gzindex = 0;
                this.method = Z_DEFLATED;
                this.last_flush = -1;
                this.w_size = 0;
                this.w_bits = 0;
                this.w_mask = 0;
                this.window = null;
                this.window_size = 0;
                this.prev = null;
                this.head = null;
                this.ins_h = 0;
                this.hash_size = 0;
                this.hash_bits = 0;
                this.hash_mask = 0;
                this.hash_shift = 0;
                this.block_start = 0;
                this.match_length = 0;
                this.prev_match = 0;
                this.match_available = 0;
                this.strstart = 0;
                this.match_start = 0;
                this.lookahead = 0;
                this.prev_length = 0;
                this.max_chain_length = 0;
                this.max_lazy_match = 0;
                this.level = 0;
                this.strategy = 0;
                this.good_match = 0;
                this.nice_match = 0;
                this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);
                this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);
                this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);
                zero(this.dyn_ltree);
                zero(this.dyn_dtree);
                zero(this.bl_tree);
                this.l_desc = null;
                this.d_desc = null;
                this.bl_desc = null;
                this.bl_count = new utils.Buf16(MAX_BITS + 1);
                this.heap = new utils.Buf16(2 * L_CODES + 1);
                zero(this.heap);
                this.heap_len = 0;
                this.heap_max = 0;
                this.depth = new utils.Buf16(2 * L_CODES + 1);
                zero(this.depth);
                this.l_buf = 0;
                this.lit_bufsize = 0;
                this.last_lit = 0;
                this.d_buf = 0;
                this.opt_len = 0;
                this.static_len = 0;
                this.matches = 0;
                this.insert = 0;
                this.bi_buf = 0;
                this.bi_valid = 0;
            }
            function deflateResetKeep(strm) {
                var s;
                if (!strm || !strm.state) {
                    return err(strm, Z_STREAM_ERROR);
                }
                strm.total_in = strm.total_out = 0;
                strm.data_type = Z_UNKNOWN;
                s = strm.state;
                s.pending = 0;
                s.pending_out = 0;
                if (s.wrap < 0) {
                    s.wrap = -s.wrap;
                }
                s.status = s.wrap ? INIT_STATE : BUSY_STATE;
                strm.adler = s.wrap === 2 ? 0 : 1;
                s.last_flush = Z_NO_FLUSH;
                trees._tr_init(s);
                return Z_OK;
            }
            function deflateReset(strm) {
                var ret = deflateResetKeep(strm);
                if (ret === Z_OK) {
                    lm_init(strm.state);
                }
                return ret;
            }
            function deflateSetHeader(strm, head) {
                if (!strm || !strm.state) {
                    return Z_STREAM_ERROR;
                }
                if (strm.state.wrap !== 2) {
                    return Z_STREAM_ERROR;
                }
                strm.state.gzhead = head;
                return Z_OK;
            }
            function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
                if (!strm) {
                    return Z_STREAM_ERROR;
                }
                var wrap = 1;
                if (level === Z_DEFAULT_COMPRESSION) {
                    level = 6;
                }
                if (windowBits < 0) {
                    wrap = 0;
                    windowBits = -windowBits;
                } else if (windowBits > 15) {
                    wrap = 2;
                    windowBits -= 16;
                }
                if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
                    return err(strm, Z_STREAM_ERROR);
                }
                if (windowBits === 8) {
                    windowBits = 9;
                }
                var s = new DeflateState();
                strm.state = s;
                s.strm = strm;
                s.wrap = wrap;
                s.gzhead = null;
                s.w_bits = windowBits;
                s.w_size = 1 << s.w_bits;
                s.w_mask = s.w_size - 1;
                s.hash_bits = memLevel + 7;
                s.hash_size = 1 << s.hash_bits;
                s.hash_mask = s.hash_size - 1;
                s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
                s.window = new utils.Buf8(s.w_size * 2);
                s.head = new utils.Buf16(s.hash_size);
                s.prev = new utils.Buf16(s.w_size);
                s.lit_bufsize = 1 << memLevel + 6;
                s.pending_buf_size = s.lit_bufsize * 4;
                s.pending_buf = new utils.Buf8(s.pending_buf_size);
                s.d_buf = s.lit_bufsize >> 1;
                s.l_buf = (1 + 2) * s.lit_bufsize;
                s.level = level;
                s.strategy = strategy;
                s.method = method;
                return deflateReset(strm);
            }
            function deflateInit(strm, level) {
                return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
            }
            function deflate(strm, flush) {
                var old_flush, s;
                var beg, val;
                if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {
                    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
                }
                s = strm.state;
                if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH) {
                    return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
                }
                s.strm = strm;
                old_flush = s.last_flush;
                s.last_flush = flush;
                if (s.status === INIT_STATE) {
                    if (s.wrap === 2) {
                        strm.adler = 0;
                        put_byte(s, 31);
                        put_byte(s, 139);
                        put_byte(s, 8);
                        if (!s.gzhead) {
                            put_byte(s, 0);
                            put_byte(s, 0);
                            put_byte(s, 0);
                            put_byte(s, 0);
                            put_byte(s, 0);
                            put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
                            put_byte(s, OS_CODE);
                            s.status = BUSY_STATE;
                        } else {
                            put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16));
                            put_byte(s, s.gzhead.time & 255);
                            put_byte(s, s.gzhead.time >> 8 & 255);
                            put_byte(s, s.gzhead.time >> 16 & 255);
                            put_byte(s, s.gzhead.time >> 24 & 255);
                            put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
                            put_byte(s, s.gzhead.os & 255);
                            if (s.gzhead.extra && s.gzhead.extra.length) {
                                put_byte(s, s.gzhead.extra.length & 255);
                                put_byte(s, s.gzhead.extra.length >> 8 & 255);
                            }
                            if (s.gzhead.hcrc) {
                                strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
                            }
                            s.gzindex = 0;
                            s.status = EXTRA_STATE;
                        }
                    } else {
                        var header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
                        var level_flags = -1;
                        if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
                            level_flags = 0;
                        } else if (s.level < 6) {
                            level_flags = 1;
                        } else if (s.level === 6) {
                            level_flags = 2;
                        } else {
                            level_flags = 3;
                        }
                        header |= level_flags << 6;
                        if (s.strstart !== 0) {
                            header |= PRESET_DICT;
                        }
                        header += 31 - header % 31;
                        s.status = BUSY_STATE;
                        putShortMSB(s, header);
                        if (s.strstart !== 0) {
                            putShortMSB(s, strm.adler >>> 16);
                            putShortMSB(s, strm.adler & 65535);
                        }
                        strm.adler = 1;
                    }
                }
                if (s.status === EXTRA_STATE) {
                    if (s.gzhead.extra) {
                        beg = s.pending;
                        while (s.gzindex < (s.gzhead.extra.length & 65535)) {
                            if (s.pending === s.pending_buf_size) {
                                if (s.gzhead.hcrc && s.pending > beg) {
                                    strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                                }
                                flush_pending(strm);
                                beg = s.pending;
                                if (s.pending === s.pending_buf_size) {
                                    break;
                                }
                            }
                            put_byte(s, s.gzhead.extra[s.gzindex] & 255);
                            s.gzindex++;
                        }
                        if (s.gzhead.hcrc && s.pending > beg) {
                            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                        }
                        if (s.gzindex === s.gzhead.extra.length) {
                            s.gzindex = 0;
                            s.status = NAME_STATE;
                        }
                    } else {
                        s.status = NAME_STATE;
                    }
                }
                if (s.status === NAME_STATE) {
                    if (s.gzhead.name) {
                        beg = s.pending;
                        do {
                            if (s.pending === s.pending_buf_size) {
                                if (s.gzhead.hcrc && s.pending > beg) {
                                    strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                                }
                                flush_pending(strm);
                                beg = s.pending;
                                if (s.pending === s.pending_buf_size) {
                                    val = 1;
                                    break;
                                }
                            }
                            if (s.gzindex < s.gzhead.name.length) {
                                val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
                            } else {
                                val = 0;
                            }
                            put_byte(s, val);
                        } while (val !== 0);
                        if (s.gzhead.hcrc && s.pending > beg) {
                            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                        }
                        if (val === 0) {
                            s.gzindex = 0;
                            s.status = COMMENT_STATE;
                        }
                    } else {
                        s.status = COMMENT_STATE;
                    }
                }
                if (s.status === COMMENT_STATE) {
                    if (s.gzhead.comment) {
                        beg = s.pending;
                        do {
                            if (s.pending === s.pending_buf_size) {
                                if (s.gzhead.hcrc && s.pending > beg) {
                                    strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                                }
                                flush_pending(strm);
                                beg = s.pending;
                                if (s.pending === s.pending_buf_size) {
                                    val = 1;
                                    break;
                                }
                            }
                            if (s.gzindex < s.gzhead.comment.length) {
                                val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
                            } else {
                                val = 0;
                            }
                            put_byte(s, val);
                        } while (val !== 0);
                        if (s.gzhead.hcrc && s.pending > beg) {
                            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                        }
                        if (val === 0) {
                            s.status = HCRC_STATE;
                        }
                    } else {
                        s.status = HCRC_STATE;
                    }
                }
                if (s.status === HCRC_STATE) {
                    if (s.gzhead.hcrc) {
                        if (s.pending + 2 > s.pending_buf_size) {
                            flush_pending(strm);
                        }
                        if (s.pending + 2 <= s.pending_buf_size) {
                            put_byte(s, strm.adler & 255);
                            put_byte(s, strm.adler >> 8 & 255);
                            strm.adler = 0;
                            s.status = BUSY_STATE;
                        }
                    } else {
                        s.status = BUSY_STATE;
                    }
                }
                if (s.pending !== 0) {
                    flush_pending(strm);
                    if (strm.avail_out === 0) {
                        s.last_flush = -1;
                        return Z_OK;
                    }
                } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
                    return err(strm, Z_BUF_ERROR);
                }
                if (s.status === FINISH_STATE && strm.avail_in !== 0) {
                    return err(strm, Z_BUF_ERROR);
                }
                if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {
                    var bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
                    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
                        s.status = FINISH_STATE;
                    }
                    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
                        if (strm.avail_out === 0) {
                            s.last_flush = -1;
                        }
                        return Z_OK;
                    }
                    if (bstate === BS_BLOCK_DONE) {
                        if (flush === Z_PARTIAL_FLUSH) {
                            trees._tr_align(s);
                        } else if (flush !== Z_BLOCK) {
                            trees._tr_stored_block(s, 0, 0, false);
                            if (flush === Z_FULL_FLUSH) {
                                zero(s.head);
                                if (s.lookahead === 0) {
                                    s.strstart = 0;
                                    s.block_start = 0;
                                    s.insert = 0;
                                }
                            }
                        }
                        flush_pending(strm);
                        if (strm.avail_out === 0) {
                            s.last_flush = -1;
                            return Z_OK;
                        }
                    }
                }
                if (flush !== Z_FINISH) {
                    return Z_OK;
                }
                if (s.wrap <= 0) {
                    return Z_STREAM_END;
                }
                if (s.wrap === 2) {
                    put_byte(s, strm.adler & 255);
                    put_byte(s, strm.adler >> 8 & 255);
                    put_byte(s, strm.adler >> 16 & 255);
                    put_byte(s, strm.adler >> 24 & 255);
                    put_byte(s, strm.total_in & 255);
                    put_byte(s, strm.total_in >> 8 & 255);
                    put_byte(s, strm.total_in >> 16 & 255);
                    put_byte(s, strm.total_in >> 24 & 255);
                } else {
                    putShortMSB(s, strm.adler >>> 16);
                    putShortMSB(s, strm.adler & 65535);
                }
                flush_pending(strm);
                if (s.wrap > 0) {
                    s.wrap = -s.wrap;
                }
                return s.pending !== 0 ? Z_OK : Z_STREAM_END;
            }
            function deflateEnd(strm) {
                var status;
                if (!strm || !strm.state) {
                    return Z_STREAM_ERROR;
                }
                status = strm.state.status;
                if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
                    return err(strm, Z_STREAM_ERROR);
                }
                strm.state = null;
                return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
            }
            exports.deflateInit = deflateInit;
            exports.deflateInit2 = deflateInit2;
            exports.deflateReset = deflateReset;
            exports.deflateResetKeep = deflateResetKeep;
            exports.deflateSetHeader = deflateSetHeader;
            exports.deflate = deflate;
            exports.deflateEnd = deflateEnd;
            exports.deflateInfo = "pako deflate (from Nodeca project)";
        }, {
            "../utils/common": 27,
            "./adler32": 29,
            "./crc32": 31,
            "./messages": 37,
            "./trees": 38
        } ],
        "33": [ function(_dereq_, module, exports) {
            "use strict";
            function GZheader() {
                this.text = 0;
                this.time = 0;
                this.xflags = 0;
                this.os = 0;
                this.extra = null;
                this.extra_len = 0;
                this.name = "";
                this.comment = "";
                this.hcrc = 0;
                this.done = false;
            }
            module.exports = GZheader;
        }, {} ],
        "34": [ function(_dereq_, module, exports) {
            "use strict";
            var BAD = 30;
            var TYPE = 12;
            module.exports = function inflate_fast(strm, start) {
                var state;
                var _in;
                var last;
                var _out;
                var beg;
                var end;
                var dmax;
                var wsize;
                var whave;
                var wnext;
                var window;
                var hold;
                var bits;
                var lcode;
                var dcode;
                var lmask;
                var dmask;
                var here;
                var op;
                var len;
                var dist;
                var from;
                var from_source;
                var input, output;
                state = strm.state;
                _in = strm.next_in;
                input = strm.input;
                last = _in + (strm.avail_in - 5);
                _out = strm.next_out;
                output = strm.output;
                beg = _out - (start - strm.avail_out);
                end = _out + (strm.avail_out - 257);
                dmax = state.dmax;
                wsize = state.wsize;
                whave = state.whave;
                wnext = state.wnext;
                window = state.window;
                hold = state.hold;
                bits = state.bits;
                lcode = state.lencode;
                dcode = state.distcode;
                lmask = (1 << state.lenbits) - 1;
                dmask = (1 << state.distbits) - 1;
                top: do {
                    if (bits < 15) {
                        hold += input[_in++] << bits;
                        bits += 8;
                        hold += input[_in++] << bits;
                        bits += 8;
                    }
                    here = lcode[hold & lmask];
                    dolen: for (;;) {
                        op = here >>> 24;
                        hold >>>= op;
                        bits -= op;
                        op = here >>> 16 & 255;
                        if (op === 0) {
                            output[_out++] = here & 65535;
                        } else if (op & 16) {
                            len = here & 65535;
                            op &= 15;
                            if (op) {
                                if (bits < op) {
                                    hold += input[_in++] << bits;
                                    bits += 8;
                                }
                                len += hold & (1 << op) - 1;
                                hold >>>= op;
                                bits -= op;
                            }
                            if (bits < 15) {
                                hold += input[_in++] << bits;
                                bits += 8;
                                hold += input[_in++] << bits;
                                bits += 8;
                            }
                            here = dcode[hold & dmask];
                            dodist: for (;;) {
                                op = here >>> 24;
                                hold >>>= op;
                                bits -= op;
                                op = here >>> 16 & 255;
                                if (op & 16) {
                                    dist = here & 65535;
                                    op &= 15;
                                    if (bits < op) {
                                        hold += input[_in++] << bits;
                                        bits += 8;
                                        if (bits < op) {
                                            hold += input[_in++] << bits;
                                            bits += 8;
                                        }
                                    }
                                    dist += hold & (1 << op) - 1;
                                    if (dist > dmax) {
                                        strm.msg = "invalid distance too far back";
                                        state.mode = BAD;
                                        break top;
                                    }
                                    hold >>>= op;
                                    bits -= op;
                                    op = _out - beg;
                                    if (dist > op) {
                                        op = dist - op;
                                        if (op > whave) {
                                            if (state.sane) {
                                                strm.msg = "invalid distance too far back";
                                                state.mode = BAD;
                                                break top;
                                            }
                                        }
                                        from = 0;
                                        from_source = window;
                                        if (wnext === 0) {
                                            from += wsize - op;
                                            if (op < len) {
                                                len -= op;
                                                do {
                                                    output[_out++] = window[from++];
                                                } while (--op);
                                                from = _out - dist;
                                                from_source = output;
                                            }
                                        } else if (wnext < op) {
                                            from += wsize + wnext - op;
                                            op -= wnext;
                                            if (op < len) {
                                                len -= op;
                                                do {
                                                    output[_out++] = window[from++];
                                                } while (--op);
                                                from = 0;
                                                if (wnext < len) {
                                                    op = wnext;
                                                    len -= op;
                                                    do {
                                                        output[_out++] = window[from++];
                                                    } while (--op);
                                                    from = _out - dist;
                                                    from_source = output;
                                                }
                                            }
                                        } else {
                                            from += wnext - op;
                                            if (op < len) {
                                                len -= op;
                                                do {
                                                    output[_out++] = window[from++];
                                                } while (--op);
                                                from = _out - dist;
                                                from_source = output;
                                            }
                                        }
                                        while (len > 2) {
                                            output[_out++] = from_source[from++];
                                            output[_out++] = from_source[from++];
                                            output[_out++] = from_source[from++];
                                            len -= 3;
                                        }
                                        if (len) {
                                            output[_out++] = from_source[from++];
                                            if (len > 1) {
                                                output[_out++] = from_source[from++];
                                            }
                                        }
                                    } else {
                                        from = _out - dist;
                                        do {
                                            output[_out++] = output[from++];
                                            output[_out++] = output[from++];
                                            output[_out++] = output[from++];
                                            len -= 3;
                                        } while (len > 2);
                                        if (len) {
                                            output[_out++] = output[from++];
                                            if (len > 1) {
                                                output[_out++] = output[from++];
                                            }
                                        }
                                    }
                                } else if ((op & 64) === 0) {
                                    here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                                    continue dodist;
                                } else {
                                    strm.msg = "invalid distance code";
                                    state.mode = BAD;
                                    break top;
                                }
                                break;
                            }
                        } else if ((op & 64) === 0) {
                            here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
                            continue dolen;
                        } else if (op & 32) {
                            state.mode = TYPE;
                            break top;
                        } else {
                            strm.msg = "invalid literal/length code";
                            state.mode = BAD;
                            break top;
                        }
                        break;
                    }
                } while (_in < last && _out < end);
                len = bits >> 3;
                _in -= len;
                bits -= len << 3;
                hold &= (1 << bits) - 1;
                strm.next_in = _in;
                strm.next_out = _out;
                strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
                strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
                state.hold = hold;
                state.bits = bits;
                return;
            };
        }, {} ],
        "35": [ function(_dereq_, module, exports) {
            "use strict";
            var utils = _dereq_("../utils/common");
            var adler32 = _dereq_("./adler32");
            var crc32 = _dereq_("./crc32");
            var inflate_fast = _dereq_("./inffast");
            var inflate_table = _dereq_("./inftrees");
            var CODES = 0;
            var LENS = 1;
            var DISTS = 2;
            var Z_FINISH = 4;
            var Z_BLOCK = 5;
            var Z_TREES = 6;
            var Z_OK = 0;
            var Z_STREAM_END = 1;
            var Z_NEED_DICT = 2;
            var Z_STREAM_ERROR = -2;
            var Z_DATA_ERROR = -3;
            var Z_MEM_ERROR = -4;
            var Z_BUF_ERROR = -5;
            var Z_DEFLATED = 8;
            var HEAD = 1;
            var FLAGS = 2;
            var TIME = 3;
            var OS = 4;
            var EXLEN = 5;
            var EXTRA = 6;
            var NAME = 7;
            var COMMENT = 8;
            var HCRC = 9;
            var DICTID = 10;
            var DICT = 11;
            var TYPE = 12;
            var TYPEDO = 13;
            var STORED = 14;
            var COPY_ = 15;
            var COPY = 16;
            var TABLE = 17;
            var LENLENS = 18;
            var CODELENS = 19;
            var LEN_ = 20;
            var LEN = 21;
            var LENEXT = 22;
            var DIST = 23;
            var DISTEXT = 24;
            var MATCH = 25;
            var LIT = 26;
            var CHECK = 27;
            var LENGTH = 28;
            var DONE = 29;
            var BAD = 30;
            var MEM = 31;
            var SYNC = 32;
            var ENOUGH_LENS = 852;
            var ENOUGH_DISTS = 592;
            var MAX_WBITS = 15;
            var DEF_WBITS = MAX_WBITS;
            function ZSWAP32(q) {
                return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
            }
            function InflateState() {
                this.mode = 0;
                this.last = false;
                this.wrap = 0;
                this.havedict = false;
                this.flags = 0;
                this.dmax = 0;
                this.check = 0;
                this.total = 0;
                this.head = null;
                this.wbits = 0;
                this.wsize = 0;
                this.whave = 0;
                this.wnext = 0;
                this.window = null;
                this.hold = 0;
                this.bits = 0;
                this.length = 0;
                this.offset = 0;
                this.extra = 0;
                this.lencode = null;
                this.distcode = null;
                this.lenbits = 0;
                this.distbits = 0;
                this.ncode = 0;
                this.nlen = 0;
                this.ndist = 0;
                this.have = 0;
                this.next = null;
                this.lens = new utils.Buf16(320);
                this.work = new utils.Buf16(288);
                this.lendyn = null;
                this.distdyn = null;
                this.sane = 0;
                this.back = 0;
                this.was = 0;
            }
            function inflateResetKeep(strm) {
                var state;
                if (!strm || !strm.state) {
                    return Z_STREAM_ERROR;
                }
                state = strm.state;
                strm.total_in = strm.total_out = state.total = 0;
                strm.msg = "";
                if (state.wrap) {
                    strm.adler = state.wrap & 1;
                }
                state.mode = HEAD;
                state.last = 0;
                state.havedict = 0;
                state.dmax = 32768;
                state.head = null;
                state.hold = 0;
                state.bits = 0;
                state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
                state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);
                state.sane = 1;
                state.back = -1;
                return Z_OK;
            }
            function inflateReset(strm) {
                var state;
                if (!strm || !strm.state) {
                    return Z_STREAM_ERROR;
                }
                state = strm.state;
                state.wsize = 0;
                state.whave = 0;
                state.wnext = 0;
                return inflateResetKeep(strm);
            }
            function inflateReset2(strm, windowBits) {
                var wrap;
                var state;
                if (!strm || !strm.state) {
                    return Z_STREAM_ERROR;
                }
                state = strm.state;
                if (windowBits < 0) {
                    wrap = 0;
                    windowBits = -windowBits;
                } else {
                    wrap = (windowBits >> 4) + 1;
                    if (windowBits < 48) {
                        windowBits &= 15;
                    }
                }
                if (windowBits && (windowBits < 8 || windowBits > 15)) {
                    return Z_STREAM_ERROR;
                }
                if (state.window !== null && state.wbits !== windowBits) {
                    state.window = null;
                }
                state.wrap = wrap;
                state.wbits = windowBits;
                return inflateReset(strm);
            }
            function inflateInit2(strm, windowBits) {
                var ret;
                var state;
                if (!strm) {
                    return Z_STREAM_ERROR;
                }
                state = new InflateState();
                strm.state = state;
                state.window = null;
                ret = inflateReset2(strm, windowBits);
                if (ret !== Z_OK) {
                    strm.state = null;
                }
                return ret;
            }
            function inflateInit(strm) {
                return inflateInit2(strm, DEF_WBITS);
            }
            var virgin = true;
            var lenfix, distfix;
            function fixedtables(state) {
                if (virgin) {
                    var sym;
                    lenfix = new utils.Buf32(512);
                    distfix = new utils.Buf32(32);
                    sym = 0;
                    while (sym < 144) {
                        state.lens[sym++] = 8;
                    }
                    while (sym < 256) {
                        state.lens[sym++] = 9;
                    }
                    while (sym < 280) {
                        state.lens[sym++] = 7;
                    }
                    while (sym < 288) {
                        state.lens[sym++] = 8;
                    }
                    inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, {
                        "bits": 9
                    });
                    sym = 0;
                    while (sym < 32) {
                        state.lens[sym++] = 5;
                    }
                    inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, {
                        "bits": 5
                    });
                    virgin = false;
                }
                state.lencode = lenfix;
                state.lenbits = 9;
                state.distcode = distfix;
                state.distbits = 5;
            }
            function updatewindow(strm, src, end, copy) {
                var dist;
                var state = strm.state;
                if (state.window === null) {
                    state.wsize = 1 << state.wbits;
                    state.wnext = 0;
                    state.whave = 0;
                    state.window = new utils.Buf8(state.wsize);
                }
                if (copy >= state.wsize) {
                    utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
                    state.wnext = 0;
                    state.whave = state.wsize;
                } else {
                    dist = state.wsize - state.wnext;
                    if (dist > copy) {
                        dist = copy;
                    }
                    utils.arraySet(state.window, src, end - copy, dist, state.wnext);
                    copy -= dist;
                    if (copy) {
                        utils.arraySet(state.window, src, end - copy, copy, 0);
                        state.wnext = copy;
                        state.whave = state.wsize;
                    } else {
                        state.wnext += dist;
                        if (state.wnext === state.wsize) {
                            state.wnext = 0;
                        }
                        if (state.whave < state.wsize) {
                            state.whave += dist;
                        }
                    }
                }
                return 0;
            }
            function inflate(strm, flush) {
                var state;
                var input, output;
                var next;
                var put;
                var have, left;
                var hold;
                var bits;
                var _in, _out;
                var copy;
                var from;
                var from_source;
                var here = 0;
                var here_bits, here_op, here_val;
                var last_bits, last_op, last_val;
                var len;
                var ret;
                var hbuf = new utils.Buf8(4);
                var opts;
                var n;
                var order = [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];
                if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
                    return Z_STREAM_ERROR;
                }
                state = strm.state;
                if (state.mode === TYPE) {
                    state.mode = TYPEDO;
                }
                put = strm.next_out;
                output = strm.output;
                left = strm.avail_out;
                next = strm.next_in;
                input = strm.input;
                have = strm.avail_in;
                hold = state.hold;
                bits = state.bits;
                _in = have;
                _out = left;
                ret = Z_OK;
                inf_leave: for (;;) {
                    switch (state.mode) {
                      case HEAD:
                        if (state.wrap === 0) {
                            state.mode = TYPEDO;
                            break;
                        }
                        while (bits < 16) {
                            if (have === 0) {
                                break inf_leave;
                            }
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                        }
                        if (state.wrap & 2 && hold === 35615) {
                            state.check = 0;
                            hbuf[0] = hold & 255;
                            hbuf[1] = hold >>> 8 & 255;
                            state.check = crc32(state.check, hbuf, 2, 0);
                            hold = 0;
                            bits = 0;
                            state.mode = FLAGS;
                            break;
                        }
                        state.flags = 0;
                        if (state.head) {
                            state.head.done = false;
                        }
                        if (!(state.wrap & 1) || (((hold & 255) << 8) + (hold >> 8)) % 31) {
                            strm.msg = "incorrect header check";
                            state.mode = BAD;
                            break;
                        }
                        if ((hold & 15) !== Z_DEFLATED) {
                            strm.msg = "unknown compression method";
                            state.mode = BAD;
                            break;
                        }
                        hold >>>= 4;
                        bits -= 4;
                        len = (hold & 15) + 8;
                        if (state.wbits === 0) {
                            state.wbits = len;
                        } else if (len > state.wbits) {
                            strm.msg = "invalid window size";
                            state.mode = BAD;
                            break;
                        }
                        state.dmax = 1 << len;
                        strm.adler = state.check = 1;
                        state.mode = hold & 512 ? DICTID : TYPE;
                        hold = 0;
                        bits = 0;
                        break;

                      case FLAGS:
                        while (bits < 16) {
                            if (have === 0) {
                                break inf_leave;
                            }
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                        }
                        state.flags = hold;
                        if ((state.flags & 255) !== Z_DEFLATED) {
                            strm.msg = "unknown compression method";
                            state.mode = BAD;
                            break;
                        }
                        if (state.flags & 57344) {
                            strm.msg = "unknown header flags set";
                            state.mode = BAD;
                            break;
                        }
                        if (state.head) {
                            state.head.text = hold >> 8 & 1;
                        }
                        if (state.flags & 512) {
                            hbuf[0] = hold & 255;
                            hbuf[1] = hold >>> 8 & 255;
                            state.check = crc32(state.check, hbuf, 2, 0);
                        }
                        hold = 0;
                        bits = 0;
                        state.mode = TIME;

                      case TIME:
                        while (bits < 32) {
                            if (have === 0) {
                                break inf_leave;
                            }
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                        }
                        if (state.head) {
                            state.head.time = hold;
                        }
                        if (state.flags & 512) {
                            hbuf[0] = hold & 255;
                            hbuf[1] = hold >>> 8 & 255;
                            hbuf[2] = hold >>> 16 & 255;
                            hbuf[3] = hold >>> 24 & 255;
                            state.check = crc32(state.check, hbuf, 4, 0);
                        }
                        hold = 0;
                        bits = 0;
                        state.mode = OS;

                      case OS:
                        while (bits < 16) {
                            if (have === 0) {
                                break inf_leave;
                            }
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                        }
                        if (state.head) {
                            state.head.xflags = hold & 255;
                            state.head.os = hold >> 8;
                        }
                        if (state.flags & 512) {
                            hbuf[0] = hold & 255;
                            hbuf[1] = hold >>> 8 & 255;
                            state.check = crc32(state.check, hbuf, 2, 0);
                        }
                        hold = 0;
                        bits = 0;
                        state.mode = EXLEN;

                      case EXLEN:
                        if (state.flags & 1024) {
                            while (bits < 16) {
                                if (have === 0) {
                                    break inf_leave;
                                }
                                have--;
                                hold += input[next++] << bits;
                                bits += 8;
                            }
                            state.length = hold;
                            if (state.head) {
                                state.head.extra_len = hold;
                            }
                            if (state.flags & 512) {
                                hbuf[0] = hold & 255;
                                hbuf[1] = hold >>> 8 & 255;
                                state.check = crc32(state.check, hbuf, 2, 0);
                            }
                            hold = 0;
                            bits = 0;
                        } else if (state.head) {
                            state.head.extra = null;
                        }
                        state.mode = EXTRA;

                      case EXTRA:
                        if (state.flags & 1024) {
                            copy = state.length;
                            if (copy > have) {
                                copy = have;
                            }
                            if (copy) {
                                if (state.head) {
                                    len = state.head.extra_len - state.length;
                                    if (!state.head.extra) {
                                        state.head.extra = new Array(state.head.extra_len);
                                    }
                                    utils.arraySet(state.head.extra, input, next, copy, len);
                                }
                                if (state.flags & 512) {
                                    state.check = crc32(state.check, input, copy, next);
                                }
                                have -= copy;
                                next += copy;
                                state.length -= copy;
                            }
                            if (state.length) {
                                break inf_leave;
                            }
                        }
                        state.length = 0;
                        state.mode = NAME;

                      case NAME:
                        if (state.flags & 2048) {
                            if (have === 0) {
                                break inf_leave;
                            }
                            copy = 0;
                            do {
                                len = input[next + copy++];
                                if (state.head && len && state.length < 65536) {
                                    state.head.name += String.fromCharCode(len);
                                }
                            } while (len && copy < have);
                            if (state.flags & 512) {
                                state.check = crc32(state.check, input, copy, next);
                            }
                            have -= copy;
                            next += copy;
                            if (len) {
                                break inf_leave;
                            }
                        } else if (state.head) {
                            state.head.name = null;
                        }
                        state.length = 0;
                        state.mode = COMMENT;

                      case COMMENT:
                        if (state.flags & 4096) {
                            if (have === 0) {
                                break inf_leave;
                            }
                            copy = 0;
                            do {
                                len = input[next + copy++];
                                if (state.head && len && state.length < 65536) {
                                    state.head.comment += String.fromCharCode(len);
                                }
                            } while (len && copy < have);
                            if (state.flags & 512) {
                                state.check = crc32(state.check, input, copy, next);
                            }
                            have -= copy;
                            next += copy;
                            if (len) {
                                break inf_leave;
                            }
                        } else if (state.head) {
                            state.head.comment = null;
                        }
                        state.mode = HCRC;

                      case HCRC:
                        if (state.flags & 512) {
                            while (bits < 16) {
                                if (have === 0) {
                                    break inf_leave;
                                }
                                have--;
                                hold += input[next++] << bits;
                                bits += 8;
                            }
                            if (hold !== (state.check & 65535)) {
                                strm.msg = "header crc mismatch";
                                state.mode = BAD;
                                break;
                            }
                            hold = 0;
                            bits = 0;
                        }
                        if (state.head) {
                            state.head.hcrc = state.flags >> 9 & 1;
                            state.head.done = true;
                        }
                        strm.adler = state.check = 0;
                        state.mode = TYPE;
                        break;

                      case DICTID:
                        while (bits < 32) {
                            if (have === 0) {
                                break inf_leave;
                            }
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                        }
                        strm.adler = state.check = ZSWAP32(hold);
                        hold = 0;
                        bits = 0;
                        state.mode = DICT;

                      case DICT:
                        if (state.havedict === 0) {
                            strm.next_out = put;
                            strm.avail_out = left;
                            strm.next_in = next;
                            strm.avail_in = have;
                            state.hold = hold;
                            state.bits = bits;
                            return Z_NEED_DICT;
                        }
                        strm.adler = state.check = 1;
                        state.mode = TYPE;

                      case TYPE:
                        if (flush === Z_BLOCK || flush === Z_TREES) {
                            break inf_leave;
                        }

                      case TYPEDO:
                        if (state.last) {
                            hold >>>= bits & 7;
                            bits -= bits & 7;
                            state.mode = CHECK;
                            break;
                        }
                        while (bits < 3) {
                            if (have === 0) {
                                break inf_leave;
                            }
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                        }
                        state.last = hold & 1;
                        hold >>>= 1;
                        bits -= 1;
                        switch (hold & 3) {
                          case 0:
                            state.mode = STORED;
                            break;

                          case 1:
                            fixedtables(state);
                            state.mode = LEN_;
                            if (flush === Z_TREES) {
                                hold >>>= 2;
                                bits -= 2;
                                break inf_leave;
                            }
                            break;

                          case 2:
                            state.mode = TABLE;
                            break;

                          case 3:
                            strm.msg = "invalid block type";
                            state.mode = BAD;
                        }
                        hold >>>= 2;
                        bits -= 2;
                        break;

                      case STORED:
                        hold >>>= bits & 7;
                        bits -= bits & 7;
                        while (bits < 32) {
                            if (have === 0) {
                                break inf_leave;
                            }
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                        }
                        if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
                            strm.msg = "invalid stored block lengths";
                            state.mode = BAD;
                            break;
                        }
                        state.length = hold & 65535;
                        hold = 0;
                        bits = 0;
                        state.mode = COPY_;
                        if (flush === Z_TREES) {
                            break inf_leave;
                        }

                      case COPY_:
                        state.mode = COPY;

                      case COPY:
                        copy = state.length;
                        if (copy) {
                            if (copy > have) {
                                copy = have;
                            }
                            if (copy > left) {
                                copy = left;
                            }
                            if (copy === 0) {
                                break inf_leave;
                            }
                            utils.arraySet(output, input, next, copy, put);
                            have -= copy;
                            next += copy;
                            left -= copy;
                            put += copy;
                            state.length -= copy;
                            break;
                        }
                        state.mode = TYPE;
                        break;

                      case TABLE:
                        while (bits < 14) {
                            if (have === 0) {
                                break inf_leave;
                            }
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                        }
                        state.nlen = (hold & 31) + 257;
                        hold >>>= 5;
                        bits -= 5;
                        state.ndist = (hold & 31) + 1;
                        hold >>>= 5;
                        bits -= 5;
                        state.ncode = (hold & 15) + 4;
                        hold >>>= 4;
                        bits -= 4;
                        if (state.nlen > 286 || state.ndist > 30) {
                            strm.msg = "too many length or distance symbols";
                            state.mode = BAD;
                            break;
                        }
                        state.have = 0;
                        state.mode = LENLENS;

                      case LENLENS:
                        while (state.have < state.ncode) {
                            while (bits < 3) {
                                if (have === 0) {
                                    break inf_leave;
                                }
                                have--;
                                hold += input[next++] << bits;
                                bits += 8;
                            }
                            state.lens[order[state.have++]] = hold & 7;
                            hold >>>= 3;
                            bits -= 3;
                        }
                        while (state.have < 19) {
                            state.lens[order[state.have++]] = 0;
                        }
                        state.lencode = state.lendyn;
                        state.lenbits = 7;
                        opts = {
                            "bits": state.lenbits
                        };
                        ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
                        state.lenbits = opts.bits;
                        if (ret) {
                            strm.msg = "invalid code lengths set";
                            state.mode = BAD;
                            break;
                        }
                        state.have = 0;
                        state.mode = CODELENS;

                      case CODELENS:
                        while (state.have < state.nlen + state.ndist) {
                            for (;;) {
                                here = state.lencode[hold & (1 << state.lenbits) - 1];
                                here_bits = here >>> 24;
                                here_op = here >>> 16 & 255;
                                here_val = here & 65535;
                                if (here_bits <= bits) {
                                    break;
                                }
                                if (have === 0) {
                                    break inf_leave;
                                }
                                have--;
                                hold += input[next++] << bits;
                                bits += 8;
                            }
                            if (here_val < 16) {
                                hold >>>= here_bits;
                                bits -= here_bits;
                                state.lens[state.have++] = here_val;
                            } else {
                                if (here_val === 16) {
                                    n = here_bits + 2;
                                    while (bits < n) {
                                        if (have === 0) {
                                            break inf_leave;
                                        }
                                        have--;
                                        hold += input[next++] << bits;
                                        bits += 8;
                                    }
                                    hold >>>= here_bits;
                                    bits -= here_bits;
                                    if (state.have === 0) {
                                        strm.msg = "invalid bit length repeat";
                                        state.mode = BAD;
                                        break;
                                    }
                                    len = state.lens[state.have - 1];
                                    copy = 3 + (hold & 3);
                                    hold >>>= 2;
                                    bits -= 2;
                                } else if (here_val === 17) {
                                    n = here_bits + 3;
                                    while (bits < n) {
                                        if (have === 0) {
                                            break inf_leave;
                                        }
                                        have--;
                                        hold += input[next++] << bits;
                                        bits += 8;
                                    }
                                    hold >>>= here_bits;
                                    bits -= here_bits;
                                    len = 0;
                                    copy = 3 + (hold & 7);
                                    hold >>>= 3;
                                    bits -= 3;
                                } else {
                                    n = here_bits + 7;
                                    while (bits < n) {
                                        if (have === 0) {
                                            break inf_leave;
                                        }
                                        have--;
                                        hold += input[next++] << bits;
                                        bits += 8;
                                    }
                                    hold >>>= here_bits;
                                    bits -= here_bits;
                                    len = 0;
                                    copy = 11 + (hold & 127);
                                    hold >>>= 7;
                                    bits -= 7;
                                }
                                if (state.have + copy > state.nlen + state.ndist) {
                                    strm.msg = "invalid bit length repeat";
                                    state.mode = BAD;
                                    break;
                                }
                                while (copy--) {
                                    state.lens[state.have++] = len;
                                }
                            }
                        }
                        if (state.mode === BAD) {
                            break;
                        }
                        if (state.lens[256] === 0) {
                            strm.msg = "invalid code -- missing end-of-block";
                            state.mode = BAD;
                            break;
                        }
                        state.lenbits = 9;
                        opts = {
                            "bits": state.lenbits
                        };
                        ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
                        state.lenbits = opts.bits;
                        if (ret) {
                            strm.msg = "invalid literal/lengths set";
                            state.mode = BAD;
                            break;
                        }
                        state.distbits = 6;
                        state.distcode = state.distdyn;
                        opts = {
                            "bits": state.distbits
                        };
                        ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
                        state.distbits = opts.bits;
                        if (ret) {
                            strm.msg = "invalid distances set";
                            state.mode = BAD;
                            break;
                        }
                        state.mode = LEN_;
                        if (flush === Z_TREES) {
                            break inf_leave;
                        }

                      case LEN_:
                        state.mode = LEN;

                      case LEN:
                        if (have >= 6 && left >= 258) {
                            strm.next_out = put;
                            strm.avail_out = left;
                            strm.next_in = next;
                            strm.avail_in = have;
                            state.hold = hold;
                            state.bits = bits;
                            inflate_fast(strm, _out);
                            put = strm.next_out;
                            output = strm.output;
                            left = strm.avail_out;
                            next = strm.next_in;
                            input = strm.input;
                            have = strm.avail_in;
                            hold = state.hold;
                            bits = state.bits;
                            if (state.mode === TYPE) {
                                state.back = -1;
                            }
                            break;
                        }
                        state.back = 0;
                        for (;;) {
                            here = state.lencode[hold & (1 << state.lenbits) - 1];
                            here_bits = here >>> 24;
                            here_op = here >>> 16 & 255;
                            here_val = here & 65535;
                            if (here_bits <= bits) {
                                break;
                            }
                            if (have === 0) {
                                break inf_leave;
                            }
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                        }
                        if (here_op && (here_op & 240) === 0) {
                            last_bits = here_bits;
                            last_op = here_op;
                            last_val = here_val;
                            for (;;) {
                                here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                                here_bits = here >>> 24;
                                here_op = here >>> 16 & 255;
                                here_val = here & 65535;
                                if (last_bits + here_bits <= bits) {
                                    break;
                                }
                                if (have === 0) {
                                    break inf_leave;
                                }
                                have--;
                                hold += input[next++] << bits;
                                bits += 8;
                            }
                            hold >>>= last_bits;
                            bits -= last_bits;
                            state.back += last_bits;
                        }
                        hold >>>= here_bits;
                        bits -= here_bits;
                        state.back += here_bits;
                        state.length = here_val;
                        if (here_op === 0) {
                            state.mode = LIT;
                            break;
                        }
                        if (here_op & 32) {
                            state.back = -1;
                            state.mode = TYPE;
                            break;
                        }
                        if (here_op & 64) {
                            strm.msg = "invalid literal/length code";
                            state.mode = BAD;
                            break;
                        }
                        state.extra = here_op & 15;
                        state.mode = LENEXT;

                      case LENEXT:
                        if (state.extra) {
                            n = state.extra;
                            while (bits < n) {
                                if (have === 0) {
                                    break inf_leave;
                                }
                                have--;
                                hold += input[next++] << bits;
                                bits += 8;
                            }
                            state.length += hold & (1 << state.extra) - 1;
                            hold >>>= state.extra;
                            bits -= state.extra;
                            state.back += state.extra;
                        }
                        state.was = state.length;
                        state.mode = DIST;

                      case DIST:
                        for (;;) {
                            here = state.distcode[hold & (1 << state.distbits) - 1];
                            here_bits = here >>> 24;
                            here_op = here >>> 16 & 255;
                            here_val = here & 65535;
                            if (here_bits <= bits) {
                                break;
                            }
                            if (have === 0) {
                                break inf_leave;
                            }
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                        }
                        if ((here_op & 240) === 0) {
                            last_bits = here_bits;
                            last_op = here_op;
                            last_val = here_val;
                            for (;;) {
                                here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                                here_bits = here >>> 24;
                                here_op = here >>> 16 & 255;
                                here_val = here & 65535;
                                if (last_bits + here_bits <= bits) {
                                    break;
                                }
                                if (have === 0) {
                                    break inf_leave;
                                }
                                have--;
                                hold += input[next++] << bits;
                                bits += 8;
                            }
                            hold >>>= last_bits;
                            bits -= last_bits;
                            state.back += last_bits;
                        }
                        hold >>>= here_bits;
                        bits -= here_bits;
                        state.back += here_bits;
                        if (here_op & 64) {
                            strm.msg = "invalid distance code";
                            state.mode = BAD;
                            break;
                        }
                        state.offset = here_val;
                        state.extra = here_op & 15;
                        state.mode = DISTEXT;

                      case DISTEXT:
                        if (state.extra) {
                            n = state.extra;
                            while (bits < n) {
                                if (have === 0) {
                                    break inf_leave;
                                }
                                have--;
                                hold += input[next++] << bits;
                                bits += 8;
                            }
                            state.offset += hold & (1 << state.extra) - 1;
                            hold >>>= state.extra;
                            bits -= state.extra;
                            state.back += state.extra;
                        }
                        if (state.offset > state.dmax) {
                            strm.msg = "invalid distance too far back";
                            state.mode = BAD;
                            break;
                        }
                        state.mode = MATCH;

                      case MATCH:
                        if (left === 0) {
                            break inf_leave;
                        }
                        copy = _out - left;
                        if (state.offset > copy) {
                            copy = state.offset - copy;
                            if (copy > state.whave) {
                                if (state.sane) {
                                    strm.msg = "invalid distance too far back";
                                    state.mode = BAD;
                                    break;
                                }
                            }
                            if (copy > state.wnext) {
                                copy -= state.wnext;
                                from = state.wsize - copy;
                            } else {
                                from = state.wnext - copy;
                            }
                            if (copy > state.length) {
                                copy = state.length;
                            }
                            from_source = state.window;
                        } else {
                            from_source = output;
                            from = put - state.offset;
                            copy = state.length;
                        }
                        if (copy > left) {
                            copy = left;
                        }
                        left -= copy;
                        state.length -= copy;
                        do {
                            output[put++] = from_source[from++];
                        } while (--copy);
                        if (state.length === 0) {
                            state.mode = LEN;
                        }
                        break;

                      case LIT:
                        if (left === 0) {
                            break inf_leave;
                        }
                        output[put++] = state.length;
                        left--;
                        state.mode = LEN;
                        break;

                      case CHECK:
                        if (state.wrap) {
                            while (bits < 32) {
                                if (have === 0) {
                                    break inf_leave;
                                }
                                have--;
                                hold |= input[next++] << bits;
                                bits += 8;
                            }
                            _out -= left;
                            strm.total_out += _out;
                            state.total += _out;
                            if (_out) {
                                strm.adler = state.check = state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
                            }
                            _out = left;
                            if ((state.flags ? hold : ZSWAP32(hold)) !== state.check) {
                                strm.msg = "incorrect data check";
                                state.mode = BAD;
                                break;
                            }
                            hold = 0;
                            bits = 0;
                        }
                        state.mode = LENGTH;

                      case LENGTH:
                        if (state.wrap && state.flags) {
                            while (bits < 32) {
                                if (have === 0) {
                                    break inf_leave;
                                }
                                have--;
                                hold += input[next++] << bits;
                                bits += 8;
                            }
                            if (hold !== (state.total & 4294967295)) {
                                strm.msg = "incorrect length check";
                                state.mode = BAD;
                                break;
                            }
                            hold = 0;
                            bits = 0;
                        }
                        state.mode = DONE;

                      case DONE:
                        ret = Z_STREAM_END;
                        break inf_leave;

                      case BAD:
                        ret = Z_DATA_ERROR;
                        break inf_leave;

                      case MEM:
                        return Z_MEM_ERROR;

                      case SYNC:
                      default:
                        return Z_STREAM_ERROR;
                    }
                }
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {
                    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
                        state.mode = MEM;
                        return Z_MEM_ERROR;
                    }
                }
                _in -= strm.avail_in;
                _out -= strm.avail_out;
                strm.total_in += _in;
                strm.total_out += _out;
                state.total += _out;
                if (state.wrap && _out) {
                    strm.adler = state.check = state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
                }
                strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
                if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
                    ret = Z_BUF_ERROR;
                }
                return ret;
            }
            function inflateEnd(strm) {
                if (!strm || !strm.state) {
                    return Z_STREAM_ERROR;
                }
                var state = strm.state;
                if (state.window) {
                    state.window = null;
                }
                strm.state = null;
                return Z_OK;
            }
            function inflateGetHeader(strm, head) {
                var state;
                if (!strm || !strm.state) {
                    return Z_STREAM_ERROR;
                }
                state = strm.state;
                if ((state.wrap & 2) === 0) {
                    return Z_STREAM_ERROR;
                }
                state.head = head;
                head.done = false;
                return Z_OK;
            }
            exports.inflateReset = inflateReset;
            exports.inflateReset2 = inflateReset2;
            exports.inflateResetKeep = inflateResetKeep;
            exports.inflateInit = inflateInit;
            exports.inflateInit2 = inflateInit2;
            exports.inflate = inflate;
            exports.inflateEnd = inflateEnd;
            exports.inflateGetHeader = inflateGetHeader;
            exports.inflateInfo = "pako inflate (from Nodeca project)";
        }, {
            "../utils/common": 27,
            "./adler32": 29,
            "./crc32": 31,
            "./inffast": 34,
            "./inftrees": 36
        } ],
        "36": [ function(_dereq_, module, exports) {
            "use strict";
            var utils = _dereq_("../utils/common");
            var MAXBITS = 15;
            var ENOUGH_LENS = 852;
            var ENOUGH_DISTS = 592;
            var CODES = 0;
            var LENS = 1;
            var DISTS = 2;
            var lbase = [ 3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0 ];
            var lext = [ 16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78 ];
            var dbase = [ 1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0 ];
            var dext = [ 16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64 ];
            module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
                var bits = opts.bits;
                var len = 0;
                var sym = 0;
                var min = 0, max = 0;
                var root = 0;
                var curr = 0;
                var drop = 0;
                var left = 0;
                var used = 0;
                var huff = 0;
                var incr;
                var fill;
                var low;
                var mask;
                var next;
                var base = null;
                var base_index = 0;
                var end;
                var count = new utils.Buf16(MAXBITS + 1);
                var offs = new utils.Buf16(MAXBITS + 1);
                var extra = null;
                var extra_index = 0;
                var here_bits, here_op, here_val;
                for (len = 0; len <= MAXBITS; len++) {
                    count[len] = 0;
                }
                for (sym = 0; sym < codes; sym++) {
                    count[lens[lens_index + sym]]++;
                }
                root = bits;
                for (max = MAXBITS; max >= 1; max--) {
                    if (count[max] !== 0) {
                        break;
                    }
                }
                if (root > max) {
                    root = max;
                }
                if (max === 0) {
                    table[table_index++] = 1 << 24 | 64 << 16 | 0;
                    table[table_index++] = 1 << 24 | 64 << 16 | 0;
                    opts.bits = 1;
                    return 0;
                }
                for (min = 1; min < max; min++) {
                    if (count[min] !== 0) {
                        break;
                    }
                }
                if (root < min) {
                    root = min;
                }
                left = 1;
                for (len = 1; len <= MAXBITS; len++) {
                    left <<= 1;
                    left -= count[len];
                    if (left < 0) {
                        return -1;
                    }
                }
                if (left > 0 && (type === CODES || max !== 1)) {
                    return -1;
                }
                offs[1] = 0;
                for (len = 1; len < MAXBITS; len++) {
                    offs[len + 1] = offs[len] + count[len];
                }
                for (sym = 0; sym < codes; sym++) {
                    if (lens[lens_index + sym] !== 0) {
                        work[offs[lens[lens_index + sym]]++] = sym;
                    }
                }
                if (type === CODES) {
                    base = extra = work;
                    end = 19;
                } else if (type === LENS) {
                    base = lbase;
                    base_index -= 257;
                    extra = lext;
                    extra_index -= 257;
                    end = 256;
                } else {
                    base = dbase;
                    extra = dext;
                    end = -1;
                }
                huff = 0;
                sym = 0;
                len = min;
                next = table_index;
                curr = root;
                drop = 0;
                low = -1;
                used = 1 << root;
                mask = used - 1;
                if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
                    return 1;
                }
                var i = 0;
                for (;;) {
                    i++;
                    here_bits = len - drop;
                    if (work[sym] < end) {
                        here_op = 0;
                        here_val = work[sym];
                    } else if (work[sym] > end) {
                        here_op = extra[extra_index + work[sym]];
                        here_val = base[base_index + work[sym]];
                    } else {
                        here_op = 32 + 64;
                        here_val = 0;
                    }
                    incr = 1 << len - drop;
                    fill = 1 << curr;
                    min = fill;
                    do {
                        fill -= incr;
                        table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
                    } while (fill !== 0);
                    incr = 1 << len - 1;
                    while (huff & incr) {
                        incr >>= 1;
                    }
                    if (incr !== 0) {
                        huff &= incr - 1;
                        huff += incr;
                    } else {
                        huff = 0;
                    }
                    sym++;
                    if (--count[len] === 0) {
                        if (len === max) {
                            break;
                        }
                        len = lens[lens_index + work[sym]];
                    }
                    if (len > root && (huff & mask) !== low) {
                        if (drop === 0) {
                            drop = root;
                        }
                        next += min;
                        curr = len - drop;
                        left = 1 << curr;
                        while (curr + drop < max) {
                            left -= count[curr + drop];
                            if (left <= 0) {
                                break;
                            }
                            curr++;
                            left <<= 1;
                        }
                        used += 1 << curr;
                        if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
                            return 1;
                        }
                        low = huff & mask;
                        table[low] = root << 24 | curr << 16 | next - table_index | 0;
                    }
                }
                if (huff !== 0) {
                    table[next + huff] = len - drop << 24 | 64 << 16 | 0;
                }
                opts.bits = root;
                return 0;
            };
        }, {
            "../utils/common": 27
        } ],
        "37": [ function(_dereq_, module, exports) {
            "use strict";
            module.exports = {
                "2": "need dictionary",
                "1": "stream end",
                "0": "",
                "-1": "file error",
                "-2": "stream error",
                "-3": "data error",
                "-4": "insufficient memory",
                "-5": "buffer error",
                "-6": "incompatible version"
            };
        }, {} ],
        "38": [ function(_dereq_, module, exports) {
            "use strict";
            var utils = _dereq_("../utils/common");
            var Z_FIXED = 4;
            var Z_BINARY = 0;
            var Z_TEXT = 1;
            var Z_UNKNOWN = 2;
            function zero(buf) {
                var len = buf.length;
                while (--len >= 0) {
                    buf[len] = 0;
                }
            }
            var STORED_BLOCK = 0;
            var STATIC_TREES = 1;
            var DYN_TREES = 2;
            var MIN_MATCH = 3;
            var MAX_MATCH = 258;
            var LENGTH_CODES = 29;
            var LITERALS = 256;
            var L_CODES = LITERALS + 1 + LENGTH_CODES;
            var D_CODES = 30;
            var BL_CODES = 19;
            var HEAP_SIZE = 2 * L_CODES + 1;
            var MAX_BITS = 15;
            var Buf_size = 16;
            var MAX_BL_BITS = 7;
            var END_BLOCK = 256;
            var REP_3_6 = 16;
            var REPZ_3_10 = 17;
            var REPZ_11_138 = 18;
            var extra_lbits = [ 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0 ];
            var extra_dbits = [ 0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13 ];
            var extra_blbits = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7 ];
            var bl_order = [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];
            var DIST_CODE_LEN = 512;
            var static_ltree = new Array((L_CODES + 2) * 2);
            zero(static_ltree);
            var static_dtree = new Array(D_CODES * 2);
            zero(static_dtree);
            var _dist_code = new Array(DIST_CODE_LEN);
            zero(_dist_code);
            var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
            zero(_length_code);
            var base_length = new Array(LENGTH_CODES);
            zero(base_length);
            var base_dist = new Array(D_CODES);
            zero(base_dist);
            var StaticTreeDesc = function(static_tree, extra_bits, extra_base, elems, max_length) {
                this.static_tree = static_tree;
                this.extra_bits = extra_bits;
                this.extra_base = extra_base;
                this.elems = elems;
                this.max_length = max_length;
                this.has_stree = static_tree && static_tree.length;
            };
            var static_l_desc;
            var static_d_desc;
            var static_bl_desc;
            var TreeDesc = function(dyn_tree, stat_desc) {
                this.dyn_tree = dyn_tree;
                this.max_code = 0;
                this.stat_desc = stat_desc;
            };
            function d_code(dist) {
                return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
            }
            function put_short(s, w) {
                s.pending_buf[s.pending++] = w & 255;
                s.pending_buf[s.pending++] = w >>> 8 & 255;
            }
            function send_bits(s, value, length) {
                if (s.bi_valid > Buf_size - length) {
                    s.bi_buf |= value << s.bi_valid & 65535;
                    put_short(s, s.bi_buf);
                    s.bi_buf = value >> Buf_size - s.bi_valid;
                    s.bi_valid += length - Buf_size;
                } else {
                    s.bi_buf |= value << s.bi_valid & 65535;
                    s.bi_valid += length;
                }
            }
            function send_code(s, c, tree) {
                send_bits(s, tree[c * 2], tree[c * 2 + 1]);
            }
            function bi_reverse(code, len) {
                var res = 0;
                do {
                    res |= code & 1;
                    code >>>= 1;
                    res <<= 1;
                } while (--len > 0);
                return res >>> 1;
            }
            function bi_flush(s) {
                if (s.bi_valid === 16) {
                    put_short(s, s.bi_buf);
                    s.bi_buf = 0;
                    s.bi_valid = 0;
                } else if (s.bi_valid >= 8) {
                    s.pending_buf[s.pending++] = s.bi_buf & 255;
                    s.bi_buf >>= 8;
                    s.bi_valid -= 8;
                }
            }
            function gen_bitlen(s, desc) {
                var tree = desc.dyn_tree;
                var max_code = desc.max_code;
                var stree = desc.stat_desc.static_tree;
                var has_stree = desc.stat_desc.has_stree;
                var extra = desc.stat_desc.extra_bits;
                var base = desc.stat_desc.extra_base;
                var max_length = desc.stat_desc.max_length;
                var h;
                var n, m;
                var bits;
                var xbits;
                var f;
                var overflow = 0;
                for (bits = 0; bits <= MAX_BITS; bits++) {
                    s.bl_count[bits] = 0;
                }
                tree[s.heap[s.heap_max] * 2 + 1] = 0;
                for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
                    n = s.heap[h];
                    bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
                    if (bits > max_length) {
                        bits = max_length;
                        overflow++;
                    }
                    tree[n * 2 + 1] = bits;
                    if (n > max_code) {
                        continue;
                    }
                    s.bl_count[bits]++;
                    xbits = 0;
                    if (n >= base) {
                        xbits = extra[n - base];
                    }
                    f = tree[n * 2];
                    s.opt_len += f * (bits + xbits);
                    if (has_stree) {
                        s.static_len += f * (stree[n * 2 + 1] + xbits);
                    }
                }
                if (overflow === 0) {
                    return;
                }
                do {
                    bits = max_length - 1;
                    while (s.bl_count[bits] === 0) {
                        bits--;
                    }
                    s.bl_count[bits]--;
                    s.bl_count[bits + 1] += 2;
                    s.bl_count[max_length]--;
                    overflow -= 2;
                } while (overflow > 0);
                for (bits = max_length; bits !== 0; bits--) {
                    n = s.bl_count[bits];
                    while (n !== 0) {
                        m = s.heap[--h];
                        if (m > max_code) {
                            continue;
                        }
                        if (tree[m * 2 + 1] !== bits) {
                            s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
                            tree[m * 2 + 1] = bits;
                        }
                        n--;
                    }
                }
            }
            function gen_codes(tree, max_code, bl_count) {
                var next_code = new Array(MAX_BITS + 1);
                var code = 0;
                var bits;
                var n;
                for (bits = 1; bits <= MAX_BITS; bits++) {
                    next_code[bits] = code = code + bl_count[bits - 1] << 1;
                }
                for (n = 0; n <= max_code; n++) {
                    var len = tree[n * 2 + 1];
                    if (len === 0) {
                        continue;
                    }
                    tree[n * 2] = bi_reverse(next_code[len]++, len);
                }
            }
            function tr_static_init() {
                var n;
                var bits;
                var length;
                var code;
                var dist;
                var bl_count = new Array(MAX_BITS + 1);
                length = 0;
                for (code = 0; code < LENGTH_CODES - 1; code++) {
                    base_length[code] = length;
                    for (n = 0; n < 1 << extra_lbits[code]; n++) {
                        _length_code[length++] = code;
                    }
                }
                _length_code[length - 1] = code;
                dist = 0;
                for (code = 0; code < 16; code++) {
                    base_dist[code] = dist;
                    for (n = 0; n < 1 << extra_dbits[code]; n++) {
                        _dist_code[dist++] = code;
                    }
                }
                dist >>= 7;
                for (;code < D_CODES; code++) {
                    base_dist[code] = dist << 7;
                    for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
                        _dist_code[256 + dist++] = code;
                    }
                }
                for (bits = 0; bits <= MAX_BITS; bits++) {
                    bl_count[bits] = 0;
                }
                n = 0;
                while (n <= 143) {
                    static_ltree[n * 2 + 1] = 8;
                    n++;
                    bl_count[8]++;
                }
                while (n <= 255) {
                    static_ltree[n * 2 + 1] = 9;
                    n++;
                    bl_count[9]++;
                }
                while (n <= 279) {
                    static_ltree[n * 2 + 1] = 7;
                    n++;
                    bl_count[7]++;
                }
                while (n <= 287) {
                    static_ltree[n * 2 + 1] = 8;
                    n++;
                    bl_count[8]++;
                }
                gen_codes(static_ltree, L_CODES + 1, bl_count);
                for (n = 0; n < D_CODES; n++) {
                    static_dtree[n * 2 + 1] = 5;
                    static_dtree[n * 2] = bi_reverse(n, 5);
                }
                static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
                static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
                static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
            }
            function init_block(s) {
                var n;
                for (n = 0; n < L_CODES; n++) {
                    s.dyn_ltree[n * 2] = 0;
                }
                for (n = 0; n < D_CODES; n++) {
                    s.dyn_dtree[n * 2] = 0;
                }
                for (n = 0; n < BL_CODES; n++) {
                    s.bl_tree[n * 2] = 0;
                }
                s.dyn_ltree[END_BLOCK * 2] = 1;
                s.opt_len = s.static_len = 0;
                s.last_lit = s.matches = 0;
            }
            function bi_windup(s) {
                if (s.bi_valid > 8) {
                    put_short(s, s.bi_buf);
                } else if (s.bi_valid > 0) {
                    s.pending_buf[s.pending++] = s.bi_buf;
                }
                s.bi_buf = 0;
                s.bi_valid = 0;
            }
            function copy_block(s, buf, len, header) {
                bi_windup(s);
                if (header) {
                    put_short(s, len);
                    put_short(s, ~len);
                }
                utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
                s.pending += len;
            }
            function smaller(tree, n, m, depth) {
                var _n2 = n * 2;
                var _m2 = m * 2;
                return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
            }
            function pqdownheap(s, tree, k) {
                var v = s.heap[k];
                var j = k << 1;
                while (j <= s.heap_len) {
                    if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
                        j++;
                    }
                    if (smaller(tree, v, s.heap[j], s.depth)) {
                        break;
                    }
                    s.heap[k] = s.heap[j];
                    k = j;
                    j <<= 1;
                }
                s.heap[k] = v;
            }
            function compress_block(s, ltree, dtree) {
                var dist;
                var lc;
                var lx = 0;
                var code;
                var extra;
                if (s.last_lit !== 0) {
                    do {
                        dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
                        lc = s.pending_buf[s.l_buf + lx];
                        lx++;
                        if (dist === 0) {
                            send_code(s, lc, ltree);
                        } else {
                            code = _length_code[lc];
                            send_code(s, code + LITERALS + 1, ltree);
                            extra = extra_lbits[code];
                            if (extra !== 0) {
                                lc -= base_length[code];
                                send_bits(s, lc, extra);
                            }
                            dist--;
                            code = d_code(dist);
                            send_code(s, code, dtree);
                            extra = extra_dbits[code];
                            if (extra !== 0) {
                                dist -= base_dist[code];
                                send_bits(s, dist, extra);
                            }
                        }
                    } while (lx < s.last_lit);
                }
                send_code(s, END_BLOCK, ltree);
            }
            function build_tree(s, desc) {
                var tree = desc.dyn_tree;
                var stree = desc.stat_desc.static_tree;
                var has_stree = desc.stat_desc.has_stree;
                var elems = desc.stat_desc.elems;
                var n, m;
                var max_code = -1;
                var node;
                s.heap_len = 0;
                s.heap_max = HEAP_SIZE;
                for (n = 0; n < elems; n++) {
                    if (tree[n * 2] !== 0) {
                        s.heap[++s.heap_len] = max_code = n;
                        s.depth[n] = 0;
                    } else {
                        tree[n * 2 + 1] = 0;
                    }
                }
                while (s.heap_len < 2) {
                    node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
                    tree[node * 2] = 1;
                    s.depth[node] = 0;
                    s.opt_len--;
                    if (has_stree) {
                        s.static_len -= stree[node * 2 + 1];
                    }
                }
                desc.max_code = max_code;
                for (n = s.heap_len >> 1; n >= 1; n--) {
                    pqdownheap(s, tree, n);
                }
                node = elems;
                do {
                    n = s.heap[1];
                    s.heap[1] = s.heap[s.heap_len--];
                    pqdownheap(s, tree, 1);
                    m = s.heap[1];
                    s.heap[--s.heap_max] = n;
                    s.heap[--s.heap_max] = m;
                    tree[node * 2] = tree[n * 2] + tree[m * 2];
                    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
                    tree[n * 2 + 1] = tree[m * 2 + 1] = node;
                    s.heap[1] = node++;
                    pqdownheap(s, tree, 1);
                } while (s.heap_len >= 2);
                s.heap[--s.heap_max] = s.heap[1];
                gen_bitlen(s, desc);
                gen_codes(tree, max_code, s.bl_count);
            }
            function scan_tree(s, tree, max_code) {
                var n;
                var prevlen = -1;
                var curlen;
                var nextlen = tree[0 * 2 + 1];
                var count = 0;
                var max_count = 7;
                var min_count = 4;
                if (nextlen === 0) {
                    max_count = 138;
                    min_count = 3;
                }
                tree[(max_code + 1) * 2 + 1] = 65535;
                for (n = 0; n <= max_code; n++) {
                    curlen = nextlen;
                    nextlen = tree[(n + 1) * 2 + 1];
                    if (++count < max_count && curlen === nextlen) {
                        continue;
                    } else if (count < min_count) {
                        s.bl_tree[curlen * 2] += count;
                    } else if (curlen !== 0) {
                        if (curlen !== prevlen) {
                            s.bl_tree[curlen * 2]++;
                        }
                        s.bl_tree[REP_3_6 * 2]++;
                    } else if (count <= 10) {
                        s.bl_tree[REPZ_3_10 * 2]++;
                    } else {
                        s.bl_tree[REPZ_11_138 * 2]++;
                    }
                    count = 0;
                    prevlen = curlen;
                    if (nextlen === 0) {
                        max_count = 138;
                        min_count = 3;
                    } else if (curlen === nextlen) {
                        max_count = 6;
                        min_count = 3;
                    } else {
                        max_count = 7;
                        min_count = 4;
                    }
                }
            }
            function send_tree(s, tree, max_code) {
                var n;
                var prevlen = -1;
                var curlen;
                var nextlen = tree[0 * 2 + 1];
                var count = 0;
                var max_count = 7;
                var min_count = 4;
                if (nextlen === 0) {
                    max_count = 138;
                    min_count = 3;
                }
                for (n = 0; n <= max_code; n++) {
                    curlen = nextlen;
                    nextlen = tree[(n + 1) * 2 + 1];
                    if (++count < max_count && curlen === nextlen) {
                        continue;
                    } else if (count < min_count) {
                        do {
                            send_code(s, curlen, s.bl_tree);
                        } while (--count !== 0);
                    } else if (curlen !== 0) {
                        if (curlen !== prevlen) {
                            send_code(s, curlen, s.bl_tree);
                            count--;
                        }
                        send_code(s, REP_3_6, s.bl_tree);
                        send_bits(s, count - 3, 2);
                    } else if (count <= 10) {
                        send_code(s, REPZ_3_10, s.bl_tree);
                        send_bits(s, count - 3, 3);
                    } else {
                        send_code(s, REPZ_11_138, s.bl_tree);
                        send_bits(s, count - 11, 7);
                    }
                    count = 0;
                    prevlen = curlen;
                    if (nextlen === 0) {
                        max_count = 138;
                        min_count = 3;
                    } else if (curlen === nextlen) {
                        max_count = 6;
                        min_count = 3;
                    } else {
                        max_count = 7;
                        min_count = 4;
                    }
                }
            }
            function build_bl_tree(s) {
                var max_blindex;
                scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
                scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
                build_tree(s, s.bl_desc);
                for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
                    if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
                        break;
                    }
                }
                s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
                return max_blindex;
            }
            function send_all_trees(s, lcodes, dcodes, blcodes) {
                var rank;
                send_bits(s, lcodes - 257, 5);
                send_bits(s, dcodes - 1, 5);
                send_bits(s, blcodes - 4, 4);
                for (rank = 0; rank < blcodes; rank++) {
                    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], 3);
                }
                send_tree(s, s.dyn_ltree, lcodes - 1);
                send_tree(s, s.dyn_dtree, dcodes - 1);
            }
            function detect_data_type(s) {
                var black_mask = 4093624447;
                var n;
                for (n = 0; n <= 31; n++, black_mask >>>= 1) {
                    if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
                        return Z_BINARY;
                    }
                }
                if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
                    return Z_TEXT;
                }
                for (n = 32; n < LITERALS; n++) {
                    if (s.dyn_ltree[n * 2] !== 0) {
                        return Z_TEXT;
                    }
                }
                return Z_BINARY;
            }
            var static_init_done = false;
            function _tr_init(s) {
                if (!static_init_done) {
                    tr_static_init();
                    static_init_done = true;
                }
                s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
                s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
                s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
                s.bi_buf = 0;
                s.bi_valid = 0;
                init_block(s);
            }
            function _tr_stored_block(s, buf, stored_len, last) {
                send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
                copy_block(s, buf, stored_len, true);
            }
            function _tr_align(s) {
                send_bits(s, STATIC_TREES << 1, 3);
                send_code(s, END_BLOCK, static_ltree);
                bi_flush(s);
            }
            function _tr_flush_block(s, buf, stored_len, last) {
                var opt_lenb, static_lenb;
                var max_blindex = 0;
                if (s.level > 0) {
                    if (s.strm.data_type === Z_UNKNOWN) {
                        s.strm.data_type = detect_data_type(s);
                    }
                    build_tree(s, s.l_desc);
                    build_tree(s, s.d_desc);
                    max_blindex = build_bl_tree(s);
                    opt_lenb = s.opt_len + 3 + 7 >>> 3;
                    static_lenb = s.static_len + 3 + 7 >>> 3;
                    if (static_lenb <= opt_lenb) {
                        opt_lenb = static_lenb;
                    }
                } else {
                    opt_lenb = static_lenb = stored_len + 5;
                }
                if (stored_len + 4 <= opt_lenb && buf !== -1) {
                    _tr_stored_block(s, buf, stored_len, last);
                } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
                    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
                    compress_block(s, static_ltree, static_dtree);
                } else {
                    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
                    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
                    compress_block(s, s.dyn_ltree, s.dyn_dtree);
                }
                init_block(s);
                if (last) {
                    bi_windup(s);
                }
            }
            function _tr_tally(s, dist, lc) {
                s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 255;
                s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 255;
                s.pending_buf[s.l_buf + s.last_lit] = lc & 255;
                s.last_lit++;
                if (dist === 0) {
                    s.dyn_ltree[lc * 2]++;
                } else {
                    s.matches++;
                    dist--;
                    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
                    s.dyn_dtree[d_code(dist) * 2]++;
                }
                return s.last_lit === s.lit_bufsize - 1;
            }
            exports._tr_init = _tr_init;
            exports._tr_stored_block = _tr_stored_block;
            exports._tr_flush_block = _tr_flush_block;
            exports._tr_tally = _tr_tally;
            exports._tr_align = _tr_align;
        }, {
            "../utils/common": 27
        } ],
        "39": [ function(_dereq_, module, exports) {
            "use strict";
            function ZStream() {
                this.input = null;
                this.next_in = 0;
                this.avail_in = 0;
                this.total_in = 0;
                this.output = null;
                this.next_out = 0;
                this.avail_out = 0;
                this.total_out = 0;
                this.msg = "";
                this.state = null;
                this.data_type = 2;
                this.adler = 0;
            }
            module.exports = ZStream;
        }, {} ]
    }, {}, [ 9 ])(9);
});

var XLSX = {};

function make_xlsx_lib(XLSX) {
    XLSX.version = "0.14.0";
    var current_codepage = 1200, current_ansi = 1252;
    if (typeof module !== "undefined" && typeof require !== "undefined") {
        if (typeof cptable === "undefined") {
            if (typeof global !== "undefined") global.cptable = require("./dist/cpexcel.js"); else if (typeof window !== "undefined") window.cptable = require("./dist/cpexcel.js");
        }
    }
    var VALID_ANSI = [ 874, 932, 936, 949, 950 ];
    for (var i = 0; i <= 8; ++i) VALID_ANSI.push(1250 + i);
    var CS2CP = {
        "0": 1252,
        "1": 65001,
        "2": 65001,
        "77": 1e4,
        "128": 932,
        "129": 949,
        "130": 1361,
        "134": 936,
        "136": 950,
        "161": 1253,
        "162": 1254,
        "163": 1258,
        "177": 1255,
        "178": 1256,
        "186": 1257,
        "204": 1251,
        "222": 874,
        "238": 1250,
        "255": 1252,
        "69": 6969
    };
    var set_ansi = function(cp) {
        if (VALID_ANSI.indexOf(cp) == -1) return;
        current_ansi = CS2CP[0] = cp;
    };
    function reset_ansi() {
        set_ansi(1252);
    }
    var set_cp = function(cp) {
        current_codepage = cp;
        set_ansi(cp);
    };
    function reset_cp() {
        set_cp(1200);
        reset_ansi();
    }
    function char_codes(data) {
        var o = [];
        for (var i = 0, len = data.length; i < len; ++i) o[i] = data.charCodeAt(i);
        return o;
    }
    function utf16leread(data) {
        var o = [];
        for (var i = 0; i < data.length >> 1; ++i) o[i] = String.fromCharCode(data.charCodeAt(2 * i) + (data.charCodeAt(2 * i + 1) << 8));
        return o.join("");
    }
    function utf16beread(data) {
        var o = [];
        for (var i = 0; i < data.length >> 1; ++i) o[i] = String.fromCharCode(data.charCodeAt(2 * i + 1) + (data.charCodeAt(2 * i) << 8));
        return o.join("");
    }
    var debom = function(data) {
        var c1 = data.charCodeAt(0), c2 = data.charCodeAt(1);
        if (c1 == 255 && c2 == 254) return utf16leread(data.slice(2));
        if (c1 == 254 && c2 == 255) return utf16beread(data.slice(2));
        if (c1 == 65279) return data.slice(1);
        return data;
    };
    var _getchar = function _gc1(x) {
        return String.fromCharCode(x);
    };
    if (typeof cptable !== "undefined") {
        set_cp = function(cp) {
            current_codepage = cp;
        };
        debom = function(data) {
            if (data.charCodeAt(0) === 255 && data.charCodeAt(1) === 254) {
                return cptable.utils.decode(1200, char_codes(data.slice(2)));
            }
            return data;
        };
        _getchar = function _gc2(x) {
            if (current_codepage === 1200) return String.fromCharCode(x);
            return cptable.utils.decode(current_codepage, [ x & 255, x >> 8 ])[0];
        };
    }
    var DENSE = null;
    var DIF_XL = true;
    var Base64 = function make_b64() {
        var map = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
        return {
            "encode": function(input) {
                var o = "";
                var c1 = 0, c2 = 0, c3 = 0, e1 = 0, e2 = 0, e3 = 0, e4 = 0;
                for (var i = 0; i < input.length; ) {
                    c1 = input.charCodeAt(i++);
                    e1 = c1 >> 2;
                    c2 = input.charCodeAt(i++);
                    e2 = (c1 & 3) << 4 | c2 >> 4;
                    c3 = input.charCodeAt(i++);
                    e3 = (c2 & 15) << 2 | c3 >> 6;
                    e4 = c3 & 63;
                    if (isNaN(c2)) {
                        e3 = e4 = 64;
                    } else if (isNaN(c3)) {
                        e4 = 64;
                    }
                    o += map.charAt(e1) + map.charAt(e2) + map.charAt(e3) + map.charAt(e4);
                }
                return o;
            },
            "decode": function b64_decode(input) {
                var o = "";
                var c1 = 0, c2 = 0, c3 = 0, e1 = 0, e2 = 0, e3 = 0, e4 = 0;
                input = input.replace(/[^\w\+\/\=]/g, "");
                for (var i = 0; i < input.length; ) {
                    e1 = map.indexOf(input.charAt(i++));
                    e2 = map.indexOf(input.charAt(i++));
                    c1 = e1 << 2 | e2 >> 4;
                    o += String.fromCharCode(c1);
                    e3 = map.indexOf(input.charAt(i++));
                    c2 = (e2 & 15) << 4 | e3 >> 2;
                    if (e3 !== 64) {
                        o += String.fromCharCode(c2);
                    }
                    e4 = map.indexOf(input.charAt(i++));
                    c3 = (e3 & 3) << 6 | e4;
                    if (e4 !== 64) {
                        o += String.fromCharCode(c3);
                    }
                }
                return o;
            }
        };
    }();
    var has_buf = typeof Buffer !== "undefined" && typeof process !== "undefined" && typeof process.versions !== "undefined" && !!process.versions.node;
    var Buffer_from = function() {};
    if (typeof Buffer !== "undefined") {
        var nbfs = !Buffer.from;
        if (!nbfs) try {
            Buffer.from("foo", "utf8");
        } catch (e) {
            nbfs = true;
        }
        Buffer_from = nbfs ? function(buf, enc) {
            return enc ? new Buffer(buf, enc) : new Buffer(buf);
        } : Buffer.from.bind(Buffer);
        if (!Buffer.alloc) Buffer.alloc = function(n) {
            return new Buffer(n);
        };
        if (!Buffer.allocUnsafe) Buffer.allocUnsafe = function(n) {
            return new Buffer(n);
        };
    }
    function new_raw_buf(len) {
        return has_buf ? Buffer.alloc(len) : new Array(len);
    }
    function new_unsafe_buf(len) {
        return has_buf ? Buffer.allocUnsafe(len) : new Array(len);
    }
    var s2a = function s2a(s) {
        if (has_buf) return Buffer_from(s, "binary");
        return s.split("").map(function(x) {
            return x.charCodeAt(0) & 255;
        });
    };
    function s2ab(s) {
        if (typeof ArrayBuffer === "undefined") return s2a(s);
        var buf = new ArrayBuffer(s.length), view = new Uint8Array(buf);
        for (var i = 0; i != s.length; ++i) view[i] = s.charCodeAt(i) & 255;
        return buf;
    }
    function a2s(data) {
        if (Array.isArray(data)) return data.map(_chr).join("");
        var o = [];
        for (var i = 0; i < data.length; ++i) o[i] = _chr(data[i]);
        return o.join("");
    }
    function a2u(data) {
        if (typeof Uint8Array === "undefined") throw new Error("Unsupported");
        return new Uint8Array(data);
    }
    function ab2a(data) {
        if (typeof ArrayBuffer == "undefined") throw new Error("Unsupported");
        if (data instanceof ArrayBuffer) return ab2a(new Uint8Array(data));
        var o = new Array(data.length);
        for (var i = 0; i < data.length; ++i) o[i] = data[i];
        return o;
    }
    var bconcat = function(bufs) {
        return [].concat.apply([], bufs);
    };
    var chr0 = /\u0000/g, chr1 = /[\u0001-\u0006]/g;
    var SSF = {};
    var make_ssf = function make_ssf(SSF) {
        SSF.version = "0.10.2";
        function _strrev(x) {
            var o = "", i = x.length - 1;
            while (i >= 0) o += x.charAt(i--);
            return o;
        }
        function fill(c, l) {
            var o = "";
            while (o.length < l) o += c;
            return o;
        }
        function pad0(v, d) {
            var t = "" + v;
            return t.length >= d ? t : fill("0", d - t.length) + t;
        }
        function pad_(v, d) {
            var t = "" + v;
            return t.length >= d ? t : fill(" ", d - t.length) + t;
        }
        function rpad_(v, d) {
            var t = "" + v;
            return t.length >= d ? t : t + fill(" ", d - t.length);
        }
        function pad0r1(v, d) {
            var t = "" + Math.round(v);
            return t.length >= d ? t : fill("0", d - t.length) + t;
        }
        function pad0r2(v, d) {
            var t = "" + v;
            return t.length >= d ? t : fill("0", d - t.length) + t;
        }
        var p2_32 = Math.pow(2, 32);
        function pad0r(v, d) {
            if (v > p2_32 || v < -p2_32) return pad0r1(v, d);
            var i = Math.round(v);
            return pad0r2(i, d);
        }
        function isgeneral(s, i) {
            i = i || 0;
            return s.length >= 7 + i && (s.charCodeAt(i) | 32) === 103 && (s.charCodeAt(i + 1) | 32) === 101 && (s.charCodeAt(i + 2) | 32) === 110 && (s.charCodeAt(i + 3) | 32) === 101 && (s.charCodeAt(i + 4) | 32) === 114 && (s.charCodeAt(i + 5) | 32) === 97 && (s.charCodeAt(i + 6) | 32) === 108;
        }
        var days = [ [ "Sun", "Sunday" ], [ "Mon", "Monday" ], [ "Tue", "Tuesday" ], [ "Wed", "Wednesday" ], [ "Thu", "Thursday" ], [ "Fri", "Friday" ], [ "Sat", "Saturday" ] ];
        var months = [ [ "J", "Jan", "January" ], [ "F", "Feb", "February" ], [ "M", "Mar", "March" ], [ "A", "Apr", "April" ], [ "M", "May", "May" ], [ "J", "Jun", "June" ], [ "J", "Jul", "July" ], [ "A", "Aug", "August" ], [ "S", "Sep", "September" ], [ "O", "Oct", "October" ], [ "N", "Nov", "November" ], [ "D", "Dec", "December" ] ];
        function init_table(t) {
            t[0] = "General";
            t[1] = "0";
            t[2] = "0.00";
            t[3] = "#,##0";
            t[4] = "#,##0.00";
            t[9] = "0%";
            t[10] = "0.00%";
            t[11] = "0.00E+00";
            t[12] = "# ?/?";
            t[13] = "# ??/??";
            t[14] = "m/d/yy";
            t[15] = "d-mmm-yy";
            t[16] = "d-mmm";
            t[17] = "mmm-yy";
            t[18] = "h:mm AM/PM";
            t[19] = "h:mm:ss AM/PM";
            t[20] = "h:mm";
            t[21] = "h:mm:ss";
            t[22] = "m/d/yy h:mm";
            t[37] = "#,##0 ;(#,##0)";
            t[38] = "#,##0 ;[Red](#,##0)";
            t[39] = "#,##0.00;(#,##0.00)";
            t[40] = "#,##0.00;[Red](#,##0.00)";
            t[45] = "mm:ss";
            t[46] = "[h]:mm:ss";
            t[47] = "mmss.0";
            t[48] = "##0.0E+0";
            t[49] = "@";
            t[56] = '"\u4e0a\u5348/\u4e0b\u5348 "hh"\u6642"mm"\u5206"ss"\u79d2 "';
            t[65535] = "General";
        }
        var table_fmt = {};
        init_table(table_fmt);
        function frac(x, D, mixed) {
            var sgn = x < 0 ? -1 : 1;
            var B = x * sgn;
            var P_2 = 0, P_1 = 1, P = 0;
            var Q_2 = 1, Q_1 = 0, Q = 0;
            var A = Math.floor(B);
            while (Q_1 < D) {
                A = Math.floor(B);
                P = A * P_1 + P_2;
                Q = A * Q_1 + Q_2;
                if (B - A < 5e-8) break;
                B = 1 / (B - A);
                P_2 = P_1;
                P_1 = P;
                Q_2 = Q_1;
                Q_1 = Q;
            }
            if (Q > D) {
                if (Q_1 > D) {
                    Q = Q_2;
                    P = P_2;
                } else {
                    Q = Q_1;
                    P = P_1;
                }
            }
            if (!mixed) return [ 0, sgn * P, Q ];
            var q = Math.floor(sgn * P / Q);
            return [ q, sgn * P - q * Q, Q ];
        }
        function parse_date_code(v, opts, b2) {
            if (v > 2958465 || v < 0) return null;
            var date = v | 0, time = Math.floor(86400 * (v - date)), dow = 0;
            var dout = [];
            var out = {
                "D": date,
                "T": time,
                "u": 86400 * (v - date) - time,
                "y": 0,
                "m": 0,
                "d": 0,
                "H": 0,
                "M": 0,
                "S": 0,
                "q": 0
            };
            if (Math.abs(out.u) < 1e-6) out.u = 0;
            if (opts && opts.date1904) date += 1462;
            if (out.u > .9999) {
                out.u = 0;
                if (++time == 86400) {
                    out.T = time = 0;
                    ++date;
                    ++out.D;
                }
            }
            if (date === 60) {
                dout = b2 ? [ 1317, 10, 29 ] : [ 1900, 2, 29 ];
                dow = 3;
            } else if (date === 0) {
                dout = b2 ? [ 1317, 8, 29 ] : [ 1900, 1, 0 ];
                dow = 6;
            } else {
                if (date > 60) --date;
                var d = new Date(1900, 0, 1);
                d.setDate(d.getDate() + date - 1);
                dout = [ d.getFullYear(), d.getMonth() + 1, d.getDate() ];
                dow = d.getDay();
                if (date < 60) dow = (dow + 6) % 7;
                if (b2) dow = fix_hijri(d, dout);
            }
            out.y = dout[0];
            out.m = dout[1];
            out.d = dout[2];
            out.S = time % 60;
            time = Math.floor(time / 60);
            out.M = time % 60;
            time = Math.floor(time / 60);
            out.H = time;
            out.q = dow;
            return out;
        }
        SSF.parse_date_code = parse_date_code;
        var basedate = new Date(1899, 11, 31, 0, 0, 0);
        var dnthresh = basedate.getTime();
        var base1904 = new Date(1900, 2, 1, 0, 0, 0);
        function datenum_local(v, date1904) {
            var epoch = v.getTime();
            if (date1904) epoch -= 1461 * 24 * 60 * 60 * 1e3; else if (v >= base1904) epoch += 24 * 60 * 60 * 1e3;
            return (epoch - (dnthresh + (v.getTimezoneOffset() - basedate.getTimezoneOffset()) * 6e4)) / (24 * 60 * 60 * 1e3);
        }
        function general_fmt_int(v) {
            return v.toString(10);
        }
        SSF._general_int = general_fmt_int;
        var general_fmt_num = function make_general_fmt_num() {
            var gnr1 = /\.(\d*[1-9])0+$/, gnr2 = /\.0*$/, gnr4 = /\.(\d*[1-9])0+/, gnr5 = /\.0*[Ee]/, gnr6 = /(E[+-])(\d)$/;
            function gfn2(v) {
                var w = v < 0 ? 12 : 11;
                var o = gfn5(v.toFixed(12));
                if (o.length <= w) return o;
                o = v.toPrecision(10);
                if (o.length <= w) return o;
                return v.toExponential(5);
            }
            function gfn3(v) {
                var o = v.toFixed(11).replace(gnr1, ".$1");
                if (o.length > (v < 0 ? 12 : 11)) o = v.toPrecision(6);
                return o;
            }
            function gfn4(o) {
                for (var i = 0; i != o.length; ++i) if ((o.charCodeAt(i) | 32) === 101) return o.replace(gnr4, ".$1").replace(gnr5, "E").replace("e", "E").replace(gnr6, "$10$2");
                return o;
            }
            function gfn5(o) {
                return o.indexOf(".") > -1 ? o.replace(gnr2, "").replace(gnr1, ".$1") : o;
            }
            return function general_fmt_num(v) {
                var V = Math.floor(Math.log(Math.abs(v)) * Math.LOG10E), o;
                if (V >= -4 && V <= -1) o = v.toPrecision(10 + V); else if (Math.abs(V) <= 9) o = gfn2(v); else if (V === 10) o = v.toFixed(10).substr(0, 12); else o = gfn3(v);
                return gfn5(gfn4(o));
            };
        }();
        SSF._general_num = general_fmt_num;
        function general_fmt(v, opts) {
            switch (typeof v) {
              case "string":
                return v;

              case "boolean":
                return v ? "TRUE" : "FALSE";

              case "number":
                return (v | 0) === v ? general_fmt_int(v) : general_fmt_num(v);

              case "undefined":
                return "";

              case "object":
                if (v == null) return "";
                if (v instanceof Date) return format(14, datenum_local(v, opts && opts.date1904), opts);
            }
            throw new Error("unsupported value in General format: " + v);
        }
        SSF._general = general_fmt;
        function fix_hijri() {
            return 0;
        }
        function write_date(type, fmt, val, ss0) {
            var o = "", ss = 0, tt = 0, y = val.y, out, outl = 0;
            switch (type) {
              case 98:
                y = val.y + 543;

              case 121:
                switch (fmt.length) {
                  case 1:
                  case 2:
                    out = y % 100;
                    outl = 2;
                    break;

                  default:
                    out = y % 1e4;
                    outl = 4;
                    break;
                }
                break;

              case 109:
                switch (fmt.length) {
                  case 1:
                  case 2:
                    out = val.m;
                    outl = fmt.length;
                    break;

                  case 3:
                    return months[val.m - 1][1];

                  case 5:
                    return months[val.m - 1][0];

                  default:
                    return months[val.m - 1][2];
                }
                break;

              case 100:
                switch (fmt.length) {
                  case 1:
                  case 2:
                    out = val.d;
                    outl = fmt.length;
                    break;

                  case 3:
                    return days[val.q][0];

                  default:
                    return days[val.q][1];
                }
                break;

              case 104:
                switch (fmt.length) {
                  case 1:
                  case 2:
                    out = 1 + (val.H + 11) % 12;
                    outl = fmt.length;
                    break;

                  default:
                    throw "bad hour format: " + fmt;
                }
                break;

              case 72:
                switch (fmt.length) {
                  case 1:
                  case 2:
                    out = val.H;
                    outl = fmt.length;
                    break;

                  default:
                    throw "bad hour format: " + fmt;
                }
                break;

              case 77:
                switch (fmt.length) {
                  case 1:
                  case 2:
                    out = val.M;
                    outl = fmt.length;
                    break;

                  default:
                    throw "bad minute format: " + fmt;
                }
                break;

              case 115:
                if (fmt != "s" && fmt != "ss" && fmt != ".0" && fmt != ".00" && fmt != ".000") throw "bad second format: " + fmt;
                if (val.u === 0 && (fmt == "s" || fmt == "ss")) return pad0(val.S, fmt.length);
                if (ss0 >= 2) tt = ss0 === 3 ? 1e3 : 100; else tt = ss0 === 1 ? 10 : 1;
                ss = Math.round(tt * (val.S + val.u));
                if (ss >= 60 * tt) ss = 0;
                if (fmt === "s") return ss === 0 ? "0" : "" + ss / tt;
                o = pad0(ss, 2 + ss0);
                if (fmt === "ss") return o.substr(0, 2);
                return "." + o.substr(2, fmt.length - 1);

              case 90:
                switch (fmt) {
                  case "[h]":
                  case "[hh]":
                    out = val.D * 24 + val.H;
                    break;

                  case "[m]":
                  case "[mm]":
                    out = (val.D * 24 + val.H) * 60 + val.M;
                    break;

                  case "[s]":
                  case "[ss]":
                    out = ((val.D * 24 + val.H) * 60 + val.M) * 60 + Math.round(val.S + val.u);
                    break;

                  default:
                    throw "bad abstime format: " + fmt;
                }
                outl = fmt.length === 3 ? 1 : 2;
                break;

              case 101:
                out = y;
                outl = 1;
            }
            if (outl > 0) return pad0(out, outl); else return "";
        }
        function commaify(s) {
            var w = 3;
            if (s.length <= w) return s;
            var j = s.length % w, o = s.substr(0, j);
            for (;j != s.length; j += w) o += (o.length > 0 ? "," : "") + s.substr(j, w);
            return o;
        }
        var write_num = function make_write_num() {
            var pct1 = /%/g;
            function write_num_pct(type, fmt, val) {
                var sfmt = fmt.replace(pct1, ""), mul = fmt.length - sfmt.length;
                return write_num(type, sfmt, val * Math.pow(10, 2 * mul)) + fill("%", mul);
            }
            function write_num_cm(type, fmt, val) {
                var idx = fmt.length - 1;
                while (fmt.charCodeAt(idx - 1) === 44) --idx;
                return write_num(type, fmt.substr(0, idx), val / Math.pow(10, 3 * (fmt.length - idx)));
            }
            function write_num_exp(fmt, val) {
                var o;
                var idx = fmt.indexOf("E") - fmt.indexOf(".") - 1;
                if (fmt.match(/^#+0.0E\+0$/)) {
                    if (val == 0) return "0.0E+0"; else if (val < 0) return "-" + write_num_exp(fmt, -val);
                    var period = fmt.indexOf(".");
                    if (period === -1) period = fmt.indexOf("E");
                    var ee = Math.floor(Math.log(val) * Math.LOG10E) % period;
                    if (ee < 0) ee += period;
                    o = (val / Math.pow(10, ee)).toPrecision(idx + 1 + (period + ee) % period);
                    if (o.indexOf("e") === -1) {
                        var fakee = Math.floor(Math.log(val) * Math.LOG10E);
                        if (o.indexOf(".") === -1) o = o.charAt(0) + "." + o.substr(1) + "E+" + (fakee - o.length + ee); else o += "E+" + (fakee - ee);
                        while (o.substr(0, 2) === "0.") {
                            o = o.charAt(0) + o.substr(2, period) + "." + o.substr(2 + period);
                            o = o.replace(/^0+([1-9])/, "$1").replace(/^0+\./, "0.");
                        }
                        o = o.replace(/\+-/, "-");
                    }
                    o = o.replace(/^([+-]?)(\d*)\.(\d*)[Ee]/, function($$, $1, $2, $3) {
                        return $1 + $2 + $3.substr(0, (period + ee) % period) + "." + $3.substr(ee) + "E";
                    });
                } else o = val.toExponential(idx);
                if (fmt.match(/E\+00$/) && o.match(/e[+-]\d$/)) o = o.substr(0, o.length - 1) + "0" + o.charAt(o.length - 1);
                if (fmt.match(/E\-/) && o.match(/e\+/)) o = o.replace(/e\+/, "e");
                return o.replace("e", "E");
            }
            var frac1 = /# (\?+)( ?)\/( ?)(\d+)/;
            function write_num_f1(r, aval, sign) {
                var den = parseInt(r[4], 10), rr = Math.round(aval * den), base = Math.floor(rr / den);
                var myn = rr - base * den, myd = den;
                return sign + (base === 0 ? "" : "" + base) + " " + (myn === 0 ? fill(" ", r[1].length + 1 + r[4].length) : pad_(myn, r[1].length) + r[2] + "/" + r[3] + pad0(myd, r[4].length));
            }
            function write_num_f2(r, aval, sign) {
                return sign + (aval === 0 ? "" : "" + aval) + fill(" ", r[1].length + 2 + r[4].length);
            }
            var dec1 = /^#*0*\.([0#]+)/;
            var closeparen = /\).*[0#]/;
            var phone = /\(###\) ###\\?-####/;
            function hashq(str) {
                var o = "", cc;
                for (var i = 0; i != str.length; ++i) switch (cc = str.charCodeAt(i)) {
                  case 35:
                    break;

                  case 63:
                    o += " ";
                    break;

                  case 48:
                    o += "0";
                    break;

                  default:
                    o += String.fromCharCode(cc);
                }
                return o;
            }
            function rnd(val, d) {
                var dd = Math.pow(10, d);
                return "" + Math.round(val * dd) / dd;
            }
            function dec(val, d) {
                if (d < ("" + Math.round((val - Math.floor(val)) * Math.pow(10, d))).length) {
                    return 0;
                }
                return Math.round((val - Math.floor(val)) * Math.pow(10, d));
            }
            function carry(val, d) {
                if (d < ("" + Math.round((val - Math.floor(val)) * Math.pow(10, d))).length) {
                    return 1;
                }
                return 0;
            }
            function flr(val) {
                if (val < 2147483647 && val > -2147483648) return "" + (val >= 0 ? val | 0 : val - 1 | 0);
                return "" + Math.floor(val);
            }
            function write_num_flt(type, fmt, val) {
                if (type.charCodeAt(0) === 40 && !fmt.match(closeparen)) {
                    var ffmt = fmt.replace(/\( */, "").replace(/ \)/, "").replace(/\)/, "");
                    if (val >= 0) return write_num_flt("n", ffmt, val);
                    return "(" + write_num_flt("n", ffmt, -val) + ")";
                }
                if (fmt.charCodeAt(fmt.length - 1) === 44) return write_num_cm(type, fmt, val);
                if (fmt.indexOf("%") !== -1) return write_num_pct(type, fmt, val);
                if (fmt.indexOf("E") !== -1) return write_num_exp(fmt, val);
                if (fmt.charCodeAt(0) === 36) return "$" + write_num_flt(type, fmt.substr(fmt.charAt(1) == " " ? 2 : 1), val);
                var o;
                var r, ri, ff, aval = Math.abs(val), sign = val < 0 ? "-" : "";
                if (fmt.match(/^00+$/)) return sign + pad0r(aval, fmt.length);
                if (fmt.match(/^[#?]+$/)) {
                    o = pad0r(val, 0);
                    if (o === "0") o = "";
                    return o.length > fmt.length ? o : hashq(fmt.substr(0, fmt.length - o.length)) + o;
                }
                if (r = fmt.match(frac1)) return write_num_f1(r, aval, sign);
                if (fmt.match(/^#+0+$/)) return sign + pad0r(aval, fmt.length - fmt.indexOf("0"));
                if (r = fmt.match(dec1)) {
                    o = rnd(val, r[1].length).replace(/^([^\.]+)$/, "$1." + hashq(r[1])).replace(/\.$/, "." + hashq(r[1])).replace(/\.(\d*)$/, function($$, $1) {
                        return "." + $1 + fill("0", hashq(r[1]).length - $1.length);
                    });
                    return fmt.indexOf("0.") !== -1 ? o : o.replace(/^0\./, ".");
                }
                fmt = fmt.replace(/^#+([0.])/, "$1");
                if (r = fmt.match(/^(0*)\.(#*)$/)) {
                    return sign + rnd(aval, r[2].length).replace(/\.(\d*[1-9])0*$/, ".$1").replace(/^(-?\d*)$/, "$1.").replace(/^0\./, r[1].length ? "0." : ".");
                }
                if (r = fmt.match(/^#{1,3},##0(\.?)$/)) return sign + commaify(pad0r(aval, 0));
                if (r = fmt.match(/^#,##0\.([#0]*0)$/)) {
                    return val < 0 ? "-" + write_num_flt(type, fmt, -val) : commaify("" + (Math.floor(val) + carry(val, r[1].length))) + "." + pad0(dec(val, r[1].length), r[1].length);
                }
                if (r = fmt.match(/^#,#*,#0/)) return write_num_flt(type, fmt.replace(/^#,#*,/, ""), val);
                if (r = fmt.match(/^([0#]+)(\\?-([0#]+))+$/)) {
                    o = _strrev(write_num_flt(type, fmt.replace(/[\\-]/g, ""), val));
                    ri = 0;
                    return _strrev(_strrev(fmt.replace(/\\/g, "")).replace(/[0#]/g, function(x) {
                        return ri < o.length ? o.charAt(ri++) : x === "0" ? "0" : "";
                    }));
                }
                if (fmt.match(phone)) {
                    o = write_num_flt(type, "##########", val);
                    return "(" + o.substr(0, 3) + ") " + o.substr(3, 3) + "-" + o.substr(6);
                }
                var oa = "";
                if (r = fmt.match(/^([#0?]+)( ?)\/( ?)([#0?]+)/)) {
                    ri = Math.min(r[4].length, 7);
                    ff = frac(aval, Math.pow(10, ri) - 1, false);
                    o = "" + sign;
                    oa = write_num("n", r[1], ff[1]);
                    if (oa.charAt(oa.length - 1) == " ") oa = oa.substr(0, oa.length - 1) + "0";
                    o += oa + r[2] + "/" + r[3];
                    oa = rpad_(ff[2], ri);
                    if (oa.length < r[4].length) oa = hashq(r[4].substr(r[4].length - oa.length)) + oa;
                    o += oa;
                    return o;
                }
                if (r = fmt.match(/^# ([#0?]+)( ?)\/( ?)([#0?]+)/)) {
                    ri = Math.min(Math.max(r[1].length, r[4].length), 7);
                    ff = frac(aval, Math.pow(10, ri) - 1, true);
                    return sign + (ff[0] || (ff[1] ? "" : "0")) + " " + (ff[1] ? pad_(ff[1], ri) + r[2] + "/" + r[3] + rpad_(ff[2], ri) : fill(" ", 2 * ri + 1 + r[2].length + r[3].length));
                }
                if (r = fmt.match(/^[#0?]+$/)) {
                    o = pad0r(val, 0);
                    if (fmt.length <= o.length) return o;
                    return hashq(fmt.substr(0, fmt.length - o.length)) + o;
                }
                if (r = fmt.match(/^([#0?]+)\.([#0]+)$/)) {
                    o = "" + val.toFixed(Math.min(r[2].length, 10)).replace(/([^0])0+$/, "$1");
                    ri = o.indexOf(".");
                    var lres = fmt.indexOf(".") - ri, rres = fmt.length - o.length - lres;
                    return hashq(fmt.substr(0, lres) + o + fmt.substr(fmt.length - rres));
                }
                if (r = fmt.match(/^00,000\.([#0]*0)$/)) {
                    ri = dec(val, r[1].length);
                    return val < 0 ? "-" + write_num_flt(type, fmt, -val) : commaify(flr(val)).replace(/^\d,\d{3}$/, "0$&").replace(/^\d*$/, function($$) {
                        return "00," + ($$.length < 3 ? pad0(0, 3 - $$.length) : "") + $$;
                    }) + "." + pad0(ri, r[1].length);
                }
                switch (fmt) {
                  case "###,##0.00":
                    return write_num_flt(type, "#,##0.00", val);

                  case "###,###":
                  case "##,###":
                  case "#,###":
                    var x = commaify(pad0r(aval, 0));
                    return x !== "0" ? sign + x : "";

                  case "###,###.00":
                    return write_num_flt(type, "###,##0.00", val).replace(/^0\./, ".");

                  case "#,###.00":
                    return write_num_flt(type, "#,##0.00", val).replace(/^0\./, ".");

                  default:                }
                throw new Error("unsupported format |" + fmt + "|");
            }
            function write_num_cm2(type, fmt, val) {
                var idx = fmt.length - 1;
                while (fmt.charCodeAt(idx - 1) === 44) --idx;
                return write_num(type, fmt.substr(0, idx), val / Math.pow(10, 3 * (fmt.length - idx)));
            }
            function write_num_pct2(type, fmt, val) {
                var sfmt = fmt.replace(pct1, ""), mul = fmt.length - sfmt.length;
                return write_num(type, sfmt, val * Math.pow(10, 2 * mul)) + fill("%", mul);
            }
            function write_num_exp2(fmt, val) {
                var o;
                var idx = fmt.indexOf("E") - fmt.indexOf(".") - 1;
                if (fmt.match(/^#+0.0E\+0$/)) {
                    if (val == 0) return "0.0E+0"; else if (val < 0) return "-" + write_num_exp2(fmt, -val);
                    var period = fmt.indexOf(".");
                    if (period === -1) period = fmt.indexOf("E");
                    var ee = Math.floor(Math.log(val) * Math.LOG10E) % period;
                    if (ee < 0) ee += period;
                    o = (val / Math.pow(10, ee)).toPrecision(idx + 1 + (period + ee) % period);
                    if (!o.match(/[Ee]/)) {
                        var fakee = Math.floor(Math.log(val) * Math.LOG10E);
                        if (o.indexOf(".") === -1) o = o.charAt(0) + "." + o.substr(1) + "E+" + (fakee - o.length + ee); else o += "E+" + (fakee - ee);
                        o = o.replace(/\+-/, "-");
                    }
                    o = o.replace(/^([+-]?)(\d*)\.(\d*)[Ee]/, function($$, $1, $2, $3) {
                        return $1 + $2 + $3.substr(0, (period + ee) % period) + "." + $3.substr(ee) + "E";
                    });
                } else o = val.toExponential(idx);
                if (fmt.match(/E\+00$/) && o.match(/e[+-]\d$/)) o = o.substr(0, o.length - 1) + "0" + o.charAt(o.length - 1);
                if (fmt.match(/E\-/) && o.match(/e\+/)) o = o.replace(/e\+/, "e");
                return o.replace("e", "E");
            }
            function write_num_int(type, fmt, val) {
                if (type.charCodeAt(0) === 40 && !fmt.match(closeparen)) {
                    var ffmt = fmt.replace(/\( */, "").replace(/ \)/, "").replace(/\)/, "");
                    if (val >= 0) return write_num_int("n", ffmt, val);
                    return "(" + write_num_int("n", ffmt, -val) + ")";
                }
                if (fmt.charCodeAt(fmt.length - 1) === 44) return write_num_cm2(type, fmt, val);
                if (fmt.indexOf("%") !== -1) return write_num_pct2(type, fmt, val);
                if (fmt.indexOf("E") !== -1) return write_num_exp2(fmt, val);
                if (fmt.charCodeAt(0) === 36) return "$" + write_num_int(type, fmt.substr(fmt.charAt(1) == " " ? 2 : 1), val);
                var o;
                var r, ri, ff, aval = Math.abs(val), sign = val < 0 ? "-" : "";
                if (fmt.match(/^00+$/)) return sign + pad0(aval, fmt.length);
                if (fmt.match(/^[#?]+$/)) {
                    o = "" + val;
                    if (val === 0) o = "";
                    return o.length > fmt.length ? o : hashq(fmt.substr(0, fmt.length - o.length)) + o;
                }
                if (r = fmt.match(frac1)) return write_num_f2(r, aval, sign);
                if (fmt.match(/^#+0+$/)) return sign + pad0(aval, fmt.length - fmt.indexOf("0"));
                if (r = fmt.match(dec1)) {
                    o = ("" + val).replace(/^([^\.]+)$/, "$1." + hashq(r[1])).replace(/\.$/, "." + hashq(r[1]));
                    o = o.replace(/\.(\d*)$/, function($$, $1) {
                        return "." + $1 + fill("0", hashq(r[1]).length - $1.length);
                    });
                    return fmt.indexOf("0.") !== -1 ? o : o.replace(/^0\./, ".");
                }
                fmt = fmt.replace(/^#+([0.])/, "$1");
                if (r = fmt.match(/^(0*)\.(#*)$/)) {
                    return sign + ("" + aval).replace(/\.(\d*[1-9])0*$/, ".$1").replace(/^(-?\d*)$/, "$1.").replace(/^0\./, r[1].length ? "0." : ".");
                }
                if (r = fmt.match(/^#{1,3},##0(\.?)$/)) return sign + commaify("" + aval);
                if (r = fmt.match(/^#,##0\.([#0]*0)$/)) {
                    return val < 0 ? "-" + write_num_int(type, fmt, -val) : commaify("" + val) + "." + fill("0", r[1].length);
                }
                if (r = fmt.match(/^#,#*,#0/)) return write_num_int(type, fmt.replace(/^#,#*,/, ""), val);
                if (r = fmt.match(/^([0#]+)(\\?-([0#]+))+$/)) {
                    o = _strrev(write_num_int(type, fmt.replace(/[\\-]/g, ""), val));
                    ri = 0;
                    return _strrev(_strrev(fmt.replace(/\\/g, "")).replace(/[0#]/g, function(x) {
                        return ri < o.length ? o.charAt(ri++) : x === "0" ? "0" : "";
                    }));
                }
                if (fmt.match(phone)) {
                    o = write_num_int(type, "##########", val);
                    return "(" + o.substr(0, 3) + ") " + o.substr(3, 3) + "-" + o.substr(6);
                }
                var oa = "";
                if (r = fmt.match(/^([#0?]+)( ?)\/( ?)([#0?]+)/)) {
                    ri = Math.min(r[4].length, 7);
                    ff = frac(aval, Math.pow(10, ri) - 1, false);
                    o = "" + sign;
                    oa = write_num("n", r[1], ff[1]);
                    if (oa.charAt(oa.length - 1) == " ") oa = oa.substr(0, oa.length - 1) + "0";
                    o += oa + r[2] + "/" + r[3];
                    oa = rpad_(ff[2], ri);
                    if (oa.length < r[4].length) oa = hashq(r[4].substr(r[4].length - oa.length)) + oa;
                    o += oa;
                    return o;
                }
                if (r = fmt.match(/^# ([#0?]+)( ?)\/( ?)([#0?]+)/)) {
                    ri = Math.min(Math.max(r[1].length, r[4].length), 7);
                    ff = frac(aval, Math.pow(10, ri) - 1, true);
                    return sign + (ff[0] || (ff[1] ? "" : "0")) + " " + (ff[1] ? pad_(ff[1], ri) + r[2] + "/" + r[3] + rpad_(ff[2], ri) : fill(" ", 2 * ri + 1 + r[2].length + r[3].length));
                }
                if (r = fmt.match(/^[#0?]+$/)) {
                    o = "" + val;
                    if (fmt.length <= o.length) return o;
                    return hashq(fmt.substr(0, fmt.length - o.length)) + o;
                }
                if (r = fmt.match(/^([#0]+)\.([#0]+)$/)) {
                    o = "" + val.toFixed(Math.min(r[2].length, 10)).replace(/([^0])0+$/, "$1");
                    ri = o.indexOf(".");
                    var lres = fmt.indexOf(".") - ri, rres = fmt.length - o.length - lres;
                    return hashq(fmt.substr(0, lres) + o + fmt.substr(fmt.length - rres));
                }
                if (r = fmt.match(/^00,000\.([#0]*0)$/)) {
                    return val < 0 ? "-" + write_num_int(type, fmt, -val) : commaify("" + val).replace(/^\d,\d{3}$/, "0$&").replace(/^\d*$/, function($$) {
                        return "00," + ($$.length < 3 ? pad0(0, 3 - $$.length) : "") + $$;
                    }) + "." + pad0(0, r[1].length);
                }
                switch (fmt) {
                  case "###,###":
                  case "##,###":
                  case "#,###":
                    var x = commaify("" + aval);
                    return x !== "0" ? sign + x : "";

                  default:
                    if (fmt.match(/\.[0#?]*$/)) return write_num_int(type, fmt.slice(0, fmt.lastIndexOf(".")), val) + hashq(fmt.slice(fmt.lastIndexOf(".")));
                }
                throw new Error("unsupported format |" + fmt + "|");
            }
            return function write_num(type, fmt, val) {
                return (val | 0) === val ? write_num_int(type, fmt, val) : write_num_flt(type, fmt, val);
            };
        }();
        function split_fmt(fmt) {
            var out = [];
            var in_str = false;
            for (var i = 0, j = 0; i < fmt.length; ++i) switch (fmt.charCodeAt(i)) {
              case 34:
                in_str = !in_str;
                break;

              case 95:
              case 42:
              case 92:
                ++i;
                break;

              case 59:
                out[out.length] = fmt.substr(j, i - j);
                j = i + 1;
            }
            out[out.length] = fmt.substr(j);
            if (in_str === true) throw new Error("Format |" + fmt + "| unterminated string ");
            return out;
        }
        SSF._split = split_fmt;
        var abstime = /\[[HhMmSs]*\]/;
        function fmt_is_date(fmt) {
            var i = 0, c = "", o = "";
            while (i < fmt.length) {
                switch (c = fmt.charAt(i)) {
                  case "G":
                    if (isgeneral(fmt, i)) i += 6;
                    i++;
                    break;

                  case '"':
                    for (;fmt.charCodeAt(++i) !== 34 && i < fmt.length; ) ++i;
                    ++i;
                    break;

                  case "\\":
                    i += 2;
                    break;

                  case "_":
                    i += 2;
                    break;

                  case "@":
                    ++i;
                    break;

                  case "B":
                  case "b":
                    if (fmt.charAt(i + 1) === "1" || fmt.charAt(i + 1) === "2") return true;

                  case "M":
                  case "D":
                  case "Y":
                  case "H":
                  case "S":
                  case "E":
                  case "m":
                  case "d":
                  case "y":
                  case "h":
                  case "s":
                  case "e":
                  case "g":
                    return true;

                  case "A":
                  case "a":
                    if (fmt.substr(i, 3).toUpperCase() === "A/P") return true;
                    if (fmt.substr(i, 5).toUpperCase() === "AM/PM") return true;
                    ++i;
                    break;

                  case "[":
                    o = c;
                    while (fmt.charAt(i++) !== "]" && i < fmt.length) o += fmt.charAt(i);
                    if (o.match(abstime)) return true;
                    break;

                  case ".":
                  case "0":
                  case "#":
                    while (i < fmt.length && ("0#?.,E+-%".indexOf(c = fmt.charAt(++i)) > -1 || c == "\\" && fmt.charAt(i + 1) == "-" && "0#".indexOf(fmt.charAt(i + 2)) > -1)) {}
                    break;

                  case "?":
                    while (fmt.charAt(++i) === c) {}
                    break;

                  case "*":
                    ++i;
                    if (fmt.charAt(i) == " " || fmt.charAt(i) == "*") ++i;
                    break;

                  case "(":
                  case ")":
                    ++i;
                    break;

                  case "1":
                  case "2":
                  case "3":
                  case "4":
                  case "5":
                  case "6":
                  case "7":
                  case "8":
                  case "9":
                    while (i < fmt.length && "0123456789".indexOf(fmt.charAt(++i)) > -1) {}
                    break;

                  case " ":
                    ++i;
                    break;

                  default:
                    ++i;
                    break;
                }
            }
            return false;
        }
        SSF.is_date = fmt_is_date;
        function eval_fmt(fmt, v, opts, flen) {
            var out = [], o = "", i = 0, c = "", lst = "t", dt, j, cc;
            var hr = "H";
            while (i < fmt.length) {
                switch (c = fmt.charAt(i)) {
                  case "G":
                    if (!isgeneral(fmt, i)) throw new Error("unrecognized character " + c + " in " + fmt);
                    out[out.length] = {
                        "t": "G",
                        "v": "General"
                    };
                    i += 7;
                    break;

                  case '"':
                    for (o = ""; (cc = fmt.charCodeAt(++i)) !== 34 && i < fmt.length; ) o += String.fromCharCode(cc);
                    out[out.length] = {
                        "t": "t",
                        "v": o
                    };
                    ++i;
                    break;

                  case "\\":
                    var w = fmt.charAt(++i), t = w === "(" || w === ")" ? w : "t";
                    out[out.length] = {
                        "t": t,
                        "v": w
                    };
                    ++i;
                    break;

                  case "_":
                    out[out.length] = {
                        "t": "t",
                        "v": " "
                    };
                    i += 2;
                    break;

                  case "@":
                    out[out.length] = {
                        "t": "T",
                        "v": v
                    };
                    ++i;
                    break;

                  case "B":
                  case "b":
                    if (fmt.charAt(i + 1) === "1" || fmt.charAt(i + 1) === "2") {
                        if (dt == null) {
                            dt = parse_date_code(v, opts, fmt.charAt(i + 1) === "2");
                            if (dt == null) return "";
                        }
                        out[out.length] = {
                            "t": "X",
                            "v": fmt.substr(i, 2)
                        };
                        lst = c;
                        i += 2;
                        break;
                    }

                  case "M":
                  case "D":
                  case "Y":
                  case "H":
                  case "S":
                  case "E":
                    c = c.toLowerCase();

                  case "m":
                  case "d":
                  case "y":
                  case "h":
                  case "s":
                  case "e":
                  case "g":
                    if (v < 0) return "";
                    if (dt == null) {
                        dt = parse_date_code(v, opts);
                        if (dt == null) return "";
                    }
                    o = c;
                    while (++i < fmt.length && fmt.charAt(i).toLowerCase() === c) o += c;
                    if (c === "m" && lst.toLowerCase() === "h") c = "M";
                    if (c === "h") c = hr;
                    out[out.length] = {
                        "t": c,
                        "v": o
                    };
                    lst = c;
                    break;

                  case "A":
                  case "a":
                    var q = {
                        "t": c,
                        "v": c
                    };
                    if (dt == null) dt = parse_date_code(v, opts);
                    if (fmt.substr(i, 3).toUpperCase() === "A/P") {
                        if (dt != null) q.v = dt.H >= 12 ? "P" : "A";
                        q.t = "T";
                        hr = "h";
                        i += 3;
                    } else if (fmt.substr(i, 5).toUpperCase() === "AM/PM") {
                        if (dt != null) q.v = dt.H >= 12 ? "PM" : "AM";
                        q.t = "T";
                        i += 5;
                        hr = "h";
                    } else {
                        q.t = "t";
                        ++i;
                    }
                    if (dt == null && q.t === "T") return "";
                    out[out.length] = q;
                    lst = c;
                    break;

                  case "[":
                    o = c;
                    while (fmt.charAt(i++) !== "]" && i < fmt.length) o += fmt.charAt(i);
                    if (o.slice(-1) !== "]") throw 'unterminated "[" block: |' + o + "|";
                    if (o.match(abstime)) {
                        if (dt == null) {
                            dt = parse_date_code(v, opts);
                            if (dt == null) return "";
                        }
                        out[out.length] = {
                            "t": "Z",
                            "v": o.toLowerCase()
                        };
                        lst = o.charAt(1);
                    } else if (o.indexOf("$") > -1) {
                        o = (o.match(/\$([^-\[\]]*)/) || [])[1] || "$";
                        if (!fmt_is_date(fmt)) out[out.length] = {
                            "t": "t",
                            "v": o
                        };
                    }
                    break;

                  case ".":
                    if (dt != null) {
                        o = c;
                        while (++i < fmt.length && (c = fmt.charAt(i)) === "0") o += c;
                        out[out.length] = {
                            "t": "s",
                            "v": o
                        };
                        break;
                    }

                  case "0":
                  case "#":
                    o = c;
                    while (++i < fmt.length && "0#?.,E+-%".indexOf(c = fmt.charAt(i)) > -1 || c == "\\" && fmt.charAt(i + 1) == "-" && i < fmt.length - 2 && "0#".indexOf(fmt.charAt(i + 2)) > -1) o += c;
                    out[out.length] = {
                        "t": "n",
                        "v": o
                    };
                    break;

                  case "?":
                    o = c;
                    while (fmt.charAt(++i) === c) o += c;
                    out[out.length] = {
                        "t": c,
                        "v": o
                    };
                    lst = c;
                    break;

                  case "*":
                    ++i;
                    if (fmt.charAt(i) == " " || fmt.charAt(i) == "*") ++i;
                    break;

                  case "(":
                  case ")":
                    out[out.length] = {
                        "t": flen === 1 ? "t" : c,
                        "v": c
                    };
                    ++i;
                    break;

                  case "1":
                  case "2":
                  case "3":
                  case "4":
                  case "5":
                  case "6":
                  case "7":
                  case "8":
                  case "9":
                    o = c;
                    while (i < fmt.length && "0123456789".indexOf(fmt.charAt(++i)) > -1) o += fmt.charAt(i);
                    out[out.length] = {
                        "t": "D",
                        "v": o
                    };
                    break;

                  case " ":
                    out[out.length] = {
                        "t": c,
                        "v": c
                    };
                    ++i;
                    break;

                  default:
                    if (",$-+/():!^&'~{}<>=\u20acacfijklopqrtuvwxzP".indexOf(c) === -1) throw new Error("unrecognized character " + c + " in " + fmt);
                    out[out.length] = {
                        "t": "t",
                        "v": c
                    };
                    ++i;
                    break;
                }
            }
            var bt = 0, ss0 = 0, ssm;
            for (i = out.length - 1, lst = "t"; i >= 0; --i) {
                switch (out[i].t) {
                  case "h":
                  case "H":
                    out[i].t = hr;
                    lst = "h";
                    if (bt < 1) bt = 1;
                    break;

                  case "s":
                    if (ssm = out[i].v.match(/\.0+$/)) ss0 = Math.max(ss0, ssm[0].length - 1);
                    if (bt < 3) bt = 3;

                  case "d":
                  case "y":
                  case "M":
                  case "e":
                    lst = out[i].t;
                    break;

                  case "m":
                    if (lst === "s") {
                        out[i].t = "M";
                        if (bt < 2) bt = 2;
                    }
                    break;

                  case "X":
                    break;

                  case "Z":
                    if (bt < 1 && out[i].v.match(/[Hh]/)) bt = 1;
                    if (bt < 2 && out[i].v.match(/[Mm]/)) bt = 2;
                    if (bt < 3 && out[i].v.match(/[Ss]/)) bt = 3;
                }
            }
            switch (bt) {
              case 0:
                break;

              case 1:
                if (dt.u >= .5) {
                    dt.u = 0;
                    ++dt.S;
                }
                if (dt.S >= 60) {
                    dt.S = 0;
                    ++dt.M;
                }
                if (dt.M >= 60) {
                    dt.M = 0;
                    ++dt.H;
                }
                break;

              case 2:
                if (dt.u >= .5) {
                    dt.u = 0;
                    ++dt.S;
                }
                if (dt.S >= 60) {
                    dt.S = 0;
                    ++dt.M;
                }
                break;
            }
            var nstr = "", jj;
            for (i = 0; i < out.length; ++i) {
                switch (out[i].t) {
                  case "t":
                  case "T":
                  case " ":
                  case "D":
                    break;

                  case "X":
                    out[i].v = "";
                    out[i].t = ";";
                    break;

                  case "d":
                  case "m":
                  case "y":
                  case "h":
                  case "H":
                  case "M":
                  case "s":
                  case "e":
                  case "b":
                  case "Z":
                    out[i].v = write_date(out[i].t.charCodeAt(0), out[i].v, dt, ss0);
                    out[i].t = "t";
                    break;

                  case "n":
                  case "(":
                  case "?":
                    jj = i + 1;
                    while (out[jj] != null && ((c = out[jj].t) === "?" || c === "D" || (c === " " || c === "t") && out[jj + 1] != null && (out[jj + 1].t === "?" || out[jj + 1].t === "t" && out[jj + 1].v === "/") || out[i].t === "(" && (c === " " || c === "n" || c === ")") || c === "t" && (out[jj].v === "/" || out[jj].v === " " && out[jj + 1] != null && out[jj + 1].t == "?"))) {
                        out[i].v += out[jj].v;
                        out[jj] = {
                            "v": "",
                            "t": ";"
                        };
                        ++jj;
                    }
                    nstr += out[i].v;
                    i = jj - 1;
                    break;

                  case "G":
                    out[i].t = "t";
                    out[i].v = general_fmt(v, opts);
                    break;
                }
            }
            var vv = "", myv, ostr;
            if (nstr.length > 0) {
                if (nstr.charCodeAt(0) == 40) {
                    myv = v < 0 && nstr.charCodeAt(0) === 45 ? -v : v;
                    ostr = write_num("(", nstr, myv);
                } else {
                    myv = v < 0 && flen > 1 ? -v : v;
                    ostr = write_num("n", nstr, myv);
                    if (myv < 0 && out[0] && out[0].t == "t") {
                        ostr = ostr.substr(1);
                        out[0].v = "-" + out[0].v;
                    }
                }
                jj = ostr.length - 1;
                var decpt = out.length;
                for (i = 0; i < out.length; ++i) if (out[i] != null && out[i].t != "t" && out[i].v.indexOf(".") > -1) {
                    decpt = i;
                    break;
                }
                var lasti = out.length;
                if (decpt === out.length && ostr.indexOf("E") === -1) {
                    for (i = out.length - 1; i >= 0; --i) {
                        if (out[i] == null || "n?(".indexOf(out[i].t) === -1) continue;
                        if (jj >= out[i].v.length - 1) {
                            jj -= out[i].v.length;
                            out[i].v = ostr.substr(jj + 1, out[i].v.length);
                        } else if (jj < 0) out[i].v = ""; else {
                            out[i].v = ostr.substr(0, jj + 1);
                            jj = -1;
                        }
                        out[i].t = "t";
                        lasti = i;
                    }
                    if (jj >= 0 && lasti < out.length) out[lasti].v = ostr.substr(0, jj + 1) + out[lasti].v;
                } else if (decpt !== out.length && ostr.indexOf("E") === -1) {
                    jj = ostr.indexOf(".") - 1;
                    for (i = decpt; i >= 0; --i) {
                        if (out[i] == null || "n?(".indexOf(out[i].t) === -1) continue;
                        j = out[i].v.indexOf(".") > -1 && i === decpt ? out[i].v.indexOf(".") - 1 : out[i].v.length - 1;
                        vv = out[i].v.substr(j + 1);
                        for (;j >= 0; --j) {
                            if (jj >= 0 && (out[i].v.charAt(j) === "0" || out[i].v.charAt(j) === "#")) vv = ostr.charAt(jj--) + vv;
                        }
                        out[i].v = vv;
                        out[i].t = "t";
                        lasti = i;
                    }
                    if (jj >= 0 && lasti < out.length) out[lasti].v = ostr.substr(0, jj + 1) + out[lasti].v;
                    jj = ostr.indexOf(".") + 1;
                    for (i = decpt; i < out.length; ++i) {
                        if (out[i] == null || "n?(".indexOf(out[i].t) === -1 && i !== decpt) continue;
                        j = out[i].v.indexOf(".") > -1 && i === decpt ? out[i].v.indexOf(".") + 1 : 0;
                        vv = out[i].v.substr(0, j);
                        for (;j < out[i].v.length; ++j) {
                            if (jj < ostr.length) vv += ostr.charAt(jj++);
                        }
                        out[i].v = vv;
                        out[i].t = "t";
                        lasti = i;
                    }
                }
            }
            for (i = 0; i < out.length; ++i) if (out[i] != null && "n(?".indexOf(out[i].t) > -1) {
                myv = flen > 1 && v < 0 && i > 0 && out[i - 1].v === "-" ? -v : v;
                out[i].v = write_num(out[i].t, out[i].v, myv);
                out[i].t = "t";
            }
            var retval = "";
            for (i = 0; i !== out.length; ++i) if (out[i] != null) retval += out[i].v;
            return retval;
        }
        SSF._eval = eval_fmt;
        var cfregex = /\[[=<>]/;
        var cfregex2 = /\[(=|>[=]?|<[>=]?)(-?\d+(?:\.\d*)?)\]/;
        function chkcond(v, rr) {
            if (rr == null) return false;
            var thresh = parseFloat(rr[2]);
            switch (rr[1]) {
              case "=":
                if (v == thresh) return true;
                break;

              case ">":
                if (v > thresh) return true;
                break;

              case "<":
                if (v < thresh) return true;
                break;

              case "<>":
                if (v != thresh) return true;
                break;

              case ">=":
                if (v >= thresh) return true;
                break;

              case "<=":
                if (v <= thresh) return true;
                break;
            }
            return false;
        }
        function choose_fmt(f, v) {
            var fmt = split_fmt(f);
            var l = fmt.length, lat = fmt[l - 1].indexOf("@");
            if (l < 4 && lat > -1) --l;
            if (fmt.length > 4) throw new Error("cannot find right format for |" + fmt.join("|") + "|");
            if (typeof v !== "number") return [ 4, fmt.length === 4 || lat > -1 ? fmt[fmt.length - 1] : "@" ];
            switch (fmt.length) {
              case 1:
                fmt = lat > -1 ? [ "General", "General", "General", fmt[0] ] : [ fmt[0], fmt[0], fmt[0], "@" ];
                break;

              case 2:
                fmt = lat > -1 ? [ fmt[0], fmt[0], fmt[0], fmt[1] ] : [ fmt[0], fmt[1], fmt[0], "@" ];
                break;

              case 3:
                fmt = lat > -1 ? [ fmt[0], fmt[1], fmt[0], fmt[2] ] : [ fmt[0], fmt[1], fmt[2], "@" ];
                break;

              case 4:
                break;
            }
            var ff = v > 0 ? fmt[0] : v < 0 ? fmt[1] : fmt[2];
            if (fmt[0].indexOf("[") === -1 && fmt[1].indexOf("[") === -1) return [ l, ff ];
            if (fmt[0].match(cfregex) != null || fmt[1].match(cfregex) != null) {
                var m1 = fmt[0].match(cfregex2);
                var m2 = fmt[1].match(cfregex2);
                return chkcond(v, m1) ? [ l, fmt[0] ] : chkcond(v, m2) ? [ l, fmt[1] ] : [ l, fmt[m1 != null && m2 != null ? 2 : 1] ];
            }
            return [ l, ff ];
        }
        function format(fmt, v, o) {
            if (o == null) o = {};
            var sfmt = "";
            switch (typeof fmt) {
              case "string":
                if (fmt == "m/d/yy" && o.dateNF) sfmt = o.dateNF; else sfmt = fmt;
                break;

              case "number":
                if (fmt == 14 && o.dateNF) sfmt = o.dateNF; else sfmt = (o.table != null ? o.table : table_fmt)[fmt];
                break;
            }
            if (isgeneral(sfmt, 0)) return general_fmt(v, o);
            if (v instanceof Date) v = datenum_local(v, o.date1904);
            var f = choose_fmt(sfmt, v);
            if (isgeneral(f[1])) return general_fmt(v, o);
            if (v === true) v = "TRUE"; else if (v === false) v = "FALSE"; else if (v === "" || v == null) return "";
            return eval_fmt(f[1], v, o, f[0]);
        }
        function load_entry(fmt, idx) {
            if (typeof idx != "number") {
                idx = +idx || -1;
                for (var i = 0; i < 392; ++i) {
                    if (table_fmt[i] == undefined) {
                        if (idx < 0) idx = i;
                        continue;
                    }
                    if (table_fmt[i] == fmt) {
                        idx = i;
                        break;
                    }
                }
                if (idx < 0) idx = 391;
            }
            table_fmt[idx] = fmt;
            return idx;
        }
        SSF.load = load_entry;
        SSF._table = table_fmt;
        SSF.get_table = function get_table() {
            return table_fmt;
        };
        SSF.load_table = function load_table(tbl) {
            for (var i = 0; i != 392; ++i) if (tbl[i] !== undefined) load_entry(tbl[i], i);
        };
        SSF.init_table = init_table;
        SSF.format = format;
    };
    make_ssf(SSF);
    var XLMLFormatMap = {
        "General Number": "General",
        "General Date": SSF._table[22],
        "Long Date": "dddd, mmmm dd, yyyy",
        "Medium Date": SSF._table[15],
        "Short Date": SSF._table[14],
        "Long Time": SSF._table[19],
        "Medium Time": SSF._table[18],
        "Short Time": SSF._table[20],
        "Currency": '"$"#,##0.00_);[Red]\\("$"#,##0.00\\)',
        "Fixed": SSF._table[2],
        "Standard": SSF._table[4],
        "Percent": SSF._table[10],
        "Scientific": SSF._table[11],
        "Yes/No": '"Yes";"Yes";"No";@',
        "True/False": '"True";"True";"False";@',
        "On/Off": '"Yes";"Yes";"No";@'
    };
    var SSFImplicit = {
        "5": '"$"#,##0_);\\("$"#,##0\\)',
        "6": '"$"#,##0_);[Red]\\("$"#,##0\\)',
        "7": '"$"#,##0.00_);\\("$"#,##0.00\\)',
        "8": '"$"#,##0.00_);[Red]\\("$"#,##0.00\\)',
        "23": "General",
        "24": "General",
        "25": "General",
        "26": "General",
        "27": "m/d/yy",
        "28": "m/d/yy",
        "29": "m/d/yy",
        "30": "m/d/yy",
        "31": "m/d/yy",
        "32": "h:mm:ss",
        "33": "h:mm:ss",
        "34": "h:mm:ss",
        "35": "h:mm:ss",
        "36": "m/d/yy",
        "41": '_(* #,##0_);_(* (#,##0);_(* "-"_);_(@_)',
        "42": '_("$"* #,##0_);_("$"* (#,##0);_("$"* "-"_);_(@_)',
        "43": '_(* #,##0.00_);_(* (#,##0.00);_(* "-"??_);_(@_)',
        "44": '_("$"* #,##0.00_);_("$"* (#,##0.00);_("$"* "-"??_);_(@_)',
        "50": "m/d/yy",
        "51": "m/d/yy",
        "52": "m/d/yy",
        "53": "m/d/yy",
        "54": "m/d/yy",
        "55": "m/d/yy",
        "56": "m/d/yy",
        "57": "m/d/yy",
        "58": "m/d/yy",
        "59": "0",
        "60": "0.00",
        "61": "#,##0",
        "62": "#,##0.00",
        "63": '"$"#,##0_);\\("$"#,##0\\)',
        "64": '"$"#,##0_);[Red]\\("$"#,##0\\)',
        "65": '"$"#,##0.00_);\\("$"#,##0.00\\)',
        "66": '"$"#,##0.00_);[Red]\\("$"#,##0.00\\)',
        "67": "0%",
        "68": "0.00%",
        "69": "# ?/?",
        "70": "# ??/??",
        "71": "m/d/yy",
        "72": "m/d/yy",
        "73": "d-mmm-yy",
        "74": "d-mmm",
        "75": "mmm-yy",
        "76": "h:mm",
        "77": "h:mm:ss",
        "78": "m/d/yy h:mm",
        "79": "mm:ss",
        "80": "[h]:mm:ss",
        "81": "mmss.0"
    };
    var dateNFregex = /[dD]+|[mM]+|[yYeE]+|[Hh]+|[Ss]+/g;
    function dateNF_regex(dateNF) {
        var fmt = typeof dateNF == "number" ? SSF._table[dateNF] : dateNF;
        fmt = fmt.replace(dateNFregex, "(\\d+)");
        return new RegExp("^" + fmt + "$");
    }
    function dateNF_fix(str, dateNF, match) {
        var Y = -1, m = -1, d = -1, H = -1, M = -1, S = -1;
        (dateNF.match(dateNFregex) || []).forEach(function(n, i) {
            var v = parseInt(match[i + 1], 10);
            switch (n.toLowerCase().charAt(0)) {
              case "y":
                Y = v;
                break;

              case "d":
                d = v;
                break;

              case "h":
                H = v;
                break;

              case "s":
                S = v;
                break;

              case "m":
                if (H >= 0) M = v; else m = v;
                break;
            }
        });
        if (S >= 0 && M == -1 && m >= 0) {
            M = m;
            m = -1;
        }
        var datestr = ("" + (Y >= 0 ? Y : new Date().getFullYear())).slice(-4) + "-" + ("00" + (m >= 1 ? m : 1)).slice(-2) + "-" + ("00" + (d >= 1 ? d : 1)).slice(-2);
        if (datestr.length == 7) datestr = "0" + datestr;
        if (datestr.length == 8) datestr = "20" + datestr;
        var timestr = ("00" + (H >= 0 ? H : 0)).slice(-2) + ":" + ("00" + (M >= 0 ? M : 0)).slice(-2) + ":" + ("00" + (S >= 0 ? S : 0)).slice(-2);
        if (H == -1 && M == -1 && S == -1) return datestr;
        if (Y == -1 && m == -1 && d == -1) return timestr;
        return datestr + "T" + timestr;
    }
    var DO_NOT_EXPORT_CFB = true;
    var CRC32;
    (function(factory) {
        factory(CRC32 = {});
    })(function(CRC32) {
        CRC32.version = "1.2.0";
        function signed_crc_table() {
            var c = 0, table = new Array(256);
            for (var n = 0; n != 256; ++n) {
                c = n;
                c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
                c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
                c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
                c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
                c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
                c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
                c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
                c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
                table[n] = c;
            }
            return typeof Int32Array !== "undefined" ? new Int32Array(table) : table;
        }
        var T = signed_crc_table();
        function crc32_bstr(bstr, seed) {
            var C = seed ^ -1, L = bstr.length - 1;
            for (var i = 0; i < L; ) {
                C = C >>> 8 ^ T[(C ^ bstr.charCodeAt(i++)) & 255];
                C = C >>> 8 ^ T[(C ^ bstr.charCodeAt(i++)) & 255];
            }
            if (i === L) C = C >>> 8 ^ T[(C ^ bstr.charCodeAt(i)) & 255];
            return C ^ -1;
        }
        function crc32_buf(buf, seed) {
            if (buf.length > 1e4) return crc32_buf_8(buf, seed);
            var C = seed ^ -1, L = buf.length - 3;
            for (var i = 0; i < L; ) {
                C = C >>> 8 ^ T[(C ^ buf[i++]) & 255];
                C = C >>> 8 ^ T[(C ^ buf[i++]) & 255];
                C = C >>> 8 ^ T[(C ^ buf[i++]) & 255];
                C = C >>> 8 ^ T[(C ^ buf[i++]) & 255];
            }
            while (i < L + 3) C = C >>> 8 ^ T[(C ^ buf[i++]) & 255];
            return C ^ -1;
        }
        function crc32_buf_8(buf, seed) {
            var C = seed ^ -1, L = buf.length - 7;
            for (var i = 0; i < L; ) {
                C = C >>> 8 ^ T[(C ^ buf[i++]) & 255];
                C = C >>> 8 ^ T[(C ^ buf[i++]) & 255];
                C = C >>> 8 ^ T[(C ^ buf[i++]) & 255];
                C = C >>> 8 ^ T[(C ^ buf[i++]) & 255];
                C = C >>> 8 ^ T[(C ^ buf[i++]) & 255];
                C = C >>> 8 ^ T[(C ^ buf[i++]) & 255];
                C = C >>> 8 ^ T[(C ^ buf[i++]) & 255];
                C = C >>> 8 ^ T[(C ^ buf[i++]) & 255];
            }
            while (i < L + 7) C = C >>> 8 ^ T[(C ^ buf[i++]) & 255];
            return C ^ -1;
        }
        function crc32_str(str, seed) {
            var C = seed ^ -1;
            for (var i = 0, L = str.length, c, d; i < L; ) {
                c = str.charCodeAt(i++);
                if (c < 128) {
                    C = C >>> 8 ^ T[(C ^ c) & 255];
                } else if (c < 2048) {
                    C = C >>> 8 ^ T[(C ^ (192 | c >> 6 & 31)) & 255];
                    C = C >>> 8 ^ T[(C ^ (128 | c & 63)) & 255];
                } else if (c >= 55296 && c < 57344) {
                    c = (c & 1023) + 64;
                    d = str.charCodeAt(i++) & 1023;
                    C = C >>> 8 ^ T[(C ^ (240 | c >> 8 & 7)) & 255];
                    C = C >>> 8 ^ T[(C ^ (128 | c >> 2 & 63)) & 255];
                    C = C >>> 8 ^ T[(C ^ (128 | d >> 6 & 15 | (c & 3) << 4)) & 255];
                    C = C >>> 8 ^ T[(C ^ (128 | d & 63)) & 255];
                } else {
                    C = C >>> 8 ^ T[(C ^ (224 | c >> 12 & 15)) & 255];
                    C = C >>> 8 ^ T[(C ^ (128 | c >> 6 & 63)) & 255];
                    C = C >>> 8 ^ T[(C ^ (128 | c & 63)) & 255];
                }
            }
            return C ^ -1;
        }
        CRC32.table = T;
        CRC32.bstr = crc32_bstr;
        CRC32.buf = crc32_buf;
        CRC32.str = crc32_str;
    });
    var CFB = function _CFB() {
        var exports = {};
        exports.version = "1.1.0";
        function namecmp(l, r) {
            var L = l.split("/"), R = r.split("/");
            for (var i = 0, c = 0, Z = Math.min(L.length, R.length); i < Z; ++i) {
                if (c = L[i].length - R[i].length) return c;
                if (L[i] != R[i]) return L[i] < R[i] ? -1 : 1;
            }
            return L.length - R.length;
        }
        function dirname(p) {
            if (p.charAt(p.length - 1) == "/") return p.slice(0, -1).indexOf("/") === -1 ? p : dirname(p.slice(0, -1));
            var c = p.lastIndexOf("/");
            return c === -1 ? p : p.slice(0, c + 1);
        }
        function filename(p) {
            if (p.charAt(p.length - 1) == "/") return filename(p.slice(0, -1));
            var c = p.lastIndexOf("/");
            return c === -1 ? p : p.slice(c + 1);
        }
        function write_dos_date(buf, date) {
            if (typeof date === "string") date = new Date(date);
            var hms = date.getHours();
            hms = hms << 6 | date.getMinutes();
            hms = hms << 5 | date.getSeconds() >>> 1;
            buf.write_shift(2, hms);
            var ymd = date.getFullYear() - 1980;
            ymd = ymd << 4 | date.getMonth() + 1;
            ymd = ymd << 5 | date.getDate();
            buf.write_shift(2, ymd);
        }
        function parse_dos_date(buf) {
            var hms = buf.read_shift(2) & 65535;
            var ymd = buf.read_shift(2) & 65535;
            var val = new Date();
            var d = ymd & 31;
            ymd >>>= 5;
            var m = ymd & 15;
            ymd >>>= 4;
            val.setMilliseconds(0);
            val.setFullYear(ymd + 1980);
            val.setMonth(m - 1);
            val.setDate(d);
            var S = hms & 31;
            hms >>>= 5;
            var M = hms & 63;
            hms >>>= 6;
            val.setHours(hms);
            val.setMinutes(M);
            val.setSeconds(S << 1);
            return val;
        }
        function parse_extra_field(blob) {
            prep_blob(blob, 0);
            var o = {};
            var flags = 0;
            while (blob.l <= blob.length - 4) {
                var type = blob.read_shift(2);
                var sz = blob.read_shift(2), tgt = blob.l + sz;
                var p = {};
                switch (type) {
                  case 21589:
                    {
                        flags = blob.read_shift(1);
                        if (flags & 1) p.mtime = blob.read_shift(4);
                        if (sz > 5) {
                            if (flags & 2) p.atime = blob.read_shift(4);
                            if (flags & 4) p.ctime = blob.read_shift(4);
                        }
                        if (p.mtime) p.mt = new Date(p.mtime * 1e3);
                    }
                    break;
                }
                blob.l = tgt;
                o[type] = p;
            }
            return o;
        }
        var fs;
        function get_fs() {
            return fs || (fs = require("fs"));
        }
        function parse(file, options) {
            if (file[0] == 80 && file[1] == 75) return parse_zip(file, options);
            if (file.length < 512) throw new Error("CFB file size " + file.length + " < 512");
            var mver = 3;
            var ssz = 512;
            var nmfs = 0;
            var difat_sec_cnt = 0;
            var dir_start = 0;
            var minifat_start = 0;
            var difat_start = 0;
            var fat_addrs = [];
            var blob = file.slice(0, 512);
            prep_blob(blob, 0);
            var mv = check_get_mver(blob);
            mver = mv[0];
            switch (mver) {
              case 3:
                ssz = 512;
                break;

              case 4:
                ssz = 4096;
                break;

              case 0:
                if (mv[1] == 0) return parse_zip(file, options);

              default:
                throw new Error("Major Version: Expected 3 or 4 saw " + mver);
            }
            if (ssz !== 512) {
                blob = file.slice(0, ssz);
                prep_blob(blob, 28);
            }
            var header = file.slice(0, ssz);
            check_shifts(blob, mver);
            var dir_cnt = blob.read_shift(4, "i");
            if (mver === 3 && dir_cnt !== 0) throw new Error("# Directory Sectors: Expected 0 saw " + dir_cnt);
            blob.l += 4;
            dir_start = blob.read_shift(4, "i");
            blob.l += 4;
            blob.chk("00100000", "Mini Stream Cutoff Size: ");
            minifat_start = blob.read_shift(4, "i");
            nmfs = blob.read_shift(4, "i");
            difat_start = blob.read_shift(4, "i");
            difat_sec_cnt = blob.read_shift(4, "i");
            for (var q = -1, j = 0; j < 109; ++j) {
                q = blob.read_shift(4, "i");
                if (q < 0) break;
                fat_addrs[j] = q;
            }
            var sectors = sectorify(file, ssz);
            sleuth_fat(difat_start, difat_sec_cnt, sectors, ssz, fat_addrs);
            var sector_list = make_sector_list(sectors, dir_start, fat_addrs, ssz);
            sector_list[dir_start].name = "!Directory";
            if (nmfs > 0 && minifat_start !== ENDOFCHAIN) sector_list[minifat_start].name = "!MiniFAT";
            sector_list[fat_addrs[0]].name = "!FAT";
            sector_list.fat_addrs = fat_addrs;
            sector_list.ssz = ssz;
            var files = {}, Paths = [], FileIndex = [], FullPaths = [];
            read_directory(dir_start, sector_list, sectors, Paths, nmfs, files, FileIndex, minifat_start);
            build_full_paths(FileIndex, FullPaths, Paths);
            Paths.shift();
            var o = {
                "FileIndex": FileIndex,
                "FullPaths": FullPaths
            };
            if (options && options.raw) o.raw = {
                "header": header,
                "sectors": sectors
            };
            return o;
        }
        function check_get_mver(blob) {
            if (blob[blob.l] == 80 && blob[blob.l + 1] == 75) return [ 0, 0 ];
            blob.chk(HEADER_SIGNATURE, "Header Signature: ");
            blob.chk(HEADER_CLSID, "CLSID: ");
            var mver = blob.read_shift(2, "u");
            return [ blob.read_shift(2, "u"), mver ];
        }
        function check_shifts(blob, mver) {
            var shift = 9;
            blob.l += 2;
            switch (shift = blob.read_shift(2)) {
              case 9:
                if (mver != 3) throw new Error("Sector Shift: Expected 9 saw " + shift);
                break;

              case 12:
                if (mver != 4) throw new Error("Sector Shift: Expected 12 saw " + shift);
                break;

              default:
                throw new Error("Sector Shift: Expected 9 or 12 saw " + shift);
            }
            blob.chk("0600", "Mini Sector Shift: ");
            blob.chk("000000000000", "Reserved: ");
        }
        function sectorify(file, ssz) {
            var nsectors = Math.ceil(file.length / ssz) - 1;
            var sectors = [];
            for (var i = 1; i < nsectors; ++i) sectors[i - 1] = file.slice(i * ssz, (i + 1) * ssz);
            sectors[nsectors - 1] = file.slice(nsectors * ssz);
            return sectors;
        }
        function build_full_paths(FI, FP, Paths) {
            var i = 0, L = 0, R = 0, C = 0, j = 0, pl = Paths.length;
            var dad = [], q = [];
            for (;i < pl; ++i) {
                dad[i] = q[i] = i;
                FP[i] = Paths[i];
            }
            for (;j < q.length; ++j) {
                i = q[j];
                L = FI[i].L;
                R = FI[i].R;
                C = FI[i].C;
                if (dad[i] === i) {
                    if (L !== -1 && dad[L] !== L) dad[i] = dad[L];
                    if (R !== -1 && dad[R] !== R) dad[i] = dad[R];
                }
                if (C !== -1) dad[C] = i;
                if (L !== -1) {
                    dad[L] = dad[i];
                    if (q.lastIndexOf(L) < j) q.push(L);
                }
                if (R !== -1) {
                    dad[R] = dad[i];
                    if (q.lastIndexOf(R) < j) q.push(R);
                }
            }
            for (i = 1; i < pl; ++i) if (dad[i] === i) {
                if (R !== -1 && dad[R] !== R) dad[i] = dad[R]; else if (L !== -1 && dad[L] !== L) dad[i] = dad[L];
            }
            for (i = 1; i < pl; ++i) {
                if (FI[i].type === 0) continue;
                j = dad[i];
                if (j === 0) FP[i] = FP[0] + "/" + FP[i]; else while (j !== 0 && j !== dad[j]) {
                    FP[i] = FP[j] + "/" + FP[i];
                    j = dad[j];
                }
                dad[i] = 0;
            }
            FP[0] += "/";
            for (i = 1; i < pl; ++i) {
                if (FI[i].type !== 2) FP[i] += "/";
            }
        }
        function get_mfat_entry(entry, payload, mini) {
            var start = entry.start, size = entry.size;
            var o = [];
            var idx = start;
            while (mini && size > 0 && idx >= 0) {
                o.push(payload.slice(idx * MSSZ, idx * MSSZ + MSSZ));
                size -= MSSZ;
                idx = __readInt32LE(mini, idx * 4);
            }
            if (o.length === 0) return new_buf(0);
            return bconcat(o).slice(0, entry.size);
        }
        function sleuth_fat(idx, cnt, sectors, ssz, fat_addrs) {
            var q = ENDOFCHAIN;
            if (idx === ENDOFCHAIN) {
                if (cnt !== 0) throw new Error("DIFAT chain shorter than expected");
            } else if (idx !== -1) {
                var sector = sectors[idx], m = (ssz >>> 2) - 1;
                if (!sector) return;
                for (var i = 0; i < m; ++i) {
                    if ((q = __readInt32LE(sector, i * 4)) === ENDOFCHAIN) break;
                    fat_addrs.push(q);
                }
                sleuth_fat(__readInt32LE(sector, ssz - 4), cnt - 1, sectors, ssz, fat_addrs);
            }
        }
        function get_sector_list(sectors, start, fat_addrs, ssz, chkd) {
            var buf = [], buf_chain = [];
            if (!chkd) chkd = [];
            var modulus = ssz - 1, j = 0, jj = 0;
            for (j = start; j >= 0; ) {
                chkd[j] = true;
                buf[buf.length] = j;
                buf_chain.push(sectors[j]);
                var addr = fat_addrs[Math.floor(j * 4 / ssz)];
                jj = j * 4 & modulus;
                if (ssz < 4 + jj) throw new Error("FAT boundary crossed: " + j + " 4 " + ssz);
                if (!sectors[addr]) break;
                j = __readInt32LE(sectors[addr], jj);
            }
            return {
                "nodes": buf,
                "data": __toBuffer([ buf_chain ])
            };
        }
        function make_sector_list(sectors, dir_start, fat_addrs, ssz) {
            var sl = sectors.length, sector_list = [];
            var chkd = [], buf = [], buf_chain = [];
            var modulus = ssz - 1, i = 0, j = 0, k = 0, jj = 0;
            for (i = 0; i < sl; ++i) {
                buf = [];
                k = i + dir_start;
                if (k >= sl) k -= sl;
                if (chkd[k]) continue;
                buf_chain = [];
                for (j = k; j >= 0; ) {
                    chkd[j] = true;
                    buf[buf.length] = j;
                    buf_chain.push(sectors[j]);
                    var addr = fat_addrs[Math.floor(j * 4 / ssz)];
                    jj = j * 4 & modulus;
                    if (ssz < 4 + jj) throw new Error("FAT boundary crossed: " + j + " 4 " + ssz);
                    if (!sectors[addr]) break;
                    j = __readInt32LE(sectors[addr], jj);
                }
                sector_list[k] = {
                    "nodes": buf,
                    "data": __toBuffer([ buf_chain ])
                };
            }
            return sector_list;
        }
        function read_directory(dir_start, sector_list, sectors, Paths, nmfs, files, FileIndex, mini) {
            var minifat_store = 0, pl = Paths.length ? 2 : 0;
            var sector = sector_list[dir_start].data;
            var i = 0, namelen = 0, name;
            for (;i < sector.length; i += 128) {
                var blob = sector.slice(i, i + 128);
                prep_blob(blob, 64);
                namelen = blob.read_shift(2);
                name = __utf16le(blob, 0, namelen - pl);
                Paths.push(name);
                var o = {
                    "name": name,
                    "type": blob.read_shift(1),
                    "color": blob.read_shift(1),
                    "L": blob.read_shift(4, "i"),
                    "R": blob.read_shift(4, "i"),
                    "C": blob.read_shift(4, "i"),
                    "clsid": blob.read_shift(16),
                    "state": blob.read_shift(4, "i"),
                    "start": 0,
                    "size": 0
                };
                var ctime = blob.read_shift(2) + blob.read_shift(2) + blob.read_shift(2) + blob.read_shift(2);
                if (ctime !== 0) o.ct = read_date(blob, blob.l - 8);
                var mtime = blob.read_shift(2) + blob.read_shift(2) + blob.read_shift(2) + blob.read_shift(2);
                if (mtime !== 0) o.mt = read_date(blob, blob.l - 8);
                o.start = blob.read_shift(4, "i");
                o.size = blob.read_shift(4, "i");
                if (o.size < 0 && o.start < 0) {
                    o.size = o.type = 0;
                    o.start = ENDOFCHAIN;
                    o.name = "";
                }
                if (o.type === 5) {
                    minifat_store = o.start;
                    if (nmfs > 0 && minifat_store !== ENDOFCHAIN) sector_list[minifat_store].name = "!StreamData";
                } else if (o.size >= 4096) {
                    o.storage = "fat";
                    if (sector_list[o.start] === undefined) sector_list[o.start] = get_sector_list(sectors, o.start, sector_list.fat_addrs, sector_list.ssz);
                    sector_list[o.start].name = o.name;
                    o.content = sector_list[o.start].data.slice(0, o.size);
                } else {
                    o.storage = "minifat";
                    if (o.size < 0) o.size = 0; else if (minifat_store !== ENDOFCHAIN && o.start !== ENDOFCHAIN && sector_list[minifat_store]) {
                        o.content = get_mfat_entry(o, sector_list[minifat_store].data, (sector_list[mini] || {}).data);
                    }
                }
                if (o.content) prep_blob(o.content, 0);
                files[name] = o;
                FileIndex.push(o);
            }
        }
        function read_date(blob, offset) {
            return new Date((__readUInt32LE(blob, offset + 4) / 1e7 * Math.pow(2, 32) + __readUInt32LE(blob, offset) / 1e7 - 11644473600) * 1e3);
        }
        function read_file(filename, options) {
            get_fs();
            return parse(fs.readFileSync(filename), options);
        }
        function read(blob, options) {
            switch (options && options.type || "base64") {
              case "file":
                return read_file(blob, options);

              case "base64":
                return parse(s2a(Base64.decode(blob)), options);

              case "binary":
                return parse(s2a(blob), options);
            }
            return parse(blob, options);
        }
        function init_cfb(cfb, opts) {
            var o = opts || {}, root = o.root || "Root Entry";
            if (!cfb.FullPaths) cfb.FullPaths = [];
            if (!cfb.FileIndex) cfb.FileIndex = [];
            if (cfb.FullPaths.length !== cfb.FileIndex.length) throw new Error("inconsistent CFB structure");
            if (cfb.FullPaths.length === 0) {
                cfb.FullPaths[0] = root + "/";
                cfb.FileIndex[0] = {
                    "name": root,
                    "type": 5
                };
            }
            if (o.CLSID) cfb.FileIndex[0].clsid = o.CLSID;
            seed_cfb(cfb);
        }
        function seed_cfb(cfb) {
            var nm = "\x01Sh33tJ5";
            if (CFB.find(cfb, "/" + nm)) return;
            var p = new_buf(4);
            p[0] = 55;
            p[1] = p[3] = 50;
            p[2] = 54;
            cfb.FileIndex.push({
                "name": nm,
                "type": 2,
                "content": p,
                "size": 4,
                "L": 69,
                "R": 69,
                "C": 69
            });
            cfb.FullPaths.push(cfb.FullPaths[0] + nm);
            rebuild_cfb(cfb);
        }
        function rebuild_cfb(cfb, f) {
            init_cfb(cfb);
            var gc = false, s = false;
            for (var i = cfb.FullPaths.length - 1; i >= 0; --i) {
                var _file = cfb.FileIndex[i];
                switch (_file.type) {
                  case 0:
                    if (s) gc = true; else {
                        cfb.FileIndex.pop();
                        cfb.FullPaths.pop();
                    }
                    break;

                  case 1:
                  case 2:
                  case 5:
                    s = true;
                    if (isNaN(_file.R * _file.L * _file.C)) gc = true;
                    if (_file.R > -1 && _file.L > -1 && _file.R == _file.L) gc = true;
                    break;

                  default:
                    gc = true;
                    break;
                }
            }
            if (!gc && !f) return;
            var now = new Date(1987, 1, 19), j = 0;
            var data = [];
            for (i = 0; i < cfb.FullPaths.length; ++i) {
                if (cfb.FileIndex[i].type === 0) continue;
                data.push([ cfb.FullPaths[i], cfb.FileIndex[i] ]);
            }
            for (i = 0; i < data.length; ++i) {
                var dad = dirname(data[i][0]);
                s = false;
                for (j = 0; j < data.length; ++j) if (data[j][0] === dad) s = true;
                if (!s) data.push([ dad, {
                    "name": filename(dad).replace("/", ""),
                    "type": 1,
                    "clsid": HEADER_CLSID,
                    "ct": now,
                    "mt": now,
                    "content": null
                } ]);
            }
            data.sort(function(x, y) {
                return namecmp(x[0], y[0]);
            });
            cfb.FullPaths = [];
            cfb.FileIndex = [];
            for (i = 0; i < data.length; ++i) {
                cfb.FullPaths[i] = data[i][0];
                cfb.FileIndex[i] = data[i][1];
            }
            for (i = 0; i < data.length; ++i) {
                var elt = cfb.FileIndex[i];
                var nm = cfb.FullPaths[i];
                elt.name = filename(nm).replace("/", "");
                elt.L = elt.R = elt.C = -(elt.color = 1);
                elt.size = elt.content ? elt.content.length : 0;
                elt.start = 0;
                elt.clsid = elt.clsid || HEADER_CLSID;
                if (i === 0) {
                    elt.C = data.length > 1 ? 1 : -1;
                    elt.size = 0;
                    elt.type = 5;
                } else if (nm.slice(-1) == "/") {
                    for (j = i + 1; j < data.length; ++j) if (dirname(cfb.FullPaths[j]) == nm) break;
                    elt.C = j >= data.length ? -1 : j;
                    for (j = i + 1; j < data.length; ++j) if (dirname(cfb.FullPaths[j]) == dirname(nm)) break;
                    elt.R = j >= data.length ? -1 : j;
                    elt.type = 1;
                } else {
                    if (dirname(cfb.FullPaths[i + 1] || "") == dirname(nm)) elt.R = i + 1;
                    elt.type = 2;
                }
            }
        }
        function _write(cfb, options) {
            var _opts = options || {};
            rebuild_cfb(cfb);
            if (_opts.fileType == "zip") return write_zip(cfb, _opts);
            var L = function(cfb) {
                var mini_size = 0, fat_size = 0;
                for (var i = 0; i < cfb.FileIndex.length; ++i) {
                    var file = cfb.FileIndex[i];
                    if (!file.content) continue;
                    var flen = file.content.length;
                    if (flen > 0) {
                        if (flen < 4096) mini_size += flen + 63 >> 6; else fat_size += flen + 511 >> 9;
                    }
                }
                var dir_cnt = cfb.FullPaths.length + 3 >> 2;
                var mini_cnt = mini_size + 7 >> 3;
                var mfat_cnt = mini_size + 127 >> 7;
                var fat_base = mini_cnt + fat_size + dir_cnt + mfat_cnt;
                var fat_cnt = fat_base + 127 >> 7;
                var difat_cnt = fat_cnt <= 109 ? 0 : Math.ceil((fat_cnt - 109) / 127);
                while (fat_base + fat_cnt + difat_cnt + 127 >> 7 > fat_cnt) difat_cnt = ++fat_cnt <= 109 ? 0 : Math.ceil((fat_cnt - 109) / 127);
                var L = [ 1, difat_cnt, fat_cnt, mfat_cnt, dir_cnt, fat_size, mini_size, 0 ];
                cfb.FileIndex[0].size = mini_size << 6;
                L[7] = (cfb.FileIndex[0].start = L[0] + L[1] + L[2] + L[3] + L[4] + L[5]) + (L[6] + 7 >> 3);
                return L;
            }(cfb);
            var o = new_buf(L[7] << 9);
            var i = 0, T = 0;
            {
                for (i = 0; i < 8; ++i) o.write_shift(1, HEADER_SIG[i]);
                for (i = 0; i < 8; ++i) o.write_shift(2, 0);
                o.write_shift(2, 62);
                o.write_shift(2, 3);
                o.write_shift(2, 65534);
                o.write_shift(2, 9);
                o.write_shift(2, 6);
                for (i = 0; i < 3; ++i) o.write_shift(2, 0);
                o.write_shift(4, 0);
                o.write_shift(4, L[2]);
                o.write_shift(4, L[0] + L[1] + L[2] + L[3] - 1);
                o.write_shift(4, 0);
                o.write_shift(4, 1 << 12);
                o.write_shift(4, L[3] ? L[0] + L[1] + L[2] - 1 : ENDOFCHAIN);
                o.write_shift(4, L[3]);
                o.write_shift(-4, L[1] ? L[0] - 1 : ENDOFCHAIN);
                o.write_shift(4, L[1]);
                for (i = 0; i < 109; ++i) o.write_shift(-4, i < L[2] ? L[1] + i : -1);
            }
            if (L[1]) {
                for (T = 0; T < L[1]; ++T) {
                    for (;i < 236 + T * 127; ++i) o.write_shift(-4, i < L[2] ? L[1] + i : -1);
                    o.write_shift(-4, T === L[1] - 1 ? ENDOFCHAIN : T + 1);
                }
            }
            var chainit = function(w) {
                for (T += w; i < T - 1; ++i) o.write_shift(-4, i + 1);
                if (w) {
                    ++i;
                    o.write_shift(-4, ENDOFCHAIN);
                }
            };
            T = i = 0;
            for (T += L[1]; i < T; ++i) o.write_shift(-4, consts.DIFSECT);
            for (T += L[2]; i < T; ++i) o.write_shift(-4, consts.FATSECT);
            chainit(L[3]);
            chainit(L[4]);
            var j = 0, flen = 0;
            var file = cfb.FileIndex[0];
            for (;j < cfb.FileIndex.length; ++j) {
                file = cfb.FileIndex[j];
                if (!file.content) continue;
                flen = file.content.length;
                if (flen < 4096) continue;
                file.start = T;
                chainit(flen + 511 >> 9);
            }
            chainit(L[6] + 7 >> 3);
            while (o.l & 511) o.write_shift(-4, consts.ENDOFCHAIN);
            T = i = 0;
            for (j = 0; j < cfb.FileIndex.length; ++j) {
                file = cfb.FileIndex[j];
                if (!file.content) continue;
                flen = file.content.length;
                if (!flen || flen >= 4096) continue;
                file.start = T;
                chainit(flen + 63 >> 6);
            }
            while (o.l & 511) o.write_shift(-4, consts.ENDOFCHAIN);
            for (i = 0; i < L[4] << 2; ++i) {
                var nm = cfb.FullPaths[i];
                if (!nm || nm.length === 0) {
                    for (j = 0; j < 17; ++j) o.write_shift(4, 0);
                    for (j = 0; j < 3; ++j) o.write_shift(4, -1);
                    for (j = 0; j < 12; ++j) o.write_shift(4, 0);
                    continue;
                }
                file = cfb.FileIndex[i];
                if (i === 0) file.start = file.size ? file.start - 1 : ENDOFCHAIN;
                var _nm = i === 0 && _opts.root || file.name;
                flen = 2 * (_nm.length + 1);
                o.write_shift(64, _nm, "utf16le");
                o.write_shift(2, flen);
                o.write_shift(1, file.type);
                o.write_shift(1, file.color);
                o.write_shift(-4, file.L);
                o.write_shift(-4, file.R);
                o.write_shift(-4, file.C);
                if (!file.clsid) for (j = 0; j < 4; ++j) o.write_shift(4, 0); else o.write_shift(16, file.clsid, "hex");
                o.write_shift(4, file.state || 0);
                o.write_shift(4, 0);
                o.write_shift(4, 0);
                o.write_shift(4, 0);
                o.write_shift(4, 0);
                o.write_shift(4, file.start);
                o.write_shift(4, file.size);
                o.write_shift(4, 0);
            }
            for (i = 1; i < cfb.FileIndex.length; ++i) {
                file = cfb.FileIndex[i];
                if (file.size >= 4096) {
                    o.l = file.start + 1 << 9;
                    for (j = 0; j < file.size; ++j) o.write_shift(1, file.content[j]);
                    for (;j & 511; ++j) o.write_shift(1, 0);
                }
            }
            for (i = 1; i < cfb.FileIndex.length; ++i) {
                file = cfb.FileIndex[i];
                if (file.size > 0 && file.size < 4096) {
                    for (j = 0; j < file.size; ++j) o.write_shift(1, file.content[j]);
                    for (;j & 63; ++j) o.write_shift(1, 0);
                }
            }
            while (o.l < o.length) o.write_shift(1, 0);
            return o;
        }
        function find(cfb, path) {
            var UCFullPaths = cfb.FullPaths.map(function(x) {
                return x.toUpperCase();
            });
            var UCPaths = UCFullPaths.map(function(x) {
                var y = x.split("/");
                return y[y.length - (x.slice(-1) == "/" ? 2 : 1)];
            });
            var k = false;
            if (path.charCodeAt(0) === 47) {
                k = true;
                path = UCFullPaths[0].slice(0, -1) + path;
            } else k = path.indexOf("/") !== -1;
            var UCPath = path.toUpperCase();
            var w = k === true ? UCFullPaths.indexOf(UCPath) : UCPaths.indexOf(UCPath);
            if (w !== -1) return cfb.FileIndex[w];
            var m = !UCPath.match(chr1);
            UCPath = UCPath.replace(chr0, "");
            if (m) UCPath = UCPath.replace(chr1, "!");
            for (w = 0; w < UCFullPaths.length; ++w) {
                if ((m ? UCFullPaths[w].replace(chr1, "!") : UCFullPaths[w]).replace(chr0, "") == UCPath) return cfb.FileIndex[w];
                if ((m ? UCPaths[w].replace(chr1, "!") : UCPaths[w]).replace(chr0, "") == UCPath) return cfb.FileIndex[w];
            }
            return null;
        }
        var MSSZ = 64;
        var ENDOFCHAIN = -2;
        var HEADER_SIGNATURE = "d0cf11e0a1b11ae1";
        var HEADER_SIG = [ 208, 207, 17, 224, 161, 177, 26, 225 ];
        var HEADER_CLSID = "00000000000000000000000000000000";
        var consts = {
            "MAXREGSECT": -6,
            "DIFSECT": -4,
            "FATSECT": -3,
            "ENDOFCHAIN": ENDOFCHAIN,
            "FREESECT": -1,
            "HEADER_SIGNATURE": HEADER_SIGNATURE,
            "HEADER_MINOR_VERSION": "3e00",
            "MAXREGSID": -6,
            "NOSTREAM": -1,
            "HEADER_CLSID": HEADER_CLSID,
            "EntryTypes": [ "unknown", "storage", "stream", "lockbytes", "property", "root" ]
        };
        function write_file(cfb, filename, options) {
            get_fs();
            var o = _write(cfb, options);
            fs.writeFileSync(filename, o);
        }
        function a2s(o) {
            var out = new Array(o.length);
            for (var i = 0; i < o.length; ++i) out[i] = String.fromCharCode(o[i]);
            return out.join("");
        }
        function write(cfb, options) {
            var o = _write(cfb, options);
            switch (options && options.type) {
              case "file":
                get_fs();
                fs.writeFileSync(options.filename, o);
                return o;

              case "binary":
                return a2s(o);

              case "base64":
                return Base64.encode(a2s(o));
            }
            return o;
        }
        var _zlib;
        function use_zlib(zlib) {
            try {
                var InflateRaw = zlib.InflateRaw;
                var InflRaw = new InflateRaw();
                InflRaw._processChunk(new Uint8Array([ 3, 0 ]), InflRaw._finishFlushFlag);
                if (InflRaw.bytesRead) _zlib = zlib; else throw new Error("zlib does not expose bytesRead");
            } catch (e) {
                console.error("cannot use native zlib: " + (e.message || e));
            }
        }
        function _inflateRawSync(payload, usz) {
            if (!_zlib) return _inflate(payload, usz);
            var InflateRaw = _zlib.InflateRaw;
            var InflRaw = new InflateRaw();
            var out = InflRaw._processChunk(payload.slice(payload.l), InflRaw._finishFlushFlag);
            payload.l += InflRaw.bytesRead;
            return out;
        }
        function _deflateRawSync(payload) {
            return _zlib ? _zlib.deflateRawSync(payload) : _deflate(payload);
        }
        var CLEN_ORDER = [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];
        var LEN_LN = [ 3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258 ];
        var DST_LN = [ 1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577 ];
        function bit_swap_8(n) {
            var t = (n << 1 | n << 11) & 139536 | (n << 5 | n << 15) & 558144;
            return (t >> 16 | t >> 8 | t) & 255;
        }
        var use_typed_arrays = typeof Uint8Array !== "undefined";
        var bitswap8 = use_typed_arrays ? new Uint8Array(1 << 8) : [];
        for (var q = 0; q < 1 << 8; ++q) bitswap8[q] = bit_swap_8(q);
        function bit_swap_n(n, b) {
            var rev = bitswap8[n & 255];
            if (b <= 8) return rev >>> 8 - b;
            rev = rev << 8 | bitswap8[n >> 8 & 255];
            if (b <= 16) return rev >>> 16 - b;
            rev = rev << 8 | bitswap8[n >> 16 & 255];
            return rev >>> 24 - b;
        }
        function read_bits_2(buf, bl) {
            var w = bl & 7, h = bl >>> 3;
            return (buf[h] | (w <= 6 ? 0 : buf[h + 1] << 8)) >>> w & 3;
        }
        function read_bits_3(buf, bl) {
            var w = bl & 7, h = bl >>> 3;
            return (buf[h] | (w <= 5 ? 0 : buf[h + 1] << 8)) >>> w & 7;
        }
        function read_bits_4(buf, bl) {
            var w = bl & 7, h = bl >>> 3;
            return (buf[h] | (w <= 4 ? 0 : buf[h + 1] << 8)) >>> w & 15;
        }
        function read_bits_5(buf, bl) {
            var w = bl & 7, h = bl >>> 3;
            return (buf[h] | (w <= 3 ? 0 : buf[h + 1] << 8)) >>> w & 31;
        }
        function read_bits_7(buf, bl) {
            var w = bl & 7, h = bl >>> 3;
            return (buf[h] | (w <= 1 ? 0 : buf[h + 1] << 8)) >>> w & 127;
        }
        function read_bits_n(buf, bl, n) {
            var w = bl & 7, h = bl >>> 3, f = (1 << n) - 1;
            var v = buf[h] >>> w;
            if (n < 8 - w) return v & f;
            v |= buf[h + 1] << 8 - w;
            if (n < 16 - w) return v & f;
            v |= buf[h + 2] << 16 - w;
            if (n < 24 - w) return v & f;
            v |= buf[h + 3] << 24 - w;
            return v & f;
        }
        function realloc(b, sz) {
            var L = b.length, M = 2 * L > sz ? 2 * L : sz + 5, i = 0;
            if (L >= sz) return b;
            if (has_buf) {
                var o = new_unsafe_buf(M);
                if (b.copy) b.copy(o); else for (;i < b.length; ++i) o[i] = b[i];
                return o;
            } else if (use_typed_arrays) {
                var a = new Uint8Array(M);
                if (a.set) a.set(b); else for (;i < b.length; ++i) a[i] = b[i];
                return a;
            }
            b.length = M;
            return b;
        }
        function zero_fill_array(n) {
            var o = new Array(n);
            for (var i = 0; i < n; ++i) o[i] = 0;
            return o;
        }
        var _deflate = function() {
            var _deflateRaw = function() {
                return function deflateRaw(data, out) {
                    var boff = 0;
                    while (boff < data.length) {
                        var L = Math.min(65535, data.length - boff);
                        var h = boff + L == data.length;
                        out.write_shift(1, +h);
                        out.write_shift(2, L);
                        out.write_shift(2, ~L & 65535);
                        while (L-- > 0) out[out.l++] = data[boff++];
                    }
                    return out.l;
                };
            }();
            return function(data) {
                var buf = new_buf(50 + Math.floor(data.length * 1.1));
                var off = _deflateRaw(data, buf);
                return buf.slice(0, off);
            };
        }();
        function build_tree(clens, cmap, MAX) {
            var maxlen = 1, w = 0, i = 0, j = 0, ccode = 0, L = clens.length;
            var bl_count = use_typed_arrays ? new Uint16Array(32) : zero_fill_array(32);
            for (i = 0; i < 32; ++i) bl_count[i] = 0;
            for (i = L; i < MAX; ++i) clens[i] = 0;
            L = clens.length;
            var ctree = use_typed_arrays ? new Uint16Array(L) : zero_fill_array(L);
            for (i = 0; i < L; ++i) {
                bl_count[w = clens[i]]++;
                if (maxlen < w) maxlen = w;
                ctree[i] = 0;
            }
            bl_count[0] = 0;
            for (i = 1; i <= maxlen; ++i) bl_count[i + 16] = ccode = ccode + bl_count[i - 1] << 1;
            for (i = 0; i < L; ++i) {
                ccode = clens[i];
                if (ccode != 0) ctree[i] = bl_count[ccode + 16]++;
            }
            var cleni = 0;
            for (i = 0; i < L; ++i) {
                cleni = clens[i];
                if (cleni != 0) {
                    ccode = bit_swap_n(ctree[i], maxlen) >> maxlen - cleni;
                    for (j = (1 << maxlen + 4 - cleni) - 1; j >= 0; --j) cmap[ccode | j << cleni] = cleni & 15 | i << 4;
                }
            }
            return maxlen;
        }
        var fix_lmap = use_typed_arrays ? new Uint16Array(512) : zero_fill_array(512);
        var fix_dmap = use_typed_arrays ? new Uint16Array(32) : zero_fill_array(32);
        if (!use_typed_arrays) {
            for (var i = 0; i < 512; ++i) fix_lmap[i] = 0;
            for (i = 0; i < 32; ++i) fix_dmap[i] = 0;
        }
        (function() {
            var dlens = [];
            var i = 0;
            for (;i < 32; i++) dlens.push(5);
            build_tree(dlens, fix_dmap, 32);
            var clens = [];
            i = 0;
            for (;i <= 143; i++) clens.push(8);
            for (;i <= 255; i++) clens.push(9);
            for (;i <= 279; i++) clens.push(7);
            for (;i <= 287; i++) clens.push(8);
            build_tree(clens, fix_lmap, 288);
        })();
        var dyn_lmap = use_typed_arrays ? new Uint16Array(32768) : zero_fill_array(32768);
        var dyn_dmap = use_typed_arrays ? new Uint16Array(32768) : zero_fill_array(32768);
        var dyn_cmap = use_typed_arrays ? new Uint16Array(128) : zero_fill_array(128);
        var dyn_len_1 = 1, dyn_len_2 = 1;
        function dyn(data, boff) {
            var _HLIT = read_bits_5(data, boff) + 257;
            boff += 5;
            var _HDIST = read_bits_5(data, boff) + 1;
            boff += 5;
            var _HCLEN = read_bits_4(data, boff) + 4;
            boff += 4;
            var w = 0;
            var clens = use_typed_arrays ? new Uint8Array(19) : zero_fill_array(19);
            var ctree = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ];
            var maxlen = 1;
            var bl_count = use_typed_arrays ? new Uint8Array(8) : zero_fill_array(8);
            var next_code = use_typed_arrays ? new Uint8Array(8) : zero_fill_array(8);
            var L = clens.length;
            for (var i = 0; i < _HCLEN; ++i) {
                clens[CLEN_ORDER[i]] = w = read_bits_3(data, boff);
                if (maxlen < w) maxlen = w;
                bl_count[w]++;
                boff += 3;
            }
            var ccode = 0;
            bl_count[0] = 0;
            for (i = 1; i <= maxlen; ++i) next_code[i] = ccode = ccode + bl_count[i - 1] << 1;
            for (i = 0; i < L; ++i) if ((ccode = clens[i]) != 0) ctree[i] = next_code[ccode]++;
            var cleni = 0;
            for (i = 0; i < L; ++i) {
                cleni = clens[i];
                if (cleni != 0) {
                    ccode = bitswap8[ctree[i]] >> 8 - cleni;
                    for (var j = (1 << 7 - cleni) - 1; j >= 0; --j) dyn_cmap[ccode | j << cleni] = cleni & 7 | i << 3;
                }
            }
            var hcodes = [];
            maxlen = 1;
            for (;hcodes.length < _HLIT + _HDIST; ) {
                ccode = dyn_cmap[read_bits_7(data, boff)];
                boff += ccode & 7;
                switch (ccode >>>= 3) {
                  case 16:
                    w = 3 + read_bits_2(data, boff);
                    boff += 2;
                    ccode = hcodes[hcodes.length - 1];
                    while (w-- > 0) hcodes.push(ccode);
                    break;

                  case 17:
                    w = 3 + read_bits_3(data, boff);
                    boff += 3;
                    while (w-- > 0) hcodes.push(0);
                    break;

                  case 18:
                    w = 11 + read_bits_7(data, boff);
                    boff += 7;
                    while (w-- > 0) hcodes.push(0);
                    break;

                  default:
                    hcodes.push(ccode);
                    if (maxlen < ccode) maxlen = ccode;
                    break;
                }
            }
            var h1 = hcodes.slice(0, _HLIT), h2 = hcodes.slice(_HLIT);
            for (i = _HLIT; i < 286; ++i) h1[i] = 0;
            for (i = _HDIST; i < 30; ++i) h2[i] = 0;
            dyn_len_1 = build_tree(h1, dyn_lmap, 286);
            dyn_len_2 = build_tree(h2, dyn_dmap, 30);
            return boff;
        }
        function inflate(data, usz) {
            if (data[0] == 3 && !(data[1] & 3)) {
                return [ new_raw_buf(usz), 2 ];
            }
            var boff = 0;
            var header = 0;
            var outbuf = new_unsafe_buf(usz ? usz : 1 << 18);
            var woff = 0;
            var OL = outbuf.length >>> 0;
            var max_len_1 = 0, max_len_2 = 0;
            while ((header & 1) == 0) {
                header = read_bits_3(data, boff);
                boff += 3;
                if (header >>> 1 == 0) {
                    if (boff & 7) boff += 8 - (boff & 7);
                    var sz = data[boff >>> 3] | data[(boff >>> 3) + 1] << 8;
                    boff += 32;
                    if (!usz && OL < woff + sz) {
                        outbuf = realloc(outbuf, woff + sz);
                        OL = outbuf.length;
                    }
                    if (typeof data.copy === "function") {
                        data.copy(outbuf, woff, boff >>> 3, (boff >>> 3) + sz);
                        woff += sz;
                        boff += 8 * sz;
                    } else while (sz-- > 0) {
                        outbuf[woff++] = data[boff >>> 3];
                        boff += 8;
                    }
                    continue;
                } else if (header >>> 1 == 1) {
                    max_len_1 = 9;
                    max_len_2 = 5;
                } else {
                    boff = dyn(data, boff);
                    max_len_1 = dyn_len_1;
                    max_len_2 = dyn_len_2;
                }
                if (!usz && OL < woff + 32767) {
                    outbuf = realloc(outbuf, woff + 32767);
                    OL = outbuf.length;
                }
                for (;;) {
                    var bits = read_bits_n(data, boff, max_len_1);
                    var code = header >>> 1 == 1 ? fix_lmap[bits] : dyn_lmap[bits];
                    boff += code & 15;
                    code >>>= 4;
                    if ((code >>> 8 & 255) === 0) outbuf[woff++] = code; else if (code == 256) break; else {
                        code -= 257;
                        var len_eb = code < 8 ? 0 : code - 4 >> 2;
                        if (len_eb > 5) len_eb = 0;
                        var tgt = woff + LEN_LN[code];
                        if (len_eb > 0) {
                            tgt += read_bits_n(data, boff, len_eb);
                            boff += len_eb;
                        }
                        bits = read_bits_n(data, boff, max_len_2);
                        code = header >>> 1 == 1 ? fix_dmap[bits] : dyn_dmap[bits];
                        boff += code & 15;
                        code >>>= 4;
                        var dst_eb = code < 4 ? 0 : code - 2 >> 1;
                        var dst = DST_LN[code];
                        if (dst_eb > 0) {
                            dst += read_bits_n(data, boff, dst_eb);
                            boff += dst_eb;
                        }
                        if (!usz && OL < tgt) {
                            outbuf = realloc(outbuf, tgt);
                            OL = outbuf.length;
                        }
                        while (woff < tgt) {
                            outbuf[woff] = outbuf[woff - dst];
                            ++woff;
                        }
                    }
                }
            }
            return [ usz ? outbuf : outbuf.slice(0, woff), boff + 7 >>> 3 ];
        }
        function _inflate(payload, usz) {
            var data = payload.slice(payload.l || 0);
            var out = inflate(data, usz);
            payload.l += out[1];
            return out[0];
        }
        function warn_or_throw(wrn, msg) {
            if (wrn) {
                if (typeof console !== "undefined") console.error(msg);
            } else throw new Error(msg);
        }
        function parse_zip(file, options) {
            var blob = file;
            prep_blob(blob, 0);
            var FileIndex = [], FullPaths = [];
            var o = {
                "FileIndex": FileIndex,
                "FullPaths": FullPaths
            };
            init_cfb(o, {
                "root": options.root
            });
            var i = blob.length - 4;
            while ((blob[i] != 80 || blob[i + 1] != 75 || blob[i + 2] != 5 || blob[i + 3] != 6) && i >= 0) --i;
            blob.l = i + 4;
            blob.l += 4;
            var fcnt = blob.read_shift(2);
            blob.l += 6;
            var start_cd = blob.read_shift(4);
            blob.l = start_cd;
            for (i = 0; i < fcnt; ++i) {
                blob.l += 20;
                var csz = blob.read_shift(4);
                var usz = blob.read_shift(4);
                var namelen = blob.read_shift(2);
                var efsz = blob.read_shift(2);
                var fcsz = blob.read_shift(2);
                blob.l += 8;
                var offset = blob.read_shift(4);
                var EF = parse_extra_field(blob.slice(blob.l + namelen, blob.l + namelen + efsz));
                blob.l += namelen + efsz + fcsz;
                var L = blob.l;
                blob.l = offset + 4;
                parse_local_file(blob, csz, usz, o, EF);
                blob.l = L;
            }
            return o;
        }
        function parse_local_file(blob, csz, usz, o, EF) {
            blob.l += 2;
            var flags = blob.read_shift(2);
            var meth = blob.read_shift(2);
            var date = parse_dos_date(blob);
            if (flags & 8257) throw new Error("Unsupported ZIP encryption");
            var crc32 = blob.read_shift(4);
            var _csz = blob.read_shift(4);
            var _usz = blob.read_shift(4);
            var namelen = blob.read_shift(2);
            var efsz = blob.read_shift(2);
            var name = "";
            for (var i = 0; i < namelen; ++i) name += String.fromCharCode(blob[blob.l++]);
            if (efsz) {
                var ef = parse_extra_field(blob.slice(blob.l, blob.l + efsz));
                if ((ef[21589] || {}).mt) date = ef[21589].mt;
                if (((EF || {})[21589] || {}).mt) date = EF[21589].mt;
            }
            blob.l += efsz;
            var data = blob.slice(blob.l, blob.l + _csz);
            switch (meth) {
              case 8:
                data = _inflateRawSync(blob, _usz);
                break;

              case 0:
                break;

              default:
                throw new Error("Unsupported ZIP Compression method " + meth);
            }
            var wrn = false;
            if (flags & 8) {
                crc32 = blob.read_shift(4);
                if (crc32 == 134695760) {
                    crc32 = blob.read_shift(4);
                    wrn = true;
                }
                _csz = blob.read_shift(4);
                _usz = blob.read_shift(4);
            }
            if (_csz != csz) warn_or_throw(wrn, "Bad compressed size: " + csz + " != " + _csz);
            if (_usz != usz) warn_or_throw(wrn, "Bad uncompressed size: " + usz + " != " + _usz);
            var _crc32 = CRC32.buf(data, 0);
            if (crc32 != _crc32) warn_or_throw(wrn, "Bad CRC32 checksum: " + crc32 + " != " + _crc32);
            cfb_add(o, name, data, {
                "unsafe": true,
                "mt": date
            });
        }
        function write_zip(cfb, options) {
            var _opts = options || {};
            var out = [], cdirs = [];
            var o = new_buf(1);
            var method = _opts.compression ? 8 : 0, flags = 0;
            var desc = false;
            if (desc) flags |= 8;
            var i = 0, j = 0;
            var start_cd = 0, fcnt = 0;
            var root = cfb.FullPaths[0], fp = root, fi = cfb.FileIndex[0];
            var crcs = [];
            var sz_cd = 0;
            for (i = 1; i < cfb.FullPaths.length; ++i) {
                fp = cfb.FullPaths[i].slice(root.length);
                fi = cfb.FileIndex[i];
                if (!fi.size || !fi.content || fp == "\x01Sh33tJ5") continue;
                var start = start_cd;
                var namebuf = new_buf(fp.length);
                for (j = 0; j < fp.length; ++j) namebuf.write_shift(1, fp.charCodeAt(j) & 127);
                namebuf = namebuf.slice(0, namebuf.l);
                crcs[fcnt] = CRC32.buf(fi.content, 0);
                var outbuf = fi.content;
                if (method == 8) outbuf = _deflateRawSync(outbuf);
                o = new_buf(30);
                o.write_shift(4, 67324752);
                o.write_shift(2, 20);
                o.write_shift(2, flags);
                o.write_shift(2, method);
                if (fi.mt) write_dos_date(o, fi.mt); else o.write_shift(4, 0);
                o.write_shift(-4, flags & 8 ? 0 : crcs[fcnt]);
                o.write_shift(4, flags & 8 ? 0 : outbuf.length);
                o.write_shift(4, flags & 8 ? 0 : fi.content.length);
                o.write_shift(2, namebuf.length);
                o.write_shift(2, 0);
                start_cd += o.length;
                out.push(o);
                start_cd += namebuf.length;
                out.push(namebuf);
                start_cd += outbuf.length;
                out.push(outbuf);
                if (flags & 8) {
                    o = new_buf(12);
                    o.write_shift(-4, crcs[fcnt]);
                    o.write_shift(4, outbuf.length);
                    o.write_shift(4, fi.content.length);
                    start_cd += o.l;
                    out.push(o);
                }
                o = new_buf(46);
                o.write_shift(4, 33639248);
                o.write_shift(2, 0);
                o.write_shift(2, 20);
                o.write_shift(2, flags);
                o.write_shift(2, method);
                o.write_shift(4, 0);
                o.write_shift(-4, crcs[fcnt]);
                o.write_shift(4, outbuf.length);
                o.write_shift(4, fi.content.length);
                o.write_shift(2, namebuf.length);
                o.write_shift(2, 0);
                o.write_shift(2, 0);
                o.write_shift(2, 0);
                o.write_shift(2, 0);
                o.write_shift(4, 0);
                o.write_shift(4, start);
                sz_cd += o.l;
                cdirs.push(o);
                sz_cd += namebuf.length;
                cdirs.push(namebuf);
                ++fcnt;
            }
            o = new_buf(22);
            o.write_shift(4, 101010256);
            o.write_shift(2, 0);
            o.write_shift(2, 0);
            o.write_shift(2, fcnt);
            o.write_shift(2, fcnt);
            o.write_shift(4, sz_cd);
            o.write_shift(4, start_cd);
            o.write_shift(2, 0);
            return bconcat([ bconcat(out), bconcat(cdirs), o ]);
        }
        function cfb_new(opts) {
            var o = {};
            init_cfb(o, opts);
            return o;
        }
        function cfb_add(cfb, name, content, opts) {
            var unsafe = opts && opts.unsafe;
            if (!unsafe) init_cfb(cfb);
            var file = !unsafe && CFB.find(cfb, name);
            if (!file) {
                var fpath = cfb.FullPaths[0];
                if (name.slice(0, fpath.length) == fpath) fpath = name; else {
                    if (fpath.slice(-1) != "/") fpath += "/";
                    fpath = (fpath + name).replace("//", "/");
                }
                file = {
                    "name": filename(name),
                    "type": 2
                };
                cfb.FileIndex.push(file);
                cfb.FullPaths.push(fpath);
                if (!unsafe) CFB.utils.cfb_gc(cfb);
            }
            file.content = content;
            file.size = content ? content.length : 0;
            if (opts) {
                if (opts.CLSID) file.clsid = opts.CLSID;
                if (opts.mt) file.mt = opts.mt;
                if (opts.ct) file.ct = opts.ct;
            }
            return file;
        }
        function cfb_del(cfb, name) {
            init_cfb(cfb);
            var file = CFB.find(cfb, name);
            if (file) for (var j = 0; j < cfb.FileIndex.length; ++j) if (cfb.FileIndex[j] == file) {
                cfb.FileIndex.splice(j, 1);
                cfb.FullPaths.splice(j, 1);
                return true;
            }
            return false;
        }
        function cfb_mov(cfb, old_name, new_name) {
            init_cfb(cfb);
            var file = CFB.find(cfb, old_name);
            if (file) for (var j = 0; j < cfb.FileIndex.length; ++j) if (cfb.FileIndex[j] == file) {
                cfb.FileIndex[j].name = filename(new_name);
                cfb.FullPaths[j] = new_name;
                return true;
            }
            return false;
        }
        function cfb_gc(cfb) {
            rebuild_cfb(cfb, true);
        }
        exports.find = find;
        exports.read = read;
        exports.parse = parse;
        exports.write = write;
        exports.writeFile = write_file;
        exports.utils = {
            "cfb_new": cfb_new,
            "cfb_add": cfb_add,
            "cfb_del": cfb_del,
            "cfb_mov": cfb_mov,
            "cfb_gc": cfb_gc,
            "ReadShift": ReadShift,
            "CheckField": CheckField,
            "prep_blob": prep_blob,
            "bconcat": bconcat,
            "use_zlib": use_zlib,
            "_deflateRaw": _deflate,
            "_inflateRaw": _inflate,
            "consts": consts
        };
        return exports;
    }();
    if (typeof require !== "undefined" && typeof module !== "undefined" && typeof DO_NOT_EXPORT_CFB === "undefined") {
        module.exports = CFB;
    }
    var _fs;
    if (typeof require !== "undefined") try {
        _fs = require("fs");
    } catch (e) {}
    function blobify(data) {
        if (typeof data === "string") return s2ab(data);
        if (Array.isArray(data)) return a2u(data);
        return data;
    }
    function write_dl(fname, payload, enc) {
        if (typeof _fs !== "undefined" && _fs.writeFileSync) return enc ? _fs.writeFileSync(fname, payload, enc) : _fs.writeFileSync(fname, payload);
        var data = enc == "utf8" ? utf8write(payload) : payload;
        if (typeof IE_SaveFile !== "undefined") return IE_SaveFile(data, fname);
        if (typeof Blob !== "undefined") {
            var blob = new Blob([ blobify(data) ], {
                "type": "application/octet-stream"
            });
            if (typeof navigator !== "undefined" && navigator.msSaveBlob) return navigator.msSaveBlob(blob, fname);
            if (typeof saveAs !== "undefined") return saveAs(blob, fname);
            if (typeof URL !== "undefined" && typeof document !== "undefined" && document.createElement && URL.createObjectURL) {
                var url = URL.createObjectURL(blob);
                if (typeof chrome === "object" && typeof (chrome.downloads || {}).download == "function") {
                    if (URL.revokeObjectURL && typeof setTimeout !== "undefined") setTimeout(function() {
                        URL.revokeObjectURL(url);
                    }, 6e4);
                    return chrome.downloads.download({
                        "url": url,
                        "filename": fname,
                        "saveAs": true
                    });
                }
                var a = document.createElement("a");
                if (a.download != null) {
                    a.download = fname;
                    a.href = url;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    if (URL.revokeObjectURL && typeof setTimeout !== "undefined") setTimeout(function() {
                        URL.revokeObjectURL(url);
                    }, 6e4);
                    return url;
                }
            }
        }
        if (typeof $ !== "undefined" && typeof File !== "undefined" && typeof Folder !== "undefined") try {
            var out = File(fname);
            out.open("w");
            out.encoding = "binary";
            if (Array.isArray(payload)) payload = a2s(payload);
            out.write(payload);
            out.close();
            return payload;
        } catch (e) {
            if (!e.message || !e.message.match(/onstruct/)) throw e;
        }
        throw new Error("cannot save file " + fname);
    }
    function read_binary(path) {
        if (typeof _fs !== "undefined") return _fs.readFileSync(path);
        if (typeof $ !== "undefined" && typeof File !== "undefined" && typeof Folder !== "undefined") try {
            var infile = File(path);
            infile.open("r");
            infile.encoding = "binary";
            var data = infile.read();
            infile.close();
            return data;
        } catch (e) {
            if (!e.message || !e.message.match(/onstruct/)) throw e;
        }
        throw new Error("Cannot access file " + path);
    }
    function keys(o) {
        var ks = Object.keys(o), o2 = [];
        for (var i = 0; i < ks.length; ++i) if (o.hasOwnProperty(ks[i])) o2.push(ks[i]);
        return o2;
    }
    function evert_key(obj, key) {
        var o = [], K = keys(obj);
        for (var i = 0; i !== K.length; ++i) if (o[obj[K[i]][key]] == null) o[obj[K[i]][key]] = K[i];
        return o;
    }
    function evert(obj) {
        var o = [], K = keys(obj);
        for (var i = 0; i !== K.length; ++i) o[obj[K[i]]] = K[i];
        return o;
    }
    function evert_num(obj) {
        var o = [], K = keys(obj);
        for (var i = 0; i !== K.length; ++i) o[obj[K[i]]] = parseInt(K[i], 10);
        return o;
    }
    function evert_arr(obj) {
        var o = [], K = keys(obj);
        for (var i = 0; i !== K.length; ++i) {
            if (o[obj[K[i]]] == null) o[obj[K[i]]] = [];
            o[obj[K[i]]].push(K[i]);
        }
        return o;
    }
    var basedate = new Date(1899, 11, 30, 0, 0, 0);
    var dnthresh = basedate.getTime() + (new Date().getTimezoneOffset() - basedate.getTimezoneOffset()) * 6e4;
    function datenum(v, date1904) {
        var epoch = v.getTime();
        if (date1904) epoch -= 1462 * 24 * 60 * 60 * 1e3;
        return (epoch - dnthresh) / (24 * 60 * 60 * 1e3);
    }
    function numdate(v) {
        var out = new Date();
        out.setTime(v * 24 * 60 * 60 * 1e3 + dnthresh);
        return out;
    }
    function parse_isodur(s) {
        var sec = 0, mt = 0, time = false;
        var m = s.match(/P([0-9\.]+Y)?([0-9\.]+M)?([0-9\.]+D)?T([0-9\.]+H)?([0-9\.]+M)?([0-9\.]+S)?/);
        if (!m) throw new Error("|" + s + "| is not an ISO8601 Duration");
        for (var i = 1; i != m.length; ++i) {
            if (!m[i]) continue;
            mt = 1;
            if (i > 3) time = true;
            switch (m[i].slice(m[i].length - 1)) {
              case "Y":
                throw new Error("Unsupported ISO Duration Field: " + m[i].slice(m[i].length - 1));

              case "D":
                mt *= 24;

              case "H":
                mt *= 60;

              case "M":
                if (!time) throw new Error("Unsupported ISO Duration Field: M"); else mt *= 60;

              case "S":
                break;
            }
            sec += mt * parseInt(m[i], 10);
        }
        return sec;
    }
    var good_pd_date = new Date("2017-02-19T19:06:09.000Z");
    if (isNaN(good_pd_date.getFullYear())) good_pd_date = new Date("2/19/17");
    var good_pd = good_pd_date.getFullYear() == 2017;
    function parseDate(str, fixdate) {
        var d = new Date(str);
        if (good_pd) {
            if (fixdate > 0) d.setTime(d.getTime() + d.getTimezoneOffset() * 60 * 1e3); else if (fixdate < 0) d.setTime(d.getTime() - d.getTimezoneOffset() * 60 * 1e3);
            return d;
        }
        if (str instanceof Date) return str;
        if (good_pd_date.getFullYear() == 1917 && !isNaN(d.getFullYear())) {
            var s = d.getFullYear();
            if (str.indexOf("" + s) > -1) return d;
            d.setFullYear(d.getFullYear() + 100);
            return d;
        }
        var n = str.match(/\d+/g) || [ "2017", "2", "19", "0", "0", "0" ];
        var out = new Date(+n[0], +n[1] - 1, +n[2], +n[3] || 0, +n[4] || 0, +n[5] || 0);
        if (str.indexOf("Z") > -1) out = new Date(out.getTime() - out.getTimezoneOffset() * 60 * 1e3);
        return out;
    }
    function cc2str(arr) {
        var o = "";
        for (var i = 0; i != arr.length; ++i) o += String.fromCharCode(arr[i]);
        return o;
    }
    function dup(o) {
        if (typeof JSON != "undefined" && !Array.isArray(o)) return JSON.parse(JSON.stringify(o));
        if (typeof o != "object" || o == null) return o;
        if (o instanceof Date) return new Date(o.getTime());
        var out = {};
        for (var k in o) if (o.hasOwnProperty(k)) out[k] = dup(o[k]);
        return out;
    }
    function fill(c, l) {
        var o = "";
        while (o.length < l) o += c;
        return o;
    }
    function fuzzynum(s) {
        var v = Number(s);
        if (!isNaN(v)) return v;
        var wt = 1;
        var ss = s.replace(/([\d]),([\d])/g, "$1$2").replace(/[$]/g, "").replace(/[%]/g, function() {
            wt *= 100;
            return "";
        });
        if (!isNaN(v = Number(ss))) return v / wt;
        ss = ss.replace(/[(](.*)[)]/, function($$, $1) {
            wt = -wt;
            return $1;
        });
        if (!isNaN(v = Number(ss))) return v / wt;
        return v;
    }
    function fuzzydate(s) {
        var o = new Date(s), n = new Date(NaN);
        var y = o.getYear(), m = o.getMonth(), d = o.getDate();
        if (isNaN(d)) return n;
        if (y < 0 || y > 8099) return n;
        if ((m > 0 || d > 1) && y != 101) return o;
        if (s.toLowerCase().match(/jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec/)) return o;
        if (s.match(/[^-0-9:,\/\\]/)) return n;
        return o;
    }
    var safe_split_regex = "abacaba".split(/(:?b)/i).length == 5;
    function split_regex(str, re, def) {
        if (safe_split_regex || typeof re == "string") return str.split(re);
        var p = str.split(re), o = [ p[0] ];
        for (var i = 1; i < p.length; ++i) {
            o.push(def);
            o.push(p[i]);
        }
        return o;
    }
    function getdatastr(data) {
        if (!data) return null;
        if (data.data) return debom(data.data);
        if (data.asNodeBuffer && has_buf) return debom(data.asNodeBuffer().toString("binary"));
        if (data.asBinary) return debom(data.asBinary());
        if (data._data && data._data.getContent) return debom(cc2str(Array.prototype.slice.call(data._data.getContent(), 0)));
        return null;
    }
    function getdatabin(data) {
        if (!data) return null;
        if (data.data) return char_codes(data.data);
        if (data.asNodeBuffer && has_buf) return data.asNodeBuffer();
        if (data._data && data._data.getContent) {
            var o = data._data.getContent();
            if (typeof o == "string") return char_codes(o);
            return Array.prototype.slice.call(o);
        }
        return null;
    }
    function getdata(data) {
        return data && data.name.slice(-4) === ".bin" ? getdatabin(data) : getdatastr(data);
    }
    function safegetzipfile(zip, file) {
        var k = keys(zip.files);
        var f = file.toLowerCase(), g = f.replace(/\//g, "\\");
        for (var i = 0; i < k.length; ++i) {
            var n = k[i].toLowerCase();
            if (f == n || g == n) return zip.files[k[i]];
        }
        return null;
    }
    function getzipfile(zip, file) {
        var o = safegetzipfile(zip, file);
        if (o == null) throw new Error("Cannot find file " + file + " in zip");
        return o;
    }
    function getzipdata(zip, file, safe) {
        if (!safe) return getdata(getzipfile(zip, file));
        if (!file) return null;
        try {
            return getzipdata(zip, file);
        } catch (e) {
            return null;
        }
    }
    function getzipstr(zip, file, safe) {
        if (!safe) return getdatastr(getzipfile(zip, file));
        if (!file) return null;
        try {
            return getzipstr(zip, file);
        } catch (e) {
            return null;
        }
    }
    function zipentries(zip) {
        var k = keys(zip.files), o = [];
        for (var i = 0; i < k.length; ++i) if (k[i].slice(-1) != "/") o.push(k[i]);
        return o.sort();
    }
    var jszip;
    if (typeof JSZipSync !== "undefined") jszip = JSZipSync;
    if (typeof exports !== "undefined") {
        if (typeof module !== "undefined" && module.exports) {
            if (typeof jszip === "undefined") jszip = require("./jszip.js");
        }
    }
    function resolve_path(path, base) {
        var result = base.split("/");
        if (base.slice(-1) != "/") result.pop();
        var target = path.split("/");
        while (target.length !== 0) {
            var step = target.shift();
            if (step === "..") result.pop(); else if (step !== ".") result.push(step);
        }
        return result.join("/");
    }
    var XML_HEADER = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\r\n';
    var attregexg = /([^"\s?>\/]+)\s*=\s*((?:")([^"]*)(?:")|(?:')([^']*)(?:')|([^'">\s]+))/g;
    var tagregex = /<[\/\?]?[a-zA-Z0-9:]+(?:\s+[^"\s?>\/]+\s*=\s*(?:"[^"]*"|'[^']*'|[^'">\s=]+))*\s?[\/\?]?>/g;
    if (!XML_HEADER.match(tagregex)) tagregex = /<[^>]*>/g;
    var nsregex = /<\w*:/, nsregex2 = /<(\/?)\w+:/;
    function parsexmltag(tag, skip_root) {
        var z = {};
        var eq = 0, c = 0;
        for (;eq !== tag.length; ++eq) if ((c = tag.charCodeAt(eq)) === 32 || c === 10 || c === 13) break;
        if (!skip_root) z[0] = tag.slice(0, eq);
        if (eq === tag.length) return z;
        var m = tag.match(attregexg), j = 0, v = "", i = 0, q = "", cc = "", quot = 1;
        if (m) for (i = 0; i != m.length; ++i) {
            cc = m[i];
            for (c = 0; c != cc.length; ++c) if (cc.charCodeAt(c) === 61) break;
            q = cc.slice(0, c).trim();
            while (cc.charCodeAt(c + 1) == 32) ++c;
            quot = (eq = cc.charCodeAt(c + 1)) == 34 || eq == 39 ? 1 : 0;
            v = cc.slice(c + 1 + quot, cc.length - quot);
            for (j = 0; j != q.length; ++j) if (q.charCodeAt(j) === 58) break;
            if (j === q.length) {
                if (q.indexOf("_") > 0) q = q.slice(0, q.indexOf("_"));
                z[q] = v;
                z[q.toLowerCase()] = v;
            } else {
                var k = (j === 5 && q.slice(0, 5) === "xmlns" ? "xmlns" : "") + q.slice(j + 1);
                if (z[k] && q.slice(j - 3, j) == "ext") continue;
                z[k] = v;
                z[k.toLowerCase()] = v;
            }
        }
        return z;
    }
    function strip_ns(x) {
        return x.replace(nsregex2, "<$1");
    }
    var encodings = {
        "&quot;": '"',
        "&apos;": "'",
        "&gt;": ">",
        "&lt;": "<",
        "&amp;": "&"
    };
    var rencoding = evert(encodings);
    var unescapexml = function() {
        var encregex = /&(?:quot|apos|gt|lt|amp|#x?([\da-fA-F]+));/g, coderegex = /_x([\da-fA-F]{4})_/g;
        return function unescapexml(text) {
            var s = text + "", i = s.indexOf("<![CDATA[");
            if (i == -1) return s.replace(encregex, function($$, $1) {
                return encodings[$$] || String.fromCharCode(parseInt($1, $$.indexOf("x") > -1 ? 16 : 10)) || $$;
            }).replace(coderegex, function(m, c) {
                return String.fromCharCode(parseInt(c, 16));
            });
            var j = s.indexOf("]]>");
            return unescapexml(s.slice(0, i)) + s.slice(i + 9, j) + unescapexml(s.slice(j + 3));
        };
    }();
    var decregex = /[&<>'"]/g, charegex = /[\u0000-\u0008\u000b-\u001f]/g;
    function escapexml(text) {
        var s = text + "";
        return s.replace(decregex, function(y) {
            return rencoding[y];
        }).replace(charegex, function(s) {
            return "_x" + ("000" + s.charCodeAt(0).toString(16)).slice(-4) + "_";
        });
    }
    function escapexmltag(text) {
        return escapexml(text).replace(/ /g, "_x0020_");
    }
    var htmlcharegex = /[\u0000-\u001f]/g;
    function escapehtml(text) {
        var s = text + "";
        return s.replace(decregex, function(y) {
            return rencoding[y];
        }).replace(/\n/g, "<br/>").replace(htmlcharegex, function(s) {
            return "&#x" + ("000" + s.charCodeAt(0).toString(16)).slice(-4) + ";";
        });
    }
    function escapexlml(text) {
        var s = text + "";
        return s.replace(decregex, function(y) {
            return rencoding[y];
        }).replace(htmlcharegex, function(s) {
            return "&#x" + s.charCodeAt(0).toString(16).toUpperCase() + ";";
        });
    }
    var xlml_fixstr = function() {
        var entregex = /&#(\d+);/g;
        function entrepl($$, $1) {
            return String.fromCharCode(parseInt($1, 10));
        }
        return function xlml_fixstr(str) {
            return str.replace(entregex, entrepl);
        };
    }();
    var xlml_unfixstr = function() {
        return function xlml_unfixstr(str) {
            return str.replace(/(\r\n|[\r\n])/g, "&#10;");
        };
    }();
    function parsexmlbool(value) {
        switch (value) {
          case 1:
          case true:
          case "1":
          case "true":
          case "TRUE":
            return true;

          default:
            return false;
        }
    }
    var utf8read = function utf8reada(orig) {
        var out = "", i = 0, c = 0, d = 0, e = 0, f = 0, w = 0;
        while (i < orig.length) {
            c = orig.charCodeAt(i++);
            if (c < 128) {
                out += String.fromCharCode(c);
                continue;
            }
            d = orig.charCodeAt(i++);
            if (c > 191 && c < 224) {
                f = (c & 31) << 6;
                f |= d & 63;
                out += String.fromCharCode(f);
                continue;
            }
            e = orig.charCodeAt(i++);
            if (c < 240) {
                out += String.fromCharCode((c & 15) << 12 | (d & 63) << 6 | e & 63);
                continue;
            }
            f = orig.charCodeAt(i++);
            w = ((c & 7) << 18 | (d & 63) << 12 | (e & 63) << 6 | f & 63) - 65536;
            out += String.fromCharCode(55296 + (w >>> 10 & 1023));
            out += String.fromCharCode(56320 + (w & 1023));
        }
        return out;
    };
    var utf8write = function(orig) {
        var out = [], i = 0, c = 0, d = 0;
        while (i < orig.length) {
            c = orig.charCodeAt(i++);
            switch (true) {
              case c < 128:
                out.push(String.fromCharCode(c));
                break;

              case c < 2048:
                out.push(String.fromCharCode(192 + (c >> 6)));
                out.push(String.fromCharCode(128 + (c & 63)));
                break;

              case c >= 55296 && c < 57344:
                c -= 55296;
                d = orig.charCodeAt(i++) - 56320 + (c << 10);
                out.push(String.fromCharCode(240 + (d >> 18 & 7)));
                out.push(String.fromCharCode(144 + (d >> 12 & 63)));
                out.push(String.fromCharCode(128 + (d >> 6 & 63)));
                out.push(String.fromCharCode(128 + (d & 63)));
                break;

              default:
                out.push(String.fromCharCode(224 + (c >> 12)));
                out.push(String.fromCharCode(128 + (c >> 6 & 63)));
                out.push(String.fromCharCode(128 + (c & 63)));
            }
        }
        return out.join("");
    };
    if (has_buf) {
        var utf8readb = function utf8readb(data) {
            var out = Buffer.alloc(2 * data.length), w, i, j = 1, k = 0, ww = 0, c;
            for (i = 0; i < data.length; i += j) {
                j = 1;
                if ((c = data.charCodeAt(i)) < 128) w = c; else if (c < 224) {
                    w = (c & 31) * 64 + (data.charCodeAt(i + 1) & 63);
                    j = 2;
                } else if (c < 240) {
                    w = (c & 15) * 4096 + (data.charCodeAt(i + 1) & 63) * 64 + (data.charCodeAt(i + 2) & 63);
                    j = 3;
                } else {
                    j = 4;
                    w = (c & 7) * 262144 + (data.charCodeAt(i + 1) & 63) * 4096 + (data.charCodeAt(i + 2) & 63) * 64 + (data.charCodeAt(i + 3) & 63);
                    w -= 65536;
                    ww = 55296 + (w >>> 10 & 1023);
                    w = 56320 + (w & 1023);
                }
                if (ww !== 0) {
                    out[k++] = ww & 255;
                    out[k++] = ww >>> 8;
                    ww = 0;
                }
                out[k++] = w % 256;
                out[k++] = w >>> 8;
            }
            return out.slice(0, k).toString("ucs2");
        };
        var corpus = "foo bar baz\xe2\x98\x83\xf0\x9f\x8d\xa3";
        if (utf8read(corpus) == utf8readb(corpus)) utf8read = utf8readb;
        var utf8readc = function utf8readc(data) {
            return Buffer_from(data, "binary").toString("utf8");
        };
        if (utf8read(corpus) == utf8readc(corpus)) utf8read = utf8readc;
        utf8write = function(data) {
            return Buffer_from(data, "utf8").toString("binary");
        };
    }
    var matchtag = function() {
        var mtcache = {};
        return function matchtag(f, g) {
            var t = f + "|" + (g || "");
            if (mtcache[t]) return mtcache[t];
            return mtcache[t] = new RegExp("<(?:\\w+:)?" + f + '(?: xml:space="preserve")?(?:[^>]*)>([\\s\\S]*?)</(?:\\w+:)?' + f + ">", g || "");
        };
    }();
    var htmldecode = function() {
        var entities = [ [ "nbsp", " " ], [ "middot", "\xb7" ], [ "quot", '"' ], [ "apos", "'" ], [ "gt", ">" ], [ "lt", "<" ], [ "amp", "&" ] ].map(function(x) {
            return [ new RegExp("&" + x[0] + ";", "g"), x[1] ];
        });
        return function htmldecode(str) {
            var o = str.replace(/^[\t\n\r ]+/, "").replace(/[\t\n\r ]+$/, "").replace(/[\t\n\r ]+/g, " ").replace(/<\s*[bB][rR]\s*\/?>/g, "\n").replace(/<[^>]*>/g, "");
            for (var i = 0; i < entities.length; ++i) o = o.replace(entities[i][0], entities[i][1]);
            return o;
        };
    }();
    var vtregex = function() {
        var vt_cache = {};
        return function vt_regex(bt) {
            if (vt_cache[bt] !== undefined) return vt_cache[bt];
            return vt_cache[bt] = new RegExp("<(?:vt:)?" + bt + ">([\\s\\S]*?)</(?:vt:)?" + bt + ">", "g");
        };
    }();
    var vtvregex = /<\/?(?:vt:)?variant>/g, vtmregex = /<(?:vt:)([^>]*)>([\s\S]*)</;
    function parseVector(data, opts) {
        var h = parsexmltag(data);
        var matches = data.match(vtregex(h.baseType)) || [];
        var res = [];
        if (matches.length != h.size) {
            if (opts.WTF) throw new Error("unexpected vector length " + matches.length + " != " + h.size);
            return res;
        }
        matches.forEach(function(x) {
            var v = x.replace(vtvregex, "").match(vtmregex);
            if (v) res.push({
                "v": utf8read(v[2]),
                "t": v[1]
            });
        });
        return res;
    }
    var wtregex = /(^\s|\s$|\n)/;
    function writetag(f, g) {
        return "<" + f + (g.match(wtregex) ? ' xml:space="preserve"' : "") + ">" + g + "</" + f + ">";
    }
    function wxt_helper(h) {
        return keys(h).map(function(k) {
            return " " + k + '="' + h[k] + '"';
        }).join("");
    }
    function writextag(f, g, h) {
        return "<" + f + (h != null ? wxt_helper(h) : "") + (g != null ? (g.match(wtregex) ? ' xml:space="preserve"' : "") + ">" + g + "</" + f : "/") + ">";
    }
    function write_w3cdtf(d, t) {
        try {
            return d.toISOString().replace(/\.\d*/, "");
        } catch (e) {
            if (t) throw e;
        }
        return "";
    }
    function write_vt(s) {
        switch (typeof s) {
          case "string":
            return writextag("vt:lpwstr", s);

          case "number":
            return writextag((s | 0) == s ? "vt:i4" : "vt:r8", String(s));

          case "boolean":
            return writextag("vt:bool", s ? "true" : "false");
        }
        if (s instanceof Date) return writextag("vt:filetime", write_w3cdtf(s));
        throw new Error("Unable to serialize " + s);
    }
    var XMLNS = {
        "dc": "http://purl.org/dc/elements/1.1/",
        "dcterms": "http://purl.org/dc/terms/",
        "dcmitype": "http://purl.org/dc/dcmitype/",
        "mx": "http://schemas.microsoft.com/office/mac/excel/2008/main",
        "r": "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
        "sjs": "http://schemas.openxmlformats.org/package/2006/sheetjs/core-properties",
        "vt": "http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes",
        "xsi": "http://www.w3.org/2001/XMLSchema-instance",
        "xsd": "http://www.w3.org/2001/XMLSchema"
    };
    XMLNS.main = [ "http://schemas.openxmlformats.org/spreadsheetml/2006/main", "http://purl.oclc.org/ooxml/spreadsheetml/main", "http://schemas.microsoft.com/office/excel/2006/main", "http://schemas.microsoft.com/office/excel/2006/2" ];
    var XLMLNS = {
        "o": "urn:schemas-microsoft-com:office:office",
        "x": "urn:schemas-microsoft-com:office:excel",
        "ss": "urn:schemas-microsoft-com:office:spreadsheet",
        "dt": "uuid:C2F41010-65B3-11d1-A29F-00AA00C14882",
        "mv": "http://macVmlSchemaUri",
        "v": "urn:schemas-microsoft-com:vml",
        "html": "http://www.w3.org/TR/REC-html40"
    };
    function read_double_le(b, idx) {
        var s = 1 - 2 * (b[idx + 7] >>> 7);
        var e = ((b[idx + 7] & 127) << 4) + (b[idx + 6] >>> 4 & 15);
        var m = b[idx + 6] & 15;
        for (var i = 5; i >= 0; --i) m = m * 256 + b[idx + i];
        if (e == 2047) return m == 0 ? s * Infinity : NaN;
        if (e == 0) e = -1022; else {
            e -= 1023;
            m += Math.pow(2, 52);
        }
        return s * Math.pow(2, e - 52) * m;
    }
    function write_double_le(b, v, idx) {
        var bs = (v < 0 || 1 / v == -Infinity ? 1 : 0) << 7, e = 0, m = 0;
        var av = bs ? -v : v;
        if (!isFinite(av)) {
            e = 2047;
            m = isNaN(v) ? 26985 : 0;
        } else if (av == 0) e = m = 0; else {
            e = Math.floor(Math.log(av) / Math.LN2);
            m = av * Math.pow(2, 52 - e);
            if (e <= -1023 && (!isFinite(m) || m < Math.pow(2, 52))) {
                e = -1022;
            } else {
                m -= Math.pow(2, 52);
                e += 1023;
            }
        }
        for (var i = 0; i <= 5; ++i, m /= 256) b[idx + i] = m & 255;
        b[idx + 6] = (e & 15) << 4 | m & 15;
        b[idx + 7] = e >> 4 | bs;
    }
    var __toBuffer = function(bufs) {
        var x = [], w = 10240;
        for (var i = 0; i < bufs[0].length; ++i) if (bufs[0][i]) for (var j = 0, L = bufs[0][i].length; j < L; j += w) x.push.apply(x, bufs[0][i].slice(j, j + w));
        return x;
    };
    var ___toBuffer = __toBuffer;
    var __utf16le = function(b, s, e) {
        var ss = [];
        for (var i = s; i < e; i += 2) ss.push(String.fromCharCode(__readUInt16LE(b, i)));
        return ss.join("").replace(chr0, "");
    };
    var ___utf16le = __utf16le;
    var __hexlify = function(b, s, l) {
        var ss = [];
        for (var i = s; i < s + l; ++i) ss.push(("0" + b[i].toString(16)).slice(-2));
        return ss.join("");
    };
    var ___hexlify = __hexlify;
    var __utf8 = function(b, s, e) {
        var ss = [];
        for (var i = s; i < e; i++) ss.push(String.fromCharCode(__readUInt8(b, i)));
        return ss.join("");
    };
    var ___utf8 = __utf8;
    var __lpstr = function(b, i) {
        var len = __readUInt32LE(b, i);
        return len > 0 ? __utf8(b, i + 4, i + 4 + len - 1) : "";
    };
    var ___lpstr = __lpstr;
    var __cpstr = function(b, i) {
        var len = __readUInt32LE(b, i);
        return len > 0 ? __utf8(b, i + 4, i + 4 + len - 1) : "";
    };
    var ___cpstr = __cpstr;
    var __lpwstr = function(b, i) {
        var len = 2 * __readUInt32LE(b, i);
        return len > 0 ? __utf8(b, i + 4, i + 4 + len - 1) : "";
    };
    var ___lpwstr = __lpwstr;
    var __lpp4, ___lpp4;
    __lpp4 = ___lpp4 = function lpp4_(b, i) {
        var len = __readUInt32LE(b, i);
        return len > 0 ? __utf16le(b, i + 4, i + 4 + len) : "";
    };
    var __8lpp4 = function(b, i) {
        var len = __readUInt32LE(b, i);
        return len > 0 ? __utf8(b, i + 4, i + 4 + len) : "";
    };
    var ___8lpp4 = __8lpp4;
    var __double, ___double;
    __double = ___double = function(b, idx) {
        return read_double_le(b, idx);
    };
    var is_buf = function is_buf_a(a) {
        return Array.isArray(a);
    };
    if (has_buf) {
        __utf16le = function(b, s, e) {
            if (!Buffer.isBuffer(b)) return ___utf16le(b, s, e);
            return b.toString("utf16le", s, e).replace(chr0, "");
        };
        __hexlify = function(b, s, l) {
            return Buffer.isBuffer(b) ? b.toString("hex", s, s + l) : ___hexlify(b, s, l);
        };
        __lpstr = function lpstr_b(b, i) {
            if (!Buffer.isBuffer(b)) return ___lpstr(b, i);
            var len = b.readUInt32LE(i);
            return len > 0 ? b.toString("utf8", i + 4, i + 4 + len - 1) : "";
        };
        __cpstr = function cpstr_b(b, i) {
            if (!Buffer.isBuffer(b)) return ___cpstr(b, i);
            var len = b.readUInt32LE(i);
            return len > 0 ? b.toString("utf8", i + 4, i + 4 + len - 1) : "";
        };
        __lpwstr = function lpwstr_b(b, i) {
            if (!Buffer.isBuffer(b)) return ___lpwstr(b, i);
            var len = 2 * b.readUInt32LE(i);
            return b.toString("utf16le", i + 4, i + 4 + len - 1);
        };
        __lpp4 = function lpp4_b(b, i) {
            if (!Buffer.isBuffer(b)) return ___lpp4(b, i);
            var len = b.readUInt32LE(i);
            return b.toString("utf16le", i + 4, i + 4 + len);
        };
        __8lpp4 = function lpp4_8b(b, i) {
            if (!Buffer.isBuffer(b)) return ___8lpp4(b, i);
            var len = b.readUInt32LE(i);
            return b.toString("utf8", i + 4, i + 4 + len);
        };
        __utf8 = function utf8_b(b, s, e) {
            return Buffer.isBuffer(b) ? b.toString("utf8", s, e) : ___utf8(b, s, e);
        };
        __toBuffer = function(bufs) {
            return bufs[0].length > 0 && Buffer.isBuffer(bufs[0][0]) ? Buffer.concat(bufs[0]) : ___toBuffer(bufs);
        };
        bconcat = function(bufs) {
            return Buffer.isBuffer(bufs[0]) ? Buffer.concat(bufs) : [].concat.apply([], bufs);
        };
        __double = function double_(b, i) {
            if (Buffer.isBuffer(b)) return b.readDoubleLE(i);
            return ___double(b, i);
        };
        is_buf = function is_buf_b(a) {
            return Buffer.isBuffer(a) || Array.isArray(a);
        };
    }
    if (typeof cptable !== "undefined") {
        __utf16le = function(b, s, e) {
            return cptable.utils.decode(1200, b.slice(s, e)).replace(chr0, "");
        };
        __utf8 = function(b, s, e) {
            return cptable.utils.decode(65001, b.slice(s, e));
        };
        __lpstr = function(b, i) {
            var len = __readUInt32LE(b, i);
            return len > 0 ? cptable.utils.decode(current_ansi, b.slice(i + 4, i + 4 + len - 1)) : "";
        };
        __cpstr = function(b, i) {
            var len = __readUInt32LE(b, i);
            return len > 0 ? cptable.utils.decode(current_codepage, b.slice(i + 4, i + 4 + len - 1)) : "";
        };
        __lpwstr = function(b, i) {
            var len = 2 * __readUInt32LE(b, i);
            return len > 0 ? cptable.utils.decode(1200, b.slice(i + 4, i + 4 + len - 1)) : "";
        };
        __lpp4 = function(b, i) {
            var len = __readUInt32LE(b, i);
            return len > 0 ? cptable.utils.decode(1200, b.slice(i + 4, i + 4 + len)) : "";
        };
        __8lpp4 = function(b, i) {
            var len = __readUInt32LE(b, i);
            return len > 0 ? cptable.utils.decode(65001, b.slice(i + 4, i + 4 + len)) : "";
        };
    }
    var __readUInt8 = function(b, idx) {
        return b[idx];
    };
    var __readUInt16LE = function(b, idx) {
        return b[idx + 1] * (1 << 8) + b[idx];
    };
    var __readInt16LE = function(b, idx) {
        var u = b[idx + 1] * (1 << 8) + b[idx];
        return u < 32768 ? u : (65535 - u + 1) * -1;
    };
    var __readUInt32LE = function(b, idx) {
        return b[idx + 3] * (1 << 24) + (b[idx + 2] << 16) + (b[idx + 1] << 8) + b[idx];
    };
    var __readInt32LE = function(b, idx) {
        return b[idx + 3] << 24 | b[idx + 2] << 16 | b[idx + 1] << 8 | b[idx];
    };
    var __readInt32BE = function(b, idx) {
        return b[idx] << 24 | b[idx + 1] << 16 | b[idx + 2] << 8 | b[idx + 3];
    };
    function ReadShift(size, t) {
        var o = "", oI, oR, oo = [], w, vv, i, loc;
        switch (t) {
          case "dbcs":
            loc = this.l;
            if (has_buf && Buffer.isBuffer(this)) o = this.slice(this.l, this.l + 2 * size).toString("utf16le"); else for (i = 0; i < size; ++i) {
                o += String.fromCharCode(__readUInt16LE(this, loc));
                loc += 2;
            }
            size *= 2;
            break;

          case "utf8":
            o = __utf8(this, this.l, this.l + size);
            break;

          case "utf16le":
            size *= 2;
            o = __utf16le(this, this.l, this.l + size);
            break;

          case "wstr":
            if (typeof cptable !== "undefined") o = cptable.utils.decode(current_codepage, this.slice(this.l, this.l + 2 * size)); else return ReadShift.call(this, size, "dbcs");
            size = 2 * size;
            break;

          case "lpstr-ansi":
            o = __lpstr(this, this.l);
            size = 4 + __readUInt32LE(this, this.l);
            break;

          case "lpstr-cp":
            o = __cpstr(this, this.l);
            size = 4 + __readUInt32LE(this, this.l);
            break;

          case "lpwstr":
            o = __lpwstr(this, this.l);
            size = 4 + 2 * __readUInt32LE(this, this.l);
            break;

          case "lpp4":
            size = 4 + __readUInt32LE(this, this.l);
            o = __lpp4(this, this.l);
            if (size & 2) size += 2;
            break;

          case "8lpp4":
            size = 4 + __readUInt32LE(this, this.l);
            o = __8lpp4(this, this.l);
            if (size & 3) size += 4 - (size & 3);
            break;

          case "cstr":
            size = 0;
            o = "";
            while ((w = __readUInt8(this, this.l + size++)) !== 0) oo.push(_getchar(w));
            o = oo.join("");
            break;

          case "_wstr":
            size = 0;
            o = "";
            while ((w = __readUInt16LE(this, this.l + size)) !== 0) {
                oo.push(_getchar(w));
                size += 2;
            }
            size += 2;
            o = oo.join("");
            break;

          case "dbcs-cont":
            o = "";
            loc = this.l;
            for (i = 0; i < size; ++i) {
                if (this.lens && this.lens.indexOf(loc) !== -1) {
                    w = __readUInt8(this, loc);
                    this.l = loc + 1;
                    vv = ReadShift.call(this, size - i, w ? "dbcs-cont" : "sbcs-cont");
                    return oo.join("") + vv;
                }
                oo.push(_getchar(__readUInt16LE(this, loc)));
                loc += 2;
            }
            o = oo.join("");
            size *= 2;
            break;

          case "cpstr":
            if (typeof cptable !== "undefined") {
                o = cptable.utils.decode(current_codepage, this.slice(this.l, this.l + size));
                break;
            }

          case "sbcs-cont":
            o = "";
            loc = this.l;
            for (i = 0; i != size; ++i) {
                if (this.lens && this.lens.indexOf(loc) !== -1) {
                    w = __readUInt8(this, loc);
                    this.l = loc + 1;
                    vv = ReadShift.call(this, size - i, w ? "dbcs-cont" : "sbcs-cont");
                    return oo.join("") + vv;
                }
                oo.push(_getchar(__readUInt8(this, loc)));
                loc += 1;
            }
            o = oo.join("");
            break;

          default:
            switch (size) {
              case 1:
                oI = __readUInt8(this, this.l);
                this.l++;
                return oI;

              case 2:
                oI = (t === "i" ? __readInt16LE : __readUInt16LE)(this, this.l);
                this.l += 2;
                return oI;

              case 4:
              case -4:
                if (t === "i" || (this[this.l + 3] & 128) === 0) {
                    oI = (size > 0 ? __readInt32LE : __readInt32BE)(this, this.l);
                    this.l += 4;
                    return oI;
                } else {
                    oR = __readUInt32LE(this, this.l);
                    this.l += 4;
                }
                return oR;

              case 8:
              case -8:
                if (t === "f") {
                    if (size == 8) oR = __double(this, this.l); else oR = __double([ this[this.l + 7], this[this.l + 6], this[this.l + 5], this[this.l + 4], this[this.l + 3], this[this.l + 2], this[this.l + 1], this[this.l + 0] ], 0);
                    this.l += 8;
                    return oR;
                } else size = 8;

              case 16:
                o = __hexlify(this, this.l, size);
                break;
            }
        }
        this.l += size;
        return o;
    }
    var __writeUInt32LE = function(b, val, idx) {
        b[idx] = val & 255;
        b[idx + 1] = val >>> 8 & 255;
        b[idx + 2] = val >>> 16 & 255;
        b[idx + 3] = val >>> 24 & 255;
    };
    var __writeInt32LE = function(b, val, idx) {
        b[idx] = val & 255;
        b[idx + 1] = val >> 8 & 255;
        b[idx + 2] = val >> 16 & 255;
        b[idx + 3] = val >> 24 & 255;
    };
    var __writeUInt16LE = function(b, val, idx) {
        b[idx] = val & 255;
        b[idx + 1] = val >>> 8 & 255;
    };
    function WriteShift(t, val, f) {
        var size = 0, i = 0;
        if (f === "dbcs") {
            for (i = 0; i != val.length; ++i) __writeUInt16LE(this, val.charCodeAt(i), this.l + 2 * i);
            size = 2 * val.length;
        } else if (f === "sbcs") {
            val = val.replace(/[^\x00-\x7F]/g, "_");
            for (i = 0; i != val.length; ++i) this[this.l + i] = val.charCodeAt(i) & 255;
            size = val.length;
        } else if (f === "hex") {
            for (;i < t; ++i) {
                this[this.l++] = parseInt(val.slice(2 * i, 2 * i + 2), 16) || 0;
            }
            return this;
        } else if (f === "utf16le") {
            var end = Math.min(this.l + t, this.length);
            for (i = 0; i < Math.min(val.length, t); ++i) {
                var cc = val.charCodeAt(i);
                this[this.l++] = cc & 255;
                this[this.l++] = cc >> 8;
            }
            while (this.l < end) this[this.l++] = 0;
            return this;
        } else switch (t) {
          case 1:
            size = 1;
            this[this.l] = val & 255;
            break;

          case 2:
            size = 2;
            this[this.l] = val & 255;
            val >>>= 8;
            this[this.l + 1] = val & 255;
            break;

          case 3:
            size = 3;
            this[this.l] = val & 255;
            val >>>= 8;
            this[this.l + 1] = val & 255;
            val >>>= 8;
            this[this.l + 2] = val & 255;
            break;

          case 4:
            size = 4;
            __writeUInt32LE(this, val, this.l);
            break;

          case 8:
            size = 8;
            if (f === "f") {
                write_double_le(this, val, this.l);
                break;
            }

          case 16:
            break;

          case -4:
            size = 4;
            __writeInt32LE(this, val, this.l);
            break;
        }
        this.l += size;
        return this;
    }
    function CheckField(hexstr, fld) {
        var m = __hexlify(this, this.l, hexstr.length >> 1);
        if (m !== hexstr) throw new Error(fld + "Expected " + hexstr + " saw " + m);
        this.l += hexstr.length >> 1;
    }
    function prep_blob(blob, pos) {
        blob.l = pos;
        blob.read_shift = ReadShift;
        blob.chk = CheckField;
        blob.write_shift = WriteShift;
    }
    function parsenoop(blob, length) {
        blob.l += length;
    }
    function new_buf(sz) {
        var o = new_raw_buf(sz);
        prep_blob(o, 0);
        return o;
    }
    function recordhopper(data, cb, opts) {
        if (!data) return;
        var tmpbyte, cntbyte, length;
        prep_blob(data, data.l || 0);
        var L = data.length, RT = 0, tgt = 0;
        while (data.l < L) {
            RT = data.read_shift(1);
            if (RT & 128) RT = (RT & 127) + ((data.read_shift(1) & 127) << 7);
            var R = XLSBRecordEnum[RT] || XLSBRecordEnum[65535];
            tmpbyte = data.read_shift(1);
            length = tmpbyte & 127;
            for (cntbyte = 1; cntbyte < 4 && tmpbyte & 128; ++cntbyte) length += ((tmpbyte = data.read_shift(1)) & 127) << 7 * cntbyte;
            tgt = data.l + length;
            var d = (R.f || parsenoop)(data, length, opts);
            data.l = tgt;
            if (cb(d, R.n, RT)) return;
        }
    }
    function buf_array() {
        var bufs = [], blksz = has_buf ? 256 : 2048;
        var newblk = function ba_newblk(sz) {
            var o = new_buf(sz);
            prep_blob(o, 0);
            return o;
        };
        var curbuf = newblk(blksz);
        var endbuf = function ba_endbuf() {
            if (!curbuf) return;
            if (curbuf.length > curbuf.l) {
                curbuf = curbuf.slice(0, curbuf.l);
                curbuf.l = curbuf.length;
            }
            if (curbuf.length > 0) bufs.push(curbuf);
            curbuf = null;
        };
        var next = function ba_next(sz) {
            if (curbuf && sz < curbuf.length - curbuf.l) return curbuf;
            endbuf();
            return curbuf = newblk(Math.max(sz + 1, blksz));
        };
        var end = function ba_end() {
            endbuf();
            return __toBuffer([ bufs ]);
        };
        var push = function ba_push(buf) {
            endbuf();
            curbuf = buf;
            if (curbuf.l == null) curbuf.l = curbuf.length;
            next(blksz);
        };
        return {
            "next": next,
            "push": push,
            "end": end,
            "_bufs": bufs
        };
    }
    function write_record(ba, type, payload, length) {
        var t = +XLSBRE[type], l;
        if (isNaN(t)) return;
        if (!length) length = XLSBRecordEnum[t].p || (payload || []).length || 0;
        l = 1 + (t >= 128 ? 1 : 0) + 1;
        if (length >= 128) ++l;
        if (length >= 16384) ++l;
        if (length >= 2097152) ++l;
        var o = ba.next(l);
        if (t <= 127) o.write_shift(1, t); else {
            o.write_shift(1, (t & 127) + 128);
            o.write_shift(1, t >> 7);
        }
        for (var i = 0; i != 4; ++i) {
            if (length >= 128) {
                o.write_shift(1, (length & 127) + 128);
                length >>= 7;
            } else {
                o.write_shift(1, length);
                break;
            }
        }
        if (length > 0 && is_buf(payload)) ba.push(payload);
    }
    function shift_cell_xls(cell, tgt, opts) {
        var out = dup(cell);
        if (tgt.s) {
            if (out.cRel) out.c += tgt.s.c;
            if (out.rRel) out.r += tgt.s.r;
        } else {
            if (out.cRel) out.c += tgt.c;
            if (out.rRel) out.r += tgt.r;
        }
        if (!opts || opts.biff < 12) {
            while (out.c >= 256) out.c -= 256;
            while (out.r >= 65536) out.r -= 65536;
        }
        return out;
    }
    function shift_range_xls(cell, range, opts) {
        var out = dup(cell);
        out.s = shift_cell_xls(out.s, range.s, opts);
        out.e = shift_cell_xls(out.e, range.s, opts);
        return out;
    }
    function encode_cell_xls(c, biff) {
        if (c.cRel && c.c < 0) {
            c = dup(c);
            c.c += biff > 8 ? 16384 : 256;
        }
        if (c.rRel && c.r < 0) {
            c = dup(c);
            c.r += biff > 8 ? 1048576 : biff > 5 ? 65536 : 16384;
        }
        var s = encode_cell(c);
        if (c.cRel === 0) s = fix_col(s);
        if (c.rRel === 0) s = fix_row(s);
        return s;
    }
    function encode_range_xls(r, opts) {
        if (r.s.r == 0 && !r.s.rRel) {
            if (r.e.r == (opts.biff >= 12 ? 1048575 : opts.biff >= 8 ? 65536 : 16384) && !r.e.rRel) {
                return (r.s.cRel ? "" : "$") + encode_col(r.s.c) + ":" + (r.e.cRel ? "" : "$") + encode_col(r.e.c);
            }
        }
        if (r.s.c == 0 && !r.s.cRel) {
            if (r.e.c == (opts.biff >= 12 ? 65535 : 255) && !r.e.cRel) {
                return (r.s.rRel ? "" : "$") + encode_row(r.s.r) + ":" + (r.e.rRel ? "" : "$") + encode_row(r.e.r);
            }
        }
        return encode_cell_xls(r.s, opts.biff) + ":" + encode_cell_xls(r.e, opts.biff);
    }
    var OFFCRYPTO = {};
    var make_offcrypto = function(O, _crypto) {
        var crypto;
        if (typeof _crypto !== "undefined") crypto = _crypto; else if (typeof require !== "undefined") {
            try {
                crypto = require("crypto");
            } catch (e) {
                crypto = null;
            }
        }
        O.rc4 = function(key, data) {
            var S = new Array(256);
            var c = 0, i = 0, j = 0, t = 0;
            for (i = 0; i != 256; ++i) S[i] = i;
            for (i = 0; i != 256; ++i) {
                j = j + S[i] + key[i % key.length].charCodeAt(0) & 255;
                t = S[i];
                S[i] = S[j];
                S[j] = t;
            }
            i = j = 0;
            var out = Buffer(data.length);
            for (c = 0; c != data.length; ++c) {
                i = i + 1 & 255;
                j = (j + S[i]) % 256;
                t = S[i];
                S[i] = S[j];
                S[j] = t;
                out[c] = data[c] ^ S[S[i] + S[j] & 255];
            }
            return out;
        };
        O.md5 = function(hex) {
            if (!crypto) throw new Error("Unsupported crypto");
            return crypto.createHash("md5").update(hex).digest("hex");
        };
    };
    make_offcrypto(OFFCRYPTO, typeof crypto !== "undefined" ? crypto : undefined);
    function decode_row(rowstr) {
        return parseInt(unfix_row(rowstr), 10) - 1;
    }
    function encode_row(row) {
        return "" + (row + 1);
    }
    function fix_row(cstr) {
        return cstr.replace(/([A-Z]|^)(\d+)$/, "$1$$$2");
    }
    function unfix_row(cstr) {
        return cstr.replace(/\$(\d+)$/, "$1");
    }
    function decode_col(colstr) {
        var c = unfix_col(colstr), d = 0, i = 0;
        for (;i !== c.length; ++i) d = 26 * d + c.charCodeAt(i) - 64;
        return d - 1;
    }
    function encode_col(col) {
        var s = "";
        for (++col; col; col = Math.floor((col - 1) / 26)) s = String.fromCharCode((col - 1) % 26 + 65) + s;
        return s;
    }
    function fix_col(cstr) {
        return cstr.replace(/^([A-Z])/, "$$$1");
    }
    function unfix_col(cstr) {
        return cstr.replace(/^\$([A-Z])/, "$1");
    }
    function split_cell(cstr) {
        return cstr.replace(/(\$?[A-Z]*)(\$?\d*)/, "$1,$2").split(",");
    }
    function decode_cell(cstr) {
        var splt = split_cell(cstr);
        return {
            "c": decode_col(splt[0]),
            "r": decode_row(splt[1])
        };
    }
    function encode_cell(cell) {
        return encode_col(cell.c) + encode_row(cell.r);
    }
    function decode_range(range) {
        var x = range.split(":").map(decode_cell);
        return {
            "s": x[0],
            "e": x[x.length - 1]
        };
    }
    function encode_range(cs, ce) {
        if (typeof ce === "undefined" || typeof ce === "number") {
            return encode_range(cs.s, cs.e);
        }
        if (typeof cs !== "string") cs = encode_cell(cs);
        if (typeof ce !== "string") ce = encode_cell(ce);
        return cs == ce ? cs : cs + ":" + ce;
    }
    function safe_decode_range(range) {
        var o = {
            "s": {
                "c": 0,
                "r": 0
            },
            "e": {
                "c": 0,
                "r": 0
            }
        };
        var idx = 0, i = 0, cc = 0;
        var len = range.length;
        for (idx = 0; i < len; ++i) {
            if ((cc = range.charCodeAt(i) - 64) < 1 || cc > 26) break;
            idx = 26 * idx + cc;
        }
        o.s.c = --idx;
        for (idx = 0; i < len; ++i) {
            if ((cc = range.charCodeAt(i) - 48) < 0 || cc > 9) break;
            idx = 10 * idx + cc;
        }
        o.s.r = --idx;
        if (i === len || range.charCodeAt(++i) === 58) {
            o.e.c = o.s.c;
            o.e.r = o.s.r;
            return o;
        }
        for (idx = 0; i != len; ++i) {
            if ((cc = range.charCodeAt(i) - 64) < 1 || cc > 26) break;
            idx = 26 * idx + cc;
        }
        o.e.c = --idx;
        for (idx = 0; i != len; ++i) {
            if ((cc = range.charCodeAt(i) - 48) < 0 || cc > 9) break;
            idx = 10 * idx + cc;
        }
        o.e.r = --idx;
        return o;
    }
    function safe_format_cell(cell, v) {
        var q = cell.t == "d" && v instanceof Date;
        if (cell.z != null) try {
            return cell.w = SSF.format(cell.z, q ? datenum(v) : v);
        } catch (e) {}
        try {
            return cell.w = SSF.format((cell.XF || {}).numFmtId || (q ? 14 : 0), q ? datenum(v) : v);
        } catch (e) {
            return "" + v;
        }
    }
    function format_cell(cell, v, o) {
        if (cell == null || cell.t == null || cell.t == "z") return "";
        if (cell.w !== undefined) return cell.w;
        if (cell.t == "d" && !cell.z && o && o.dateNF) cell.z = o.dateNF;
        if (v == undefined) return safe_format_cell(cell, cell.v);
        return safe_format_cell(cell, v);
    }
    function sheet_to_workbook(sheet, opts) {
        var n = opts && opts.sheet ? opts.sheet : "Sheet1";
        var sheets = {};
        sheets[n] = sheet;
        return {
            "SheetNames": [ n ],
            "Sheets": sheets
        };
    }
    function sheet_add_aoa(_ws, data, opts) {
        var o = opts || {};
        var dense = _ws ? Array.isArray(_ws) : o.dense;
        if (DENSE != null && dense == null) dense = DENSE;
        var ws = _ws || (dense ? [] : {});
        var _R = 0, _C = 0;
        if (ws && o.origin != null) {
            if (typeof o.origin == "number") _R = o.origin; else {
                var _origin = typeof o.origin == "string" ? decode_cell(o.origin) : o.origin;
                _R = _origin.r;
                _C = _origin.c;
            }
        }
        var range = {
            "s": {
                "c": 1e7,
                "r": 1e7
            },
            "e": {
                "c": 0,
                "r": 0
            }
        };
        if (ws["!ref"]) {
            var _range = safe_decode_range(ws["!ref"]);
            range.s.c = _range.s.c;
            range.s.r = _range.s.r;
            range.e.c = Math.max(range.e.c, _range.e.c);
            range.e.r = Math.max(range.e.r, _range.e.r);
            if (_R == -1) range.e.r = _R = _range.e.r + 1;
        }
        for (var R = 0; R != data.length; ++R) {
            if (!data[R]) continue;
            if (!Array.isArray(data[R])) throw new Error("aoa_to_sheet expects an array of arrays");
            for (var C = 0; C != data[R].length; ++C) {
                if (typeof data[R][C] === "undefined") continue;
                var cell = {
                    "v": data[R][C]
                };
                if (Array.isArray(cell.v)) {
                    cell.f = data[R][C][1];
                    cell.v = cell.v[0];
                }
                var __R = _R + R, __C = _C + C;
                if (range.s.r > __R) range.s.r = __R;
                if (range.s.c > __C) range.s.c = __C;
                if (range.e.r < __R) range.e.r = __R;
                if (range.e.c < __C) range.e.c = __C;
                if (cell.v === null) {
                    if (cell.f) cell.t = "n"; else if (!o.cellStubs) continue; else cell.t = "z";
                } else if (typeof cell.v === "number") cell.t = "n"; else if (typeof cell.v === "boolean") cell.t = "b"; else if (cell.v instanceof Date) {
                    cell.z = o.dateNF || SSF._table[14];
                    if (o.cellDates) {
                        cell.t = "d";
                        cell.w = SSF.format(cell.z, datenum(cell.v));
                    } else {
                        cell.t = "n";
                        cell.v = datenum(cell.v);
                        cell.w = SSF.format(cell.z, cell.v);
                    }
                } else cell.t = "s";
                if (dense) {
                    if (!ws[__R]) ws[__R] = [];
                    ws[__R][__C] = cell;
                } else {
                    var cell_ref = encode_cell({
                        "c": __C,
                        "r": __R
                    });
                    ws[cell_ref] = cell;
                }
            }
        }
        if (range.s.c < 1e7) ws["!ref"] = encode_range(range);
        return ws;
    }
    function aoa_to_sheet(data, opts) {
        return sheet_add_aoa(null, data, opts);
    }
    function write_UInt32LE(x, o) {
        if (!o) o = new_buf(4);
        o.write_shift(4, x);
        return o;
    }
    function parse_XLWideString(data) {
        var cchCharacters = data.read_shift(4);
        return cchCharacters === 0 ? "" : data.read_shift(cchCharacters, "dbcs");
    }
    function write_XLWideString(data, o) {
        var _null = false;
        if (o == null) {
            _null = true;
            o = new_buf(4 + 2 * data.length);
        }
        o.write_shift(4, data.length);
        if (data.length > 0) o.write_shift(0, data, "dbcs");
        return _null ? o.slice(0, o.l) : o;
    }
    function parse_StrRun(data) {
        return {
            "ich": data.read_shift(2),
            "ifnt": data.read_shift(2)
        };
    }
    function write_StrRun(run, o) {
        if (!o) o = new_buf(4);
        o.write_shift(2, run.ich || 0);
        o.write_shift(2, run.ifnt || 0);
        return o;
    }
    function parse_RichStr(data, length) {
        var start = data.l;
        var flags = data.read_shift(1);
        var str = parse_XLWideString(data);
        var rgsStrRun = [];
        var z = {
            "t": str,
            "h": str
        };
        if ((flags & 1) !== 0) {
            var dwSizeStrRun = data.read_shift(4);
            for (var i = 0; i != dwSizeStrRun; ++i) rgsStrRun.push(parse_StrRun(data));
            z.r = rgsStrRun;
        } else z.r = [ {
            "ich": 0,
            "ifnt": 0
        } ];
        data.l = start + length;
        return z;
    }
    function write_RichStr(str, o) {
        var _null = false;
        if (o == null) {
            _null = true;
            o = new_buf(15 + 4 * str.t.length);
        }
        o.write_shift(1, 0);
        write_XLWideString(str.t, o);
        return _null ? o.slice(0, o.l) : o;
    }
    var parse_BrtCommentText = parse_RichStr;
    function write_BrtCommentText(str, o) {
        var _null = false;
        if (o == null) {
            _null = true;
            o = new_buf(23 + 4 * str.t.length);
        }
        o.write_shift(1, 1);
        write_XLWideString(str.t, o);
        o.write_shift(4, 1);
        write_StrRun({
            "ich": 0,
            "ifnt": 0
        }, o);
        return _null ? o.slice(0, o.l) : o;
    }
    function parse_XLSBCell(data) {
        var col = data.read_shift(4);
        var iStyleRef = data.read_shift(2);
        iStyleRef += data.read_shift(1) << 16;
        data.l++;
        return {
            "c": col,
            "iStyleRef": iStyleRef
        };
    }
    function write_XLSBCell(cell, o) {
        if (o == null) o = new_buf(8);
        o.write_shift(-4, cell.c);
        o.write_shift(3, cell.iStyleRef || cell.s);
        o.write_shift(1, 0);
        return o;
    }
    var parse_XLSBCodeName = parse_XLWideString;
    var write_XLSBCodeName = write_XLWideString;
    function parse_XLNullableWideString(data) {
        var cchCharacters = data.read_shift(4);
        return cchCharacters === 0 || cchCharacters === 4294967295 ? "" : data.read_shift(cchCharacters, "dbcs");
    }
    function write_XLNullableWideString(data, o) {
        var _null = false;
        if (o == null) {
            _null = true;
            o = new_buf(127);
        }
        o.write_shift(4, data.length > 0 ? data.length : 4294967295);
        if (data.length > 0) o.write_shift(0, data, "dbcs");
        return _null ? o.slice(0, o.l) : o;
    }
    var parse_XLNameWideString = parse_XLWideString;
    var parse_RelID = parse_XLNullableWideString;
    var write_RelID = write_XLNullableWideString;
    function parse_RkNumber(data) {
        var b = data.slice(data.l, data.l + 4);
        var fX100 = b[0] & 1, fInt = b[0] & 2;
        data.l += 4;
        b[0] &= 252;
        var RK = fInt === 0 ? __double([ 0, 0, 0, 0, b[0], b[1], b[2], b[3] ], 0) : __readInt32LE(b, 0) >> 2;
        return fX100 ? RK / 100 : RK;
    }
    function write_RkNumber(data, o) {
        if (o == null) o = new_buf(4);
        var fX100 = 0, fInt = 0, d100 = data * 100;
        if (data == (data | 0) && data >= -(1 << 29) && data < 1 << 29) {
            fInt = 1;
        } else if (d100 == (d100 | 0) && d100 >= -(1 << 29) && d100 < 1 << 29) {
            fInt = 1;
            fX100 = 1;
        }
        if (fInt) o.write_shift(-4, ((fX100 ? d100 : data) << 2) + (fX100 + 2)); else throw new Error("unsupported RkNumber " + data);
    }
    function parse_RfX(data) {
        var cell = {
            "s": {},
            "e": {}
        };
        cell.s.r = data.read_shift(4);
        cell.e.r = data.read_shift(4);
        cell.s.c = data.read_shift(4);
        cell.e.c = data.read_shift(4);
        return cell;
    }
    function write_RfX(r, o) {
        if (!o) o = new_buf(16);
        o.write_shift(4, r.s.r);
        o.write_shift(4, r.e.r);
        o.write_shift(4, r.s.c);
        o.write_shift(4, r.e.c);
        return o;
    }
    var parse_UncheckedRfX = parse_RfX;
    var write_UncheckedRfX = write_RfX;
    function parse_Xnum(data) {
        return data.read_shift(8, "f");
    }
    function write_Xnum(data, o) {
        return (o || new_buf(8)).write_shift(8, data, "f");
    }
    var BErr = {
        "0": "#NULL!",
        "7": "#DIV/0!",
        "15": "#VALUE!",
        "23": "#REF!",
        "29": "#NAME?",
        "36": "#NUM!",
        "42": "#N/A",
        "43": "#GETTING_DATA",
        "255": "#WTF?"
    };
    var RBErr = evert_num(BErr);
    function parse_BrtColor(data) {
        var out = {};
        var d = data.read_shift(1);
        var xColorType = d >>> 1;
        var index = data.read_shift(1);
        var nTS = data.read_shift(2, "i");
        var bR = data.read_shift(1);
        var bG = data.read_shift(1);
        var bB = data.read_shift(1);
        data.l++;
        switch (xColorType) {
          case 0:
            out.auto = 1;
            break;

          case 1:
            out.index = index;
            var icv = XLSIcv[index];
            if (icv) out.rgb = rgb2Hex(icv);
            break;

          case 2:
            out.rgb = rgb2Hex([ bR, bG, bB ]);
            break;

          case 3:
            out.theme = index;
            break;
        }
        if (nTS != 0) out.tint = nTS > 0 ? nTS / 32767 : nTS / 32768;
        return out;
    }
    function write_BrtColor(color, o) {
        if (!o) o = new_buf(8);
        if (!color || color.auto) {
            o.write_shift(4, 0);
            o.write_shift(4, 0);
            return o;
        }
        if (color.index) {
            o.write_shift(1, 2);
            o.write_shift(1, color.index);
        } else if (color.theme) {
            o.write_shift(1, 6);
            o.write_shift(1, color.theme);
        } else {
            o.write_shift(1, 5);
            o.write_shift(1, 0);
        }
        var nTS = color.tint || 0;
        if (nTS > 0) nTS *= 32767; else if (nTS < 0) nTS *= 32768;
        o.write_shift(2, nTS);
        if (!color.rgb) {
            o.write_shift(2, 0);
            o.write_shift(1, 0);
            o.write_shift(1, 0);
        } else {
            var rgb = color.rgb || "FFFFFF";
            o.write_shift(1, parseInt(rgb.slice(0, 2), 16));
            o.write_shift(1, parseInt(rgb.slice(2, 4), 16));
            o.write_shift(1, parseInt(rgb.slice(4, 6), 16));
            o.write_shift(1, 255);
        }
        return o;
    }
    function parse_FontFlags(data) {
        var d = data.read_shift(1);
        data.l++;
        var out = {
            "fItalic": d & 2,
            "fStrikeout": d & 8,
            "fOutline": d & 16,
            "fShadow": d & 32,
            "fCondense": d & 64,
            "fExtend": d & 128
        };
        return out;
    }
    function write_FontFlags(font, o) {
        if (!o) o = new_buf(2);
        var grbit = (font.italic ? 2 : 0) | (font.strike ? 8 : 0) | (font.outline ? 16 : 0) | (font.shadow ? 32 : 0) | (font.condense ? 64 : 0) | (font.extend ? 128 : 0);
        o.write_shift(1, grbit);
        o.write_shift(1, 0);
        return o;
    }
    function parse_ClipboardFormatOrString(o, w) {
        var ClipFmt = {
            "2": "BITMAP",
            "3": "METAFILEPICT",
            "8": "DIB",
            "14": "ENHMETAFILE"
        };
        var m = o.read_shift(4);
        switch (m) {
          case 0:
            return "";

          case 4294967295:
          case 4294967294:
            return ClipFmt[o.read_shift(4)] || "";
        }
        if (m > 400) throw new Error("Unsupported Clipboard: " + m.toString(16));
        o.l -= 4;
        return o.read_shift(0, w == 1 ? "lpstr" : "lpwstr");
    }
    function parse_ClipboardFormatOrAnsiString(o) {
        return parse_ClipboardFormatOrString(o, 1);
    }
    function parse_ClipboardFormatOrUnicodeString(o) {
        return parse_ClipboardFormatOrString(o, 2);
    }
    var VT_I2 = 2;
    var VT_I4 = 3;
    var VT_BOOL = 11;
    var VT_VARIANT = 12;
    var VT_UI4 = 19;
    var VT_LPSTR = 30;
    var VT_FILETIME = 64;
    var VT_BLOB = 65;
    var VT_CF = 71;
    var VT_VECTOR = 4096;
    var VT_STRING = 80;
    var VT_USTR = 81;
    var VT_CUSTOM = [ VT_STRING, VT_USTR ];
    var DocSummaryPIDDSI = {
        "1": {
            "n": "CodePage",
            "t": VT_I2
        },
        "2": {
            "n": "Category",
            "t": VT_STRING
        },
        "3": {
            "n": "PresentationFormat",
            "t": VT_STRING
        },
        "4": {
            "n": "ByteCount",
            "t": VT_I4
        },
        "5": {
            "n": "LineCount",
            "t": VT_I4
        },
        "6": {
            "n": "ParagraphCount",
            "t": VT_I4
        },
        "7": {
            "n": "SlideCount",
            "t": VT_I4
        },
        "8": {
            "n": "NoteCount",
            "t": VT_I4
        },
        "9": {
            "n": "HiddenCount",
            "t": VT_I4
        },
        "10": {
            "n": "MultimediaClipCount",
            "t": VT_I4
        },
        "11": {
            "n": "ScaleCrop",
            "t": VT_BOOL
        },
        "12": {
            "n": "HeadingPairs",
            "t": VT_VECTOR | VT_VARIANT
        },
        "13": {
            "n": "TitlesOfParts",
            "t": VT_VECTOR | VT_LPSTR
        },
        "14": {
            "n": "Manager",
            "t": VT_STRING
        },
        "15": {
            "n": "Company",
            "t": VT_STRING
        },
        "16": {
            "n": "LinksUpToDate",
            "t": VT_BOOL
        },
        "17": {
            "n": "CharacterCount",
            "t": VT_I4
        },
        "19": {
            "n": "SharedDoc",
            "t": VT_BOOL
        },
        "22": {
            "n": "HyperlinksChanged",
            "t": VT_BOOL
        },
        "23": {
            "n": "AppVersion",
            "t": VT_I4,
            "p": "version"
        },
        "24": {
            "n": "DigSig",
            "t": VT_BLOB
        },
        "26": {
            "n": "ContentType",
            "t": VT_STRING
        },
        "27": {
            "n": "ContentStatus",
            "t": VT_STRING
        },
        "28": {
            "n": "Language",
            "t": VT_STRING
        },
        "29": {
            "n": "Version",
            "t": VT_STRING
        },
        "255": {}
    };
    var SummaryPIDSI = {
        "1": {
            "n": "CodePage",
            "t": VT_I2
        },
        "2": {
            "n": "Title",
            "t": VT_STRING
        },
        "3": {
            "n": "Subject",
            "t": VT_STRING
        },
        "4": {
            "n": "Author",
            "t": VT_STRING
        },
        "5": {
            "n": "Keywords",
            "t": VT_STRING
        },
        "6": {
            "n": "Comments",
            "t": VT_STRING
        },
        "7": {
            "n": "Template",
            "t": VT_STRING
        },
        "8": {
            "n": "LastAuthor",
            "t": VT_STRING
        },
        "9": {
            "n": "RevNumber",
            "t": VT_STRING
        },
        "10": {
            "n": "EditTime",
            "t": VT_FILETIME
        },
        "11": {
            "n": "LastPrinted",
            "t": VT_FILETIME
        },
        "12": {
            "n": "CreatedDate",
            "t": VT_FILETIME
        },
        "13": {
            "n": "ModifiedDate",
            "t": VT_FILETIME
        },
        "14": {
            "n": "PageCount",
            "t": VT_I4
        },
        "15": {
            "n": "WordCount",
            "t": VT_I4
        },
        "16": {
            "n": "CharCount",
            "t": VT_I4
        },
        "17": {
            "n": "Thumbnail",
            "t": VT_CF
        },
        "18": {
            "n": "Application",
            "t": VT_STRING
        },
        "19": {
            "n": "DocSecurity",
            "t": VT_I4
        },
        "255": {}
    };
    var SpecialProperties = {
        "2147483648": {
            "n": "Locale",
            "t": VT_UI4
        },
        "2147483651": {
            "n": "Behavior",
            "t": VT_UI4
        },
        "1919054434": {}
    };
    (function() {
        for (var y in SpecialProperties) if (SpecialProperties.hasOwnProperty(y)) DocSummaryPIDDSI[y] = SummaryPIDSI[y] = SpecialProperties[y];
    })();
    var DocSummaryRE = evert_key(DocSummaryPIDDSI, "n");
    var SummaryRE = evert_key(SummaryPIDSI, "n");
    var CountryEnum = {
        "1": "US",
        "2": "CA",
        "3": "",
        "7": "RU",
        "20": "EG",
        "30": "GR",
        "31": "NL",
        "32": "BE",
        "33": "FR",
        "34": "ES",
        "36": "HU",
        "39": "IT",
        "41": "CH",
        "43": "AT",
        "44": "GB",
        "45": "DK",
        "46": "SE",
        "47": "NO",
        "48": "PL",
        "49": "DE",
        "52": "MX",
        "55": "BR",
        "61": "AU",
        "64": "NZ",
        "66": "TH",
        "81": "JP",
        "82": "KR",
        "84": "VN",
        "86": "CN",
        "90": "TR",
        "105": "JS",
        "213": "DZ",
        "216": "MA",
        "218": "LY",
        "351": "PT",
        "354": "IS",
        "358": "FI",
        "420": "CZ",
        "886": "TW",
        "961": "LB",
        "962": "JO",
        "963": "SY",
        "964": "IQ",
        "965": "KW",
        "966": "SA",
        "971": "AE",
        "972": "IL",
        "974": "QA",
        "981": "IR",
        "65535": "US"
    };
    var XLSFillPattern = [ null, "solid", "mediumGray", "darkGray", "lightGray", "darkHorizontal", "darkVertical", "darkDown", "darkUp", "darkGrid", "darkTrellis", "lightHorizontal", "lightVertical", "lightDown", "lightUp", "lightGrid", "lightTrellis", "gray125", "gray0625" ];
    function rgbify(arr) {
        return arr.map(function(x) {
            return [ x >> 16 & 255, x >> 8 & 255, x & 255 ];
        });
    }
    var XLSIcv = rgbify([ 0, 16777215, 16711680, 65280, 255, 16776960, 16711935, 65535, 0, 16777215, 16711680, 65280, 255, 16776960, 16711935, 65535, 8388608, 32768, 128, 8421376, 8388736, 32896, 12632256, 8421504, 10066431, 10040166, 16777164, 13434879, 6684774, 16744576, 26316, 13421823, 128, 16711935, 16776960, 65535, 8388736, 8388608, 32896, 255, 52479, 13434879, 13434828, 16777113, 10079487, 16751052, 13408767, 16764057, 3368703, 3394764, 10079232, 16763904, 16750848, 16737792, 6710937, 9868950, 13158, 3381606, 13056, 3355392, 10040064, 10040166, 3355545, 3355443, 16777215, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ]);
    var ct2type = {
        "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": "workbooks",
        "application/vnd.ms-excel.binIndexWs": "TODO",
        "application/vnd.ms-excel.intlmacrosheet": "TODO",
        "application/vnd.ms-excel.binIndexMs": "TODO",
        "application/vnd.openxmlformats-package.core-properties+xml": "coreprops",
        "application/vnd.openxmlformats-officedocument.custom-properties+xml": "custprops",
        "application/vnd.openxmlformats-officedocument.extended-properties+xml": "extprops",
        "application/vnd.openxmlformats-officedocument.customXmlProperties+xml": "TODO",
        "application/vnd.openxmlformats-officedocument.spreadsheetml.customProperty": "TODO",
        "application/vnd.ms-excel.pivotTable": "TODO",
        "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotTable+xml": "TODO",
        "application/vnd.ms-office.chartcolorstyle+xml": "TODO",
        "application/vnd.ms-office.chartstyle+xml": "TODO",
        "application/vnd.ms-excel.calcChain": "calcchains",
        "application/vnd.openxmlformats-officedocument.spreadsheetml.calcChain+xml": "calcchains",
        "application/vnd.openxmlformats-officedocument.spreadsheetml.printerSettings": "TODO",
        "application/vnd.ms-office.activeX": "TODO",
        "application/vnd.ms-office.activeX+xml": "TODO",
        "application/vnd.ms-excel.attachedToolbars": "TODO",
        "application/vnd.ms-excel.connections": "TODO",
        "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": "TODO",
        "application/vnd.ms-excel.externalLink": "links",
        "application/vnd.openxmlformats-officedocument.spreadsheetml.externalLink+xml": "links",
        "application/vnd.ms-excel.sheetMetadata": "TODO",
        "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetMetadata+xml": "TODO",
        "application/vnd.ms-excel.pivotCacheDefinition": "TODO",
        "application/vnd.ms-excel.pivotCacheRecords": "TODO",
        "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotCacheDefinition+xml": "TODO",
        "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotCacheRecords+xml": "TODO",
        "application/vnd.ms-excel.queryTable": "TODO",
        "application/vnd.openxmlformats-officedocument.spreadsheetml.queryTable+xml": "TODO",
        "application/vnd.ms-excel.userNames": "TODO",
        "application/vnd.ms-excel.revisionHeaders": "TODO",
        "application/vnd.ms-excel.revisionLog": "TODO",
        "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionHeaders+xml": "TODO",
        "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionLog+xml": "TODO",
        "application/vnd.openxmlformats-officedocument.spreadsheetml.userNames+xml": "TODO",
        "application/vnd.ms-excel.tableSingleCells": "TODO",
        "application/vnd.openxmlformats-officedocument.spreadsheetml.tableSingleCells+xml": "TODO",
        "application/vnd.ms-excel.slicer": "TODO",
        "application/vnd.ms-excel.slicerCache": "TODO",
        "application/vnd.ms-excel.slicer+xml": "TODO",
        "application/vnd.ms-excel.slicerCache+xml": "TODO",
        "application/vnd.ms-excel.wsSortMap": "TODO",
        "application/vnd.ms-excel.table": "TODO",
        "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": "TODO",
        "application/vnd.openxmlformats-officedocument.theme+xml": "themes",
        "application/vnd.openxmlformats-officedocument.themeOverride+xml": "TODO",
        "application/vnd.ms-excel.Timeline+xml": "TODO",
        "application/vnd.ms-excel.TimelineCache+xml": "TODO",
        "application/vnd.ms-office.vbaProject": "vba",
        "application/vnd.ms-office.vbaProjectSignature": "vba",
        "application/vnd.ms-office.volatileDependencies": "TODO",
        "application/vnd.openxmlformats-officedocument.spreadsheetml.volatileDependencies+xml": "TODO",
        "application/vnd.ms-excel.controlproperties+xml": "TODO",
        "application/vnd.openxmlformats-officedocument.model+data": "TODO",
        "application/vnd.ms-excel.Survey+xml": "TODO",
        "application/vnd.openxmlformats-officedocument.drawing+xml": "drawings",
        "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": "TODO",
        "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": "TODO",
        "application/vnd.openxmlformats-officedocument.drawingml.diagramColors+xml": "TODO",
        "application/vnd.openxmlformats-officedocument.drawingml.diagramData+xml": "TODO",
        "application/vnd.openxmlformats-officedocument.drawingml.diagramLayout+xml": "TODO",
        "application/vnd.openxmlformats-officedocument.drawingml.diagramStyle+xml": "TODO",
        "application/vnd.openxmlformats-officedocument.vmlDrawing": "TODO",
        "application/vnd.openxmlformats-package.relationships+xml": "rels",
        "application/vnd.openxmlformats-officedocument.oleObject": "TODO",
        "image/png": "TODO",
        "sheet": "js"
    };
    var CT_LIST = function() {
        var o = {
            "workbooks": {
                "xlsx": "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml",
                "xlsm": "application/vnd.ms-excel.sheet.macroEnabled.main+xml",
                "xlsb": "application/vnd.ms-excel.sheet.binary.macroEnabled.main",
                "xlam": "application/vnd.ms-excel.addin.macroEnabled.main+xml",
                "xltx": "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml"
            },
            "strs": {
                "xlsx": "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml",
                "xlsb": "application/vnd.ms-excel.sharedStrings"
            },
            "comments": {
                "xlsx": "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml",
                "xlsb": "application/vnd.ms-excel.comments"
            },
            "sheets": {
                "xlsx": "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml",
                "xlsb": "application/vnd.ms-excel.worksheet"
            },
            "charts": {
                "xlsx": "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml",
                "xlsb": "application/vnd.ms-excel.chartsheet"
            },
            "dialogs": {
                "xlsx": "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml",
                "xlsb": "application/vnd.ms-excel.dialogsheet"
            },
            "macros": {
                "xlsx": "application/vnd.ms-excel.macrosheet+xml",
                "xlsb": "application/vnd.ms-excel.macrosheet"
            },
            "styles": {
                "xlsx": "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml",
                "xlsb": "application/vnd.ms-excel.styles"
            }
        };
        keys(o).forEach(function(k) {
            [ "xlsm", "xlam" ].forEach(function(v) {
                if (!o[k][v]) o[k][v] = o[k].xlsx;
            });
        });
        keys(o).forEach(function(k) {
            keys(o[k]).forEach(function(v) {
                ct2type[o[k][v]] = k;
            });
        });
        return o;
    }();
    var type2ct = evert_arr(ct2type);
    XMLNS.CT = "http://schemas.openxmlformats.org/package/2006/content-types";
    function new_ct() {
        return {
            "workbooks": [],
            "sheets": [],
            "charts": [],
            "dialogs": [],
            "macros": [],
            "rels": [],
            "strs": [],
            "comments": [],
            "links": [],
            "coreprops": [],
            "extprops": [],
            "custprops": [],
            "themes": [],
            "styles": [],
            "calcchains": [],
            "vba": [],
            "drawings": [],
            "TODO": [],
            "xmlns": ""
        };
    }
    function parse_ct(data) {
        var ct = new_ct();
        if (!data || !data.match) return ct;
        var ctext = {};
        (data.match(tagregex) || []).forEach(function(x) {
            var y = parsexmltag(x);
            switch (y[0].replace(nsregex, "<")) {
              case "<?xml":
                break;

              case "<Types":
                ct.xmlns = y["xmlns" + (y[0].match(/<(\w+):/) || [ "", "" ])[1]];
                break;

              case "<Default":
                ctext[y.Extension] = y.ContentType;
                break;

              case "<Override":
                if (ct[ct2type[y.ContentType]] !== undefined) ct[ct2type[y.ContentType]].push(y.PartName);
                break;
            }
        });
        if (ct.xmlns !== XMLNS.CT) throw new Error("Unknown Namespace: " + ct.xmlns);
        ct.calcchain = ct.calcchains.length > 0 ? ct.calcchains[0] : "";
        ct.sst = ct.strs.length > 0 ? ct.strs[0] : "";
        ct.style = ct.styles.length > 0 ? ct.styles[0] : "";
        ct.defaults = ctext;
        delete ct.calcchains;
        return ct;
    }
    var CTYPE_XML_ROOT = writextag("Types", null, {
        "xmlns": XMLNS.CT,
        "xmlns:xsd": XMLNS.xsd,
        "xmlns:xsi": XMLNS.xsi
    });
    var CTYPE_DEFAULTS = [ [ "xml", "application/xml" ], [ "bin", "application/vnd.ms-excel.sheet.binary.macroEnabled.main" ], [ "vml", "application/vnd.openxmlformats-officedocument.vmlDrawing" ], [ "bmp", "image/bmp" ], [ "png", "image/png" ], [ "gif", "image/gif" ], [ "emf", "image/x-emf" ], [ "wmf", "image/x-wmf" ], [ "jpg", "image/jpeg" ], [ "jpeg", "image/jpeg" ], [ "tif", "image/tiff" ], [ "tiff", "image/tiff" ], [ "pdf", "application/pdf" ], [ "rels", type2ct.rels[0] ] ].map(function(x) {
        return writextag("Default", null, {
            "Extension": x[0],
            "ContentType": x[1]
        });
    });
    function write_ct(ct, opts) {
        var o = [], v;
        o[o.length] = XML_HEADER;
        o[o.length] = CTYPE_XML_ROOT;
        o = o.concat(CTYPE_DEFAULTS);
        var f1 = function(w) {
            if (ct[w] && ct[w].length > 0) {
                v = ct[w][0];
                o[o.length] = writextag("Override", null, {
                    "PartName": (v[0] == "/" ? "" : "/") + v,
                    "ContentType": CT_LIST[w][opts.bookType || "xlsx"]
                });
            }
        };
        var f2 = function(w) {
            (ct[w] || []).forEach(function(v) {
                o[o.length] = writextag("Override", null, {
                    "PartName": (v[0] == "/" ? "" : "/") + v,
                    "ContentType": CT_LIST[w][opts.bookType || "xlsx"]
                });
            });
        };
        var f3 = function(t) {
            (ct[t] || []).forEach(function(v) {
                o[o.length] = writextag("Override", null, {
                    "PartName": (v[0] == "/" ? "" : "/") + v,
                    "ContentType": type2ct[t][0]
                });
            });
        };
        f1("workbooks");
        f2("sheets");
        f2("charts");
        f3("themes");
        [ "strs", "styles" ].forEach(f1);
        [ "coreprops", "extprops", "custprops" ].forEach(f3);
        f3("vba");
        f3("comments");
        f3("drawings");
        if (o.length > 2) {
            o[o.length] = "</Types>";
            o[1] = o[1].replace("/>", ">");
        }
        return o.join("");
    }
    var RELS = {
        "WB": "http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument",
        "SHEET": "http://sheetjs.openxmlformats.org/officeDocument/2006/relationships/officeDocument",
        "HLINK": "http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink",
        "VML": "http://schemas.openxmlformats.org/officeDocument/2006/relationships/vmlDrawing",
        "VBA": "http://schemas.microsoft.com/office/2006/relationships/vbaProject"
    };
    function get_rels_path(file) {
        var n = file.lastIndexOf("/");
        return file.slice(0, n + 1) + "_rels/" + file.slice(n + 1) + ".rels";
    }
    function parse_rels(data, currentFilePath) {
        if (!data) return data;
        if (currentFilePath.charAt(0) !== "/") {
            currentFilePath = "/" + currentFilePath;
        }
        var rels = {};
        var hash = {};
        (data.match(tagregex) || []).forEach(function(x) {
            var y = parsexmltag(x);
            if (y[0] === "<Relationship") {
                var rel = {};
                rel.Type = y.Type;
                rel.Target = y.Target;
                rel.Id = y.Id;
                rel.TargetMode = y.TargetMode;
                var canonictarget = y.TargetMode === "External" ? y.Target : resolve_path(y.Target, currentFilePath);
                rels[canonictarget] = rel;
                hash[y.Id] = rel;
            }
        });
        rels["!id"] = hash;
        return rels;
    }
    XMLNS.RELS = "http://schemas.openxmlformats.org/package/2006/relationships";
    var RELS_ROOT = writextag("Relationships", null, {
        "xmlns": XMLNS.RELS
    });
    function write_rels(rels) {
        var o = [ XML_HEADER, RELS_ROOT ];
        keys(rels["!id"]).forEach(function(rid) {
            o[o.length] = writextag("Relationship", null, rels["!id"][rid]);
        });
        if (o.length > 2) {
            o[o.length] = "</Relationships>";
            o[1] = o[1].replace("/>", ">");
        }
        return o.join("");
    }
    function add_rels(rels, rId, f, type, relobj) {
        if (!relobj) relobj = {};
        if (!rels["!id"]) rels["!id"] = {};
        if (rId < 0) for (rId = 1; rels["!id"]["rId" + rId]; ++rId) {}
        relobj.Id = "rId" + rId;
        relobj.Type = type;
        relobj.Target = f;
        if (relobj.Type == RELS.HLINK) relobj.TargetMode = "External";
        if (rels["!id"][relobj.Id]) throw new Error("Cannot rewrite rId " + rId);
        rels["!id"][relobj.Id] = relobj;
        rels[("/" + relobj.Target).replace("//", "/")] = relobj;
        return rId;
    }
    var CT_ODS = "application/vnd.oasis.opendocument.spreadsheet";
    function parse_manifest(d, opts) {
        var str = xlml_normalize(d);
        var Rn;
        var FEtag;
        while (Rn = xlmlregex.exec(str)) switch (Rn[3]) {
          case "manifest":
            break;

          case "file-entry":
            FEtag = parsexmltag(Rn[0], false);
            if (FEtag.path == "/" && FEtag.type !== CT_ODS) throw new Error("This OpenDocument is not a spreadsheet");
            break;

          case "encryption-data":
          case "algorithm":
          case "start-key-generation":
          case "key-derivation":
            throw new Error("Unsupported ODS Encryption");

          default:
            if (opts && opts.WTF) throw Rn;
        }
    }
    function write_manifest(manifest) {
        var o = [ XML_HEADER ];
        o.push('<manifest:manifest xmlns:manifest="urn:oasis:names:tc:opendocument:xmlns:manifest:1.0" manifest:version="1.2">\n');
        o.push('  <manifest:file-entry manifest:full-path="/" manifest:version="1.2" manifest:media-type="application/vnd.oasis.opendocument.spreadsheet"/>\n');
        for (var i = 0; i < manifest.length; ++i) o.push('  <manifest:file-entry manifest:full-path="' + manifest[i][0] + '" manifest:media-type="' + manifest[i][1] + '"/>\n');
        o.push("</manifest:manifest>");
        return o.join("");
    }
    function write_rdf_type(file, res, tag) {
        return [ '  <rdf:Description rdf:about="' + file + '">\n', '    <rdf:type rdf:resource="http://docs.oasis-open.org/ns/office/1.2/meta/' + (tag || "odf") + "#" + res + '"/>\n', "  </rdf:Description>\n" ].join("");
    }
    function write_rdf_has(base, file) {
        return [ '  <rdf:Description rdf:about="' + base + '">\n', '    <ns0:hasPart xmlns:ns0="http://docs.oasis-open.org/ns/office/1.2/meta/pkg#" rdf:resource="' + file + '"/>\n', "  </rdf:Description>\n" ].join("");
    }
    function write_rdf(rdf) {
        var o = [ XML_HEADER ];
        o.push('<rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">\n');
        for (var i = 0; i != rdf.length; ++i) {
            o.push(write_rdf_type(rdf[i][0], rdf[i][1]));
            o.push(write_rdf_has("", rdf[i][0]));
        }
        o.push(write_rdf_type("", "Document", "pkg"));
        o.push("</rdf:RDF>");
        return o.join("");
    }
    var write_meta_ods = function() {
        var payload = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?><office:document-meta xmlns:office="urn:oasis:names:tc:opendocument:xmlns:office:1.0" xmlns:meta="urn:oasis:names:tc:opendocument:xmlns:meta:1.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:xlink="http://www.w3.org/1999/xlink" office:version="1.2"><office:meta><meta:generator>Sheet' + "JS " + XLSX.version + "</meta:generator></office:meta></office:document-meta>";
        return function wmo() {
            return payload;
        };
    }();
    var CORE_PROPS = [ [ "cp:category", "Category" ], [ "cp:contentStatus", "ContentStatus" ], [ "cp:keywords", "Keywords" ], [ "cp:lastModifiedBy", "LastAuthor" ], [ "cp:lastPrinted", "LastPrinted" ], [ "cp:revision", "RevNumber" ], [ "cp:version", "Version" ], [ "dc:creator", "Author" ], [ "dc:description", "Comments" ], [ "dc:identifier", "Identifier" ], [ "dc:language", "Language" ], [ "dc:subject", "Subject" ], [ "dc:title", "Title" ], [ "dcterms:created", "CreatedDate", "date" ], [ "dcterms:modified", "ModifiedDate", "date" ] ];
    XMLNS.CORE_PROPS = "http://schemas.openxmlformats.org/package/2006/metadata/core-properties";
    RELS.CORE_PROPS = "http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties";
    var CORE_PROPS_REGEX = function() {
        var r = new Array(CORE_PROPS.length);
        for (var i = 0; i < CORE_PROPS.length; ++i) {
            var f = CORE_PROPS[i];
            var g = "(?:" + f[0].slice(0, f[0].indexOf(":")) + ":)" + f[0].slice(f[0].indexOf(":") + 1);
            r[i] = new RegExp("<" + g + "[^>]*>([\\s\\S]*?)</" + g + ">");
        }
        return r;
    }();
    function parse_core_props(data) {
        var p = {};
        data = utf8read(data);
        for (var i = 0; i < CORE_PROPS.length; ++i) {
            var f = CORE_PROPS[i], cur = data.match(CORE_PROPS_REGEX[i]);
            if (cur != null && cur.length > 0) p[f[1]] = cur[1];
            if (f[2] === "date" && p[f[1]]) p[f[1]] = parseDate(p[f[1]]);
        }
        return p;
    }
    var CORE_PROPS_XML_ROOT = writextag("cp:coreProperties", null, {
        "xmlns:cp": XMLNS.CORE_PROPS,
        "xmlns:dc": XMLNS.dc,
        "xmlns:dcterms": XMLNS.dcterms,
        "xmlns:dcmitype": XMLNS.dcmitype,
        "xmlns:xsi": XMLNS.xsi
    });
    function cp_doit(f, g, h, o, p) {
        if (p[f] != null || g == null || g === "") return;
        p[f] = g;
        o[o.length] = h ? writextag(f, g, h) : writetag(f, g);
    }
    function write_core_props(cp, _opts) {
        var opts = _opts || {};
        var o = [ XML_HEADER, CORE_PROPS_XML_ROOT ], p = {};
        if (!cp && !opts.Props) return o.join("");
        if (cp) {
            if (cp.CreatedDate != null) cp_doit("dcterms:created", typeof cp.CreatedDate === "string" ? cp.CreatedDate : write_w3cdtf(cp.CreatedDate, opts.WTF), {
                "xsi:type": "dcterms:W3CDTF"
            }, o, p);
            if (cp.ModifiedDate != null) cp_doit("dcterms:modified", typeof cp.ModifiedDate === "string" ? cp.ModifiedDate : write_w3cdtf(cp.ModifiedDate, opts.WTF), {
                "xsi:type": "dcterms:W3CDTF"
            }, o, p);
        }
        for (var i = 0; i != CORE_PROPS.length; ++i) {
            var f = CORE_PROPS[i];
            var v = opts.Props && opts.Props[f[1]] != null ? opts.Props[f[1]] : cp ? cp[f[1]] : null;
            if (v === true) v = "1"; else if (v === false) v = "0"; else if (typeof v == "number") v = String(v);
            if (v != null) cp_doit(f[0], v, null, o, p);
        }
        if (o.length > 2) {
            o[o.length] = "</cp:coreProperties>";
            o[1] = o[1].replace("/>", ">");
        }
        return o.join("");
    }
    var EXT_PROPS = [ [ "Application", "Application", "string" ], [ "AppVersion", "AppVersion", "string" ], [ "Company", "Company", "string" ], [ "DocSecurity", "DocSecurity", "string" ], [ "Manager", "Manager", "string" ], [ "HyperlinksChanged", "HyperlinksChanged", "bool" ], [ "SharedDoc", "SharedDoc", "bool" ], [ "LinksUpToDate", "LinksUpToDate", "bool" ], [ "ScaleCrop", "ScaleCrop", "bool" ], [ "HeadingPairs", "HeadingPairs", "raw" ], [ "TitlesOfParts", "TitlesOfParts", "raw" ] ];
    XMLNS.EXT_PROPS = "http://schemas.openxmlformats.org/officeDocument/2006/extended-properties";
    RELS.EXT_PROPS = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties";
    var PseudoPropsPairs = [ "Worksheets", "SheetNames", "NamedRanges", "DefinedNames", "Chartsheets", "ChartNames" ];
    function load_props_pairs(HP, TOP, props, opts) {
        var v = [];
        if (typeof HP == "string") v = parseVector(HP, opts); else for (var j = 0; j < HP.length; ++j) v = v.concat(HP[j].map(function(hp) {
            return {
                "v": hp
            };
        }));
        var parts = typeof TOP == "string" ? parseVector(TOP, opts).map(function(x) {
            return x.v;
        }) : TOP;
        var idx = 0, len = 0;
        if (parts.length > 0) for (var i = 0; i !== v.length; i += 2) {
            len = +v[i + 1].v;
            switch (v[i].v) {
              case "Worksheets":
              case "\u5de5\u4f5c\u8868":
              case "\u041b\u0438\u0441\u0442\u044b":
              case "\u0623\u0648\u0631\u0627\u0642 \u0627\u0644\u0639\u0645\u0644":
              case "\u30ef\u30fc\u30af\u30b7\u30fc\u30c8":
              case "\u05d2\u05dc\u05d9\u05d5\u05e0\u05d5\u05ea \u05e2\u05d1\u05d5\u05d3\u05d4":
              case "Arbeitsbl\xe4tter":
              case "\xc7al\u0131\u015fma Sayfalar\u0131":
              case "Feuilles de calcul":
              case "Fogli di lavoro":
              case "Folhas de c\xe1lculo":
              case "Planilhas":
              case "Regneark":
              case "Werkbladen":
                props.Worksheets = len;
                props.SheetNames = parts.slice(idx, idx + len);
                break;

              case "Named Ranges":
              case "\u540d\u524d\u4ed8\u304d\u4e00\u89a7":
              case "Benannte Bereiche":
              case "Navngivne omr\xe5der":
                props.NamedRanges = len;
                props.DefinedNames = parts.slice(idx, idx + len);
                break;

              case "Charts":
              case "Diagramme":
                props.Chartsheets = len;
                props.ChartNames = parts.slice(idx, idx + len);
                break;
            }
            idx += len;
        }
    }
    function parse_ext_props(data, p, opts) {
        var q = {};
        if (!p) p = {};
        data = utf8read(data);
        EXT_PROPS.forEach(function(f) {
            switch (f[2]) {
              case "string":
                p[f[1]] = (data.match(matchtag(f[0])) || [])[1];
                break;

              case "bool":
                p[f[1]] = (data.match(matchtag(f[0])) || [])[1] === "true";
                break;

              case "raw":
                var cur = data.match(new RegExp("<" + f[0] + "[^>]*>([\\s\\S]*?)</" + f[0] + ">"));
                if (cur && cur.length > 0) q[f[1]] = cur[1];
                break;
            }
        });
        if (q.HeadingPairs && q.TitlesOfParts) load_props_pairs(q.HeadingPairs, q.TitlesOfParts, p, opts);
        return p;
    }
    var EXT_PROPS_XML_ROOT = writextag("Properties", null, {
        "xmlns": XMLNS.EXT_PROPS,
        "xmlns:vt": XMLNS.vt
    });
    function write_ext_props(cp) {
        var o = [], W = writextag;
        if (!cp) cp = {};
        cp.Application = "SheetJS";
        o[o.length] = XML_HEADER;
        o[o.length] = EXT_PROPS_XML_ROOT;
        EXT_PROPS.forEach(function(f) {
            if (cp[f[1]] === undefined) return;
            var v;
            switch (f[2]) {
              case "string":
                v = String(cp[f[1]]);
                break;

              case "bool":
                v = cp[f[1]] ? "true" : "false";
                break;
            }
            if (v !== undefined) o[o.length] = W(f[0], v);
        });
        o[o.length] = W("HeadingPairs", W("vt:vector", W("vt:variant", "<vt:lpstr>Worksheets</vt:lpstr>") + W("vt:variant", W("vt:i4", String(cp.Worksheets))), {
            "size": 2,
            "baseType": "variant"
        }));
        o[o.length] = W("TitlesOfParts", W("vt:vector", cp.SheetNames.map(function(s) {
            return "<vt:lpstr>" + escapexml(s) + "</vt:lpstr>";
        }).join(""), {
            "size": cp.Worksheets,
            "baseType": "lpstr"
        }));
        if (o.length > 2) {
            o[o.length] = "</Properties>";
            o[1] = o[1].replace("/>", ">");
        }
        return o.join("");
    }
    XMLNS.CUST_PROPS = "http://schemas.openxmlformats.org/officeDocument/2006/custom-properties";
    RELS.CUST_PROPS = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/custom-properties";
    var custregex = /<[^>]+>[^<]*/g;
    function parse_cust_props(data, opts) {
        var p = {}, name = "";
        var m = data.match(custregex);
        if (m) for (var i = 0; i != m.length; ++i) {
            var x = m[i], y = parsexmltag(x);
            switch (y[0]) {
              case "<?xml":
                break;

              case "<Properties":
                break;

              case "<property":
                name = y.name;
                break;

              case "</property>":
                name = null;
                break;

              default:
                if (x.indexOf("<vt:") === 0) {
                    var toks = x.split(">");
                    var type = toks[0].slice(4), text = toks[1];
                    switch (type) {
                      case "lpstr":
                      case "bstr":
                      case "lpwstr":
                        p[name] = unescapexml(text);
                        break;

                      case "bool":
                        p[name] = parsexmlbool(text);
                        break;

                      case "i1":
                      case "i2":
                      case "i4":
                      case "i8":
                      case "int":
                      case "uint":
                        p[name] = parseInt(text, 10);
                        break;

                      case "r4":
                      case "r8":
                      case "decimal":
                        p[name] = parseFloat(text);
                        break;

                      case "filetime":
                      case "date":
                        p[name] = parseDate(text);
                        break;

                      case "cy":
                      case "error":
                        p[name] = unescapexml(text);
                        break;

                      default:
                        if (type.slice(-1) == "/") break;
                        if (opts.WTF && typeof console !== "undefined") console.warn("Unexpected", x, type, toks);
                    }
                } else if (x.slice(0, 2) === "</") {} else if (opts.WTF) throw new Error(x);
            }
        }
        return p;
    }
    var CUST_PROPS_XML_ROOT = writextag("Properties", null, {
        "xmlns": XMLNS.CUST_PROPS,
        "xmlns:vt": XMLNS.vt
    });
    function write_cust_props(cp) {
        var o = [ XML_HEADER, CUST_PROPS_XML_ROOT ];
        if (!cp) return o.join("");
        var pid = 1;
        keys(cp).forEach(function custprop(k) {
            ++pid;
            o[o.length] = writextag("property", write_vt(cp[k]), {
                "fmtid": "{D5CDD505-2E9C-101B-9397-08002B2CF9AE}",
                "pid": pid,
                "name": k
            });
        });
        if (o.length > 2) {
            o[o.length] = "</Properties>";
            o[1] = o[1].replace("/>", ">");
        }
        return o.join("");
    }
    var XLMLDocPropsMap = {
        "Title": "Title",
        "Subject": "Subject",
        "Author": "Author",
        "Keywords": "Keywords",
        "Comments": "Description",
        "LastAuthor": "LastAuthor",
        "RevNumber": "Revision",
        "Application": "AppName",
        "LastPrinted": "LastPrinted",
        "CreatedDate": "Created",
        "ModifiedDate": "LastSaved",
        "Category": "Category",
        "Manager": "Manager",
        "Company": "Company",
        "AppVersion": "Version",
        "ContentStatus": "ContentStatus",
        "Identifier": "Identifier",
        "Language": "Language"
    };
    var evert_XLMLDPM = evert(XLMLDocPropsMap);
    function xlml_set_prop(Props, tag, val) {
        tag = evert_XLMLDPM[tag] || tag;
        Props[tag] = val;
    }
    function xlml_write_docprops(Props, opts) {
        var o = [];
        keys(XLMLDocPropsMap).map(function(m) {
            for (var i = 0; i < CORE_PROPS.length; ++i) if (CORE_PROPS[i][1] == m) return CORE_PROPS[i];
            for (i = 0; i < EXT_PROPS.length; ++i) if (EXT_PROPS[i][1] == m) return EXT_PROPS[i];
            throw m;
        }).forEach(function(p) {
            if (Props[p[1]] == null) return;
            var m = opts && opts.Props && opts.Props[p[1]] != null ? opts.Props[p[1]] : Props[p[1]];
            switch (p[2]) {
              case "date":
                m = new Date(m).toISOString().replace(/\.\d*Z/, "Z");
                break;
            }
            if (typeof m == "number") m = String(m); else if (m === true || m === false) {
                m = m ? "1" : "0";
            } else if (m instanceof Date) m = new Date(m).toISOString().replace(/\.\d*Z/, "");
            o.push(writetag(XLMLDocPropsMap[p[1]] || p[1], m));
        });
        return writextag("DocumentProperties", o.join(""), {
            "xmlns": XLMLNS.o
        });
    }
    function xlml_write_custprops(Props, Custprops) {
        var BLACKLIST = [ "Worksheets", "SheetNames" ];
        var T = "CustomDocumentProperties";
        var o = [];
        if (Props) keys(Props).forEach(function(k) {
            if (!Props.hasOwnProperty(k)) return;
            for (var i = 0; i < CORE_PROPS.length; ++i) if (k == CORE_PROPS[i][1]) return;
            for (i = 0; i < EXT_PROPS.length; ++i) if (k == EXT_PROPS[i][1]) return;
            for (i = 0; i < BLACKLIST.length; ++i) if (k == BLACKLIST[i]) return;
            var m = Props[k];
            var t = "string";
            if (typeof m == "number") {
                t = "float";
                m = String(m);
            } else if (m === true || m === false) {
                t = "boolean";
                m = m ? "1" : "0";
            } else m = String(m);
            o.push(writextag(escapexmltag(k), m, {
                "dt:dt": t
            }));
        });
        if (Custprops) keys(Custprops).forEach(function(k) {
            if (!Custprops.hasOwnProperty(k)) return;
            if (Props && Props.hasOwnProperty(k)) return;
            var m = Custprops[k];
            var t = "string";
            if (typeof m == "number") {
                t = "float";
                m = String(m);
            } else if (m === true || m === false) {
                t = "boolean";
                m = m ? "1" : "0";
            } else if (m instanceof Date) {
                t = "dateTime.tz";
                m = m.toISOString();
            } else m = String(m);
            o.push(writextag(escapexmltag(k), m, {
                "dt:dt": t
            }));
        });
        return "<" + T + ' xmlns="' + XLMLNS.o + '">' + o.join("") + "</" + T + ">";
    }
    function parse_FILETIME(blob) {
        var dwLowDateTime = blob.read_shift(4), dwHighDateTime = blob.read_shift(4);
        return new Date((dwHighDateTime / 1e7 * Math.pow(2, 32) + dwLowDateTime / 1e7 - 11644473600) * 1e3).toISOString().replace(/\.000/, "");
    }
    function write_FILETIME(time) {
        var date = typeof time == "string" ? new Date(Date.parse(time)) : time;
        var t = date.getTime() / 1e3 + 11644473600;
        var l = t % Math.pow(2, 32), h = (t - l) / Math.pow(2, 32);
        l *= 1e7;
        h *= 1e7;
        var w = l / Math.pow(2, 32) | 0;
        if (w > 0) {
            l = l % Math.pow(2, 32);
            h += w;
        }
        var o = new_buf(8);
        o.write_shift(4, l);
        o.write_shift(4, h);
        return o;
    }
    function parse_lpstr(blob, type, pad) {
        var start = blob.l;
        var str = blob.read_shift(0, "lpstr-cp");
        if (pad) while (blob.l - start & 3) ++blob.l;
        return str;
    }
    function parse_lpwstr(blob, type, pad) {
        var str = blob.read_shift(0, "lpwstr");
        if (pad) blob.l += 4 - (str.length + 1 & 3) & 3;
        return str;
    }
    function parse_VtStringBase(blob, stringType, pad) {
        if (stringType === 31) return parse_lpwstr(blob);
        return parse_lpstr(blob, stringType, pad);
    }
    function parse_VtString(blob, t, pad) {
        return parse_VtStringBase(blob, t, pad === false ? 0 : 4);
    }
    function parse_VtUnalignedString(blob, t) {
        if (!t) throw new Error("VtUnalignedString must have positive length");
        return parse_VtStringBase(blob, t, 0);
    }
    function parse_VtVecUnalignedLpstrValue(blob) {
        var length = blob.read_shift(4);
        var ret = [];
        for (var i = 0; i != length; ++i) ret[i] = blob.read_shift(0, "lpstr-cp").replace(chr0, "");
        return ret;
    }
    function parse_VtVecUnalignedLpstr(blob) {
        return parse_VtVecUnalignedLpstrValue(blob);
    }
    function parse_VtHeadingPair(blob) {
        var headingString = parse_TypedPropertyValue(blob, VT_USTR);
        var headerParts = parse_TypedPropertyValue(blob, VT_I4);
        return [ headingString, headerParts ];
    }
    function parse_VtVecHeadingPairValue(blob) {
        var cElements = blob.read_shift(4);
        var out = [];
        for (var i = 0; i != cElements / 2; ++i) out.push(parse_VtHeadingPair(blob));
        return out;
    }
    function parse_VtVecHeadingPair(blob) {
        return parse_VtVecHeadingPairValue(blob);
    }
    function parse_dictionary(blob, CodePage) {
        var cnt = blob.read_shift(4);
        var dict = {};
        for (var j = 0; j != cnt; ++j) {
            var pid = blob.read_shift(4);
            var len = blob.read_shift(4);
            dict[pid] = blob.read_shift(len, CodePage === 1200 ? "utf16le" : "utf8").replace(chr0, "").replace(chr1, "!");
            if (CodePage === 1200 && len % 2) blob.l += 2;
        }
        if (blob.l & 3) blob.l = blob.l >> 2 + 1 << 2;
        return dict;
    }
    function parse_BLOB(blob) {
        var size = blob.read_shift(4);
        var bytes = blob.slice(blob.l, blob.l + size);
        blob.l += size;
        if ((size & 3) > 0) blob.l += 4 - (size & 3) & 3;
        return bytes;
    }
    function parse_ClipboardData(blob) {
        var o = {};
        o.Size = blob.read_shift(4);
        blob.l += o.Size + 3 - (o.Size - 1) % 4;
        return o;
    }
    function parse_TypedPropertyValue(blob, type, _opts) {
        var t = blob.read_shift(2), ret, opts = _opts || {};
        blob.l += 2;
        if (type !== VT_VARIANT) if (t !== type && VT_CUSTOM.indexOf(type) === -1) throw new Error("Expected type " + type + " saw " + t);
        switch (type === VT_VARIANT ? t : type) {
          case 2:
            ret = blob.read_shift(2, "i");
            if (!opts.raw) blob.l += 2;
            return ret;

          case 3:
            ret = blob.read_shift(4, "i");
            return ret;

          case 11:
            return blob.read_shift(4) !== 0;

          case 19:
            ret = blob.read_shift(4);
            return ret;

          case 30:
            return parse_lpstr(blob, t, 4).replace(chr0, "");

          case 31:
            return parse_lpwstr(blob);

          case 64:
            return parse_FILETIME(blob);

          case 65:
            return parse_BLOB(blob);

          case 71:
            return parse_ClipboardData(blob);

          case 80:
            return parse_VtString(blob, t, !opts.raw).replace(chr0, "");

          case 81:
            return parse_VtUnalignedString(blob, t).replace(chr0, "");

          case 4108:
            return parse_VtVecHeadingPair(blob);

          case 4126:
            return parse_VtVecUnalignedLpstr(blob);

          default:
            throw new Error("TypedPropertyValue unrecognized type " + type + " " + t);
        }
    }
    function write_TypedPropertyValue(type, value) {
        var o = new_buf(4), p = new_buf(4);
        o.write_shift(4, type == 80 ? 31 : type);
        switch (type) {
          case 3:
            p.write_shift(-4, value);
            break;

          case 5:
            p = new_buf(8);
            p.write_shift(8, value, "f");
            break;

          case 11:
            p.write_shift(4, value ? 1 : 0);
            break;

          case 64:
            p = write_FILETIME(value);
            break;

          case 31:
          case 80:
            p = new_buf(4 + 2 * (value.length + 1) + (value.length % 2 ? 0 : 2));
            p.write_shift(4, value.length + 1);
            p.write_shift(0, value, "dbcs");
            while (p.l != p.length) p.write_shift(1, 0);
            break;

          default:
            throw new Error("TypedPropertyValue unrecognized type " + type + " " + value);
        }
        return bconcat([ o, p ]);
    }
    function parse_PropertySet(blob, PIDSI) {
        var start_addr = blob.l;
        var size = blob.read_shift(4);
        var NumProps = blob.read_shift(4);
        var Props = [], i = 0;
        var CodePage = 0;
        var Dictionary = -1, DictObj = {};
        for (i = 0; i != NumProps; ++i) {
            var PropID = blob.read_shift(4);
            var Offset = blob.read_shift(4);
            Props[i] = [ PropID, Offset + start_addr ];
        }
        Props.sort(function(x, y) {
            return x[1] - y[1];
        });
        var PropH = {};
        for (i = 0; i != NumProps; ++i) {
            if (blob.l !== Props[i][1]) {
                var fail = true;
                if (i > 0 && PIDSI) switch (PIDSI[Props[i - 1][0]].t) {
                  case 2:
                    if (blob.l + 2 === Props[i][1]) {
                        blob.l += 2;
                        fail = false;
                    }
                    break;

                  case 80:
                    if (blob.l <= Props[i][1]) {
                        blob.l = Props[i][1];
                        fail = false;
                    }
                    break;

                  case 4108:
                    if (blob.l <= Props[i][1]) {
                        blob.l = Props[i][1];
                        fail = false;
                    }
                    break;
                }
                if ((!PIDSI || i == 0) && blob.l <= Props[i][1]) {
                    fail = false;
                    blob.l = Props[i][1];
                }
                if (fail) throw new Error("Read Error: Expected address " + Props[i][1] + " at " + blob.l + " :" + i);
            }
            if (PIDSI) {
                var piddsi = PIDSI[Props[i][0]];
                PropH[piddsi.n] = parse_TypedPropertyValue(blob, piddsi.t, {
                    "raw": true
                });
                if (piddsi.p === "version") PropH[piddsi.n] = String(PropH[piddsi.n] >> 16) + "." + ("0000" + String(PropH[piddsi.n] & 65535)).slice(-4);
                if (piddsi.n == "CodePage") switch (PropH[piddsi.n]) {
                  case 0:
                    PropH[piddsi.n] = 1252;

                  case 874:
                  case 932:
                  case 936:
                  case 949:
                  case 950:
                  case 1250:
                  case 1251:
                  case 1253:
                  case 1254:
                  case 1255:
                  case 1256:
                  case 1257:
                  case 1258:
                  case 1e4:
                  case 1200:
                  case 1201:
                  case 1252:
                  case 65e3:
                  case -536:
                  case 65001:
                  case -535:
                    set_cp(CodePage = PropH[piddsi.n] >>> 0 & 65535);
                    break;

                  default:
                    throw new Error("Unsupported CodePage: " + PropH[piddsi.n]);
                }
            } else {
                if (Props[i][0] === 1) {
                    CodePage = PropH.CodePage = parse_TypedPropertyValue(blob, VT_I2);
                    set_cp(CodePage);
                    if (Dictionary !== -1) {
                        var oldpos = blob.l;
                        blob.l = Props[Dictionary][1];
                        DictObj = parse_dictionary(blob, CodePage);
                        blob.l = oldpos;
                    }
                } else if (Props[i][0] === 0) {
                    if (CodePage === 0) {
                        Dictionary = i;
                        blob.l = Props[i + 1][1];
                        continue;
                    }
                    DictObj = parse_dictionary(blob, CodePage);
                } else {
                    var name = DictObj[Props[i][0]];
                    var val;
                    switch (blob[blob.l]) {
                      case 65:
                        blob.l += 4;
                        val = parse_BLOB(blob);
                        break;

                      case 30:
                        blob.l += 4;
                        val = parse_VtString(blob, blob[blob.l - 4]).replace(/\u0000+$/, "");
                        break;

                      case 31:
                        blob.l += 4;
                        val = parse_VtString(blob, blob[blob.l - 4]).replace(/\u0000+$/, "");
                        break;

                      case 3:
                        blob.l += 4;
                        val = blob.read_shift(4, "i");
                        break;

                      case 19:
                        blob.l += 4;
                        val = blob.read_shift(4);
                        break;

                      case 5:
                        blob.l += 4;
                        val = blob.read_shift(8, "f");
                        break;

                      case 11:
                        blob.l += 4;
                        val = parsebool(blob, 4);
                        break;

                      case 64:
                        blob.l += 4;
                        val = parseDate(parse_FILETIME(blob));
                        break;

                      default:
                        throw new Error("unparsed value: " + blob[blob.l]);
                    }
                    PropH[name] = val;
                }
            }
        }
        blob.l = start_addr + size;
        return PropH;
    }
    var XLSPSSkip = [ "CodePage", "Thumbnail", "_PID_LINKBASE", "_PID_HLINKS", "SystemIdentifier", "FMTID" ].concat(PseudoPropsPairs);
    function guess_property_type(val) {
        switch (typeof val) {
          case "boolean":
            return 11;

          case "number":
            return (val | 0) == val ? 3 : 5;

          case "string":
            return 31;

          case "object":
            if (val instanceof Date) return 64;
            break;
        }
        return -1;
    }
    function write_PropertySet(entries, RE, PIDSI) {
        var hdr = new_buf(8), piao = [], prop = [];
        var sz = 8, i = 0;
        var pr = new_buf(8), pio = new_buf(8);
        pr.write_shift(4, 2);
        pr.write_shift(4, 1200);
        pio.write_shift(4, 1);
        prop.push(pr);
        piao.push(pio);
        sz += 8 + pr.length;
        if (!RE) {
            pio = new_buf(8);
            pio.write_shift(4, 0);
            piao.unshift(pio);
            var bufs = [ new_buf(4) ];
            bufs[0].write_shift(4, entries.length);
            for (i = 0; i < entries.length; ++i) {
                var value = entries[i][0];
                pr = new_buf(4 + 4 + 2 * (value.length + 1) + (value.length % 2 ? 0 : 2));
                pr.write_shift(4, i + 2);
                pr.write_shift(4, value.length + 1);
                pr.write_shift(0, value, "dbcs");
                while (pr.l != pr.length) pr.write_shift(1, 0);
                bufs.push(pr);
            }
            pr = bconcat(bufs);
            prop.unshift(pr);
            sz += 8 + pr.length;
        }
        for (i = 0; i < entries.length; ++i) {
            if (RE && !RE[entries[i][0]]) continue;
            if (XLSPSSkip.indexOf(entries[i][0]) > -1) continue;
            if (entries[i][1] == null) continue;
            var val = entries[i][1], idx = 0;
            if (RE) {
                idx = +RE[entries[i][0]];
                var pinfo = PIDSI[idx];
                if (pinfo.p == "version" && typeof val == "string") {
                    var arr = val.split(".");
                    val = (+arr[0] << 16) + (+arr[1] || 0);
                }
                pr = write_TypedPropertyValue(pinfo.t, val);
            } else {
                var T = guess_property_type(val);
                if (T == -1) {
                    T = 31;
                    val = String(val);
                }
                pr = write_TypedPropertyValue(T, val);
            }
            prop.push(pr);
            pio = new_buf(8);
            pio.write_shift(4, !RE ? 2 + i : idx);
            piao.push(pio);
            sz += 8 + pr.length;
        }
        var w = 8 * (prop.length + 1);
        for (i = 0; i < prop.length; ++i) {
            piao[i].write_shift(4, w);
            w += prop[i].length;
        }
        hdr.write_shift(4, sz);
        hdr.write_shift(4, prop.length);
        return bconcat([ hdr ].concat(piao).concat(prop));
    }
    function parse_PropertySetStream(file, PIDSI, clsid) {
        var blob = file.content;
        if (!blob) return {};
        prep_blob(blob, 0);
        var NumSets, FMTID0, FMTID1, Offset0, Offset1 = 0;
        blob.chk("feff", "Byte Order: ");
        blob.read_shift(2);
        var SystemIdentifier = blob.read_shift(4);
        var CLSID = blob.read_shift(16);
        if (CLSID !== CFB.utils.consts.HEADER_CLSID && CLSID !== clsid) throw new Error("Bad PropertySet CLSID " + CLSID);
        NumSets = blob.read_shift(4);
        if (NumSets !== 1 && NumSets !== 2) throw new Error("Unrecognized #Sets: " + NumSets);
        FMTID0 = blob.read_shift(16);
        Offset0 = blob.read_shift(4);
        if (NumSets === 1 && Offset0 !== blob.l) throw new Error("Length mismatch: " + Offset0 + " !== " + blob.l); else if (NumSets === 2) {
            FMTID1 = blob.read_shift(16);
            Offset1 = blob.read_shift(4);
        }
        var PSet0 = parse_PropertySet(blob, PIDSI);
        var rval = {
            "SystemIdentifier": SystemIdentifier
        };
        for (var y in PSet0) rval[y] = PSet0[y];
        rval.FMTID = FMTID0;
        if (NumSets === 1) return rval;
        if (Offset1 - blob.l == 2) blob.l += 2;
        if (blob.l !== Offset1) throw new Error("Length mismatch 2: " + blob.l + " !== " + Offset1);
        var PSet1;
        try {
            PSet1 = parse_PropertySet(blob, null);
        } catch (e) {}
        for (y in PSet1) rval[y] = PSet1[y];
        rval.FMTID = [ FMTID0, FMTID1 ];
        return rval;
    }
    function write_PropertySetStream(entries, clsid, RE, PIDSI, entries2, clsid2) {
        var hdr = new_buf(entries2 ? 68 : 48);
        var bufs = [ hdr ];
        hdr.write_shift(2, 65534);
        hdr.write_shift(2, 0);
        hdr.write_shift(4, 842412599);
        hdr.write_shift(16, CFB.utils.consts.HEADER_CLSID, "hex");
        hdr.write_shift(4, entries2 ? 2 : 1);
        hdr.write_shift(16, clsid, "hex");
        hdr.write_shift(4, entries2 ? 68 : 48);
        var ps0 = write_PropertySet(entries, RE, PIDSI);
        bufs.push(ps0);
        if (entries2) {
            var ps1 = write_PropertySet(entries2, null, null);
            hdr.write_shift(16, clsid2, "hex");
            hdr.write_shift(4, 68 + ps0.length);
            bufs.push(ps1);
        }
        return bconcat(bufs);
    }
    function parsenoop2(blob, length) {
        blob.read_shift(length);
        return null;
    }
    function writezeroes(n, o) {
        if (!o) o = new_buf(n);
        for (var j = 0; j < n; ++j) o.write_shift(1, 0);
        return o;
    }
    function parslurp(blob, length, cb) {
        var arr = [], target = blob.l + length;
        while (blob.l < target) arr.push(cb(blob, target - blob.l));
        if (target !== blob.l) throw new Error("Slurp error");
        return arr;
    }
    function parsebool(blob, length) {
        return blob.read_shift(length) === 1;
    }
    function writebool(v, o) {
        if (!o) o = new_buf(2);
        o.write_shift(2, +!!v);
        return o;
    }
    function parseuint16(blob) {
        return blob.read_shift(2, "u");
    }
    function writeuint16(v, o) {
        if (!o) o = new_buf(2);
        o.write_shift(2, v);
        return o;
    }
    function parseuint16a(blob, length) {
        return parslurp(blob, length, parseuint16);
    }
    function parse_Bes(blob) {
        var v = blob.read_shift(1), t = blob.read_shift(1);
        return t === 1 ? v : v === 1;
    }
    function write_Bes(v, t, o) {
        if (!o) o = new_buf(2);
        o.write_shift(1, +v);
        o.write_shift(1, t == "e" ? 1 : 0);
        return o;
    }
    function parse_ShortXLUnicodeString(blob, length, opts) {
        var cch = blob.read_shift(opts && opts.biff >= 12 ? 2 : 1);
        var encoding = "sbcs-cont";
        var cp = current_codepage;
        if (opts && opts.biff >= 8) current_codepage = 1200;
        if (!opts || opts.biff == 8) {
            var fHighByte = blob.read_shift(1);
            if (fHighByte) {
                encoding = "dbcs-cont";
            }
        } else if (opts.biff == 12) {
            encoding = "wstr";
        }
        if (opts.biff >= 2 && opts.biff <= 5) encoding = "cpstr";
        var o = cch ? blob.read_shift(cch, encoding) : "";
        current_codepage = cp;
        return o;
    }
    function parse_XLUnicodeRichExtendedString(blob) {
        var cp = current_codepage;
        current_codepage = 1200;
        var cch = blob.read_shift(2), flags = blob.read_shift(1);
        var fExtSt = flags & 4, fRichSt = flags & 8;
        var width = 1 + (flags & 1);
        var cRun = 0, cbExtRst;
        var z = {};
        if (fRichSt) cRun = blob.read_shift(2);
        if (fExtSt) cbExtRst = blob.read_shift(4);
        var encoding = width == 2 ? "dbcs-cont" : "sbcs-cont";
        var msg = cch === 0 ? "" : blob.read_shift(cch, encoding);
        if (fRichSt) blob.l += 4 * cRun;
        if (fExtSt) blob.l += cbExtRst;
        z.t = msg;
        if (!fRichSt) {
            z.raw = "<t>" + z.t + "</t>";
            z.r = z.t;
        }
        current_codepage = cp;
        return z;
    }
    function parse_XLUnicodeStringNoCch(blob, cch, opts) {
        var retval;
        if (opts) {
            if (opts.biff >= 2 && opts.biff <= 5) return blob.read_shift(cch, "cpstr");
            if (opts.biff >= 12) return blob.read_shift(cch, "dbcs-cont");
        }
        var fHighByte = blob.read_shift(1);
        if (fHighByte === 0) {
            retval = blob.read_shift(cch, "sbcs-cont");
        } else {
            retval = blob.read_shift(cch, "dbcs-cont");
        }
        return retval;
    }
    function parse_XLUnicodeString(blob, length, opts) {
        var cch = blob.read_shift(opts && opts.biff == 2 ? 1 : 2);
        if (cch === 0) {
            blob.l++;
            return "";
        }
        return parse_XLUnicodeStringNoCch(blob, cch, opts);
    }
    function parse_XLUnicodeString2(blob, length, opts) {
        if (opts.biff > 5) return parse_XLUnicodeString(blob, length, opts);
        var cch = blob.read_shift(1);
        if (cch === 0) {
            blob.l++;
            return "";
        }
        return blob.read_shift(cch, opts.biff <= 4 || !blob.lens ? "cpstr" : "sbcs-cont");
    }
    function write_XLUnicodeString(str, opts, o) {
        if (!o) o = new_buf(3 + 2 * str.length);
        o.write_shift(2, str.length);
        o.write_shift(1, 1);
        o.write_shift(31, str, "utf16le");
        return o;
    }
    function parse_ControlInfo(blob) {
        var flags = blob.read_shift(1);
        blob.l++;
        var accel = blob.read_shift(2);
        blob.l += 2;
        return [ flags, accel ];
    }
    function parse_URLMoniker(blob) {
        var len = blob.read_shift(4), start = blob.l;
        var extra = false;
        if (len > 24) {
            blob.l += len - 24;
            if (blob.read_shift(16) === "795881f43b1d7f48af2c825dc4852763") extra = true;
            blob.l = start;
        }
        var url = blob.read_shift((extra ? len - 24 : len) >> 1, "utf16le").replace(chr0, "");
        if (extra) blob.l += 24;
        return url;
    }
    function parse_FileMoniker(blob) {
        blob.l += 2;
        var ansiPath = blob.read_shift(0, "lpstr-ansi");
        blob.l += 2;
        if (blob.read_shift(2) != 57005) throw new Error("Bad FileMoniker");
        var sz = blob.read_shift(4);
        if (sz === 0) return ansiPath.replace(/\\/g, "/");
        var bytes = blob.read_shift(4);
        if (blob.read_shift(2) != 3) throw new Error("Bad FileMoniker");
        var unicodePath = blob.read_shift(bytes >> 1, "utf16le").replace(chr0, "");
        return unicodePath;
    }
    function parse_HyperlinkMoniker(blob, length) {
        var clsid = blob.read_shift(16);
        length -= 16;
        switch (clsid) {
          case "e0c9ea79f9bace118c8200aa004ba90b":
            return parse_URLMoniker(blob, length);

          case "0303000000000000c000000000000046":
            return parse_FileMoniker(blob, length);

          default:
            throw new Error("Unsupported Moniker " + clsid);
        }
    }
    function parse_HyperlinkString(blob) {
        var len = blob.read_shift(4);
        var o = len > 0 ? blob.read_shift(len, "utf16le").replace(chr0, "") : "";
        return o;
    }
    function parse_Hyperlink(blob, length) {
        var end = blob.l + length;
        var sVer = blob.read_shift(4);
        if (sVer !== 2) throw new Error("Unrecognized streamVersion: " + sVer);
        var flags = blob.read_shift(2);
        blob.l += 2;
        var displayName, targetFrameName, moniker, oleMoniker, Loc = "", guid, fileTime;
        if (flags & 16) displayName = parse_HyperlinkString(blob, end - blob.l);
        if (flags & 128) targetFrameName = parse_HyperlinkString(blob, end - blob.l);
        if ((flags & 257) === 257) moniker = parse_HyperlinkString(blob, end - blob.l);
        if ((flags & 257) === 1) oleMoniker = parse_HyperlinkMoniker(blob, end - blob.l);
        if (flags & 8) Loc = parse_HyperlinkString(blob, end - blob.l);
        if (flags & 32) guid = blob.read_shift(16);
        if (flags & 64) fileTime = parse_FILETIME(blob);
        blob.l = end;
        var target = targetFrameName || moniker || oleMoniker || "";
        if (target && Loc) target += "#" + Loc;
        if (!target) target = "#" + Loc;
        var out = {
            "Target": target
        };
        if (guid) out.guid = guid;
        if (fileTime) out.time = fileTime;
        if (displayName) out.Tooltip = displayName;
        return out;
    }
    function write_Hyperlink(hl) {
        var out = new_buf(512), i = 0;
        var Target = hl.Target;
        var F = Target.indexOf("#") > -1 ? 31 : 23;
        switch (Target.charAt(0)) {
          case "#":
            F = 28;
            break;

          case ".":
            F &= ~2;
            break;
        }
        out.write_shift(4, 2);
        out.write_shift(4, F);
        var data = [ 8, 6815827, 6619237, 4849780, 83 ];
        for (i = 0; i < data.length; ++i) out.write_shift(4, data[i]);
        if (F == 28) {
            Target = Target.slice(1);
            out.write_shift(4, Target.length + 1);
            for (i = 0; i < Target.length; ++i) out.write_shift(2, Target.charCodeAt(i));
            out.write_shift(2, 0);
        } else if (F & 2) {
            data = "e0 c9 ea 79 f9 ba ce 11 8c 82 00 aa 00 4b a9 0b".split(" ");
            for (i = 0; i < data.length; ++i) out.write_shift(1, parseInt(data[i], 16));
            out.write_shift(4, 2 * (Target.length + 1));
            for (i = 0; i < Target.length; ++i) out.write_shift(2, Target.charCodeAt(i));
            out.write_shift(2, 0);
        } else {
            data = "03 03 00 00 00 00 00 00 c0 00 00 00 00 00 00 46".split(" ");
            for (i = 0; i < data.length; ++i) out.write_shift(1, parseInt(data[i], 16));
            var P = 0;
            while (Target.slice(P * 3, P * 3 + 3) == "../" || Target.slice(P * 3, P * 3 + 3) == "..\\") ++P;
            out.write_shift(2, P);
            out.write_shift(4, Target.length + 1);
            for (i = 0; i < Target.length; ++i) out.write_shift(1, Target.charCodeAt(i) & 255);
            out.write_shift(1, 0);
            out.write_shift(2, 65535);
            out.write_shift(2, 57005);
            for (i = 0; i < 6; ++i) out.write_shift(4, 0);
        }
        return out.slice(0, out.l);
    }
    function parse_LongRGBA(blob) {
        var r = blob.read_shift(1), g = blob.read_shift(1), b = blob.read_shift(1), a = blob.read_shift(1);
        return [ r, g, b, a ];
    }
    function parse_LongRGB(blob, length) {
        var x = parse_LongRGBA(blob, length);
        x[3] = 0;
        return x;
    }
    function parse_XLSCell(blob) {
        var rw = blob.read_shift(2);
        var col = blob.read_shift(2);
        var ixfe = blob.read_shift(2);
        return {
            "r": rw,
            "c": col,
            "ixfe": ixfe
        };
    }
    function write_XLSCell(R, C, ixfe, o) {
        if (!o) o = new_buf(6);
        o.write_shift(2, R);
        o.write_shift(2, C);
        o.write_shift(2, ixfe || 0);
        return o;
    }
    function parse_frtHeader(blob) {
        var rt = blob.read_shift(2);
        var flags = blob.read_shift(2);
        blob.l += 8;
        return {
            "type": rt,
            "flags": flags
        };
    }
    function parse_OptXLUnicodeString(blob, length, opts) {
        return length === 0 ? "" : parse_XLUnicodeString2(blob, length, opts);
    }
    function parse_XTI(blob, length, opts) {
        var w = opts.biff > 8 ? 4 : 2;
        var iSupBook = blob.read_shift(w), itabFirst = blob.read_shift(w, "i"), itabLast = blob.read_shift(w, "i");
        return [ iSupBook, itabFirst, itabLast ];
    }
    function parse_RkRec(blob) {
        var ixfe = blob.read_shift(2);
        var RK = parse_RkNumber(blob);
        return [ ixfe, RK ];
    }
    function parse_AddinUdf(blob, length, opts) {
        blob.l += 4;
        length -= 4;
        var l = blob.l + length;
        var udfName = parse_ShortXLUnicodeString(blob, length, opts);
        var cb = blob.read_shift(2);
        l -= blob.l;
        if (cb !== l) throw new Error("Malformed AddinUdf: padding = " + l + " != " + cb);
        blob.l += cb;
        return udfName;
    }
    function parse_Ref8U(blob) {
        var rwFirst = blob.read_shift(2);
        var rwLast = blob.read_shift(2);
        var colFirst = blob.read_shift(2);
        var colLast = blob.read_shift(2);
        return {
            "s": {
                "c": colFirst,
                "r": rwFirst
            },
            "e": {
                "c": colLast,
                "r": rwLast
            }
        };
    }
    function write_Ref8U(r, o) {
        if (!o) o = new_buf(8);
        o.write_shift(2, r.s.r);
        o.write_shift(2, r.e.r);
        o.write_shift(2, r.s.c);
        o.write_shift(2, r.e.c);
        return o;
    }
    function parse_RefU(blob) {
        var rwFirst = blob.read_shift(2);
        var rwLast = blob.read_shift(2);
        var colFirst = blob.read_shift(1);
        var colLast = blob.read_shift(1);
        return {
            "s": {
                "c": colFirst,
                "r": rwFirst
            },
            "e": {
                "c": colLast,
                "r": rwLast
            }
        };
    }
    var parse_Ref = parse_RefU;
    function parse_FtCmo(blob) {
        blob.l += 4;
        var ot = blob.read_shift(2);
        var id = blob.read_shift(2);
        var flags = blob.read_shift(2);
        blob.l += 12;
        return [ id, ot, flags ];
    }
    function parse_FtNts(blob) {
        var out = {};
        blob.l += 4;
        blob.l += 16;
        out.fSharedNote = blob.read_shift(2);
        blob.l += 4;
        return out;
    }
    function parse_FtCf(blob) {
        var out = {};
        blob.l += 4;
        blob.cf = blob.read_shift(2);
        return out;
    }
    function parse_FtSkip(blob) {
        blob.l += 2;
        blob.l += blob.read_shift(2);
    }
    var FtTab = {
        "0": parse_FtSkip,
        "4": parse_FtSkip,
        "5": parse_FtSkip,
        "6": parse_FtSkip,
        "7": parse_FtCf,
        "8": parse_FtSkip,
        "9": parse_FtSkip,
        "10": parse_FtSkip,
        "11": parse_FtSkip,
        "12": parse_FtSkip,
        "13": parse_FtNts,
        "14": parse_FtSkip,
        "15": parse_FtSkip,
        "16": parse_FtSkip,
        "17": parse_FtSkip,
        "18": parse_FtSkip,
        "19": parse_FtSkip,
        "20": parse_FtSkip,
        "21": parse_FtCmo
    };
    function parse_FtArray(blob, length) {
        var tgt = blob.l + length;
        var fts = [];
        while (blob.l < tgt) {
            var ft = blob.read_shift(2);
            blob.l -= 2;
            try {
                fts.push(FtTab[ft](blob, tgt - blob.l));
            } catch (e) {
                blob.l = tgt;
                return fts;
            }
        }
        if (blob.l != tgt) blob.l = tgt;
        return fts;
    }
    function parse_BOF(blob, length) {
        var o = {
            "BIFFVer": 0,
            "dt": 0
        };
        o.BIFFVer = blob.read_shift(2);
        length -= 2;
        if (length >= 2) {
            o.dt = blob.read_shift(2);
            blob.l -= 2;
        }
        switch (o.BIFFVer) {
          case 1536:
          case 1280:
          case 1024:
          case 768:
          case 512:
          case 2:
          case 7:
            break;

          default:
            if (length > 6) throw new Error("Unexpected BIFF Ver " + o.BIFFVer);
        }
        blob.read_shift(length);
        return o;
    }
    function write_BOF(wb, t, o) {
        var h = 1536, w = 16;
        switch (o.bookType) {
          case "biff8":
            break;

          case "biff5":
            h = 1280;
            w = 8;
            break;

          case "biff4":
            h = 4;
            w = 6;
            break;

          case "biff3":
            h = 3;
            w = 6;
            break;

          case "biff2":
            h = 2;
            w = 4;
            break;

          case "xla":
            break;

          default:
            throw new Error("unsupported BIFF version");
        }
        var out = new_buf(w);
        out.write_shift(2, h);
        out.write_shift(2, t);
        if (w > 4) out.write_shift(2, 29282);
        if (w > 6) out.write_shift(2, 1997);
        if (w > 8) {
            out.write_shift(2, 49161);
            out.write_shift(2, 1);
            out.write_shift(2, 1798);
            out.write_shift(2, 0);
        }
        return out;
    }
    function parse_InterfaceHdr(blob, length) {
        if (length === 0) return 1200;
        if (blob.read_shift(2) !== 1200) {}
        return 1200;
    }
    function parse_WriteAccess(blob, length, opts) {
        if (opts.enc) {
            blob.l += length;
            return "";
        }
        var l = blob.l;
        var UserName = parse_XLUnicodeString2(blob, 0, opts);
        blob.read_shift(length + l - blob.l);
        return UserName;
    }
    function write_WriteAccess(s, opts) {
        var b8 = !opts || opts.biff == 8;
        var o = new_buf(b8 ? 112 : 54);
        o.write_shift(opts.biff == 8 ? 2 : 1, 7);
        if (b8) o.write_shift(1, 0);
        o.write_shift(4, 859007059);
        o.write_shift(4, 5458548 | (b8 ? 0 : 536870912));
        while (o.l < o.length) o.write_shift(1, b8 ? 0 : 32);
        return o;
    }
    function parse_WsBool(blob, length, opts) {
        var flags = opts && opts.biff == 8 || length == 2 ? blob.read_shift(2) : (blob.l += length, 
        0);
        return {
            "fDialog": flags & 16
        };
    }
    function parse_BoundSheet8(blob, length, opts) {
        var pos = blob.read_shift(4);
        var hidden = blob.read_shift(1) & 3;
        var dt = blob.read_shift(1);
        switch (dt) {
          case 0:
            dt = "Worksheet";
            break;

          case 1:
            dt = "Macrosheet";
            break;

          case 2:
            dt = "Chartsheet";
            break;

          case 6:
            dt = "VBAModule";
            break;
        }
        var name = parse_ShortXLUnicodeString(blob, 0, opts);
        if (name.length === 0) name = "Sheet1";
        return {
            "pos": pos,
            "hs": hidden,
            "dt": dt,
            "name": name
        };
    }
    function write_BoundSheet8(data, opts) {
        var w = !opts || opts.biff >= 8 ? 2 : 1;
        var o = new_buf(8 + w * data.name.length);
        o.write_shift(4, data.pos);
        o.write_shift(1, data.hs || 0);
        o.write_shift(1, data.dt);
        o.write_shift(1, data.name.length);
        if (opts.biff >= 8) o.write_shift(1, 1);
        o.write_shift(w * data.name.length, data.name, opts.biff < 8 ? "sbcs" : "utf16le");
        var out = o.slice(0, o.l);
        out.l = o.l;
        return out;
    }
    function parse_SST(blob, length) {
        var end = blob.l + length;
        var cnt = blob.read_shift(4);
        var ucnt = blob.read_shift(4);
        var strs = [];
        for (var i = 0; i != ucnt && blob.l < end; ++i) {
            strs.push(parse_XLUnicodeRichExtendedString(blob));
        }
        strs.Count = cnt;
        strs.Unique = ucnt;
        return strs;
    }
    function parse_ExtSST(blob, length) {
        var extsst = {};
        extsst.dsst = blob.read_shift(2);
        blob.l += length - 2;
        return extsst;
    }
    function parse_Row(blob) {
        var z = {};
        z.r = blob.read_shift(2);
        z.c = blob.read_shift(2);
        z.cnt = blob.read_shift(2) - z.c;
        var miyRw = blob.read_shift(2);
        blob.l += 4;
        var flags = blob.read_shift(1);
        blob.l += 3;
        if (flags & 7) z.level = flags & 7;
        if (flags & 32) z.hidden = true;
        if (flags & 64) z.hpt = miyRw / 20;
        return z;
    }
    function parse_ForceFullCalculation(blob) {
        var header = parse_frtHeader(blob);
        if (header.type != 2211) throw new Error("Invalid Future Record " + header.type);
        var fullcalc = blob.read_shift(4);
        return fullcalc !== 0;
    }
    function parse_RecalcId(blob) {
        blob.read_shift(2);
        return blob.read_shift(4);
    }
    function parse_DefaultRowHeight(blob, length, opts) {
        var f = 0;
        if (!(opts && opts.biff == 2)) {
            f = blob.read_shift(2);
        }
        var miyRw = blob.read_shift(2);
        if (opts && opts.biff == 2) {
            f = 1 - (miyRw >> 15);
            miyRw &= 32767;
        }
        var fl = {
            "Unsynced": f & 1,
            "DyZero": (f & 2) >> 1,
            "ExAsc": (f & 4) >> 2,
            "ExDsc": (f & 8) >> 3
        };
        return [ fl, miyRw ];
    }
    function parse_Window1(blob) {
        var xWn = blob.read_shift(2), yWn = blob.read_shift(2), dxWn = blob.read_shift(2), dyWn = blob.read_shift(2);
        var flags = blob.read_shift(2), iTabCur = blob.read_shift(2), iTabFirst = blob.read_shift(2);
        var ctabSel = blob.read_shift(2), wTabRatio = blob.read_shift(2);
        return {
            "Pos": [ xWn, yWn ],
            "Dim": [ dxWn, dyWn ],
            "Flags": flags,
            "CurTab": iTabCur,
            "FirstTab": iTabFirst,
            "Selected": ctabSel,
            "TabRatio": wTabRatio
        };
    }
    function write_Window1() {
        var o = new_buf(18);
        o.write_shift(2, 0);
        o.write_shift(2, 0);
        o.write_shift(2, 29280);
        o.write_shift(2, 17600);
        o.write_shift(2, 56);
        o.write_shift(2, 0);
        o.write_shift(2, 0);
        o.write_shift(2, 1);
        o.write_shift(2, 500);
        return o;
    }
    function parse_Window2(blob, length, opts) {
        if (opts && opts.biff >= 2 && opts.biff < 8) return {};
        var f = blob.read_shift(2);
        return {
            "RTL": f & 64
        };
    }
    function write_Window2(view) {
        var o = new_buf(18), f = 1718;
        if (view && view.RTL) f |= 64;
        o.write_shift(2, f);
        o.write_shift(4, 0);
        o.write_shift(4, 64);
        o.write_shift(4, 0);
        o.write_shift(4, 0);
        return o;
    }
    function parse_Font(blob, length, opts) {
        var o = {
            "dyHeight": blob.read_shift(2),
            "fl": blob.read_shift(2)
        };
        switch (opts && opts.biff || 8) {
          case 2:
            break;

          case 3:
          case 4:
            blob.l += 2;
            break;

          default:
            blob.l += 10;
            break;
        }
        o.name = parse_ShortXLUnicodeString(blob, 0, opts);
        return o;
    }
    function write_Font(data, opts) {
        var name = data.name || "Arial";
        var b5 = opts && opts.biff == 5, w = b5 ? 15 + name.length : 16 + 2 * name.length;
        var o = new_buf(w);
        o.write_shift(2, (data.sz || 12) * 20);
        o.write_shift(4, 0);
        o.write_shift(2, 400);
        o.write_shift(4, 0);
        o.write_shift(2, 0);
        o.write_shift(1, name.length);
        if (!b5) o.write_shift(1, 1);
        o.write_shift((b5 ? 1 : 2) * name.length, name, b5 ? "sbcs" : "utf16le");
        return o;
    }
    function parse_LabelSst(blob) {
        var cell = parse_XLSCell(blob);
        cell.isst = blob.read_shift(4);
        return cell;
    }
    function parse_Label(blob, length, opts) {
        var target = blob.l + length;
        var cell = parse_XLSCell(blob, 6);
        if (opts.biff == 2) blob.l++;
        var str = parse_XLUnicodeString(blob, target - blob.l, opts);
        cell.val = str;
        return cell;
    }
    function write_Label(R, C, v, os, opts) {
        var b8 = !opts || opts.biff == 8;
        var o = new_buf(6 + 2 + +b8 + (1 + b8) * v.length);
        write_XLSCell(R, C, os, o);
        o.write_shift(2, v.length);
        if (b8) o.write_shift(1, 1);
        o.write_shift((1 + b8) * v.length, v, b8 ? "utf16le" : "sbcs");
        return o;
    }
    function parse_Format(blob, length, opts) {
        var numFmtId = blob.read_shift(2);
        var fmtstr = parse_XLUnicodeString2(blob, 0, opts);
        return [ numFmtId, fmtstr ];
    }
    function write_Format(i, f, opts, o) {
        var b5 = opts && opts.biff == 5;
        if (!o) o = new_buf(b5 ? 3 + f.length : 5 + 2 * f.length);
        o.write_shift(2, i);
        o.write_shift(b5 ? 1 : 2, f.length);
        if (!b5) o.write_shift(1, 1);
        o.write_shift((b5 ? 1 : 2) * f.length, f, b5 ? "sbcs" : "utf16le");
        var out = o.length > o.l ? o.slice(0, o.l) : o;
        if (out.l == null) out.l = out.length;
        return out;
    }
    var parse_BIFF2Format = parse_XLUnicodeString2;
    function parse_Dimensions(blob, length, opts) {
        var end = blob.l + length;
        var w = opts.biff == 8 || !opts.biff ? 4 : 2;
        var r = blob.read_shift(w), R = blob.read_shift(w);
        var c = blob.read_shift(2), C = blob.read_shift(2);
        blob.l = end;
        return {
            "s": {
                "r": r,
                "c": c
            },
            "e": {
                "r": R,
                "c": C
            }
        };
    }
    function write_Dimensions(range, opts) {
        var w = opts.biff == 8 || !opts.biff ? 4 : 2;
        var o = new_buf(2 * w + 6);
        o.write_shift(w, range.s.r);
        o.write_shift(w, range.e.r + 1);
        o.write_shift(2, range.s.c);
        o.write_shift(2, range.e.c + 1);
        o.write_shift(2, 0);
        return o;
    }
    function parse_RK(blob) {
        var rw = blob.read_shift(2), col = blob.read_shift(2);
        var rkrec = parse_RkRec(blob);
        return {
            "r": rw,
            "c": col,
            "ixfe": rkrec[0],
            "rknum": rkrec[1]
        };
    }
    function parse_MulRk(blob, length) {
        var target = blob.l + length - 2;
        var rw = blob.read_shift(2), col = blob.read_shift(2);
        var rkrecs = [];
        while (blob.l < target) rkrecs.push(parse_RkRec(blob));
        if (blob.l !== target) throw new Error("MulRK read error");
        var lastcol = blob.read_shift(2);
        if (rkrecs.length != lastcol - col + 1) throw new Error("MulRK length mismatch");
        return {
            "r": rw,
            "c": col,
            "C": lastcol,
            "rkrec": rkrecs
        };
    }
    function parse_MulBlank(blob, length) {
        var target = blob.l + length - 2;
        var rw = blob.read_shift(2), col = blob.read_shift(2);
        var ixfes = [];
        while (blob.l < target) ixfes.push(blob.read_shift(2));
        if (blob.l !== target) throw new Error("MulBlank read error");
        var lastcol = blob.read_shift(2);
        if (ixfes.length != lastcol - col + 1) throw new Error("MulBlank length mismatch");
        return {
            "r": rw,
            "c": col,
            "C": lastcol,
            "ixfe": ixfes
        };
    }
    function parse_CellStyleXF(blob, length, style, opts) {
        var o = {};
        var a = blob.read_shift(4), b = blob.read_shift(4);
        var c = blob.read_shift(4), d = blob.read_shift(2);
        o.patternType = XLSFillPattern[c >> 26];
        if (!opts.cellStyles) return o;
        o.alc = a & 7;
        o.fWrap = a >> 3 & 1;
        o.alcV = a >> 4 & 7;
        o.fJustLast = a >> 7 & 1;
        o.trot = a >> 8 & 255;
        o.cIndent = a >> 16 & 15;
        o.fShrinkToFit = a >> 20 & 1;
        o.iReadOrder = a >> 22 & 2;
        o.fAtrNum = a >> 26 & 1;
        o.fAtrFnt = a >> 27 & 1;
        o.fAtrAlc = a >> 28 & 1;
        o.fAtrBdr = a >> 29 & 1;
        o.fAtrPat = a >> 30 & 1;
        o.fAtrProt = a >> 31 & 1;
        o.dgLeft = b & 15;
        o.dgRight = b >> 4 & 15;
        o.dgTop = b >> 8 & 15;
        o.dgBottom = b >> 12 & 15;
        o.icvLeft = b >> 16 & 127;
        o.icvRight = b >> 23 & 127;
        o.grbitDiag = b >> 30 & 3;
        o.icvTop = c & 127;
        o.icvBottom = c >> 7 & 127;
        o.icvDiag = c >> 14 & 127;
        o.dgDiag = c >> 21 & 15;
        o.icvFore = d & 127;
        o.icvBack = d >> 7 & 127;
        o.fsxButton = d >> 14 & 1;
        return o;
    }
    function parse_XF(blob, length, opts) {
        var o = {};
        o.ifnt = blob.read_shift(2);
        o.numFmtId = blob.read_shift(2);
        o.flags = blob.read_shift(2);
        o.fStyle = o.flags >> 2 & 1;
        length -= 6;
        o.data = parse_CellStyleXF(blob, length, o.fStyle, opts);
        return o;
    }
    function write_XF(data, ixfeP, opts, o) {
        var b5 = opts && opts.biff == 5;
        if (!o) o = new_buf(b5 ? 16 : 20);
        o.write_shift(2, 0);
        if (data.style) {
            o.write_shift(2, data.numFmtId || 0);
            o.write_shift(2, 65524);
        } else {
            o.write_shift(2, data.numFmtId || 0);
            o.write_shift(2, ixfeP << 4);
        }
        o.write_shift(4, 0);
        o.write_shift(4, 0);
        if (!b5) o.write_shift(4, 0);
        o.write_shift(2, 0);
        return o;
    }
    function parse_Guts(blob) {
        blob.l += 4;
        var out = [ blob.read_shift(2), blob.read_shift(2) ];
        if (out[0] !== 0) out[0]--;
        if (out[1] !== 0) out[1]--;
        if (out[0] > 7 || out[1] > 7) throw new Error("Bad Gutters: " + out.join("|"));
        return out;
    }
    function write_Guts(guts) {
        var o = new_buf(8);
        o.write_shift(4, 0);
        o.write_shift(2, guts[0] ? guts[0] + 1 : 0);
        o.write_shift(2, guts[1] ? guts[1] + 1 : 0);
        return o;
    }
    function parse_BoolErr(blob, length, opts) {
        var cell = parse_XLSCell(blob, 6);
        if (opts.biff == 2) ++blob.l;
        var val = parse_Bes(blob, 2);
        cell.val = val;
        cell.t = val === true || val === false ? "b" : "e";
        return cell;
    }
    function write_BoolErr(R, C, v, os, opts, t) {
        var o = new_buf(8);
        write_XLSCell(R, C, os, o);
        write_Bes(v, t, o);
        return o;
    }
    function parse_Number(blob) {
        var cell = parse_XLSCell(blob, 6);
        var xnum = parse_Xnum(blob, 8);
        cell.val = xnum;
        return cell;
    }
    function write_Number(R, C, v, os) {
        var o = new_buf(14);
        write_XLSCell(R, C, os, o);
        write_Xnum(v, o);
        return o;
    }
    var parse_XLHeaderFooter = parse_OptXLUnicodeString;
    function parse_SupBook(blob, length, opts) {
        var end = blob.l + length;
        var ctab = blob.read_shift(2);
        var cch = blob.read_shift(2);
        opts.sbcch = cch;
        if (cch == 1025 || cch == 14849) return [ cch, ctab ];
        if (cch < 1 || cch > 255) throw new Error("Unexpected SupBook type: " + cch);
        var virtPath = parse_XLUnicodeStringNoCch(blob, cch);
        var rgst = [];
        while (end > blob.l) rgst.push(parse_XLUnicodeString(blob));
        return [ cch, ctab, virtPath, rgst ];
    }
    function parse_ExternName(blob, length, opts) {
        var flags = blob.read_shift(2);
        var body;
        var o = {
            "fBuiltIn": flags & 1,
            "fWantAdvise": flags >>> 1 & 1,
            "fWantPict": flags >>> 2 & 1,
            "fOle": flags >>> 3 & 1,
            "fOleLink": flags >>> 4 & 1,
            "cf": flags >>> 5 & 1023,
            "fIcon": flags >>> 15 & 1
        };
        if (opts.sbcch === 14849) body = parse_AddinUdf(blob, length - 2, opts);
        o.body = body || blob.read_shift(length - 2);
        if (typeof body === "string") o.Name = body;
        return o;
    }
    var XLSLblBuiltIn = [ "_xlnm.Consolidate_Area", "_xlnm.Auto_Open", "_xlnm.Auto_Close", "_xlnm.Extract", "_xlnm.Database", "_xlnm.Criteria", "_xlnm.Print_Area", "_xlnm.Print_Titles", "_xlnm.Recorder", "_xlnm.Data_Form", "_xlnm.Auto_Activate", "_xlnm.Auto_Deactivate", "_xlnm.Sheet_Title", "_xlnm._FilterDatabase" ];
    function parse_Lbl(blob, length, opts) {
        var target = blob.l + length;
        var flags = blob.read_shift(2);
        var chKey = blob.read_shift(1);
        var cch = blob.read_shift(1);
        var cce = blob.read_shift(opts && opts.biff == 2 ? 1 : 2);
        var itab = 0;
        if (!opts || opts.biff >= 5) {
            if (opts.biff != 5) blob.l += 2;
            itab = blob.read_shift(2);
            if (opts.biff == 5) blob.l += 2;
            blob.l += 4;
        }
        var name = parse_XLUnicodeStringNoCch(blob, cch, opts);
        if (flags & 32) name = XLSLblBuiltIn[name.charCodeAt(0)];
        var npflen = target - blob.l;
        if (opts && opts.biff == 2) --npflen;
        var rgce = target == blob.l || cce === 0 ? [] : parse_NameParsedFormula(blob, npflen, opts, cce);
        return {
            "chKey": chKey,
            "Name": name,
            "itab": itab,
            "rgce": rgce
        };
    }
    function parse_ExternSheet(blob, length, opts) {
        if (opts.biff < 8) return parse_BIFF5ExternSheet(blob, length, opts);
        var o = [], target = blob.l + length, len = blob.read_shift(opts.biff > 8 ? 4 : 2);
        while (len-- !== 0) o.push(parse_XTI(blob, opts.biff > 8 ? 12 : 6, opts));
        if (blob.l != target) throw new Error("Bad ExternSheet: " + blob.l + " != " + target);
        return o;
    }
    function parse_BIFF5ExternSheet(blob, length, opts) {
        if (blob[blob.l + 1] == 3) blob[blob.l]++;
        var o = parse_ShortXLUnicodeString(blob, length, opts);
        return o.charCodeAt(0) == 3 ? o.slice(1) : o;
    }
    function parse_NameCmt(blob, length, opts) {
        if (opts.biff < 8) {
            blob.l += length;
            return;
        }
        var cchName = blob.read_shift(2);
        var cchComment = blob.read_shift(2);
        var name = parse_XLUnicodeStringNoCch(blob, cchName, opts);
        var comment = parse_XLUnicodeStringNoCch(blob, cchComment, opts);
        return [ name, comment ];
    }
    function parse_ShrFmla(blob, length, opts) {
        var ref = parse_RefU(blob, 6);
        blob.l++;
        var cUse = blob.read_shift(1);
        length -= 8;
        return [ parse_SharedParsedFormula(blob, length, opts), cUse, ref ];
    }
    function parse_Array(blob, length, opts) {
        var ref = parse_Ref(blob, 6);
        switch (opts.biff) {
          case 2:
            blob.l++;
            length -= 7;
            break;

          case 3:
          case 4:
            blob.l += 2;
            length -= 8;
            break;

          default:
            blob.l += 6;
            length -= 12;
        }
        return [ ref, parse_ArrayParsedFormula(blob, length, opts, ref) ];
    }
    function parse_MTRSettings(blob) {
        var fMTREnabled = blob.read_shift(4) !== 0;
        var fUserSetThreadCount = blob.read_shift(4) !== 0;
        var cUserThreadCount = blob.read_shift(4);
        return [ fMTREnabled, fUserSetThreadCount, cUserThreadCount ];
    }
    function parse_NoteSh(blob, length, opts) {
        if (opts.biff < 8) return;
        var row = blob.read_shift(2), col = blob.read_shift(2);
        var flags = blob.read_shift(2), idObj = blob.read_shift(2);
        var stAuthor = parse_XLUnicodeString2(blob, 0, opts);
        if (opts.biff < 8) blob.read_shift(1);
        return [ {
            "r": row,
            "c": col
        }, stAuthor, idObj, flags ];
    }
    function parse_Note(blob, length, opts) {
        return parse_NoteSh(blob, length, opts);
    }
    function parse_MergeCells(blob, length) {
        var merges = [];
        var cmcs = blob.read_shift(2);
        while (cmcs--) merges.push(parse_Ref8U(blob, length));
        return merges;
    }
    function write_MergeCells(merges) {
        var o = new_buf(2 + merges.length * 8);
        o.write_shift(2, merges.length);
        for (var i = 0; i < merges.length; ++i) write_Ref8U(merges[i], o);
        return o;
    }
    function parse_Obj(blob, length, opts) {
        if (opts && opts.biff < 8) return parse_BIFF5Obj(blob, length, opts);
        var cmo = parse_FtCmo(blob, 22);
        var fts = parse_FtArray(blob, length - 22, cmo[1]);
        return {
            "cmo": cmo,
            "ft": fts
        };
    }
    var parse_BIFF5OT = [];
    parse_BIFF5OT[8] = function(blob, length) {
        var tgt = blob.l + length;
        blob.l += 10;
        var cf = blob.read_shift(2);
        blob.l += 4;
        blob.l += 2;
        blob.l += 2;
        blob.l += 2;
        blob.l += 4;
        var cchName = blob.read_shift(1);
        blob.l += cchName;
        blob.l = tgt;
        return {
            "fmt": cf
        };
    };
    function parse_BIFF5Obj(blob, length, opts) {
        blob.l += 4;
        var ot = blob.read_shift(2);
        var id = blob.read_shift(2);
        var grbit = blob.read_shift(2);
        blob.l += 2;
        blob.l += 2;
        blob.l += 2;
        blob.l += 2;
        blob.l += 2;
        blob.l += 2;
        blob.l += 2;
        blob.l += 2;
        blob.l += 2;
        blob.l += 6;
        length -= 36;
        var fts = [];
        fts.push((parse_BIFF5OT[ot] || parsenoop)(blob, length, opts));
        return {
            "cmo": [ id, ot, grbit ],
            "ft": fts
        };
    }
    function parse_TxO(blob, length, opts) {
        var s = blob.l;
        var texts = "";
        try {
            blob.l += 4;
            var ot = (opts.lastobj || {
                "cmo": [ 0, 0 ]
            }).cmo[1];
            var controlInfo;
            if ([ 0, 5, 7, 11, 12, 14 ].indexOf(ot) == -1) blob.l += 6; else controlInfo = parse_ControlInfo(blob, 6, opts);
            var cchText = blob.read_shift(2);
            blob.read_shift(2);
            parseuint16(blob, 2);
            var len = blob.read_shift(2);
            blob.l += len;
            for (var i = 1; i < blob.lens.length - 1; ++i) {
                if (blob.l - s != blob.lens[i]) throw new Error("TxO: bad continue record");
                var hdr = blob[blob.l];
                var t = parse_XLUnicodeStringNoCch(blob, blob.lens[i + 1] - blob.lens[i] - 1);
                texts += t;
                if (texts.length >= (hdr ? cchText : 2 * cchText)) break;
            }
            if (texts.length !== cchText && texts.length !== cchText * 2) {
                throw new Error("cchText: " + cchText + " != " + texts.length);
            }
            blob.l = s + length;
            return {
                "t": texts
            };
        } catch (e) {
            blob.l = s + length;
            return {
                "t": texts
            };
        }
    }
    function parse_HLink(blob, length) {
        var ref = parse_Ref8U(blob, 8);
        blob.l += 16;
        var hlink = parse_Hyperlink(blob, length - 24);
        return [ ref, hlink ];
    }
    function write_HLink(hl) {
        var O = new_buf(24);
        var ref = decode_cell(hl[0]);
        O.write_shift(2, ref.r);
        O.write_shift(2, ref.r);
        O.write_shift(2, ref.c);
        O.write_shift(2, ref.c);
        var clsid = "d0 c9 ea 79 f9 ba ce 11 8c 82 00 aa 00 4b a9 0b".split(" ");
        for (var i = 0; i < 16; ++i) O.write_shift(1, parseInt(clsid[i], 16));
        return bconcat([ O, write_Hyperlink(hl[1]) ]);
    }
    function parse_HLinkTooltip(blob, length) {
        blob.read_shift(2);
        var ref = parse_Ref8U(blob, 8);
        var wzTooltip = blob.read_shift((length - 10) / 2, "dbcs-cont");
        wzTooltip = wzTooltip.replace(chr0, "");
        return [ ref, wzTooltip ];
    }
    function write_HLinkTooltip(hl) {
        var TT = hl[1].Tooltip;
        var O = new_buf(10 + 2 * (TT.length + 1));
        O.write_shift(2, 2048);
        var ref = decode_cell(hl[0]);
        O.write_shift(2, ref.r);
        O.write_shift(2, ref.r);
        O.write_shift(2, ref.c);
        O.write_shift(2, ref.c);
        for (var i = 0; i < TT.length; ++i) O.write_shift(2, TT.charCodeAt(i));
        O.write_shift(2, 0);
        return O;
    }
    function parse_Country(blob) {
        var o = [ 0, 0 ], d;
        d = blob.read_shift(2);
        o[0] = CountryEnum[d] || d;
        d = blob.read_shift(2);
        o[1] = CountryEnum[d] || d;
        return o;
    }
    function write_Country(o) {
        if (!o) o = new_buf(4);
        o.write_shift(2, 1);
        o.write_shift(2, 1);
        return o;
    }
    function parse_ClrtClient(blob) {
        var ccv = blob.read_shift(2);
        var o = [];
        while (ccv-- > 0) o.push(parse_LongRGB(blob, 8));
        return o;
    }
    function parse_Palette(blob) {
        var ccv = blob.read_shift(2);
        var o = [];
        while (ccv-- > 0) o.push(parse_LongRGB(blob, 8));
        return o;
    }
    function parse_XFCRC(blob) {
        blob.l += 2;
        var o = {
            "cxfs": 0,
            "crc": 0
        };
        o.cxfs = blob.read_shift(2);
        o.crc = blob.read_shift(4);
        return o;
    }
    function parse_ColInfo(blob, length, opts) {
        if (!opts.cellStyles) return parsenoop(blob, length);
        var w = opts && opts.biff >= 12 ? 4 : 2;
        var colFirst = blob.read_shift(w);
        var colLast = blob.read_shift(w);
        var coldx = blob.read_shift(w);
        var ixfe = blob.read_shift(w);
        var flags = blob.read_shift(2);
        if (w == 2) blob.l += 2;
        return {
            "s": colFirst,
            "e": colLast,
            "w": coldx,
            "ixfe": ixfe,
            "flags": flags
        };
    }
    function parse_Setup(blob, length) {
        var o = {};
        if (length < 32) return o;
        blob.l += 16;
        o.header = parse_Xnum(blob, 8);
        o.footer = parse_Xnum(blob, 8);
        blob.l += 2;
        return o;
    }
    function parse_ShtProps(blob, length, opts) {
        var def = {
            "area": false
        };
        if (opts.biff != 5) {
            blob.l += length;
            return def;
        }
        var d = blob.read_shift(1);
        blob.l += 3;
        if (d & 16) def.area = true;
        return def;
    }
    function write_RRTabId(n) {
        var out = new_buf(2 * n);
        for (var i = 0; i < n; ++i) out.write_shift(2, i + 1);
        return out;
    }
    var parse_Blank = parse_XLSCell;
    var parse_Scl = parseuint16a;
    var parse_String = parse_XLUnicodeString;
    function parse_ImData(blob) {
        var cf = blob.read_shift(2);
        var env = blob.read_shift(2);
        var lcb = blob.read_shift(4);
        var o = {
            "fmt": cf,
            "env": env,
            "len": lcb,
            "data": blob.slice(blob.l, blob.l + lcb)
        };
        blob.l += lcb;
        return o;
    }
    function parse_BIFF2STR(blob, length, opts) {
        var cell = parse_XLSCell(blob, 6);
        ++blob.l;
        var str = parse_XLUnicodeString2(blob, length - 7, opts);
        cell.t = "str";
        cell.val = str;
        return cell;
    }
    function parse_BIFF2NUM(blob) {
        var cell = parse_XLSCell(blob, 6);
        ++blob.l;
        var num = parse_Xnum(blob, 8);
        cell.t = "n";
        cell.val = num;
        return cell;
    }
    function write_BIFF2NUM(r, c, val) {
        var out = new_buf(15);
        write_BIFF2Cell(out, r, c);
        out.write_shift(8, val, "f");
        return out;
    }
    function parse_BIFF2INT(blob) {
        var cell = parse_XLSCell(blob, 6);
        ++blob.l;
        var num = blob.read_shift(2);
        cell.t = "n";
        cell.val = num;
        return cell;
    }
    function write_BIFF2INT(r, c, val) {
        var out = new_buf(9);
        write_BIFF2Cell(out, r, c);
        out.write_shift(2, val);
        return out;
    }
    function parse_BIFF2STRING(blob) {
        var cch = blob.read_shift(1);
        if (cch === 0) {
            blob.l++;
            return "";
        }
        return blob.read_shift(cch, "sbcs-cont");
    }
    function parse_BIFF2FONTXTRA(blob, length) {
        blob.l += 6;
        blob.l += 2;
        blob.l += 1;
        blob.l += 3;
        blob.l += 1;
        blob.l += length - 13;
    }
    function parse_RString(blob, length, opts) {
        var end = blob.l + length;
        var cell = parse_XLSCell(blob, 6);
        var cch = blob.read_shift(2);
        var str = parse_XLUnicodeStringNoCch(blob, cch, opts);
        blob.l = end;
        cell.t = "str";
        cell.val = str;
        return cell;
    }
    var DBF = function() {
        var dbf_codepage_map = {
            "1": 437,
            "2": 850,
            "3": 1252,
            "4": 1e4,
            "100": 852,
            "101": 866,
            "102": 865,
            "103": 861,
            "104": 895,
            "105": 620,
            "106": 737,
            "107": 857,
            "120": 950,
            "121": 949,
            "122": 936,
            "123": 932,
            "124": 874,
            "125": 1255,
            "126": 1256,
            "150": 10007,
            "151": 10029,
            "152": 10006,
            "200": 1250,
            "201": 1251,
            "202": 1254,
            "203": 1253,
            "0": 20127,
            "8": 865,
            "9": 437,
            "10": 850,
            "11": 437,
            "13": 437,
            "14": 850,
            "15": 437,
            "16": 850,
            "17": 437,
            "18": 850,
            "19": 932,
            "20": 850,
            "21": 437,
            "22": 850,
            "23": 865,
            "24": 437,
            "25": 437,
            "26": 850,
            "27": 437,
            "28": 863,
            "29": 850,
            "31": 852,
            "34": 852,
            "35": 852,
            "36": 860,
            "37": 850,
            "38": 866,
            "55": 850,
            "64": 852,
            "77": 936,
            "78": 949,
            "79": 950,
            "80": 874,
            "87": 1252,
            "88": 1252,
            "89": 1252,
            "255": 16969
        };
        function dbf_to_aoa(buf, opts) {
            var out = [];
            var d = new_raw_buf(1);
            switch (opts.type) {
              case "base64":
                d = s2a(Base64.decode(buf));
                break;

              case "binary":
                d = s2a(buf);
                break;

              case "buffer":
              case "array":
                d = buf;
                break;
            }
            prep_blob(d, 0);
            var ft = d.read_shift(1);
            var memo = false;
            var vfp = false, l7 = false;
            switch (ft) {
              case 2:
              case 3:
                break;

              case 48:
                vfp = true;
                memo = true;
                break;

              case 49:
                vfp = true;
                break;

              case 131:
                memo = true;
                break;

              case 139:
                memo = true;
                break;

              case 140:
                memo = true;
                l7 = true;
                break;

              case 245:
                memo = true;
                break;

              default:
                throw new Error("DBF Unsupported Version: " + ft.toString(16));
            }
            var nrow = 0, fpos = 0;
            if (ft == 2) nrow = d.read_shift(2);
            d.l += 3;
            if (ft != 2) nrow = d.read_shift(4);
            if (ft != 2) fpos = d.read_shift(2);
            var rlen = d.read_shift(2);
            var current_cp = 1252;
            if (ft != 2) {
                d.l += 16;
                d.read_shift(1);
                if (d[d.l] !== 0) current_cp = dbf_codepage_map[d[d.l]];
                d.l += 1;
                d.l += 2;
            }
            if (l7) d.l += 36;
            var fields = [], field = {};
            var hend = fpos - 10 - (vfp ? 264 : 0), ww = l7 ? 32 : 11;
            while (ft == 2 ? d.l < d.length && d[d.l] != 13 : d.l < hend) {
                field = {};
                field.name = cptable.utils.decode(current_cp, d.slice(d.l, d.l + ww)).replace(/[\u0000\r\n].*$/g, "");
                d.l += ww;
                field.type = String.fromCharCode(d.read_shift(1));
                if (ft != 2 && !l7) field.offset = d.read_shift(4);
                field.len = d.read_shift(1);
                if (ft == 2) field.offset = d.read_shift(2);
                field.dec = d.read_shift(1);
                if (field.name.length) fields.push(field);
                if (ft != 2) d.l += l7 ? 13 : 14;
                switch (field.type) {
                  case "B":
                    if ((!vfp || field.len != 8) && opts.WTF) console.log("Skipping " + field.name + ":" + field.type);
                    break;

                  case "G":
                  case "P":
                    if (opts.WTF) console.log("Skipping " + field.name + ":" + field.type);
                    break;

                  case "C":
                  case "D":
                  case "F":
                  case "I":
                  case "L":
                  case "M":
                  case "N":
                  case "O":
                  case "T":
                  case "Y":
                  case "0":
                  case "@":
                  case "+":
                    break;

                  default:
                    throw new Error("Unknown Field Type: " + field.type);
                }
            }
            if (d[d.l] !== 13) d.l = fpos - 1; else if (ft == 2) d.l = 521;
            if (ft != 2) {
                if (d.read_shift(1) !== 13) throw new Error("DBF Terminator not found " + d.l + " " + d[d.l]);
                d.l = fpos;
            }
            var R = 0, C = 0;
            out[0] = [];
            for (C = 0; C != fields.length; ++C) out[0][C] = fields[C].name;
            while (nrow-- > 0) {
                if (d[d.l] === 42) {
                    d.l += rlen;
                    continue;
                }
                ++d.l;
                out[++R] = [];
                C = 0;
                for (C = 0; C != fields.length; ++C) {
                    var dd = d.slice(d.l, d.l + fields[C].len);
                    d.l += fields[C].len;
                    prep_blob(dd, 0);
                    var s = cptable.utils.decode(current_cp, dd);
                    switch (fields[C].type) {
                      case "C":
                        out[R][C] = cptable.utils.decode(current_cp, dd);
                        out[R][C] = out[R][C].trim();
                        break;

                      case "D":
                        if (s.length === 8) out[R][C] = new Date(+s.slice(0, 4), +s.slice(4, 6) - 1, +s.slice(6, 8)); else out[R][C] = s;
                        break;

                      case "F":
                        out[R][C] = parseFloat(s.trim());
                        break;

                      case "+":
                      case "I":
                        out[R][C] = l7 ? dd.read_shift(-4, "i") ^ 2147483648 : dd.read_shift(4, "i");
                        break;

                      case "L":
                        switch (s.toUpperCase()) {
                          case "Y":
                          case "T":
                            out[R][C] = true;
                            break;

                          case "N":
                          case "F":
                            out[R][C] = false;
                            break;

                          case " ":
                          case "?":
                            out[R][C] = false;
                            break;

                          default:
                            throw new Error("DBF Unrecognized L:|" + s + "|");
                        }
                        break;

                      case "M":
                        if (!memo) throw new Error("DBF Unexpected MEMO for type " + ft.toString(16));
                        out[R][C] = "##MEMO##" + (l7 ? parseInt(s.trim(), 10) : dd.read_shift(4));
                        break;

                      case "N":
                        out[R][C] = +s.replace(/\u0000/g, "").trim();
                        break;

                      case "@":
                        out[R][C] = new Date(dd.read_shift(-8, "f") - 621356832e5);
                        break;

                      case "T":
                        out[R][C] = new Date((dd.read_shift(4) - 2440588) * 864e5 + dd.read_shift(4));
                        break;

                      case "Y":
                        out[R][C] = dd.read_shift(4, "i") / 1e4;
                        break;

                      case "O":
                        out[R][C] = -dd.read_shift(-8, "f");
                        break;

                      case "B":
                        if (vfp && fields[C].len == 8) {
                            out[R][C] = dd.read_shift(8, "f");
                            break;
                        }

                      case "G":
                      case "P":
                        dd.l += fields[C].len;
                        break;

                      case "0":
                        if (fields[C].name === "_NullFlags") break;

                      default:
                        throw new Error("DBF Unsupported data type " + fields[C].type);
                    }
                }
            }
            if (ft != 2) if (d.l < d.length && d[d.l++] != 26) throw new Error("DBF EOF Marker missing " + (d.l - 1) + " of " + d.length + " " + d[d.l - 1].toString(16));
            if (opts && opts.sheetRows) out = out.slice(0, opts.sheetRows);
            return out;
        }
        function dbf_to_sheet(buf, opts) {
            var o = opts || {};
            if (!o.dateNF) o.dateNF = "yyyymmdd";
            return aoa_to_sheet(dbf_to_aoa(buf, o), o);
        }
        function dbf_to_workbook(buf, opts) {
            try {
                return sheet_to_workbook(dbf_to_sheet(buf, opts), opts);
            } catch (e) {
                if (opts && opts.WTF) throw e;
            }
            return {
                "SheetNames": [],
                "Sheets": {}
            };
        }
        var _RLEN = {
            "B": 8,
            "C": 250,
            "L": 1,
            "D": 8,
            "?": 0,
            "": 0
        };
        function sheet_to_dbf(ws, opts) {
            var o = opts || {};
            if (o.type == "string") throw new Error("Cannot write DBF to JS string");
            var ba = buf_array();
            var aoa = sheet_to_json(ws, {
                "header": 1,
                "cellDates": true
            });
            var headers = aoa[0], data = aoa.slice(1);
            var i = 0, j = 0, hcnt = 0, rlen = 1;
            for (i = 0; i < headers.length; ++i) {
                if (i == null) continue;
                ++hcnt;
                if (typeof headers[i] === "number") headers[i] = headers[i].toString(10);
                if (typeof headers[i] !== "string") throw new Error("DBF Invalid column name " + headers[i] + " |" + typeof headers[i] + "|");
                if (headers.indexOf(headers[i]) !== i) for (j = 0; j < 1024; ++j) if (headers.indexOf(headers[i] + "_" + j) == -1) {
                    headers[i] += "_" + j;
                    break;
                }
            }
            var range = safe_decode_range(ws["!ref"]);
            var coltypes = [];
            for (i = 0; i <= range.e.c - range.s.c; ++i) {
                var col = [];
                for (j = 0; j < data.length; ++j) {
                    if (data[j][i] != null) col.push(data[j][i]);
                }
                if (col.length == 0 || headers[i] == null) {
                    coltypes[i] = "?";
                    continue;
                }
                var guess = "", _guess = "";
                for (j = 0; j < col.length; ++j) {
                    switch (typeof col[j]) {
                      case "number":
                        _guess = "B";
                        break;

                      case "string":
                        _guess = "C";
                        break;

                      case "boolean":
                        _guess = "L";
                        break;

                      case "object":
                        _guess = col[j] instanceof Date ? "D" : "C";
                        break;

                      default:
                        _guess = "C";
                    }
                    guess = guess && guess != _guess ? "C" : _guess;
                    if (guess == "C") break;
                }
                rlen += _RLEN[guess] || 0;
                coltypes[i] = guess;
            }
            var h = ba.next(32);
            h.write_shift(4, 318902576);
            h.write_shift(4, data.length);
            h.write_shift(2, 296 + 32 * hcnt);
            h.write_shift(2, rlen);
            for (i = 0; i < 4; ++i) h.write_shift(4, 0);
            h.write_shift(4, 768);
            for (i = 0, j = 0; i < headers.length; ++i) {
                if (headers[i] == null) continue;
                var hf = ba.next(32);
                var _f = (headers[i].slice(-10) + "\0\0\0\0\0\0\0\0\0\0\0").slice(0, 11);
                hf.write_shift(1, _f, "sbcs");
                hf.write_shift(1, coltypes[i] == "?" ? "C" : coltypes[i], "sbcs");
                hf.write_shift(4, j);
                hf.write_shift(1, _RLEN[coltypes[i]] || 0);
                hf.write_shift(1, 0);
                hf.write_shift(1, 2);
                hf.write_shift(4, 0);
                hf.write_shift(1, 0);
                hf.write_shift(4, 0);
                hf.write_shift(4, 0);
                j += _RLEN[coltypes[i]] || 0;
            }
            var hb = ba.next(264);
            hb.write_shift(4, 13);
            for (i = 0; i < 65; ++i) hb.write_shift(4, 0);
            for (i = 0; i < data.length; ++i) {
                var rout = ba.next(rlen);
                rout.write_shift(1, 0);
                for (j = 0; j < headers.length; ++j) {
                    if (headers[j] == null) continue;
                    switch (coltypes[j]) {
                      case "L":
                        rout.write_shift(1, data[i][j] == null ? 63 : data[i][j] ? 84 : 70);
                        break;

                      case "B":
                        rout.write_shift(8, data[i][j] || 0, "f");
                        break;

                      case "D":
                        if (!data[i][j]) rout.write_shift(8, "00000000", "sbcs"); else {
                            rout.write_shift(4, ("0000" + data[i][j].getFullYear()).slice(-4), "sbcs");
                            rout.write_shift(2, ("00" + (data[i][j].getMonth() + 1)).slice(-2), "sbcs");
                            rout.write_shift(2, ("00" + data[i][j].getDate()).slice(-2), "sbcs");
                        }
                        break;

                      case "C":
                        var _s = String(data[i][j] || "");
                        rout.write_shift(1, _s, "sbcs");
                        for (hcnt = 0; hcnt < 250 - _s.length; ++hcnt) rout.write_shift(1, 32);
                        break;
                    }
                }
            }
            ba.next(1).write_shift(1, 26);
            return ba.end();
        }
        return {
            "to_workbook": dbf_to_workbook,
            "to_sheet": dbf_to_sheet,
            "from_sheet": sheet_to_dbf
        };
    }();
    var SYLK = function() {
        function sylk_to_aoa(d, opts) {
            switch (opts.type) {
              case "base64":
                return sylk_to_aoa_str(Base64.decode(d), opts);

              case "binary":
                return sylk_to_aoa_str(d, opts);

              case "buffer":
                return sylk_to_aoa_str(d.toString("binary"), opts);

              case "array":
                return sylk_to_aoa_str(cc2str(d), opts);
            }
            throw new Error("Unrecognized type " + opts.type);
        }
        function sylk_to_aoa_str(str, opts) {
            var records = str.split(/[\n\r]+/), R = -1, C = -1, ri = 0, rj = 0, arr = [];
            var formats = [];
            var next_cell_format = null;
            var sht = {}, rowinfo = [], colinfo = [], cw = [];
            var Mval = 0, j;
            for (;ri !== records.length; ++ri) {
                Mval = 0;
                var rstr = records[ri].trim();
                var record = rstr.replace(/;;/g, "\x01").split(";").map(function(x) {
                    return x.replace(/\u0001/g, ";");
                });
                var RT = record[0], val;
                if (rstr.length > 0) switch (RT) {
                  case "ID":
                    break;

                  case "E":
                    break;

                  case "B":
                    break;

                  case "O":
                    break;

                  case "P":
                    if (record[1].charAt(0) == "P") formats.push(rstr.slice(3).replace(/;;/g, ";"));
                    break;

                  case "C":
                    var C_seen_K = false, C_seen_X = false;
                    for (rj = 1; rj < record.length; ++rj) switch (record[rj].charAt(0)) {
                      case "X":
                        C = parseInt(record[rj].slice(1)) - 1;
                        C_seen_X = true;
                        break;

                      case "Y":
                        R = parseInt(record[rj].slice(1)) - 1;
                        if (!C_seen_X) C = 0;
                        for (j = arr.length; j <= R; ++j) arr[j] = [];
                        break;

                      case "K":
                        val = record[rj].slice(1);
                        if (val.charAt(0) === '"') val = val.slice(1, val.length - 1); else if (val === "TRUE") val = true; else if (val === "FALSE") val = false; else if (!isNaN(fuzzynum(val))) {
                            val = fuzzynum(val);
                            if (next_cell_format !== null && SSF.is_date(next_cell_format)) val = numdate(val);
                        } else if (!isNaN(fuzzydate(val).getDate())) {
                            val = parseDate(val);
                        }
                        if (typeof cptable !== "undefined" && typeof val == "string" && (opts || {}).type != "string" && (opts || {}).codepage) val = cptable.utils.decode(opts.codepage, val);
                        C_seen_K = true;
                        break;

                      case "E":
                        var formula = rc_to_a1(record[rj].slice(1), {
                            "r": R,
                            "c": C
                        });
                        arr[R][C] = [ arr[R][C], formula ];
                        break;

                      default:
                        if (opts && opts.WTF) throw new Error("SYLK bad record " + rstr);
                    }
                    if (C_seen_K) {
                        arr[R][C] = val;
                        next_cell_format = null;
                    }
                    break;

                  case "F":
                    var F_seen = 0;
                    for (rj = 1; rj < record.length; ++rj) switch (record[rj].charAt(0)) {
                      case "X":
                        C = parseInt(record[rj].slice(1)) - 1;
                        ++F_seen;
                        break;

                      case "Y":
                        R = parseInt(record[rj].slice(1)) - 1;
                        for (j = arr.length; j <= R; ++j) arr[j] = [];
                        break;

                      case "M":
                        Mval = parseInt(record[rj].slice(1)) / 20;
                        break;

                      case "F":
                        break;

                      case "G":
                        break;

                      case "P":
                        next_cell_format = formats[parseInt(record[rj].slice(1))];
                        break;

                      case "S":
                        break;

                      case "D":
                        break;

                      case "N":
                        break;

                      case "W":
                        cw = record[rj].slice(1).split(" ");
                        for (j = parseInt(cw[0], 10); j <= parseInt(cw[1], 10); ++j) {
                            Mval = parseInt(cw[2], 10);
                            colinfo[j - 1] = Mval === 0 ? {
                                "hidden": true
                            } : {
                                "wch": Mval
                            };
                            process_col(colinfo[j - 1]);
                        }
                        break;

                      case "C":
                        C = parseInt(record[rj].slice(1)) - 1;
                        if (!colinfo[C]) colinfo[C] = {};
                        break;

                      case "R":
                        R = parseInt(record[rj].slice(1)) - 1;
                        if (!rowinfo[R]) rowinfo[R] = {};
                        if (Mval > 0) {
                            rowinfo[R].hpt = Mval;
                            rowinfo[R].hpx = pt2px(Mval);
                        } else if (Mval === 0) rowinfo[R].hidden = true;
                        break;

                      default:
                        if (opts && opts.WTF) throw new Error("SYLK bad record " + rstr);
                    }
                    if (F_seen < 1) next_cell_format = null;
                    break;

                  default:
                    if (opts && opts.WTF) throw new Error("SYLK bad record " + rstr);
                }
            }
            if (rowinfo.length > 0) sht["!rows"] = rowinfo;
            if (colinfo.length > 0) sht["!cols"] = colinfo;
            if (opts && opts.sheetRows) arr = arr.slice(0, opts.sheetRows);
            return [ arr, sht ];
        }
        function sylk_to_sheet(d, opts) {
            var aoasht = sylk_to_aoa(d, opts);
            var aoa = aoasht[0], ws = aoasht[1];
            var o = aoa_to_sheet(aoa, opts);
            keys(ws).forEach(function(k) {
                o[k] = ws[k];
            });
            return o;
        }
        function sylk_to_workbook(d, opts) {
            return sheet_to_workbook(sylk_to_sheet(d, opts), opts);
        }
        function write_ws_cell_sylk(cell, ws, R, C) {
            var o = "C;Y" + (R + 1) + ";X" + (C + 1) + ";K";
            switch (cell.t) {
              case "n":
                o += cell.v || 0;
                if (cell.f && !cell.F) o += ";E" + a1_to_rc(cell.f, {
                    "r": R,
                    "c": C
                });
                break;

              case "b":
                o += cell.v ? "TRUE" : "FALSE";
                break;

              case "e":
                o += cell.w || cell.v;
                break;

              case "d":
                o += '"' + (cell.w || cell.v) + '"';
                break;

              case "s":
                o += '"' + cell.v.replace(/"/g, "") + '"';
                break;
            }
            return o;
        }
        function write_ws_cols_sylk(out, cols) {
            cols.forEach(function(col, i) {
                var rec = "F;W" + (i + 1) + " " + (i + 1) + " ";
                if (col.hidden) rec += "0"; else {
                    if (typeof col.width == "number") col.wpx = width2px(col.width);
                    if (typeof col.wpx == "number") col.wch = px2char(col.wpx);
                    if (typeof col.wch == "number") rec += Math.round(col.wch);
                }
                if (rec.charAt(rec.length - 1) != " ") out.push(rec);
            });
        }
        function write_ws_rows_sylk(out, rows) {
            rows.forEach(function(row, i) {
                var rec = "F;";
                if (row.hidden) rec += "M0;"; else if (row.hpt) rec += "M" + 20 * row.hpt + ";"; else if (row.hpx) rec += "M" + 20 * px2pt(row.hpx) + ";";
                if (rec.length > 2) out.push(rec + "R" + (i + 1));
            });
        }
        function sheet_to_sylk(ws, opts) {
            var preamble = [ "ID;PWXL;N;E" ], o = [];
            var r = safe_decode_range(ws["!ref"]), cell;
            var dense = Array.isArray(ws);
            var RS = "\r\n";
            preamble.push("P;PGeneral");
            preamble.push("F;P0;DG0G8;M255");
            if (ws["!cols"]) write_ws_cols_sylk(preamble, ws["!cols"]);
            if (ws["!rows"]) write_ws_rows_sylk(preamble, ws["!rows"]);
            preamble.push("B;Y" + (r.e.r - r.s.r + 1) + ";X" + (r.e.c - r.s.c + 1) + ";D" + [ r.s.c, r.s.r, r.e.c, r.e.r ].join(" "));
            for (var R = r.s.r; R <= r.e.r; ++R) {
                for (var C = r.s.c; C <= r.e.c; ++C) {
                    var coord = encode_cell({
                        "r": R,
                        "c": C
                    });
                    cell = dense ? (ws[R] || [])[C] : ws[coord];
                    if (!cell || cell.v == null && (!cell.f || cell.F)) continue;
                    o.push(write_ws_cell_sylk(cell, ws, R, C, opts));
                }
            }
            return preamble.join(RS) + RS + o.join(RS) + RS + "E" + RS;
        }
        return {
            "to_workbook": sylk_to_workbook,
            "to_sheet": sylk_to_sheet,
            "from_sheet": sheet_to_sylk
        };
    }();
    var DIF = function() {
        function dif_to_aoa(d, opts) {
            switch (opts.type) {
              case "base64":
                return dif_to_aoa_str(Base64.decode(d), opts);

              case "binary":
                return dif_to_aoa_str(d, opts);

              case "buffer":
                return dif_to_aoa_str(d.toString("binary"), opts);

              case "array":
                return dif_to_aoa_str(cc2str(d), opts);
            }
            throw new Error("Unrecognized type " + opts.type);
        }
        function dif_to_aoa_str(str, opts) {
            var records = str.split("\n"), R = -1, C = -1, ri = 0, arr = [];
            for (;ri !== records.length; ++ri) {
                if (records[ri].trim() === "BOT") {
                    arr[++R] = [];
                    C = 0;
                    continue;
                }
                if (R < 0) continue;
                var metadata = records[ri].trim().split(",");
                var type = metadata[0], value = metadata[1];
                ++ri;
                var data = records[ri].trim();
                switch (+type) {
                  case -1:
                    if (data === "BOT") {
                        arr[++R] = [];
                        C = 0;
                        continue;
                    } else if (data !== "EOD") throw new Error("Unrecognized DIF special command " + data);
                    break;

                  case 0:
                    if (data === "TRUE") arr[R][C] = true; else if (data === "FALSE") arr[R][C] = false; else if (!isNaN(fuzzynum(value))) arr[R][C] = fuzzynum(value); else if (!isNaN(fuzzydate(value).getDate())) arr[R][C] = parseDate(value); else arr[R][C] = value;
                    ++C;
                    break;

                  case 1:
                    data = data.slice(1, data.length - 1);
                    arr[R][C++] = data !== "" ? data : null;
                    break;
                }
                if (data === "EOD") break;
            }
            if (opts && opts.sheetRows) arr = arr.slice(0, opts.sheetRows);
            return arr;
        }
        function dif_to_sheet(str, opts) {
            return aoa_to_sheet(dif_to_aoa(str, opts), opts);
        }
        function dif_to_workbook(str, opts) {
            return sheet_to_workbook(dif_to_sheet(str, opts), opts);
        }
        var sheet_to_dif = function() {
            var push_field = function pf(o, topic, v, n, s) {
                o.push(topic);
                o.push(v + "," + n);
                o.push('"' + s.replace(/"/g, '""') + '"');
            };
            var push_value = function po(o, type, v, s) {
                o.push(type + "," + v);
                o.push(type == 1 ? '"' + s.replace(/"/g, '""') + '"' : s);
            };
            return function sheet_to_dif(ws) {
                var o = [];
                var r = safe_decode_range(ws["!ref"]), cell;
                var dense = Array.isArray(ws);
                push_field(o, "TABLE", 0, 1, "sheetjs");
                push_field(o, "VECTORS", 0, r.e.r - r.s.r + 1, "");
                push_field(o, "TUPLES", 0, r.e.c - r.s.c + 1, "");
                push_field(o, "DATA", 0, 0, "");
                for (var R = r.s.r; R <= r.e.r; ++R) {
                    push_value(o, -1, 0, "BOT");
                    for (var C = r.s.c; C <= r.e.c; ++C) {
                        var coord = encode_cell({
                            "r": R,
                            "c": C
                        });
                        cell = dense ? (ws[R] || [])[C] : ws[coord];
                        if (!cell) {
                            push_value(o, 1, 0, "");
                            continue;
                        }
                        switch (cell.t) {
                          case "n":
                            var val = DIF_XL ? cell.w : cell.v;
                            if (!val && cell.v != null) val = cell.v;
                            if (val == null) {
                                if (DIF_XL && cell.f && !cell.F) push_value(o, 1, 0, "=" + cell.f); else push_value(o, 1, 0, "");
                            } else push_value(o, 0, val, "V");
                            break;

                          case "b":
                            push_value(o, 0, cell.v ? 1 : 0, cell.v ? "TRUE" : "FALSE");
                            break;

                          case "s":
                            push_value(o, 1, 0, !DIF_XL || isNaN(cell.v) ? cell.v : '="' + cell.v + '"');
                            break;

                          case "d":
                            if (!cell.w) cell.w = SSF.format(cell.z || SSF._table[14], datenum(parseDate(cell.v)));
                            if (DIF_XL) push_value(o, 0, cell.w, "V"); else push_value(o, 1, 0, cell.w);
                            break;

                          default:
                            push_value(o, 1, 0, "");
                        }
                    }
                }
                push_value(o, -1, 0, "EOD");
                var RS = "\r\n";
                var oo = o.join(RS);
                return oo;
            };
        }();
        return {
            "to_workbook": dif_to_workbook,
            "to_sheet": dif_to_sheet,
            "from_sheet": sheet_to_dif
        };
    }();
    var ETH = function() {
        function decode(s) {
            return s.replace(/\\b/g, "\\").replace(/\\c/g, ":").replace(/\\n/g, "\n");
        }
        function encode(s) {
            return s.replace(/\\/g, "\\b").replace(/:/g, "\\c").replace(/\n/g, "\\n");
        }
        function eth_to_aoa(str, opts) {
            var records = str.split("\n"), R = -1, C = -1, ri = 0, arr = [];
            for (;ri !== records.length; ++ri) {
                var record = records[ri].trim().split(":");
                if (record[0] !== "cell") continue;
                var addr = decode_cell(record[1]);
                if (arr.length <= addr.r) for (R = arr.length; R <= addr.r; ++R) if (!arr[R]) arr[R] = [];
                R = addr.r;
                C = addr.c;
                switch (record[2]) {
                  case "t":
                    arr[R][C] = decode(record[3]);
                    break;

                  case "v":
                    arr[R][C] = +record[3];
                    break;

                  case "vtf":
                    var _f = record[record.length - 1];

                  case "vtc":
                    switch (record[3]) {
                      case "nl":
                        arr[R][C] = +record[4] ? true : false;
                        break;

                      default:
                        arr[R][C] = +record[4];
                        break;
                    }
                    if (record[2] == "vtf") arr[R][C] = [ arr[R][C], _f ];
                }
            }
            if (opts && opts.sheetRows) arr = arr.slice(0, opts.sheetRows);
            return arr;
        }
        function eth_to_sheet(d, opts) {
            return aoa_to_sheet(eth_to_aoa(d, opts), opts);
        }
        function eth_to_workbook(d, opts) {
            return sheet_to_workbook(eth_to_sheet(d, opts), opts);
        }
        var header = [ "socialcalc:version:1.5", "MIME-Version: 1.0", "Content-Type: multipart/mixed; boundary=SocialCalcSpreadsheetControlSave" ].join("\n");
        var sep = [ "--SocialCalcSpreadsheetControlSave", "Content-type: text/plain; charset=UTF-8" ].join("\n") + "\n";
        var meta = [ "# SocialCalc Spreadsheet Control Save", "part:sheet" ].join("\n");
        var end = "--SocialCalcSpreadsheetControlSave--";
        function sheet_to_eth_data(ws) {
            if (!ws || !ws["!ref"]) return "";
            var o = [], oo = [], cell, coord = "";
            var r = decode_range(ws["!ref"]);
            var dense = Array.isArray(ws);
            for (var R = r.s.r; R <= r.e.r; ++R) {
                for (var C = r.s.c; C <= r.e.c; ++C) {
                    coord = encode_cell({
                        "r": R,
                        "c": C
                    });
                    cell = dense ? (ws[R] || [])[C] : ws[coord];
                    if (!cell || cell.v == null || cell.t === "z") continue;
                    oo = [ "cell", coord, "t" ];
                    switch (cell.t) {
                      case "s":
                      case "str":
                        oo.push(encode(cell.v));
                        break;

                      case "n":
                        if (!cell.f) {
                            oo[2] = "v";
                            oo[3] = cell.v;
                        } else {
                            oo[2] = "vtf";
                            oo[3] = "n";
                            oo[4] = cell.v;
                            oo[5] = encode(cell.f);
                        }
                        break;

                      case "b":
                        oo[2] = "vt" + (cell.f ? "f" : "c");
                        oo[3] = "nl";
                        oo[4] = cell.v ? "1" : "0";
                        oo[5] = encode(cell.f || (cell.v ? "TRUE" : "FALSE"));
                        break;

                      case "d":
                        var t = datenum(parseDate(cell.v));
                        oo[2] = "vtc";
                        oo[3] = "nd";
                        oo[4] = "" + t;
                        oo[5] = cell.w || SSF.format(cell.z || SSF._table[14], t);
                        break;

                      case "e":
                        continue;
                    }
                    o.push(oo.join(":"));
                }
            }
            o.push("sheet:c:" + (r.e.c - r.s.c + 1) + ":r:" + (r.e.r - r.s.r + 1) + ":tvf:1");
            o.push("valueformat:1:text-wiki");
            return o.join("\n");
        }
        function sheet_to_eth(ws) {
            return [ header, sep, meta, sep, sheet_to_eth_data(ws), end ].join("\n");
        }
        return {
            "to_workbook": eth_to_workbook,
            "to_sheet": eth_to_sheet,
            "from_sheet": sheet_to_eth
        };
    }();
    var PRN = function() {
        function set_text_arr(data, arr, R, C, o) {
            if (o.raw) arr[R][C] = data; else if (data === "TRUE") arr[R][C] = true; else if (data === "FALSE") arr[R][C] = false; else if (data === "") {} else if (!isNaN(fuzzynum(data))) arr[R][C] = fuzzynum(data); else if (!isNaN(fuzzydate(data).getDate())) arr[R][C] = parseDate(data); else arr[R][C] = data;
        }
        function prn_to_aoa_str(f, opts) {
            var o = opts || {};
            var arr = [];
            if (!f || f.length === 0) return arr;
            var lines = f.split(/[\r\n]/);
            var L = lines.length - 1;
            while (L >= 0 && lines[L].length === 0) --L;
            var start = 10, idx = 0;
            var R = 0;
            for (;R <= L; ++R) {
                idx = lines[R].indexOf(" ");
                if (idx == -1) idx = lines[R].length; else idx++;
                start = Math.max(start, idx);
            }
            for (R = 0; R <= L; ++R) {
                arr[R] = [];
                var C = 0;
                set_text_arr(lines[R].slice(0, start).trim(), arr, R, C, o);
                for (C = 1; C <= (lines[R].length - start) / 10 + 1; ++C) set_text_arr(lines[R].slice(start + (C - 1) * 10, start + C * 10).trim(), arr, R, C, o);
            }
            if (o.sheetRows) arr = arr.slice(0, o.sheetRows);
            return arr;
        }
        var guess_seps = {
            "44": ",",
            "9": "\t",
            "59": ";"
        };
        var guess_sep_weights = {
            "44": 3,
            "9": 2,
            "59": 1
        };
        function guess_sep(str) {
            var cnt = {}, instr = false, end = 0, cc = 0;
            for (;end < str.length; ++end) {
                if ((cc = str.charCodeAt(end)) == 34) instr = !instr; else if (!instr && cc in guess_seps) cnt[cc] = (cnt[cc] || 0) + 1;
            }
            cc = [];
            for (end in cnt) if (cnt.hasOwnProperty(end)) {
                cc.push([ cnt[end], end ]);
            }
            if (!cc.length) {
                cnt = guess_sep_weights;
                for (end in cnt) if (cnt.hasOwnProperty(end)) {
                    cc.push([ cnt[end], end ]);
                }
            }
            cc.sort(function(a, b) {
                return a[0] - b[0] || guess_sep_weights[a[1]] - guess_sep_weights[b[1]];
            });
            return guess_seps[cc.pop()[1]];
        }
        function dsv_to_sheet_str(str, opts) {
            var o = opts || {};
            var sep = "";
            if (DENSE != null && o.dense == null) o.dense = DENSE;
            var ws = o.dense ? [] : {};
            var range = {
                "s": {
                    "c": 0,
                    "r": 0
                },
                "e": {
                    "c": 0,
                    "r": 0
                }
            };
            if (str.slice(0, 4) == "sep=" && str.charCodeAt(5) == 10) {
                sep = str.charAt(4);
                str = str.slice(6);
            } else sep = guess_sep(str.slice(0, 1024));
            var R = 0, C = 0, v = 0;
            var start = 0, end = 0, sepcc = sep.charCodeAt(0), instr = false, cc = 0;
            str = str.replace(/\r\n/gm, "\n");
            var _re = o.dateNF != null ? dateNF_regex(o.dateNF) : null;
            function finish_cell() {
                var s = str.slice(start, end);
                var cell = {};
                if (s.charAt(0) == '"' && s.charAt(s.length - 1) == '"') s = s.slice(1, -1).replace(/""/g, '"');
                if (s.length === 0) cell.t = "z"; else if (o.raw) {
                    cell.t = "s";
                    cell.v = s;
                } else if (s.trim().length === 0) {
                    cell.t = "s";
                    cell.v = s;
                } else if (s.charCodeAt(0) == 61) {
                    if (s.charCodeAt(1) == 34 && s.charCodeAt(s.length - 1) == 34) {
                        cell.t = "s";
                        cell.v = s.slice(2, -1).replace(/""/g, '"');
                    } else if (fuzzyfmla(s)) {
                        cell.t = "n";
                        cell.f = s.slice(1);
                    } else {
                        cell.t = "s";
                        cell.v = s;
                    }
                } else if (s == "TRUE") {
                    cell.t = "b";
                    cell.v = true;
                } else if (s == "FALSE") {
                    cell.t = "b";
                    cell.v = false;
                } else if (!isNaN(v = fuzzynum(s))) {
                    cell.t = "n";
                    if (o.cellText !== false) cell.w = s;
                    cell.v = v;
                } else if (!isNaN(fuzzydate(s).getDate()) || _re && s.match(_re)) {
                    cell.z = o.dateNF || SSF._table[14];
                    var k = 0;
                    if (_re && s.match(_re)) {
                        s = dateNF_fix(s, o.dateNF, s.match(_re) || []);
                        k = 1;
                    }
                    if (o.cellDates) {
                        cell.t = "d";
                        cell.v = parseDate(s, k);
                    } else {
                        cell.t = "n";
                        cell.v = datenum(parseDate(s, k));
                    }
                    if (o.cellText !== false) cell.w = SSF.format(cell.z, cell.v instanceof Date ? datenum(cell.v) : cell.v);
                    if (!o.cellNF) delete cell.z;
                } else {
                    cell.t = "s";
                    cell.v = s;
                }
                if (cell.t == "z") {} else if (o.dense) {
                    if (!ws[R]) ws[R] = [];
                    ws[R][C] = cell;
                } else ws[encode_cell({
                    "c": C,
                    "r": R
                })] = cell;
                start = end + 1;
                if (range.e.c < C) range.e.c = C;
                if (range.e.r < R) range.e.r = R;
                if (cc == sepcc) ++C; else {
                    C = 0;
                    ++R;
                    if (o.sheetRows && o.sheetRows <= R) return true;
                }
            }
            outer: for (;end < str.length; ++end) switch (cc = str.charCodeAt(end)) {
              case 34:
                instr = !instr;
                break;

              case sepcc:
              case 10:
              case 13:
                if (!instr && finish_cell()) break outer;
                break;

              default:
                break;
            }
            if (end - start > 0) finish_cell();
            ws["!ref"] = encode_range(range);
            return ws;
        }
        function prn_to_sheet_str(str, opts) {
            if (str.slice(0, 4) == "sep=") return dsv_to_sheet_str(str, opts);
            if (str.indexOf("\t") >= 0 || str.indexOf(",") >= 0 || str.indexOf(";") >= 0) return dsv_to_sheet_str(str, opts);
            return aoa_to_sheet(prn_to_aoa_str(str, opts), opts);
        }
        function prn_to_sheet(d, opts) {
            var str = "", bytes = opts.type == "string" ? [ 0, 0, 0, 0 ] : firstbyte(d, opts);
            switch (opts.type) {
              case "base64":
                str = Base64.decode(d);
                break;

              case "binary":
                str = d;
                break;

              case "buffer":
                if (opts.codepage == 65001) str = d.toString("utf8"); else if (opts.codepage && typeof cptable !== "undefined") str = cptable.utils.decode(opts.codepage, d); else str = d.toString("binary");
                break;

              case "array":
                str = cc2str(d);
                break;

              case "string":
                str = d;
                break;

              default:
                throw new Error("Unrecognized type " + opts.type);
            }
            if (bytes[0] == 239 && bytes[1] == 187 && bytes[2] == 191) str = utf8read(str.slice(3)); else if (opts.type == "binary" && typeof cptable !== "undefined" && opts.codepage) str = cptable.utils.decode(opts.codepage, cptable.utils.encode(1252, str));
            if (str.slice(0, 19) == "socialcalc:version:") return ETH.to_sheet(opts.type == "string" ? str : utf8read(str), opts);
            return prn_to_sheet_str(str, opts);
        }
        function prn_to_workbook(d, opts) {
            return sheet_to_workbook(prn_to_sheet(d, opts), opts);
        }
        function sheet_to_prn(ws) {
            var o = [];
            var r = safe_decode_range(ws["!ref"]), cell;
            var dense = Array.isArray(ws);
            for (var R = r.s.r; R <= r.e.r; ++R) {
                var oo = [];
                for (var C = r.s.c; C <= r.e.c; ++C) {
                    var coord = encode_cell({
                        "r": R,
                        "c": C
                    });
                    cell = dense ? (ws[R] || [])[C] : ws[coord];
                    if (!cell || cell.v == null) {
                        oo.push("          ");
                        continue;
                    }
                    var w = (cell.w || (format_cell(cell), cell.w) || "").slice(0, 10);
                    while (w.length < 10) w += " ";
                    oo.push(w + (C === 0 ? " " : ""));
                }
                o.push(oo.join(""));
            }
            return o.join("\n");
        }
        return {
            "to_workbook": prn_to_workbook,
            "to_sheet": prn_to_sheet,
            "from_sheet": sheet_to_prn
        };
    }();
    function read_wb_ID(d, opts) {
        var o = opts || {}, OLD_WTF = !!o.WTF;
        o.WTF = true;
        try {
            var out = SYLK.to_workbook(d, o);
            o.WTF = OLD_WTF;
            return out;
        } catch (e) {
            o.WTF = OLD_WTF;
            if (!e.message.match(/SYLK bad record ID/) && OLD_WTF) throw e;
            return PRN.to_workbook(d, opts);
        }
    }
    var WK_ = function() {
        function lotushopper(data, cb, opts) {
            if (!data) return;
            prep_blob(data, data.l || 0);
            var Enum = opts.Enum || WK1Enum;
            while (data.l < data.length) {
                var RT = data.read_shift(2);
                var R = Enum[RT] || Enum[255];
                var length = data.read_shift(2);
                var tgt = data.l + length;
                var d = (R.f || parsenoop)(data, length, opts);
                data.l = tgt;
                if (cb(d, R.n, RT)) return;
            }
        }
        function lotus_to_workbook(d, opts) {
            switch (opts.type) {
              case "base64":
                return lotus_to_workbook_buf(s2a(Base64.decode(d)), opts);

              case "binary":
                return lotus_to_workbook_buf(s2a(d), opts);

              case "buffer":
              case "array":
                return lotus_to_workbook_buf(d, opts);
            }
            throw "Unsupported type " + opts.type;
        }
        function lotus_to_workbook_buf(d, opts) {
            if (!d) return d;
            var o = opts || {};
            if (DENSE != null && o.dense == null) o.dense = DENSE;
            var s = o.dense ? [] : {}, n = "Sheet1", sidx = 0;
            var sheets = {}, snames = [ n ];
            var refguess = {
                "s": {
                    "r": 0,
                    "c": 0
                },
                "e": {
                    "r": 0,
                    "c": 0
                }
            };
            var sheetRows = o.sheetRows || 0;
            if (d[2] == 2) o.Enum = WK1Enum; else if (d[2] == 26) o.Enum = WK3Enum; else if (d[2] == 14) {
                o.Enum = WK3Enum;
                o.qpro = true;
                d.l = 0;
            } else throw new Error("Unrecognized LOTUS BOF " + d[2]);
            lotushopper(d, function(val, Rn, RT) {
                if (d[2] == 2) switch (RT) {
                  case 0:
                    o.vers = val;
                    if (val >= 4096) o.qpro = true;
                    break;

                  case 6:
                    refguess = val;
                    break;

                  case 15:
                    if (!o.qpro) val[1].v = val[1].v.slice(1);

                  case 13:
                  case 14:
                  case 16:
                  case 51:
                    if (RT == 14 && (val[2] & 112) == 112 && (val[2] & 15) > 1 && (val[2] & 15) < 15) {
                        val[1].z = o.dateNF || SSF._table[14];
                        if (o.cellDates) {
                            val[1].t = "d";
                            val[1].v = numdate(val[1].v);
                        }
                    }
                    if (o.dense) {
                        if (!s[val[0].r]) s[val[0].r] = [];
                        s[val[0].r][val[0].c] = val[1];
                    } else s[encode_cell(val[0])] = val[1];
                    break;
                } else switch (RT) {
                  case 22:
                    val[1].v = val[1].v.slice(1);

                  case 23:
                  case 24:
                  case 25:
                  case 37:
                  case 39:
                  case 40:
                    if (val[3] > sidx) {
                        s["!ref"] = encode_range(refguess);
                        sheets[n] = s;
                        s = o.dense ? [] : {};
                        refguess = {
                            "s": {
                                "r": 0,
                                "c": 0
                            },
                            "e": {
                                "r": 0,
                                "c": 0
                            }
                        };
                        sidx = val[3];
                        n = "Sheet" + (sidx + 1);
                        snames.push(n);
                    }
                    if (sheetRows > 0 && val[0].r >= sheetRows) break;
                    if (o.dense) {
                        if (!s[val[0].r]) s[val[0].r] = [];
                        s[val[0].r][val[0].c] = val[1];
                    } else s[encode_cell(val[0])] = val[1];
                    if (refguess.e.c < val[0].c) refguess.e.c = val[0].c;
                    if (refguess.e.r < val[0].r) refguess.e.r = val[0].r;
                    break;

                  default:
                    break;
                }
            }, o);
            s["!ref"] = encode_range(refguess);
            sheets[n] = s;
            return {
                "SheetNames": snames,
                "Sheets": sheets
            };
        }
        function parse_RANGE(blob) {
            var o = {
                "s": {
                    "c": 0,
                    "r": 0
                },
                "e": {
                    "c": 0,
                    "r": 0
                }
            };
            o.s.c = blob.read_shift(2);
            o.s.r = blob.read_shift(2);
            o.e.c = blob.read_shift(2);
            o.e.r = blob.read_shift(2);
            if (o.s.c == 65535) o.s.c = o.e.c = o.s.r = o.e.r = 0;
            return o;
        }
        function parse_cell(blob, length, opts) {
            var o = [ {
                "c": 0,
                "r": 0
            }, {
                "t": "n",
                "v": 0
            }, 0 ];
            if (opts.qpro && opts.vers != 20768) {
                o[0].c = blob.read_shift(1);
                blob.l++;
                o[0].r = blob.read_shift(2);
                blob.l += 2;
            } else {
                o[2] = blob.read_shift(1);
                o[0].c = blob.read_shift(2);
                o[0].r = blob.read_shift(2);
            }
            return o;
        }
        function parse_LABEL(blob, length, opts) {
            var tgt = blob.l + length;
            var o = parse_cell(blob, length, opts);
            o[1].t = "s";
            if (opts.vers == 20768) {
                blob.l++;
                var len = blob.read_shift(1);
                o[1].v = blob.read_shift(len, "utf8");
                return o;
            }
            if (opts.qpro) blob.l++;
            o[1].v = blob.read_shift(tgt - blob.l, "cstr");
            return o;
        }
        function parse_INTEGER(blob, length, opts) {
            var o = parse_cell(blob, length, opts);
            o[1].v = blob.read_shift(2, "i");
            return o;
        }
        function parse_NUMBER(blob, length, opts) {
            var o = parse_cell(blob, length, opts);
            o[1].v = blob.read_shift(8, "f");
            return o;
        }
        function parse_FORMULA(blob, length, opts) {
            var tgt = blob.l + length;
            var o = parse_cell(blob, length, opts);
            o[1].v = blob.read_shift(8, "f");
            if (opts.qpro) blob.l = tgt; else {
                var flen = blob.read_shift(2);
                blob.l += flen;
            }
            return o;
        }
        function parse_cell_3(blob) {
            var o = [ {
                "c": 0,
                "r": 0
            }, {
                "t": "n",
                "v": 0
            }, 0 ];
            o[0].r = blob.read_shift(2);
            o[3] = blob[blob.l++];
            o[0].c = blob[blob.l++];
            return o;
        }
        function parse_LABEL_16(blob, length) {
            var o = parse_cell_3(blob, length);
            o[1].t = "s";
            o[1].v = blob.read_shift(length - 4, "cstr");
            return o;
        }
        function parse_NUMBER_18(blob, length) {
            var o = parse_cell_3(blob, length);
            o[1].v = blob.read_shift(2);
            var v = o[1].v >> 1;
            if (o[1].v & 1) {
                switch (v & 7) {
                  case 1:
                    v = (v >> 3) * 500;
                    break;

                  case 2:
                    v = (v >> 3) / 20;
                    break;

                  case 4:
                    v = (v >> 3) / 2e3;
                    break;

                  case 6:
                    v = (v >> 3) / 16;
                    break;

                  case 7:
                    v = (v >> 3) / 64;
                    break;

                  default:
                    throw "unknown NUMBER_18 encoding " + (v & 7);
                }
            }
            o[1].v = v;
            return o;
        }
        function parse_NUMBER_17(blob, length) {
            var o = parse_cell_3(blob, length);
            var v1 = blob.read_shift(4);
            var v2 = blob.read_shift(4);
            var e = blob.read_shift(2);
            if (e == 65535) {
                o[1].v = 0;
                return o;
            }
            var s = e & 32768;
            e = (e & 32767) - 16446;
            o[1].v = (s * 2 - 1) * ((e > 0 ? v2 << e : v2 >>> -e) + (e > -32 ? v1 << e + 32 : v1 >>> -(e + 32)));
            return o;
        }
        function parse_FORMULA_19(blob, length) {
            var o = parse_NUMBER_17(blob, 14);
            blob.l += length - 14;
            return o;
        }
        function parse_NUMBER_25(blob, length) {
            var o = parse_cell_3(blob, length);
            var v1 = blob.read_shift(4);
            o[1].v = v1 >> 6;
            return o;
        }
        function parse_NUMBER_27(blob, length) {
            var o = parse_cell_3(blob, length);
            var v1 = blob.read_shift(8, "f");
            o[1].v = v1;
            return o;
        }
        function parse_FORMULA_28(blob, length) {
            var o = parse_NUMBER_27(blob, 14);
            blob.l += length - 10;
            return o;
        }
        var WK1Enum = {
            "0": {
                "n": "BOF",
                "f": parseuint16
            },
            "1": {
                "n": "EOF"
            },
            "2": {
                "n": "CALCMODE"
            },
            "3": {
                "n": "CALCORDER"
            },
            "4": {
                "n": "SPLIT"
            },
            "5": {
                "n": "SYNC"
            },
            "6": {
                "n": "RANGE",
                "f": parse_RANGE
            },
            "7": {
                "n": "WINDOW1"
            },
            "8": {
                "n": "COLW1"
            },
            "9": {
                "n": "WINTWO"
            },
            "10": {
                "n": "COLW2"
            },
            "11": {
                "n": "NAME"
            },
            "12": {
                "n": "BLANK"
            },
            "13": {
                "n": "INTEGER",
                "f": parse_INTEGER
            },
            "14": {
                "n": "NUMBER",
                "f": parse_NUMBER
            },
            "15": {
                "n": "LABEL",
                "f": parse_LABEL
            },
            "16": {
                "n": "FORMULA",
                "f": parse_FORMULA
            },
            "24": {
                "n": "TABLE"
            },
            "25": {
                "n": "ORANGE"
            },
            "26": {
                "n": "PRANGE"
            },
            "27": {
                "n": "SRANGE"
            },
            "28": {
                "n": "FRANGE"
            },
            "29": {
                "n": "KRANGE1"
            },
            "32": {
                "n": "HRANGE"
            },
            "35": {
                "n": "KRANGE2"
            },
            "36": {
                "n": "PROTEC"
            },
            "37": {
                "n": "FOOTER"
            },
            "38": {
                "n": "HEADER"
            },
            "39": {
                "n": "SETUP"
            },
            "40": {
                "n": "MARGINS"
            },
            "41": {
                "n": "LABELFMT"
            },
            "42": {
                "n": "TITLES"
            },
            "43": {
                "n": "SHEETJS"
            },
            "45": {
                "n": "GRAPH"
            },
            "46": {
                "n": "NGRAPH"
            },
            "47": {
                "n": "CALCCOUNT"
            },
            "48": {
                "n": "UNFORMATTED"
            },
            "49": {
                "n": "CURSORW12"
            },
            "50": {
                "n": "WINDOW"
            },
            "51": {
                "n": "STRING",
                "f": parse_LABEL
            },
            "55": {
                "n": "PASSWORD"
            },
            "56": {
                "n": "LOCKED"
            },
            "60": {
                "n": "QUERY"
            },
            "61": {
                "n": "QUERYNAME"
            },
            "62": {
                "n": "PRINT"
            },
            "63": {
                "n": "PRINTNAME"
            },
            "64": {
                "n": "GRAPH2"
            },
            "65": {
                "n": "GRAPHNAME"
            },
            "66": {
                "n": "ZOOM"
            },
            "67": {
                "n": "SYMSPLIT"
            },
            "68": {
                "n": "NSROWS"
            },
            "69": {
                "n": "NSCOLS"
            },
            "70": {
                "n": "RULER"
            },
            "71": {
                "n": "NNAME"
            },
            "72": {
                "n": "ACOMM"
            },
            "73": {
                "n": "AMACRO"
            },
            "74": {
                "n": "PARSE"
            },
            "255": {
                "n": "",
                "f": parsenoop
            }
        };
        var WK3Enum = {
            "0": {
                "n": "BOF"
            },
            "1": {
                "n": "EOF"
            },
            "3": {
                "n": "??"
            },
            "4": {
                "n": "??"
            },
            "5": {
                "n": "??"
            },
            "6": {
                "n": "??"
            },
            "7": {
                "n": "??"
            },
            "9": {
                "n": "??"
            },
            "10": {
                "n": "??"
            },
            "11": {
                "n": "??"
            },
            "12": {
                "n": "??"
            },
            "14": {
                "n": "??"
            },
            "15": {
                "n": "??"
            },
            "16": {
                "n": "??"
            },
            "17": {
                "n": "??"
            },
            "18": {
                "n": "??"
            },
            "19": {
                "n": "??"
            },
            "21": {
                "n": "??"
            },
            "22": {
                "n": "LABEL16",
                "f": parse_LABEL_16
            },
            "23": {
                "n": "NUMBER17",
                "f": parse_NUMBER_17
            },
            "24": {
                "n": "NUMBER18",
                "f": parse_NUMBER_18
            },
            "25": {
                "n": "FORMULA19",
                "f": parse_FORMULA_19
            },
            "26": {
                "n": "??"
            },
            "27": {
                "n": "??"
            },
            "28": {
                "n": "??"
            },
            "29": {
                "n": "??"
            },
            "30": {
                "n": "??"
            },
            "31": {
                "n": "??"
            },
            "33": {
                "n": "??"
            },
            "37": {
                "n": "NUMBER25",
                "f": parse_NUMBER_25
            },
            "39": {
                "n": "NUMBER27",
                "f": parse_NUMBER_27
            },
            "40": {
                "n": "FORMULA28",
                "f": parse_FORMULA_28
            },
            "255": {
                "n": "",
                "f": parsenoop
            }
        };
        return {
            "to_workbook": lotus_to_workbook
        };
    }();
    var parse_rs = function parse_rs_factory() {
        var tregex = matchtag("t"), rpregex = matchtag("rPr"), rregex = /<(?:\w+:)?r>/g, rend = /<\/(?:\w+:)?r>/, nlregex = /\r\n/g;
        var parse_rpr = function parse_rpr(rpr, intro, outro) {
            var font = {}, cp = 65001, align = "";
            var pass = false;
            var m = rpr.match(tagregex), i = 0;
            if (m) for (;i != m.length; ++i) {
                var y = parsexmltag(m[i]);
                switch (y[0].replace(/\w*:/g, "")) {
                  case "<condense":
                    break;

                  case "<extend":
                    break;

                  case "<shadow":
                    if (!y.val) break;

                  case "<shadow>":
                  case "<shadow/>":
                    font.shadow = 1;
                    break;

                  case "</shadow>":
                    break;

                  case "<charset":
                    if (y.val == "1") break;
                    cp = CS2CP[parseInt(y.val, 10)];
                    break;

                  case "<outline":
                    if (!y.val) break;

                  case "<outline>":
                  case "<outline/>":
                    font.outline = 1;
                    break;

                  case "</outline>":
                    break;

                  case "<rFont":
                    font.name = y.val;
                    break;

                  case "<sz":
                    font.sz = y.val;
                    break;

                  case "<strike":
                    if (!y.val) break;

                  case "<strike>":
                  case "<strike/>":
                    font.strike = 1;
                    break;

                  case "</strike>":
                    break;

                  case "<u":
                    if (!y.val) break;
                    switch (y.val) {
                      case "double":
                        font.uval = "double";
                        break;

                      case "singleAccounting":
                        font.uval = "single-accounting";
                        break;

                      case "doubleAccounting":
                        font.uval = "double-accounting";
                        break;
                    }

                  case "<u>":
                  case "<u/>":
                    font.u = 1;
                    break;

                  case "</u>":
                    break;

                  case "<b":
                    if (y.val == "0") break;

                  case "<b>":
                  case "<b/>":
                    font.b = 1;
                    break;

                  case "</b>":
                    break;

                  case "<i":
                    if (y.val == "0") break;

                  case "<i>":
                  case "<i/>":
                    font.i = 1;
                    break;

                  case "</i>":
                    break;

                  case "<color":
                    if (y.rgb) font.color = y.rgb.slice(2, 8);
                    break;

                  case "<family":
                    font.family = y.val;
                    break;

                  case "<vertAlign":
                    align = y.val;
                    break;

                  case "<scheme":
                    break;

                  case "<extLst":
                  case "<extLst>":
                  case "</extLst>":
                    break;

                  case "<ext":
                    pass = true;
                    break;

                  case "</ext>":
                    pass = false;
                    break;

                  default:
                    if (y[0].charCodeAt(1) !== 47 && !pass) throw new Error("Unrecognized rich format " + y[0]);
                }
            }
            var style = [];
            if (font.u) style.push("text-decoration: underline;");
            if (font.uval) style.push("text-underline-style:" + font.uval + ";");
            if (font.sz) style.push("font-size:" + font.sz + "pt;");
            if (font.outline) style.push("text-effect: outline;");
            if (font.shadow) style.push("text-shadow: auto;");
            intro.push('<span style="' + style.join("") + '">');
            if (font.b) {
                intro.push("<b>");
                outro.push("</b>");
            }
            if (font.i) {
                intro.push("<i>");
                outro.push("</i>");
            }
            if (font.strike) {
                intro.push("<s>");
                outro.push("</s>");
            }
            if (align == "superscript") align = "sup"; else if (align == "subscript") align = "sub";
            if (align != "") {
                intro.push("<" + align + ">");
                outro.push("</" + align + ">");
            }
            outro.push("</span>");
            return cp;
        };
        function parse_r(r) {
            var terms = [ [], "", [] ];
            var t = r.match(tregex);
            if (!t) return "";
            terms[1] = t[1];
            var rpr = r.match(rpregex);
            if (rpr) parse_rpr(rpr[1], terms[0], terms[2]);
            return terms[0].join("") + terms[1].replace(nlregex, "<br/>") + terms[2].join("");
        }
        return function parse_rs(rs) {
            return rs.replace(rregex, "").split(rend).map(parse_r).join("");
        };
    }();
    var sitregex = /<(?:\w+:)?t[^>]*>([^<]*)<\/(?:\w+:)?t>/g, sirregex = /<(?:\w+:)?r>/;
    var sirphregex = /<(?:\w+:)?rPh.*?>([\s\S]*?)<\/(?:\w+:)?rPh>/g;
    function parse_si(x, opts) {
        var html = opts ? opts.cellHTML : true;
        var z = {};
        if (!x) return null;
        if (x.match(/^\s*<(?:\w+:)?t[^>]*>/)) {
            z.t = unescapexml(utf8read(x.slice(x.indexOf(">") + 1).split(/<\/(?:\w+:)?t>/)[0] || ""));
            z.r = utf8read(x);
            if (html) z.h = escapehtml(z.t);
        } else if (x.match(sirregex)) {
            z.r = utf8read(x);
            z.t = unescapexml(utf8read((x.replace(sirphregex, "").match(sitregex) || []).join("").replace(tagregex, "")));
            if (html) z.h = parse_rs(z.r);
        }
        return z;
    }
    var sstr0 = /<(?:\w+:)?sst([^>]*)>([\s\S]*)<\/(?:\w+:)?sst>/;
    var sstr1 = /<(?:\w+:)?(?:si|sstItem)>/g;
    var sstr2 = /<\/(?:\w+:)?(?:si|sstItem)>/;
    function parse_sst_xml(data, opts) {
        var s = [], ss = "";
        if (!data) return s;
        var sst = data.match(sstr0);
        if (sst) {
            ss = sst[2].replace(sstr1, "").split(sstr2);
            for (var i = 0; i != ss.length; ++i) {
                var o = parse_si(ss[i].trim(), opts);
                if (o != null) s[s.length] = o;
            }
            sst = parsexmltag(sst[1]);
            s.Count = sst.count;
            s.Unique = sst.uniqueCount;
        }
        return s;
    }
    RELS.SST = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings";
    var straywsregex = /^\s|\s$|[\t\n\r]/;
    function write_sst_xml(sst, opts) {
        if (!opts.bookSST) return "";
        var o = [ XML_HEADER ];
        o[o.length] = writextag("sst", null, {
            "xmlns": XMLNS.main[0],
            "count": sst.Count,
            "uniqueCount": sst.Unique
        });
        for (var i = 0; i != sst.length; ++i) {
            if (sst[i] == null) continue;
            var s = sst[i];
            var sitag = "<si>";
            if (s.r) sitag += s.r; else {
                sitag += "<t";
                if (!s.t) s.t = "";
                if (s.t.match(straywsregex)) sitag += ' xml:space="preserve"';
                sitag += ">" + escapexml(s.t) + "</t>";
            }
            sitag += "</si>";
            o[o.length] = sitag;
        }
        if (o.length > 2) {
            o[o.length] = "</sst>";
            o[1] = o[1].replace("/>", ">");
        }
        return o.join("");
    }
    function parse_BrtBeginSst(data) {
        return [ data.read_shift(4), data.read_shift(4) ];
    }
    function parse_sst_bin(data, opts) {
        var s = [];
        var pass = false;
        recordhopper(data, function hopper_sst(val, R_n, RT) {
            switch (RT) {
              case 159:
                s.Count = val[0];
                s.Unique = val[1];
                break;

              case 19:
                s.push(val);
                break;

              case 160:
                return true;

              case 35:
                pass = true;
                break;

              case 36:
                pass = false;
                break;

              default:
                if (R_n.indexOf("Begin") > 0) {} else if (R_n.indexOf("End") > 0) {}
                if (!pass || opts.WTF) throw new Error("Unexpected record " + RT + " " + R_n);
            }
        });
        return s;
    }
    function write_BrtBeginSst(sst, o) {
        if (!o) o = new_buf(8);
        o.write_shift(4, sst.Count);
        o.write_shift(4, sst.Unique);
        return o;
    }
    var write_BrtSSTItem = write_RichStr;
    function write_sst_bin(sst) {
        var ba = buf_array();
        write_record(ba, "BrtBeginSst", write_BrtBeginSst(sst));
        for (var i = 0; i < sst.length; ++i) write_record(ba, "BrtSSTItem", write_BrtSSTItem(sst[i]));
        write_record(ba, "BrtEndSst");
        return ba.end();
    }
    function _JS2ANSI(str) {
        if (typeof cptable !== "undefined") return cptable.utils.encode(current_ansi, str);
        var o = [], oo = str.split("");
        for (var i = 0; i < oo.length; ++i) o[i] = oo[i].charCodeAt(0);
        return o;
    }
    function parse_CRYPTOVersion(blob, length) {
        var o = {};
        o.Major = blob.read_shift(2);
        o.Minor = blob.read_shift(2);
        if (length >= 4) blob.l += length - 4;
        return o;
    }
    function parse_DataSpaceVersionInfo(blob) {
        var o = {};
        o.id = blob.read_shift(0, "lpp4");
        o.R = parse_CRYPTOVersion(blob, 4);
        o.U = parse_CRYPTOVersion(blob, 4);
        o.W = parse_CRYPTOVersion(blob, 4);
        return o;
    }
    function parse_DataSpaceMapEntry(blob) {
        var len = blob.read_shift(4);
        var end = blob.l + len - 4;
        var o = {};
        var cnt = blob.read_shift(4);
        var comps = [];
        while (cnt-- > 0) comps.push({
            "t": blob.read_shift(4),
            "v": blob.read_shift(0, "lpp4")
        });
        o.name = blob.read_shift(0, "lpp4");
        o.comps = comps;
        if (blob.l != end) throw new Error("Bad DataSpaceMapEntry: " + blob.l + " != " + end);
        return o;
    }
    function parse_DataSpaceMap(blob) {
        var o = [];
        blob.l += 4;
        var cnt = blob.read_shift(4);
        while (cnt-- > 0) o.push(parse_DataSpaceMapEntry(blob));
        return o;
    }
    function parse_DataSpaceDefinition(blob) {
        var o = [];
        blob.l += 4;
        var cnt = blob.read_shift(4);
        while (cnt-- > 0) o.push(blob.read_shift(0, "lpp4"));
        return o;
    }
    function parse_TransformInfoHeader(blob) {
        var o = {};
        blob.read_shift(4);
        blob.l += 4;
        o.id = blob.read_shift(0, "lpp4");
        o.name = blob.read_shift(0, "lpp4");
        o.R = parse_CRYPTOVersion(blob, 4);
        o.U = parse_CRYPTOVersion(blob, 4);
        o.W = parse_CRYPTOVersion(blob, 4);
        return o;
    }
    function parse_Primary(blob) {
        var hdr = parse_TransformInfoHeader(blob);
        hdr.ename = blob.read_shift(0, "8lpp4");
        hdr.blksz = blob.read_shift(4);
        hdr.cmode = blob.read_shift(4);
        if (blob.read_shift(4) != 4) throw new Error("Bad !Primary record");
        return hdr;
    }
    function parse_EncryptionHeader(blob, length) {
        var tgt = blob.l + length;
        var o = {};
        o.Flags = blob.read_shift(4) & 63;
        blob.l += 4;
        o.AlgID = blob.read_shift(4);
        var valid = false;
        switch (o.AlgID) {
          case 26126:
          case 26127:
          case 26128:
            valid = o.Flags == 36;
            break;

          case 26625:
            valid = o.Flags == 4;
            break;

          case 0:
            valid = o.Flags == 16 || o.Flags == 4 || o.Flags == 36;
            break;

          default:
            throw "Unrecognized encryption algorithm: " + o.AlgID;
        }
        if (!valid) throw new Error("Encryption Flags/AlgID mismatch");
        o.AlgIDHash = blob.read_shift(4);
        o.KeySize = blob.read_shift(4);
        o.ProviderType = blob.read_shift(4);
        blob.l += 8;
        o.CSPName = blob.read_shift(tgt - blob.l >> 1, "utf16le");
        blob.l = tgt;
        return o;
    }
    function parse_EncryptionVerifier(blob, length) {
        var o = {}, tgt = blob.l + length;
        blob.l += 4;
        o.Salt = blob.slice(blob.l, blob.l + 16);
        blob.l += 16;
        o.Verifier = blob.slice(blob.l, blob.l + 16);
        blob.l += 16;
        blob.read_shift(4);
        o.VerifierHash = blob.slice(blob.l, tgt);
        blob.l = tgt;
        return o;
    }
    function parse_EncryptionInfo(blob) {
        var vers = parse_CRYPTOVersion(blob);
        switch (vers.Minor) {
          case 2:
            return [ vers.Minor, parse_EncInfoStd(blob, vers) ];

          case 3:
            return [ vers.Minor, parse_EncInfoExt(blob, vers) ];

          case 4:
            return [ vers.Minor, parse_EncInfoAgl(blob, vers) ];
        }
        throw new Error("ECMA-376 Encrypted file unrecognized Version: " + vers.Minor);
    }
    function parse_EncInfoStd(blob) {
        var flags = blob.read_shift(4);
        if ((flags & 63) != 36) throw new Error("EncryptionInfo mismatch");
        var sz = blob.read_shift(4);
        var hdr = parse_EncryptionHeader(blob, sz);
        var verifier = parse_EncryptionVerifier(blob, blob.length - blob.l);
        return {
            "t": "Std",
            "h": hdr,
            "v": verifier
        };
    }
    function parse_EncInfoExt() {
        throw new Error("File is password-protected: ECMA-376 Extensible");
    }
    function parse_EncInfoAgl(blob) {
        var KeyData = [ "saltSize", "blockSize", "keyBits", "hashSize", "cipherAlgorithm", "cipherChaining", "hashAlgorithm", "saltValue" ];
        blob.l += 4;
        var xml = blob.read_shift(blob.length - blob.l, "utf8");
        var o = {};
        xml.replace(tagregex, function xml_agile(x) {
            var y = parsexmltag(x);
            switch (strip_ns(y[0])) {
              case "<?xml":
                break;

              case "<encryption":
              case "</encryption>":
                break;

              case "<keyData":
                KeyData.forEach(function(k) {
                    o[k] = y[k];
                });
                break;

              case "<dataIntegrity":
                o.encryptedHmacKey = y.encryptedHmacKey;
                o.encryptedHmacValue = y.encryptedHmacValue;
                break;

              case "<keyEncryptors>":
              case "<keyEncryptors":
                o.encs = [];
                break;

              case "</keyEncryptors>":
                break;

              case "<keyEncryptor":
                o.uri = y.uri;
                break;

              case "</keyEncryptor>":
                break;

              case "<encryptedKey":
                o.encs.push(y);
                break;

              default:
                throw y[0];
            }
        });
        return o;
    }
    function parse_RC4CryptoHeader(blob, length) {
        var o = {};
        var vers = o.EncryptionVersionInfo = parse_CRYPTOVersion(blob, 4);
        length -= 4;
        if (vers.Minor != 2) throw new Error("unrecognized minor version code: " + vers.Minor);
        if (vers.Major > 4 || vers.Major < 2) throw new Error("unrecognized major version code: " + vers.Major);
        o.Flags = blob.read_shift(4);
        length -= 4;
        var sz = blob.read_shift(4);
        length -= 4;
        o.EncryptionHeader = parse_EncryptionHeader(blob, sz);
        length -= sz;
        o.EncryptionVerifier = parse_EncryptionVerifier(blob, length);
        return o;
    }
    function parse_RC4Header(blob) {
        var o = {};
        var vers = o.EncryptionVersionInfo = parse_CRYPTOVersion(blob, 4);
        if (vers.Major != 1 || vers.Minor != 1) throw "unrecognized version code " + vers.Major + " : " + vers.Minor;
        o.Salt = blob.read_shift(16);
        o.EncryptedVerifier = blob.read_shift(16);
        o.EncryptedVerifierHash = blob.read_shift(16);
        return o;
    }
    function crypto_CreatePasswordVerifier_Method1(Password) {
        var Verifier = 0, PasswordArray;
        var PasswordDecoded = _JS2ANSI(Password);
        var len = PasswordDecoded.length + 1, i, PasswordByte;
        var Intermediate1, Intermediate2, Intermediate3;
        PasswordArray = new_raw_buf(len);
        PasswordArray[0] = PasswordDecoded.length;
        for (i = 1; i != len; ++i) PasswordArray[i] = PasswordDecoded[i - 1];
        for (i = len - 1; i >= 0; --i) {
            PasswordByte = PasswordArray[i];
            Intermediate1 = (Verifier & 16384) === 0 ? 0 : 1;
            Intermediate2 = Verifier << 1 & 32767;
            Intermediate3 = Intermediate1 | Intermediate2;
            Verifier = Intermediate3 ^ PasswordByte;
        }
        return Verifier ^ 52811;
    }
    var crypto_CreateXorArray_Method1 = function() {
        var PadArray = [ 187, 255, 255, 186, 255, 255, 185, 128, 0, 190, 15, 0, 191, 15, 0 ];
        var InitialCode = [ 57840, 7439, 52380, 33984, 4364, 3600, 61902, 12606, 6258, 57657, 54287, 34041, 10252, 43370, 20163 ];
        var XorMatrix = [ 44796, 19929, 39858, 10053, 20106, 40212, 10761, 31585, 63170, 64933, 60267, 50935, 40399, 11199, 17763, 35526, 1453, 2906, 5812, 11624, 23248, 885, 1770, 3540, 7080, 14160, 28320, 56640, 55369, 41139, 20807, 41614, 21821, 43642, 17621, 28485, 56970, 44341, 19019, 38038, 14605, 29210, 60195, 50791, 40175, 10751, 21502, 43004, 24537, 18387, 36774, 3949, 7898, 15796, 31592, 63184, 47201, 24803, 49606, 37805, 14203, 28406, 56812, 17824, 35648, 1697, 3394, 6788, 13576, 27152, 43601, 17539, 35078, 557, 1114, 2228, 4456, 30388, 60776, 51953, 34243, 7079, 14158, 28316, 14128, 28256, 56512, 43425, 17251, 34502, 7597, 13105, 26210, 52420, 35241, 883, 1766, 3532, 4129, 8258, 16516, 33032, 4657, 9314, 18628 ];
        var Ror = function(Byte) {
            return (Byte / 2 | Byte * 128) & 255;
        };
        var XorRor = function(byte1, byte2) {
            return Ror(byte1 ^ byte2);
        };
        var CreateXorKey_Method1 = function(Password) {
            var XorKey = InitialCode[Password.length - 1];
            var CurrentElement = 104;
            for (var i = Password.length - 1; i >= 0; --i) {
                var Char = Password[i];
                for (var j = 0; j != 7; ++j) {
                    if (Char & 64) XorKey ^= XorMatrix[CurrentElement];
                    Char *= 2;
                    --CurrentElement;
                }
            }
            return XorKey;
        };
        return function(password) {
            var Password = _JS2ANSI(password);
            var XorKey = CreateXorKey_Method1(Password);
            var Index = Password.length;
            var ObfuscationArray = new_raw_buf(16);
            for (var i = 0; i != 16; ++i) ObfuscationArray[i] = 0;
            var Temp, PasswordLastChar, PadIndex;
            if ((Index & 1) === 1) {
                Temp = XorKey >> 8;
                ObfuscationArray[Index] = XorRor(PadArray[0], Temp);
                --Index;
                Temp = XorKey & 255;
                PasswordLastChar = Password[Password.length - 1];
                ObfuscationArray[Index] = XorRor(PasswordLastChar, Temp);
            }
            while (Index > 0) {
                --Index;
                Temp = XorKey >> 8;
                ObfuscationArray[Index] = XorRor(Password[Index], Temp);
                --Index;
                Temp = XorKey & 255;
                ObfuscationArray[Index] = XorRor(Password[Index], Temp);
            }
            Index = 15;
            PadIndex = 15 - Password.length;
            while (PadIndex > 0) {
                Temp = XorKey >> 8;
                ObfuscationArray[Index] = XorRor(PadArray[PadIndex], Temp);
                --Index;
                --PadIndex;
                Temp = XorKey & 255;
                ObfuscationArray[Index] = XorRor(Password[Index], Temp);
                --Index;
                --PadIndex;
            }
            return ObfuscationArray;
        };
    }();
    var crypto_DecryptData_Method1 = function(password, Data, XorArrayIndex, XorArray, O) {
        if (!O) O = Data;
        if (!XorArray) XorArray = crypto_CreateXorArray_Method1(password);
        var Index, Value;
        for (Index = 0; Index != Data.length; ++Index) {
            Value = Data[Index];
            Value ^= XorArray[XorArrayIndex];
            Value = (Value >> 5 | Value << 3) & 255;
            O[Index] = Value;
            ++XorArrayIndex;
        }
        return [ O, XorArrayIndex, XorArray ];
    };
    var crypto_MakeXorDecryptor = function(password) {
        var XorArrayIndex = 0, XorArray = crypto_CreateXorArray_Method1(password);
        return function(Data) {
            var O = crypto_DecryptData_Method1("", Data, XorArrayIndex, XorArray);
            XorArrayIndex = O[1];
            return O[0];
        };
    };
    function parse_XORObfuscation(blob, length, opts, out) {
        var o = {
            "key": parseuint16(blob),
            "verificationBytes": parseuint16(blob)
        };
        if (opts.password) o.verifier = crypto_CreatePasswordVerifier_Method1(opts.password);
        out.valid = o.verificationBytes === o.verifier;
        if (out.valid) out.insitu = crypto_MakeXorDecryptor(opts.password);
        return o;
    }
    function parse_FilePassHeader(blob, length, oo) {
        var o = oo || {};
        o.Info = blob.read_shift(2);
        blob.l -= 2;
        if (o.Info === 1) o.Data = parse_RC4Header(blob, length); else o.Data = parse_RC4CryptoHeader(blob, length);
        return o;
    }
    function parse_FilePass(blob, length, opts) {
        var o = {
            "Type": opts.biff >= 8 ? blob.read_shift(2) : 0
        };
        if (o.Type) parse_FilePassHeader(blob, length - 2, o); else parse_XORObfuscation(blob, opts.biff >= 8 ? length : length - 2, opts, o);
        return o;
    }
    var RTF = function() {
        function rtf_to_sheet(d, opts) {
            switch (opts.type) {
              case "base64":
                return rtf_to_sheet_str(Base64.decode(d), opts);

              case "binary":
                return rtf_to_sheet_str(d, opts);

              case "buffer":
                return rtf_to_sheet_str(d.toString("binary"), opts);

              case "array":
                return rtf_to_sheet_str(cc2str(d), opts);
            }
            throw new Error("Unrecognized type " + opts.type);
        }
        function rtf_to_sheet_str(str, opts) {
            var o = opts || {};
            var ws = o.dense ? [] : {};
            var range = {
                "s": {
                    "c": 0,
                    "r": 0
                },
                "e": {
                    "c": 0,
                    "r": 0
                }
            };
            if (!str.match(/\\trowd/)) throw new Error("RTF missing table");
            ws["!ref"] = encode_range(range);
            return ws;
        }
        function rtf_to_workbook(d, opts) {
            return sheet_to_workbook(rtf_to_sheet(d, opts), opts);
        }
        function sheet_to_rtf(ws) {
            var o = [ "{\\rtf1\\ansi" ];
            var r = safe_decode_range(ws["!ref"]), cell;
            var dense = Array.isArray(ws);
            for (var R = r.s.r; R <= r.e.r; ++R) {
                o.push("\\trowd\\trautofit1");
                for (var C = r.s.c; C <= r.e.c; ++C) o.push("\\cellx" + (C + 1));
                o.push("\\pard\\intbl");
                for (C = r.s.c; C <= r.e.c; ++C) {
                    var coord = encode_cell({
                        "r": R,
                        "c": C
                    });
                    cell = dense ? (ws[R] || [])[C] : ws[coord];
                    if (!cell || cell.v == null && (!cell.f || cell.F)) continue;
                    o.push(" " + (cell.w || (format_cell(cell), cell.w)));
                    o.push("\\cell");
                }
                o.push("\\pard\\intbl\\row");
            }
            return o.join("") + "}";
        }
        return {
            "to_workbook": rtf_to_workbook,
            "to_sheet": rtf_to_sheet,
            "from_sheet": sheet_to_rtf
        };
    }();
    function hex2RGB(h) {
        var o = h.slice(h[0] === "#" ? 1 : 0).slice(0, 6);
        return [ parseInt(o.slice(0, 2), 16), parseInt(o.slice(2, 4), 16), parseInt(o.slice(4, 6), 16) ];
    }
    function rgb2Hex(rgb) {
        for (var i = 0, o = 1; i != 3; ++i) o = o * 256 + (rgb[i] > 255 ? 255 : rgb[i] < 0 ? 0 : rgb[i]);
        return o.toString(16).toUpperCase().slice(1);
    }
    function rgb2HSL(rgb) {
        var R = rgb[0] / 255, G = rgb[1] / 255, B = rgb[2] / 255;
        var M = Math.max(R, G, B), m = Math.min(R, G, B), C = M - m;
        if (C === 0) return [ 0, 0, R ];
        var H6 = 0, S = 0, L2 = M + m;
        S = C / (L2 > 1 ? 2 - L2 : L2);
        switch (M) {
          case R:
            H6 = ((G - B) / C + 6) % 6;
            break;

          case G:
            H6 = (B - R) / C + 2;
            break;

          case B:
            H6 = (R - G) / C + 4;
            break;
        }
        return [ H6 / 6, S, L2 / 2 ];
    }
    function hsl2RGB(hsl) {
        var H = hsl[0], S = hsl[1], L = hsl[2];
        var C = S * 2 * (L < .5 ? L : 1 - L), m = L - C / 2;
        var rgb = [ m, m, m ], h6 = 6 * H;
        var X;
        if (S !== 0) switch (h6 | 0) {
          case 0:
          case 6:
            X = C * h6;
            rgb[0] += C;
            rgb[1] += X;
            break;

          case 1:
            X = C * (2 - h6);
            rgb[0] += X;
            rgb[1] += C;
            break;

          case 2:
            X = C * (h6 - 2);
            rgb[1] += C;
            rgb[2] += X;
            break;

          case 3:
            X = C * (4 - h6);
            rgb[1] += X;
            rgb[2] += C;
            break;

          case 4:
            X = C * (h6 - 4);
            rgb[2] += C;
            rgb[0] += X;
            break;

          case 5:
            X = C * (6 - h6);
            rgb[2] += X;
            rgb[0] += C;
            break;
        }
        for (var i = 0; i != 3; ++i) rgb[i] = Math.round(rgb[i] * 255);
        return rgb;
    }
    function rgb_tint(hex, tint) {
        if (tint === 0) return hex;
        var hsl = rgb2HSL(hex2RGB(hex));
        if (tint < 0) hsl[2] = hsl[2] * (1 + tint); else hsl[2] = 1 - (1 - hsl[2]) * (1 - tint);
        return rgb2Hex(hsl2RGB(hsl));
    }
    var DEF_MDW = 6, MAX_MDW = 15, MIN_MDW = 1, MDW = DEF_MDW;
    function width2px(width) {
        return Math.floor((width + Math.round(128 / MDW) / 256) * MDW);
    }
    function px2char(px) {
        return Math.floor((px - 5) / MDW * 100 + .5) / 100;
    }
    function char2width(chr) {
        return Math.round((chr * MDW + 5) / MDW * 256) / 256;
    }
    function cycle_width(collw) {
        return char2width(px2char(width2px(collw)));
    }
    function find_mdw_colw(collw) {
        var delta = Math.abs(collw - cycle_width(collw)), _MDW = MDW;
        if (delta > .005) for (MDW = MIN_MDW; MDW < MAX_MDW; ++MDW) if (Math.abs(collw - cycle_width(collw)) <= delta) {
            delta = Math.abs(collw - cycle_width(collw));
            _MDW = MDW;
        }
        MDW = _MDW;
    }
    function process_col(coll) {
        if (coll.width) {
            coll.wpx = width2px(coll.width);
            coll.wch = px2char(coll.wpx);
            coll.MDW = MDW;
        } else if (coll.wpx) {
            coll.wch = px2char(coll.wpx);
            coll.width = char2width(coll.wch);
            coll.MDW = MDW;
        } else if (typeof coll.wch == "number") {
            coll.width = char2width(coll.wch);
            coll.wpx = width2px(coll.width);
            coll.MDW = MDW;
        }
        if (coll.customWidth) delete coll.customWidth;
    }
    var DEF_PPI = 96, PPI = DEF_PPI;
    function px2pt(px) {
        return px * 96 / PPI;
    }
    function pt2px(pt) {
        return pt * PPI / 96;
    }
    var XLMLPatternTypeMap = {
        "None": "none",
        "Solid": "solid",
        "Gray50": "mediumGray",
        "Gray75": "darkGray",
        "Gray25": "lightGray",
        "HorzStripe": "darkHorizontal",
        "VertStripe": "darkVertical",
        "ReverseDiagStripe": "darkDown",
        "DiagStripe": "darkUp",
        "DiagCross": "darkGrid",
        "ThickDiagCross": "darkTrellis",
        "ThinHorzStripe": "lightHorizontal",
        "ThinVertStripe": "lightVertical",
        "ThinReverseDiagStripe": "lightDown",
        "ThinHorzCross": "lightGrid"
    };
    function parse_borders(t, styles, themes, opts) {
        styles.Borders = [];
        var border = {};
        var pass = false;
        t[0].match(tagregex).forEach(function(x) {
            var y = parsexmltag(x);
            switch (strip_ns(y[0])) {
              case "<borders":
              case "<borders>":
              case "</borders>":
                break;

              case "<border":
              case "<border>":
              case "<border/>":
                border = {};
                if (y.diagonalUp) {
                    border.diagonalUp = y.diagonalUp;
                }
                if (y.diagonalDown) {
                    border.diagonalDown = y.diagonalDown;
                }
                styles.Borders.push(border);
                break;

              case "</border>":
                break;

              case "<left/>":
                break;

              case "<left":
              case "<left>":
                break;

              case "</left>":
                break;

              case "<right/>":
                break;

              case "<right":
              case "<right>":
                break;

              case "</right>":
                break;

              case "<top/>":
                break;

              case "<top":
              case "<top>":
                break;

              case "</top>":
                break;

              case "<bottom/>":
                break;

              case "<bottom":
              case "<bottom>":
                break;

              case "</bottom>":
                break;

              case "<diagonal":
              case "<diagonal>":
              case "<diagonal/>":
                break;

              case "</diagonal>":
                break;

              case "<horizontal":
              case "<horizontal>":
              case "<horizontal/>":
                break;

              case "</horizontal>":
                break;

              case "<vertical":
              case "<vertical>":
              case "<vertical/>":
                break;

              case "</vertical>":
                break;

              case "<start":
              case "<start>":
              case "<start/>":
                break;

              case "</start>":
                break;

              case "<end":
              case "<end>":
              case "<end/>":
                break;

              case "</end>":
                break;

              case "<color":
              case "<color>":
                break;

              case "<color/>":
              case "</color>":
                break;

              case "<extLst":
              case "<extLst>":
              case "</extLst>":
                break;

              case "<ext":
                pass = true;
                break;

              case "</ext>":
                pass = false;
                break;

              default:
                if (opts && opts.WTF) {
                    if (!pass) throw new Error("unrecognized " + y[0] + " in borders");
                }
            }
        });
    }
    function parse_fills(t, styles, themes, opts) {
        styles.Fills = [];
        var fill = {};
        var pass = false;
        t[0].match(tagregex).forEach(function(x) {
            var y = parsexmltag(x);
            switch (strip_ns(y[0])) {
              case "<fills":
              case "<fills>":
              case "</fills>":
                break;

              case "<fill>":
              case "<fill":
              case "<fill/>":
                fill = {};
                styles.Fills.push(fill);
                break;

              case "</fill>":
                break;

              case "<gradientFill>":
                break;

              case "<gradientFill":
              case "</gradientFill>":
                styles.Fills.push(fill);
                fill = {};
                break;

              case "<patternFill":
              case "<patternFill>":
                if (y.patternType) fill.patternType = y.patternType;
                break;

              case "<patternFill/>":
              case "</patternFill>":
                break;

              case "<bgColor":
                if (!fill.bgColor) fill.bgColor = {};
                if (y.indexed) fill.bgColor.indexed = parseInt(y.indexed, 10);
                if (y.theme) fill.bgColor.theme = parseInt(y.theme, 10);
                if (y.tint) fill.bgColor.tint = parseFloat(y.tint);
                if (y.rgb) fill.bgColor.rgb = y.rgb.slice(-6);
                break;

              case "<bgColor/>":
              case "</bgColor>":
                break;

              case "<fgColor":
                if (!fill.fgColor) fill.fgColor = {};
                if (y.theme) fill.fgColor.theme = parseInt(y.theme, 10);
                if (y.tint) fill.fgColor.tint = parseFloat(y.tint);
                if (y.rgb) fill.fgColor.rgb = y.rgb.slice(-6);
                break;

              case "<fgColor/>":
              case "</fgColor>":
                break;

              case "<stop":
              case "<stop/>":
                break;

              case "</stop>":
                break;

              case "<color":
              case "<color/>":
                break;

              case "</color>":
                break;

              case "<extLst":
              case "<extLst>":
              case "</extLst>":
                break;

              case "<ext":
                pass = true;
                break;

              case "</ext>":
                pass = false;
                break;

              default:
                if (opts && opts.WTF) {
                    if (!pass) throw new Error("unrecognized " + y[0] + " in fills");
                }
            }
        });
    }
    function parse_fonts(t, styles, themes, opts) {
        styles.Fonts = [];
        var font = {};
        var pass = false;
        t[0].match(tagregex).forEach(function(x) {
            var y = parsexmltag(x);
            switch (strip_ns(y[0])) {
              case "<fonts":
              case "<fonts>":
              case "</fonts>":
                break;

              case "<font":
              case "<font>":
                break;

              case "</font>":
              case "<font/>":
                styles.Fonts.push(font);
                font = {};
                break;

              case "<name":
                if (y.val) font.name = y.val;
                break;

              case "<name/>":
              case "</name>":
                break;

              case "<b":
                font.bold = y.val ? parsexmlbool(y.val) : 1;
                break;

              case "<b/>":
                font.bold = 1;
                break;

              case "<i":
                font.italic = y.val ? parsexmlbool(y.val) : 1;
                break;

              case "<i/>":
                font.italic = 1;
                break;

              case "<u":
                switch (y.val) {
                  case "none":
                    font.underline = 0;
                    break;

                  case "single":
                    font.underline = 1;
                    break;

                  case "double":
                    font.underline = 2;
                    break;

                  case "singleAccounting":
                    font.underline = 33;
                    break;

                  case "doubleAccounting":
                    font.underline = 34;
                    break;
                }
                break;

              case "<u/>":
                font.underline = 1;
                break;

              case "<strike":
                font.strike = y.val ? parsexmlbool(y.val) : 1;
                break;

              case "<strike/>":
                font.strike = 1;
                break;

              case "<outline":
                font.outline = y.val ? parsexmlbool(y.val) : 1;
                break;

              case "<outline/>":
                font.outline = 1;
                break;

              case "<shadow":
                font.shadow = y.val ? parsexmlbool(y.val) : 1;
                break;

              case "<shadow/>":
                font.shadow = 1;
                break;

              case "<condense":
                font.condense = y.val ? parsexmlbool(y.val) : 1;
                break;

              case "<condense/>":
                font.condense = 1;
                break;

              case "<extend":
                font.extend = y.val ? parsexmlbool(y.val) : 1;
                break;

              case "<extend/>":
                font.extend = 1;
                break;

              case "<sz":
                if (y.val) font.sz = +y.val;
                break;

              case "<sz/>":
              case "</sz>":
                break;

              case "<vertAlign":
                if (y.val) font.vertAlign = y.val;
                break;

              case "<vertAlign/>":
              case "</vertAlign>":
                break;

              case "<family":
                if (y.val) font.family = parseInt(y.val, 10);
                break;

              case "<family/>":
              case "</family>":
                break;

              case "<scheme":
                if (y.val) font.scheme = y.val;
                break;

              case "<scheme/>":
              case "</scheme>":
                break;

              case "<charset":
                if (y.val == "1") break;
                y.codepage = CS2CP[parseInt(y.val, 10)];
                break;

              case "<color":
                if (!font.color) font.color = {};
                if (y.auto) font.color.auto = parsexmlbool(y.auto);
                if (y.rgb) font.color.rgb = y.rgb.slice(-6); else if (y.indexed) {
                    font.color.index = parseInt(y.indexed, 10);
                    var icv = XLSIcv[font.color.index];
                    if (font.color.index == 81) icv = XLSIcv[1];
                    if (!icv) throw new Error(x);
                    font.color.rgb = icv[0].toString(16) + icv[1].toString(16) + icv[2].toString(16);
                } else if (y.theme) {
                    font.color.theme = parseInt(y.theme, 10);
                    if (y.tint) font.color.tint = parseFloat(y.tint);
                    if (y.theme && themes.themeElements && themes.themeElements.clrScheme) {
                        font.color.rgb = rgb_tint(themes.themeElements.clrScheme[font.color.theme].rgb, font.color.tint || 0);
                    }
                }
                break;

              case "<color/>":
              case "</color>":
                break;

              case "<extLst":
              case "<extLst>":
              case "</extLst>":
                break;

              case "<ext":
                pass = true;
                break;

              case "</ext>":
                pass = false;
                break;

              default:
                if (opts && opts.WTF) {
                    if (!pass) throw new Error("unrecognized " + y[0] + " in fonts");
                }
            }
        });
    }
    function parse_numFmts(t, styles, opts) {
        styles.NumberFmt = [];
        var k = keys(SSF._table);
        for (var i = 0; i < k.length; ++i) styles.NumberFmt[k[i]] = SSF._table[k[i]];
        var m = t[0].match(tagregex);
        if (!m) return;
        for (i = 0; i < m.length; ++i) {
            var y = parsexmltag(m[i]);
            switch (strip_ns(y[0])) {
              case "<numFmts":
              case "</numFmts>":
              case "<numFmts/>":
              case "<numFmts>":
                break;

              case "<numFmt":
                {
                    var f = unescapexml(utf8read(y.formatCode)), j = parseInt(y.numFmtId, 10);
                    styles.NumberFmt[j] = f;
                    if (j > 0) {
                        if (j > 392) {
                            for (j = 392; j > 60; --j) if (styles.NumberFmt[j] == null) break;
                            styles.NumberFmt[j] = f;
                        }
                        SSF.load(f, j);
                    }
                }
                break;

              case "</numFmt>":
                break;

              default:
                if (opts.WTF) throw new Error("unrecognized " + y[0] + " in numFmts");
            }
        }
    }
    function write_numFmts(NF) {
        var o = [ "<numFmts>" ];
        [ [ 5, 8 ], [ 23, 26 ], [ 41, 44 ], [ 50, 392 ] ].forEach(function(r) {
            for (var i = r[0]; i <= r[1]; ++i) if (NF[i] != null) o[o.length] = writextag("numFmt", null, {
                "numFmtId": i,
                "formatCode": escapexml(NF[i])
            });
        });
        if (o.length === 1) return "";
        o[o.length] = "</numFmts>";
        o[0] = writextag("numFmts", null, {
            "count": o.length - 2
        }).replace("/>", ">");
        return o.join("");
    }
    var cellXF_uint = [ "numFmtId", "fillId", "fontId", "borderId", "xfId" ];
    var cellXF_bool = [ "applyAlignment", "applyBorder", "applyFill", "applyFont", "applyNumberFormat", "applyProtection", "pivotButton", "quotePrefix" ];
    function parse_cellXfs(t, styles, opts) {
        styles.CellXf = [];
        var xf;
        var pass = false;
        t[0].match(tagregex).forEach(function(x) {
            var y = parsexmltag(x), i = 0;
            switch (strip_ns(y[0])) {
              case "<cellXfs":
              case "<cellXfs>":
              case "<cellXfs/>":
              case "</cellXfs>":
                break;

              case "<xf":
              case "<xf/>":
                xf = y;
                delete xf[0];
                for (i = 0; i < cellXF_uint.length; ++i) if (xf[cellXF_uint[i]]) xf[cellXF_uint[i]] = parseInt(xf[cellXF_uint[i]], 10);
                for (i = 0; i < cellXF_bool.length; ++i) if (xf[cellXF_bool[i]]) xf[cellXF_bool[i]] = parsexmlbool(xf[cellXF_bool[i]]);
                if (xf.numFmtId > 392) {
                    for (i = 392; i > 60; --i) if (styles.NumberFmt[xf.numFmtId] == styles.NumberFmt[i]) {
                        xf.numFmtId = i;
                        break;
                    }
                }
                styles.CellXf.push(xf);
                break;

              case "</xf>":
                break;

              case "<alignment":
              case "<alignment/>":
                var alignment = {};
                if (y.vertical) alignment.vertical = y.vertical;
                if (y.horizontal) alignment.horizontal = y.horizontal;
                if (y.textRotation != null) alignment.textRotation = y.textRotation;
                if (y.indent) alignment.indent = y.indent;
                if (y.wrapText) alignment.wrapText = y.wrapText;
                xf.alignment = alignment;
                break;

              case "</alignment>":
                break;

              case "<protection":
              case "</protection>":
              case "<protection/>":
                break;

              case "<extLst":
              case "<extLst>":
              case "</extLst>":
                break;

              case "<ext":
                pass = true;
                break;

              case "</ext>":
                pass = false;
                break;

              default:
                if (opts && opts.WTF) {
                    if (!pass) throw new Error("unrecognized " + y[0] + " in cellXfs");
                }
            }
        });
    }
    function write_cellXfs(cellXfs) {
        var o = [];
        o[o.length] = writextag("cellXfs", null);
        cellXfs.forEach(function(c) {
            o[o.length] = writextag("xf", null, c);
        });
        o[o.length] = "</cellXfs>";
        if (o.length === 2) return "";
        o[0] = writextag("cellXfs", null, {
            "count": o.length - 2
        }).replace("/>", ">");
        return o.join("");
    }
    var parse_sty_xml = function make_pstyx() {
        var numFmtRegex = /<(?:\w+:)?numFmts([^>]*)>[\S\s]*?<\/(?:\w+:)?numFmts>/;
        var cellXfRegex = /<(?:\w+:)?cellXfs([^>]*)>[\S\s]*?<\/(?:\w+:)?cellXfs>/;
        var fillsRegex = /<(?:\w+:)?fills([^>]*)>[\S\s]*?<\/(?:\w+:)?fills>/;
        var fontsRegex = /<(?:\w+:)?fonts([^>]*)>[\S\s]*?<\/(?:\w+:)?fonts>/;
        var bordersRegex = /<(?:\w+:)?borders([^>]*)>[\S\s]*?<\/(?:\w+:)?borders>/;
        return function parse_sty_xml(data, themes, opts) {
            var styles = {};
            if (!data) return styles;
            data = data.replace(/<!--([\s\S]*?)-->/gm, "").replace(/<!DOCTYPE[^\[]*\[[^\]]*\]>/gm, "");
            var t;
            if (t = data.match(numFmtRegex)) parse_numFmts(t, styles, opts);
            if (t = data.match(fontsRegex)) parse_fonts(t, styles, themes, opts);
            if (t = data.match(fillsRegex)) parse_fills(t, styles, themes, opts);
            if (t = data.match(bordersRegex)) parse_borders(t, styles, themes, opts);
            if (t = data.match(cellXfRegex)) parse_cellXfs(t, styles, opts);
            return styles;
        };
    }();
    var STYLES_XML_ROOT = writextag("styleSheet", null, {
        "xmlns": XMLNS.main[0],
        "xmlns:vt": XMLNS.vt
    });
    RELS.STY = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles";
    function write_sty_xml(wb, opts) {
        var o = [ XML_HEADER, STYLES_XML_ROOT ], w;
        if (wb.SSF && (w = write_numFmts(wb.SSF)) != null) o[o.length] = w;
        o[o.length] = '<fonts count="1"><font><sz val="12"/><color theme="1"/><name val="Calibri"/><family val="2"/><scheme val="minor"/></font></fonts>';
        o[o.length] = '<fills count="2"><fill><patternFill patternType="none"/></fill><fill><patternFill patternType="gray125"/></fill></fills>';
        o[o.length] = '<borders count="1"><border><left/><right/><top/><bottom/><diagonal/></border></borders>';
        o[o.length] = '<cellStyleXfs count="1"><xf numFmtId="0" fontId="0" fillId="0" borderId="0"/></cellStyleXfs>';
        if (w = write_cellXfs(opts.cellXfs)) o[o.length] = w;
        o[o.length] = '<cellStyles count="1"><cellStyle name="Normal" xfId="0" builtinId="0"/></cellStyles>';
        o[o.length] = '<dxfs count="0"/>';
        o[o.length] = '<tableStyles count="0" defaultTableStyle="TableStyleMedium9" defaultPivotStyle="PivotStyleMedium4"/>';
        if (o.length > 2) {
            o[o.length] = "</styleSheet>";
            o[1] = o[1].replace("/>", ">");
        }
        return o.join("");
    }
    function parse_BrtFmt(data, length) {
        var numFmtId = data.read_shift(2);
        var stFmtCode = parse_XLWideString(data, length - 2);
        return [ numFmtId, stFmtCode ];
    }
    function write_BrtFmt(i, f, o) {
        if (!o) o = new_buf(6 + 4 * f.length);
        o.write_shift(2, i);
        write_XLWideString(f, o);
        var out = o.length > o.l ? o.slice(0, o.l) : o;
        if (o.l == null) o.l = o.length;
        return out;
    }
    function parse_BrtFont(data, length, opts) {
        var out = {};
        out.sz = data.read_shift(2) / 20;
        var grbit = parse_FontFlags(data, 2, opts);
        if (grbit.fCondense) out.condense = 1;
        if (grbit.fExtend) out.extend = 1;
        if (grbit.fShadow) out.shadow = 1;
        if (grbit.fOutline) out.outline = 1;
        if (grbit.fStrikeout) out.strike = 1;
        if (grbit.fItalic) out.italic = 1;
        var bls = data.read_shift(2);
        if (bls === 700) out.bold = 1;
        switch (data.read_shift(2)) {
          case 1:
            out.vertAlign = "superscript";
            break;

          case 2:
            out.vertAlign = "subscript";
            break;
        }
        var underline = data.read_shift(1);
        if (underline != 0) out.underline = underline;
        var family = data.read_shift(1);
        if (family > 0) out.family = family;
        var bCharSet = data.read_shift(1);
        if (bCharSet > 0) out.charset = bCharSet;
        data.l++;
        out.color = parse_BrtColor(data, 8);
        switch (data.read_shift(1)) {
          case 1:
            out.scheme = "major";
            break;

          case 2:
            out.scheme = "minor";
            break;
        }
        out.name = parse_XLWideString(data, length - 21);
        return out;
    }
    function write_BrtFont(font, o) {
        if (!o) o = new_buf(25 + 4 * 32);
        o.write_shift(2, font.sz * 20);
        write_FontFlags(font, o);
        o.write_shift(2, font.bold ? 700 : 400);
        var sss = 0;
        if (font.vertAlign == "superscript") sss = 1; else if (font.vertAlign == "subscript") sss = 2;
        o.write_shift(2, sss);
        o.write_shift(1, font.underline || 0);
        o.write_shift(1, font.family || 0);
        o.write_shift(1, font.charset || 0);
        o.write_shift(1, 0);
        write_BrtColor(font.color, o);
        var scheme = 0;
        if (font.scheme == "major") scheme = 1;
        if (font.scheme == "minor") scheme = 2;
        o.write_shift(1, scheme);
        write_XLWideString(font.name, o);
        return o.length > o.l ? o.slice(0, o.l) : o;
    }
    var XLSBFillPTNames = [ "none", "solid", "mediumGray", "darkGray", "lightGray", "darkHorizontal", "darkVertical", "darkDown", "darkUp", "darkGrid", "darkTrellis", "lightHorizontal", "lightVertical", "lightDown", "lightUp", "lightGrid", "lightTrellis", "gray125", "gray0625" ];
    var rev_XLSBFillPTNames = evert(XLSBFillPTNames);
    var parse_BrtFill = parsenoop;
    function write_BrtFill(fill, o) {
        if (!o) o = new_buf(4 * 3 + 8 * 7 + 16 * 1);
        var fls = rev_XLSBFillPTNames[fill.patternType];
        if (fls == null) fls = 40;
        o.write_shift(4, fls);
        var j = 0;
        if (fls != 40) {
            write_BrtColor({
                "auto": 1
            }, o);
            write_BrtColor({
                "auto": 1
            }, o);
            for (;j < 12; ++j) o.write_shift(4, 0);
        } else {
            for (;j < 4; ++j) o.write_shift(4, 0);
            for (;j < 12; ++j) o.write_shift(4, 0);
        }
        return o.length > o.l ? o.slice(0, o.l) : o;
    }
    function parse_BrtXF(data, length) {
        var tgt = data.l + length;
        var ixfeParent = data.read_shift(2);
        var ifmt = data.read_shift(2);
        data.l = tgt;
        return {
            "ixfe": ixfeParent,
            "numFmtId": ifmt
        };
    }
    function write_BrtXF(data, ixfeP, o) {
        if (!o) o = new_buf(16);
        o.write_shift(2, ixfeP || 0);
        o.write_shift(2, data.numFmtId || 0);
        o.write_shift(2, 0);
        o.write_shift(2, 0);
        o.write_shift(2, 0);
        o.write_shift(1, 0);
        o.write_shift(1, 0);
        o.write_shift(1, 0);
        o.write_shift(1, 0);
        o.write_shift(1, 0);
        o.write_shift(1, 0);
        return o;
    }
    function write_Blxf(data, o) {
        if (!o) o = new_buf(10);
        o.write_shift(1, 0);
        o.write_shift(1, 0);
        o.write_shift(4, 0);
        o.write_shift(4, 0);
        return o;
    }
    var parse_BrtBorder = parsenoop;
    function write_BrtBorder(border, o) {
        if (!o) o = new_buf(51);
        o.write_shift(1, 0);
        write_Blxf(null, o);
        write_Blxf(null, o);
        write_Blxf(null, o);
        write_Blxf(null, o);
        write_Blxf(null, o);
        return o.length > o.l ? o.slice(0, o.l) : o;
    }
    function write_BrtStyle(style, o) {
        if (!o) o = new_buf(12 + 4 * 10);
        o.write_shift(4, style.xfId);
        o.write_shift(2, 1);
        o.write_shift(1, +style.builtinId);
        o.write_shift(1, 0);
        write_XLNullableWideString(style.name || "", o);
        return o.length > o.l ? o.slice(0, o.l) : o;
    }
    function write_BrtBeginTableStyles(cnt, defTableStyle, defPivotStyle) {
        var o = new_buf(4 + 256 * 2 * 4);
        o.write_shift(4, cnt);
        write_XLNullableWideString(defTableStyle, o);
        write_XLNullableWideString(defPivotStyle, o);
        return o.length > o.l ? o.slice(0, o.l) : o;
    }
    function parse_sty_bin(data, themes, opts) {
        var styles = {};
        styles.NumberFmt = [];
        for (var y in SSF._table) styles.NumberFmt[y] = SSF._table[y];
        styles.CellXf = [];
        styles.Fonts = [];
        var state = [];
        var pass = false;
        recordhopper(data, function hopper_sty(val, R_n, RT) {
            switch (RT) {
              case 44:
                styles.NumberFmt[val[0]] = val[1];
                SSF.load(val[1], val[0]);
                break;

              case 43:
                styles.Fonts.push(val);
                if (val.color.theme != null && themes && themes.themeElements && themes.themeElements.clrScheme) {
                    val.color.rgb = rgb_tint(themes.themeElements.clrScheme[val.color.theme].rgb, val.color.tint || 0);
                }
                break;

              case 1025:
                break;

              case 45:
                break;

              case 46:
                break;

              case 47:
                if (state[state.length - 1] == "BrtBeginCellXFs") {
                    styles.CellXf.push(val);
                }
                break;

              case 48:
              case 507:
              case 572:
              case 475:
                break;

              case 1171:
              case 2102:
              case 1130:
              case 512:
              case 2095:
              case 3072:
                break;

              case 35:
                pass = true;
                break;

              case 36:
                pass = false;
                break;

              case 37:
                state.push(R_n);
                break;

              case 38:
                state.pop();
                break;

              default:
                if ((R_n || "").indexOf("Begin") > 0) state.push(R_n); else if ((R_n || "").indexOf("End") > 0) state.pop(); else if (!pass || opts.WTF) throw new Error("Unexpected record " + RT + " " + R_n);
            }
        });
        return styles;
    }
    function write_FMTS_bin(ba, NF) {
        if (!NF) return;
        var cnt = 0;
        [ [ 5, 8 ], [ 23, 26 ], [ 41, 44 ], [ 50, 392 ] ].forEach(function(r) {
            for (var i = r[0]; i <= r[1]; ++i) if (NF[i] != null) ++cnt;
        });
        if (cnt == 0) return;
        write_record(ba, "BrtBeginFmts", write_UInt32LE(cnt));
        [ [ 5, 8 ], [ 23, 26 ], [ 41, 44 ], [ 50, 392 ] ].forEach(function(r) {
            for (var i = r[0]; i <= r[1]; ++i) if (NF[i] != null) write_record(ba, "BrtFmt", write_BrtFmt(i, NF[i]));
        });
        write_record(ba, "BrtEndFmts");
    }
    function write_FONTS_bin(ba) {
        var cnt = 1;
        if (cnt == 0) return;
        write_record(ba, "BrtBeginFonts", write_UInt32LE(cnt));
        write_record(ba, "BrtFont", write_BrtFont({
            "sz": 12,
            "color": {
                "theme": 1
            },
            "name": "Calibri",
            "family": 2,
            "scheme": "minor"
        }));
        write_record(ba, "BrtEndFonts");
    }
    function write_FILLS_bin(ba) {
        var cnt = 2;
        if (cnt == 0) return;
        write_record(ba, "BrtBeginFills", write_UInt32LE(cnt));
        write_record(ba, "BrtFill", write_BrtFill({
            "patternType": "none"
        }));
        write_record(ba, "BrtFill", write_BrtFill({
            "patternType": "gray125"
        }));
        write_record(ba, "BrtEndFills");
    }
    function write_BORDERS_bin(ba) {
        var cnt = 1;
        if (cnt == 0) return;
        write_record(ba, "BrtBeginBorders", write_UInt32LE(cnt));
        write_record(ba, "BrtBorder", write_BrtBorder({}));
        write_record(ba, "BrtEndBorders");
    }
    function write_CELLSTYLEXFS_bin(ba) {
        var cnt = 1;
        write_record(ba, "BrtBeginCellStyleXFs", write_UInt32LE(cnt));
        write_record(ba, "BrtXF", write_BrtXF({
            "numFmtId": 0,
            "fontId": 0,
            "fillId": 0,
            "borderId": 0
        }, 65535));
        write_record(ba, "BrtEndCellStyleXFs");
    }
    function write_CELLXFS_bin(ba, data) {
        write_record(ba, "BrtBeginCellXFs", write_UInt32LE(data.length));
        data.forEach(function(c) {
            write_record(ba, "BrtXF", write_BrtXF(c, 0));
        });
        write_record(ba, "BrtEndCellXFs");
    }
    function write_STYLES_bin(ba) {
        var cnt = 1;
        write_record(ba, "BrtBeginStyles", write_UInt32LE(cnt));
        write_record(ba, "BrtStyle", write_BrtStyle({
            "xfId": 0,
            "builtinId": 0,
            "name": "Normal"
        }));
        write_record(ba, "BrtEndStyles");
    }
    function write_DXFS_bin(ba) {
        var cnt = 0;
        write_record(ba, "BrtBeginDXFs", write_UInt32LE(cnt));
        write_record(ba, "BrtEndDXFs");
    }
    function write_TABLESTYLES_bin(ba) {
        var cnt = 0;
        write_record(ba, "BrtBeginTableStyles", write_BrtBeginTableStyles(cnt, "TableStyleMedium9", "PivotStyleMedium4"));
        write_record(ba, "BrtEndTableStyles");
    }
    function write_COLORPALETTE_bin() {
        return;
    }
    function write_sty_bin(wb, opts) {
        var ba = buf_array();
        write_record(ba, "BrtBeginStyleSheet");
        write_FMTS_bin(ba, wb.SSF);
        write_FONTS_bin(ba, wb);
        write_FILLS_bin(ba, wb);
        write_BORDERS_bin(ba, wb);
        write_CELLSTYLEXFS_bin(ba, wb);
        write_CELLXFS_bin(ba, opts.cellXfs);
        write_STYLES_bin(ba, wb);
        write_DXFS_bin(ba, wb);
        write_TABLESTYLES_bin(ba, wb);
        write_COLORPALETTE_bin(ba, wb);
        write_record(ba, "BrtEndStyleSheet");
        return ba.end();
    }
    RELS.THEME = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme";
    function parse_clrScheme(t, themes, opts) {
        themes.themeElements.clrScheme = [];
        var color = {};
        (t[0].match(tagregex) || []).forEach(function(x) {
            var y = parsexmltag(x);
            switch (y[0]) {
              case "<a:clrScheme":
              case "</a:clrScheme>":
                break;

              case "<a:srgbClr":
                color.rgb = y.val;
                break;

              case "<a:sysClr":
                color.rgb = y.lastClr;
                break;

              case "<a:dk1>":
              case "</a:dk1>":
              case "<a:lt1>":
              case "</a:lt1>":
              case "<a:dk2>":
              case "</a:dk2>":
              case "<a:lt2>":
              case "</a:lt2>":
              case "<a:accent1>":
              case "</a:accent1>":
              case "<a:accent2>":
              case "</a:accent2>":
              case "<a:accent3>":
              case "</a:accent3>":
              case "<a:accent4>":
              case "</a:accent4>":
              case "<a:accent5>":
              case "</a:accent5>":
              case "<a:accent6>":
              case "</a:accent6>":
              case "<a:hlink>":
              case "</a:hlink>":
              case "<a:folHlink>":
              case "</a:folHlink>":
                if (y[0].charAt(1) === "/") {
                    themes.themeElements.clrScheme.push(color);
                    color = {};
                } else {
                    color.name = y[0].slice(3, y[0].length - 1);
                }
                break;

              default:
                if (opts && opts.WTF) throw new Error("Unrecognized " + y[0] + " in clrScheme");
            }
        });
    }
    function parse_fontScheme() {}
    function parse_fmtScheme() {}
    var clrsregex = /<a:clrScheme([^>]*)>[\s\S]*<\/a:clrScheme>/;
    var fntsregex = /<a:fontScheme([^>]*)>[\s\S]*<\/a:fontScheme>/;
    var fmtsregex = /<a:fmtScheme([^>]*)>[\s\S]*<\/a:fmtScheme>/;
    function parse_themeElements(data, themes, opts) {
        themes.themeElements = {};
        var t;
        [ [ "clrScheme", clrsregex, parse_clrScheme ], [ "fontScheme", fntsregex, parse_fontScheme ], [ "fmtScheme", fmtsregex, parse_fmtScheme ] ].forEach(function(m) {
            if (!(t = data.match(m[1]))) throw new Error(m[0] + " not found in themeElements");
            m[2](t, themes, opts);
        });
    }
    var themeltregex = /<a:themeElements([^>]*)>[\s\S]*<\/a:themeElements>/;
    function parse_theme_xml(data, opts) {
        if (!data || data.length === 0) return parse_theme_xml(write_theme());
        var t;
        var themes = {};
        if (!(t = data.match(themeltregex))) throw new Error("themeElements not found in theme");
        parse_themeElements(t[0], themes, opts);
        return themes;
    }
    function write_theme(Themes, opts) {
        if (opts && opts.themeXLSX) return opts.themeXLSX;
        var o = [ XML_HEADER ];
        o[o.length] = '<a:theme xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" name="Office Theme">';
        o[o.length] = "<a:themeElements>";
        o[o.length] = '<a:clrScheme name="Office">';
        o[o.length] = '<a:dk1><a:sysClr val="windowText" lastClr="000000"/></a:dk1>';
        o[o.length] = '<a:lt1><a:sysClr val="window" lastClr="FFFFFF"/></a:lt1>';
        o[o.length] = '<a:dk2><a:srgbClr val="1F497D"/></a:dk2>';
        o[o.length] = '<a:lt2><a:srgbClr val="EEECE1"/></a:lt2>';
        o[o.length] = '<a:accent1><a:srgbClr val="4F81BD"/></a:accent1>';
        o[o.length] = '<a:accent2><a:srgbClr val="C0504D"/></a:accent2>';
        o[o.length] = '<a:accent3><a:srgbClr val="9BBB59"/></a:accent3>';
        o[o.length] = '<a:accent4><a:srgbClr val="8064A2"/></a:accent4>';
        o[o.length] = '<a:accent5><a:srgbClr val="4BACC6"/></a:accent5>';
        o[o.length] = '<a:accent6><a:srgbClr val="F79646"/></a:accent6>';
        o[o.length] = '<a:hlink><a:srgbClr val="0000FF"/></a:hlink>';
        o[o.length] = '<a:folHlink><a:srgbClr val="800080"/></a:folHlink>';
        o[o.length] = "</a:clrScheme>";
        o[o.length] = '<a:fontScheme name="Office">';
        o[o.length] = "<a:majorFont>";
        o[o.length] = '<a:latin typeface="Cambria"/>';
        o[o.length] = '<a:ea typeface=""/>';
        o[o.length] = '<a:cs typeface=""/>';
        o[o.length] = '<a:font script="Jpan" typeface="\uff2d\uff33 \uff30\u30b4\u30b7\u30c3\u30af"/>';
        o[o.length] = '<a:font script="Hang" typeface="\ub9d1\uc740 \uace0\ub515"/>';
        o[o.length] = '<a:font script="Hans" typeface="\u5b8b\u4f53"/>';
        o[o.length] = '<a:font script="Hant" typeface="\u65b0\u7d30\u660e\u9ad4"/>';
        o[o.length] = '<a:font script="Arab" typeface="Times New Roman"/>';
        o[o.length] = '<a:font script="Hebr" typeface="Times New Roman"/>';
        o[o.length] = '<a:font script="Thai" typeface="Tahoma"/>';
        o[o.length] = '<a:font script="Ethi" typeface="Nyala"/>';
        o[o.length] = '<a:font script="Beng" typeface="Vrinda"/>';
        o[o.length] = '<a:font script="Gujr" typeface="Shruti"/>';
        o[o.length] = '<a:font script="Khmr" typeface="MoolBoran"/>';
        o[o.length] = '<a:font script="Knda" typeface="Tunga"/>';
        o[o.length] = '<a:font script="Guru" typeface="Raavi"/>';
        o[o.length] = '<a:font script="Cans" typeface="Euphemia"/>';
        o[o.length] = '<a:font script="Cher" typeface="Plantagenet Cherokee"/>';
        o[o.length] = '<a:font script="Yiii" typeface="Microsoft Yi Baiti"/>';
        o[o.length] = '<a:font script="Tibt" typeface="Microsoft Himalaya"/>';
        o[o.length] = '<a:font script="Thaa" typeface="MV Boli"/>';
        o[o.length] = '<a:font script="Deva" typeface="Mangal"/>';
        o[o.length] = '<a:font script="Telu" typeface="Gautami"/>';
        o[o.length] = '<a:font script="Taml" typeface="Latha"/>';
        o[o.length] = '<a:font script="Syrc" typeface="Estrangelo Edessa"/>';
        o[o.length] = '<a:font script="Orya" typeface="Kalinga"/>';
        o[o.length] = '<a:font script="Mlym" typeface="Kartika"/>';
        o[o.length] = '<a:font script="Laoo" typeface="DokChampa"/>';
        o[o.length] = '<a:font script="Sinh" typeface="Iskoola Pota"/>';
        o[o.length] = '<a:font script="Mong" typeface="Mongolian Baiti"/>';
        o[o.length] = '<a:font script="Viet" typeface="Times New Roman"/>';
        o[o.length] = '<a:font script="Uigh" typeface="Microsoft Uighur"/>';
        o[o.length] = '<a:font script="Geor" typeface="Sylfaen"/>';
        o[o.length] = "</a:majorFont>";
        o[o.length] = "<a:minorFont>";
        o[o.length] = '<a:latin typeface="Calibri"/>';
        o[o.length] = '<a:ea typeface=""/>';
        o[o.length] = '<a:cs typeface=""/>';
        o[o.length] = '<a:font script="Jpan" typeface="\uff2d\uff33 \uff30\u30b4\u30b7\u30c3\u30af"/>';
        o[o.length] = '<a:font script="Hang" typeface="\ub9d1\uc740 \uace0\ub515"/>';
        o[o.length] = '<a:font script="Hans" typeface="\u5b8b\u4f53"/>';
        o[o.length] = '<a:font script="Hant" typeface="\u65b0\u7d30\u660e\u9ad4"/>';
        o[o.length] = '<a:font script="Arab" typeface="Arial"/>';
        o[o.length] = '<a:font script="Hebr" typeface="Arial"/>';
        o[o.length] = '<a:font script="Thai" typeface="Tahoma"/>';
        o[o.length] = '<a:font script="Ethi" typeface="Nyala"/>';
        o[o.length] = '<a:font script="Beng" typeface="Vrinda"/>';
        o[o.length] = '<a:font script="Gujr" typeface="Shruti"/>';
        o[o.length] = '<a:font script="Khmr" typeface="DaunPenh"/>';
        o[o.length] = '<a:font script="Knda" typeface="Tunga"/>';
        o[o.length] = '<a:font script="Guru" typeface="Raavi"/>';
        o[o.length] = '<a:font script="Cans" typeface="Euphemia"/>';
        o[o.length] = '<a:font script="Cher" typeface="Plantagenet Cherokee"/>';
        o[o.length] = '<a:font script="Yiii" typeface="Microsoft Yi Baiti"/>';
        o[o.length] = '<a:font script="Tibt" typeface="Microsoft Himalaya"/>';
        o[o.length] = '<a:font script="Thaa" typeface="MV Boli"/>';
        o[o.length] = '<a:font script="Deva" typeface="Mangal"/>';
        o[o.length] = '<a:font script="Telu" typeface="Gautami"/>';
        o[o.length] = '<a:font script="Taml" typeface="Latha"/>';
        o[o.length] = '<a:font script="Syrc" typeface="Estrangelo Edessa"/>';
        o[o.length] = '<a:font script="Orya" typeface="Kalinga"/>';
        o[o.length] = '<a:font script="Mlym" typeface="Kartika"/>';
        o[o.length] = '<a:font script="Laoo" typeface="DokChampa"/>';
        o[o.length] = '<a:font script="Sinh" typeface="Iskoola Pota"/>';
        o[o.length] = '<a:font script="Mong" typeface="Mongolian Baiti"/>';
        o[o.length] = '<a:font script="Viet" typeface="Arial"/>';
        o[o.length] = '<a:font script="Uigh" typeface="Microsoft Uighur"/>';
        o[o.length] = '<a:font script="Geor" typeface="Sylfaen"/>';
        o[o.length] = "</a:minorFont>";
        o[o.length] = "</a:fontScheme>";
        o[o.length] = '<a:fmtScheme name="Office">';
        o[o.length] = "<a:fillStyleLst>";
        o[o.length] = '<a:solidFill><a:schemeClr val="phClr"/></a:solidFill>';
        o[o.length] = '<a:gradFill rotWithShape="1">';
        o[o.length] = "<a:gsLst>";
        o[o.length] = '<a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="50000"/><a:satMod val="300000"/></a:schemeClr></a:gs>';
        o[o.length] = '<a:gs pos="35000"><a:schemeClr val="phClr"><a:tint val="37000"/><a:satMod val="300000"/></a:schemeClr></a:gs>';
        o[o.length] = '<a:gs pos="100000"><a:schemeClr val="phClr"><a:tint val="15000"/><a:satMod val="350000"/></a:schemeClr></a:gs>';
        o[o.length] = "</a:gsLst>";
        o[o.length] = '<a:lin ang="16200000" scaled="1"/>';
        o[o.length] = "</a:gradFill>";
        o[o.length] = '<a:gradFill rotWithShape="1">';
        o[o.length] = "<a:gsLst>";
        o[o.length] = '<a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="100000"/><a:shade val="100000"/><a:satMod val="130000"/></a:schemeClr></a:gs>';
        o[o.length] = '<a:gs pos="100000"><a:schemeClr val="phClr"><a:tint val="50000"/><a:shade val="100000"/><a:satMod val="350000"/></a:schemeClr></a:gs>';
        o[o.length] = "</a:gsLst>";
        o[o.length] = '<a:lin ang="16200000" scaled="0"/>';
        o[o.length] = "</a:gradFill>";
        o[o.length] = "</a:fillStyleLst>";
        o[o.length] = "<a:lnStyleLst>";
        o[o.length] = '<a:ln w="9525" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"><a:shade val="95000"/><a:satMod val="105000"/></a:schemeClr></a:solidFill><a:prstDash val="solid"/></a:ln>';
        o[o.length] = '<a:ln w="25400" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/></a:ln>';
        o[o.length] = '<a:ln w="38100" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/></a:ln>';
        o[o.length] = "</a:lnStyleLst>";
        o[o.length] = "<a:effectStyleLst>";
        o[o.length] = "<a:effectStyle>";
        o[o.length] = "<a:effectLst>";
        o[o.length] = '<a:outerShdw blurRad="40000" dist="20000" dir="5400000" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="38000"/></a:srgbClr></a:outerShdw>';
        o[o.length] = "</a:effectLst>";
        o[o.length] = "</a:effectStyle>";
        o[o.length] = "<a:effectStyle>";
        o[o.length] = "<a:effectLst>";
        o[o.length] = '<a:outerShdw blurRad="40000" dist="23000" dir="5400000" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="35000"/></a:srgbClr></a:outerShdw>';
        o[o.length] = "</a:effectLst>";
        o[o.length] = "</a:effectStyle>";
        o[o.length] = "<a:effectStyle>";
        o[o.length] = "<a:effectLst>";
        o[o.length] = '<a:outerShdw blurRad="40000" dist="23000" dir="5400000" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="35000"/></a:srgbClr></a:outerShdw>';
        o[o.length] = "</a:effectLst>";
        o[o.length] = '<a:scene3d><a:camera prst="orthographicFront"><a:rot lat="0" lon="0" rev="0"/></a:camera><a:lightRig rig="threePt" dir="t"><a:rot lat="0" lon="0" rev="1200000"/></a:lightRig></a:scene3d>';
        o[o.length] = '<a:sp3d><a:bevelT w="63500" h="25400"/></a:sp3d>';
        o[o.length] = "</a:effectStyle>";
        o[o.length] = "</a:effectStyleLst>";
        o[o.length] = "<a:bgFillStyleLst>";
        o[o.length] = '<a:solidFill><a:schemeClr val="phClr"/></a:solidFill>';
        o[o.length] = '<a:gradFill rotWithShape="1">';
        o[o.length] = "<a:gsLst>";
        o[o.length] = '<a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="40000"/><a:satMod val="350000"/></a:schemeClr></a:gs>';
        o[o.length] = '<a:gs pos="40000"><a:schemeClr val="phClr"><a:tint val="45000"/><a:shade val="99000"/><a:satMod val="350000"/></a:schemeClr></a:gs>';
        o[o.length] = '<a:gs pos="100000"><a:schemeClr val="phClr"><a:shade val="20000"/><a:satMod val="255000"/></a:schemeClr></a:gs>';
        o[o.length] = "</a:gsLst>";
        o[o.length] = '<a:path path="circle"><a:fillToRect l="50000" t="-80000" r="50000" b="180000"/></a:path>';
        o[o.length] = "</a:gradFill>";
        o[o.length] = '<a:gradFill rotWithShape="1">';
        o[o.length] = "<a:gsLst>";
        o[o.length] = '<a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="80000"/><a:satMod val="300000"/></a:schemeClr></a:gs>';
        o[o.length] = '<a:gs pos="100000"><a:schemeClr val="phClr"><a:shade val="30000"/><a:satMod val="200000"/></a:schemeClr></a:gs>';
        o[o.length] = "</a:gsLst>";
        o[o.length] = '<a:path path="circle"><a:fillToRect l="50000" t="50000" r="50000" b="50000"/></a:path>';
        o[o.length] = "</a:gradFill>";
        o[o.length] = "</a:bgFillStyleLst>";
        o[o.length] = "</a:fmtScheme>";
        o[o.length] = "</a:themeElements>";
        o[o.length] = "<a:objectDefaults>";
        o[o.length] = "<a:spDef>";
        o[o.length] = '<a:spPr/><a:bodyPr/><a:lstStyle/><a:style><a:lnRef idx="1"><a:schemeClr val="accent1"/></a:lnRef><a:fillRef idx="3"><a:schemeClr val="accent1"/></a:fillRef><a:effectRef idx="2"><a:schemeClr val="accent1"/></a:effectRef><a:fontRef idx="minor"><a:schemeClr val="lt1"/></a:fontRef></a:style>';
        o[o.length] = "</a:spDef>";
        o[o.length] = "<a:lnDef>";
        o[o.length] = '<a:spPr/><a:bodyPr/><a:lstStyle/><a:style><a:lnRef idx="2"><a:schemeClr val="accent1"/></a:lnRef><a:fillRef idx="0"><a:schemeClr val="accent1"/></a:fillRef><a:effectRef idx="1"><a:schemeClr val="accent1"/></a:effectRef><a:fontRef idx="minor"><a:schemeClr val="tx1"/></a:fontRef></a:style>';
        o[o.length] = "</a:lnDef>";
        o[o.length] = "</a:objectDefaults>";
        o[o.length] = "<a:extraClrSchemeLst/>";
        o[o.length] = "</a:theme>";
        return o.join("");
    }
    function parse_Theme(blob, length, opts) {
        var end = blob.l + length;
        var dwThemeVersion = blob.read_shift(4);
        if (dwThemeVersion === 124226) return;
        if (!opts.cellStyles || !jszip) {
            blob.l = end;
            return;
        }
        var data = blob.slice(blob.l);
        blob.l = end;
        var zip;
        try {
            zip = new jszip(data);
        } catch (e) {
            return;
        }
        var themeXML = getzipstr(zip, "theme/theme/theme1.xml", true);
        if (!themeXML) return;
        return parse_theme_xml(themeXML, opts);
    }
    function parse_ColorTheme(blob) {
        return blob.read_shift(4);
    }
    function parse_FullColorExt(blob) {
        var o = {};
        o.xclrType = blob.read_shift(2);
        o.nTintShade = blob.read_shift(2);
        switch (o.xclrType) {
          case 0:
            blob.l += 4;
            break;

          case 1:
            o.xclrValue = parse_IcvXF(blob, 4);
            break;

          case 2:
            o.xclrValue = parse_LongRGBA(blob, 4);
            break;

          case 3:
            o.xclrValue = parse_ColorTheme(blob, 4);
            break;

          case 4:
            blob.l += 4;
            break;
        }
        blob.l += 8;
        return o;
    }
    function parse_IcvXF(blob, length) {
        return parsenoop(blob, length);
    }
    function parse_XFExtGradient(blob, length) {
        return parsenoop(blob, length);
    }
    function parse_ExtProp(blob) {
        var extType = blob.read_shift(2);
        var cb = blob.read_shift(2) - 4;
        var o = [ extType ];
        switch (extType) {
          case 4:
          case 5:
          case 7:
          case 8:
          case 9:
          case 10:
          case 11:
          case 13:
            o[1] = parse_FullColorExt(blob, cb);
            break;

          case 6:
            o[1] = parse_XFExtGradient(blob, cb);
            break;

          case 14:
          case 15:
            o[1] = blob.read_shift(cb === 1 ? 1 : 2);
            break;

          default:
            throw new Error("Unrecognized ExtProp type: " + extType + " " + cb);
        }
        return o;
    }
    function parse_XFExt(blob, length) {
        var end = blob.l + length;
        blob.l += 2;
        var ixfe = blob.read_shift(2);
        blob.l += 2;
        var cexts = blob.read_shift(2);
        var ext = [];
        while (cexts-- > 0) ext.push(parse_ExtProp(blob, end - blob.l));
        return {
            "ixfe": ixfe,
            "ext": ext
        };
    }
    function update_xfext(xf, xfext) {
        xfext.forEach(function(xfe) {
            switch (xfe[0]) {
              case 4:
                break;

              case 5:
                break;

              case 6:
                break;

              case 7:
                break;

              case 8:
                break;

              case 9:
                break;

              case 10:
                break;

              case 11:
                break;

              case 13:
                break;

              case 14:
                break;

              case 15:
                break;
            }
        });
    }
    function parse_cc_xml(data) {
        var d = [];
        if (!data) return d;
        var i = 1;
        (data.match(tagregex) || []).forEach(function(x) {
            var y = parsexmltag(x);
            switch (y[0]) {
              case "<?xml":
                break;

              case "<calcChain":
              case "<calcChain>":
              case "</calcChain>":
                break;

              case "<c":
                delete y[0];
                if (y.i) i = y.i; else y.i = i;
                d.push(y);
                break;
            }
        });
        return d;
    }
    function parse_BrtCalcChainItem$(data) {
        var out = {};
        out.i = data.read_shift(4);
        var cell = {};
        cell.r = data.read_shift(4);
        cell.c = data.read_shift(4);
        out.r = encode_cell(cell);
        var flags = data.read_shift(1);
        if (flags & 2) out.l = "1";
        if (flags & 8) out.a = "1";
        return out;
    }
    function parse_cc_bin(data, name, opts) {
        var out = [];
        var pass = false;
        recordhopper(data, function hopper_cc(val, R_n, RT) {
            switch (RT) {
              case 63:
                out.push(val);
                break;

              default:
                if ((R_n || "").indexOf("Begin") > 0) {} else if ((R_n || "").indexOf("End") > 0) {} else if (!pass || opts.WTF) throw new Error("Unexpected record " + RT + " " + R_n);
            }
        });
        return out;
    }
    function parse_xlink_xml() {}
    function parse_xlink_bin(data, name, _opts) {
        if (!data) return data;
        var opts = _opts || {};
        var pass = false, end = false;
        recordhopper(data, function xlink_parse(val, R_n, RT) {
            if (end) return;
            switch (RT) {
              case 359:
              case 363:
              case 364:
              case 366:
              case 367:
              case 368:
              case 369:
              case 370:
              case 371:
              case 472:
              case 577:
              case 578:
              case 579:
              case 580:
              case 581:
              case 582:
              case 583:
              case 584:
              case 585:
              case 586:
              case 587:
                break;

              case 35:
                pass = true;
                break;

              case 36:
                pass = false;
                break;

              default:
                if ((R_n || "").indexOf("Begin") > 0) {} else if ((R_n || "").indexOf("End") > 0) {} else if (!pass || opts.WTF) throw new Error("Unexpected record " + RT.toString(16) + " " + R_n);
            }
        }, opts);
    }
    RELS.IMG = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image";
    RELS.DRAW = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/drawing";
    function parse_drawing(data, rels) {
        if (!data) return "??";
        var id = (data.match(/<c:chart [^>]*r:id="([^"]*)"/) || [ "", "" ])[1];
        return rels["!id"][id].Target;
    }
    var _shapeid = 1024;
    function write_comments_vml(rId, comments) {
        var csize = [ 21600, 21600 ];
        var bbox = [ "m0,0l0", csize[1], csize[0], csize[1], csize[0], "0xe" ].join(",");
        var o = [ writextag("xml", null, {
            "xmlns:v": XLMLNS.v,
            "xmlns:o": XLMLNS.o,
            "xmlns:x": XLMLNS.x,
            "xmlns:mv": XLMLNS.mv
        }).replace(/\/>/, ">"), writextag("o:shapelayout", writextag("o:idmap", null, {
            "v:ext": "edit",
            "data": rId
        }), {
            "v:ext": "edit"
        }), writextag("v:shapetype", [ writextag("v:stroke", null, {
            "joinstyle": "miter"
        }), writextag("v:path", null, {
            "gradientshapeok": "t",
            "o:connecttype": "rect"
        }) ].join(""), {
            "id": "_x0000_t202",
            "o:spt": 202,
            "coordsize": csize.join(","),
            "path": bbox
        }) ];
        while (_shapeid < rId * 1e3) _shapeid += 1e3;
        comments.forEach(function(x) {
            var c = decode_cell(x[0]);
            o = o.concat([ "<v:shape" + wxt_helper({
                "id": "_x0000_s" + ++_shapeid,
                "type": "#_x0000_t202",
                "style": "position:absolute; margin-left:80pt;margin-top:5pt;width:104pt;height:64pt;z-index:10" + (x[1].hidden ? ";visibility:hidden" : ""),
                "fillcolor": "#ECFAD4",
                "strokecolor": "#edeaa1"
            }) + ">", writextag("v:fill", writextag("o:fill", null, {
                "type": "gradientUnscaled",
                "v:ext": "view"
            }), {
                "color2": "#BEFF82",
                "angle": "-180",
                "type": "gradient"
            }), writextag("v:shadow", null, {
                "on": "t",
                "obscured": "t"
            }), writextag("v:path", null, {
                "o:connecttype": "none"
            }), '<v:textbox><div style="text-align:left"></div></v:textbox>', '<x:ClientData ObjectType="Note">', "<x:MoveWithCells/>", "<x:SizeWithCells/>", writetag("x:Anchor", [ c.c, 0, c.r, 0, c.c + 3, 100, c.r + 5, 100 ].join(",")), writetag("x:AutoFill", "False"), writetag("x:Row", String(c.r)), writetag("x:Column", String(c.c)), x[1].hidden ? "" : "<x:Visible/>", "</x:ClientData>", "</v:shape>" ]);
        });
        o.push("</xml>");
        return o.join("");
    }
    RELS.CMNT = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/comments";
    function parse_comments(zip, dirComments, sheets, sheetRels, opts) {
        for (var i = 0; i != dirComments.length; ++i) {
            var canonicalpath = dirComments[i];
            var comments = parse_cmnt(getzipdata(zip, canonicalpath.replace(/^\//, ""), true), canonicalpath, opts);
            if (!comments || !comments.length) continue;
            var sheetNames = keys(sheets);
            for (var j = 0; j != sheetNames.length; ++j) {
                var sheetName = sheetNames[j];
                var rels = sheetRels[sheetName];
                if (rels) {
                    var rel = rels[canonicalpath];
                    if (rel) insertCommentsIntoSheet(sheetName, sheets[sheetName], comments);
                }
            }
        }
    }
    function insertCommentsIntoSheet(sheetName, sheet, comments) {
        var dense = Array.isArray(sheet);
        var cell, r;
        comments.forEach(function(comment) {
            if (dense) {
                r = decode_cell(comment.ref);
                if (!sheet[r.r]) sheet[r.r] = [];
                cell = sheet[r.r][r.c];
            } else cell = sheet[comment.ref];
            if (!cell) {
                cell = {};
                if (dense) sheet[r.r][r.c] = cell; else sheet[comment.ref] = cell;
                var range = safe_decode_range(sheet["!ref"] || "BDWGO1000001:A1");
                var thisCell = decode_cell(comment.ref);
                if (range.s.r > thisCell.r) range.s.r = thisCell.r;
                if (range.e.r < thisCell.r) range.e.r = thisCell.r;
                if (range.s.c > thisCell.c) range.s.c = thisCell.c;
                if (range.e.c < thisCell.c) range.e.c = thisCell.c;
                var encoded = encode_range(range);
                if (encoded !== sheet["!ref"]) sheet["!ref"] = encoded;
            }
            if (!cell.c) cell.c = [];
            var o = {
                "a": comment.author,
                "t": comment.t,
                "r": comment.r
            };
            if (comment.h) o.h = comment.h;
            cell.c.push(o);
        });
    }
    function parse_comments_xml(data, opts) {
        if (data.match(/<(?:\w+:)?comments *\/>/)) return [];
        var authors = [];
        var commentList = [];
        var authtag = data.match(/<(?:\w+:)?authors>([\s\S]*)<\/(?:\w+:)?authors>/);
        if (authtag && authtag[1]) authtag[1].split(/<\/\w*:?author>/).forEach(function(x) {
            if (x === "" || x.trim() === "") return;
            var a = x.match(/<(?:\w+:)?author[^>]*>(.*)/);
            if (a) authors.push(a[1]);
        });
        var cmnttag = data.match(/<(?:\w+:)?commentList>([\s\S]*)<\/(?:\w+:)?commentList>/);
        if (cmnttag && cmnttag[1]) cmnttag[1].split(/<\/\w*:?comment>/).forEach(function(x) {
            if (x === "" || x.trim() === "") return;
            var cm = x.match(/<(?:\w+:)?comment[^>]*>/);
            if (!cm) return;
            var y = parsexmltag(cm[0]);
            var comment = {
                "author": y.authorId && authors[y.authorId] || "sheetjsghost",
                "ref": y.ref,
                "guid": y.guid
            };
            var cell = decode_cell(y.ref);
            if (opts.sheetRows && opts.sheetRows <= cell.r) return;
            var textMatch = x.match(/<(?:\w+:)?text>([\s\S]*)<\/(?:\w+:)?text>/);
            var rt = !!textMatch && !!textMatch[1] && parse_si(textMatch[1]) || {
                "r": "",
                "t": "",
                "h": ""
            };
            comment.r = rt.r;
            if (rt.r == "<t></t>") rt.t = rt.h = "";
            comment.t = rt.t.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
            if (opts.cellHTML) comment.h = rt.h;
            commentList.push(comment);
        });
        return commentList;
    }
    var CMNT_XML_ROOT = writextag("comments", null, {
        "xmlns": XMLNS.main[0]
    });
    function write_comments_xml(data) {
        var o = [ XML_HEADER, CMNT_XML_ROOT ];
        var iauthor = [];
        o.push("<authors>");
        data.forEach(function(x) {
            x[1].forEach(function(w) {
                var a = escapexml(w.a);
                if (iauthor.indexOf(a) > -1) return;
                iauthor.push(a);
                o.push("<author>" + a + "</author>");
            });
        });
        o.push("</authors>");
        o.push("<commentList>");
        data.forEach(function(d) {
            d[1].forEach(function(c) {
                o.push('<comment ref="' + d[0] + '" authorId="' + iauthor.indexOf(escapexml(c.a)) + '"><text>');
                o.push(writetag("t", c.t == null ? "" : c.t));
                o.push("</text></comment>");
            });
        });
        o.push("</commentList>");
        if (o.length > 2) {
            o[o.length] = "</comments>";
            o[1] = o[1].replace("/>", ">");
        }
        return o.join("");
    }
    function parse_BrtBeginComment(data) {
        var out = {};
        out.iauthor = data.read_shift(4);
        var rfx = parse_UncheckedRfX(data, 16);
        out.rfx = rfx.s;
        out.ref = encode_cell(rfx.s);
        data.l += 16;
        return out;
    }
    function write_BrtBeginComment(data, o) {
        if (o == null) o = new_buf(36);
        o.write_shift(4, data[1].iauthor);
        write_UncheckedRfX(data[0], o);
        o.write_shift(4, 0);
        o.write_shift(4, 0);
        o.write_shift(4, 0);
        o.write_shift(4, 0);
        return o;
    }
    var parse_BrtCommentAuthor = parse_XLWideString;
    function write_BrtCommentAuthor(data) {
        return write_XLWideString(data.slice(0, 54));
    }
    function parse_comments_bin(data, opts) {
        var out = [];
        var authors = [];
        var c = {};
        var pass = false;
        recordhopper(data, function hopper_cmnt(val, R_n, RT) {
            switch (RT) {
              case 632:
                authors.push(val);
                break;

              case 635:
                c = val;
                break;

              case 637:
                c.t = val.t;
                c.h = val.h;
                c.r = val.r;
                break;

              case 636:
                c.author = authors[c.iauthor];
                delete c.iauthor;
                if (opts.sheetRows && opts.sheetRows <= c.rfx.r) break;
                if (!c.t) c.t = "";
                delete c.rfx;
                out.push(c);
                break;

              case 3072:
                break;

              case 35:
                pass = true;
                break;

              case 36:
                pass = false;
                break;

              case 37:
                break;

              case 38:
                break;

              default:
                if ((R_n || "").indexOf("Begin") > 0) {} else if ((R_n || "").indexOf("End") > 0) {} else if (!pass || opts.WTF) throw new Error("Unexpected record " + RT + " " + R_n);
            }
        });
        return out;
    }
    function write_comments_bin(data) {
        var ba = buf_array();
        var iauthor = [];
        write_record(ba, "BrtBeginComments");
        write_record(ba, "BrtBeginCommentAuthors");
        data.forEach(function(comment) {
            comment[1].forEach(function(c) {
                if (iauthor.indexOf(c.a) > -1) return;
                iauthor.push(c.a.slice(0, 54));
                write_record(ba, "BrtCommentAuthor", write_BrtCommentAuthor(c.a));
            });
        });
        write_record(ba, "BrtEndCommentAuthors");
        write_record(ba, "BrtBeginCommentList");
        data.forEach(function(comment) {
            comment[1].forEach(function(c) {
                c.iauthor = iauthor.indexOf(c.a);
                var range = {
                    "s": decode_cell(comment[0]),
                    "e": decode_cell(comment[0])
                };
                write_record(ba, "BrtBeginComment", write_BrtBeginComment([ range, c ]));
                if (c.t && c.t.length > 0) write_record(ba, "BrtCommentText", write_BrtCommentText(c));
                write_record(ba, "BrtEndComment");
                delete c.iauthor;
            });
        });
        write_record(ba, "BrtEndCommentList");
        write_record(ba, "BrtEndComments");
        return ba.end();
    }
    var CT_VBA = "application/vnd.ms-office.vbaProject";
    function make_vba_xls(cfb) {
        var newcfb = CFB.utils.cfb_new({
            "root": "R"
        });
        cfb.FullPaths.forEach(function(p, i) {
            if (p.slice(-1) === "/" || !p.match(/_VBA_PROJECT_CUR/)) return;
            var newpath = p.replace(/^[^\/]*/, "R").replace(/\/_VBA_PROJECT_CUR\u0000*/, "");
            CFB.utils.cfb_add(newcfb, newpath, cfb.FileIndex[i].content);
        });
        return CFB.write(newcfb);
    }
    function fill_vba_xls(cfb, vba) {
        vba.FullPaths.forEach(function(p, i) {
            if (i == 0) return;
            var newpath = p.replace(/[^\/]*[\/]/, "/_VBA_PROJECT_CUR/");
            if (newpath.slice(-1) !== "/") CFB.utils.cfb_add(cfb, newpath, vba.FileIndex[i].content);
        });
    }
    var VBAFMTS = [ "xlsb", "xlsm", "xlam", "biff8", "xla" ];
    RELS.DS = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/dialogsheet";
    RELS.MS = "http://schemas.microsoft.com/office/2006/relationships/xlMacrosheet";
    function parse_ds_bin() {
        return {
            "!type": "dialog"
        };
    }
    function parse_ds_xml() {
        return {
            "!type": "dialog"
        };
    }
    function parse_ms_bin() {
        return {
            "!type": "macro"
        };
    }
    function parse_ms_xml() {
        return {
            "!type": "macro"
        };
    }
    var rc_to_a1 = function() {
        var rcregex = /(^|[^A-Za-z])R(\[?)(-?\d+|)\]?C(\[?)(-?\d+|)\]?/g;
        var rcbase = {
            "r": 0,
            "c": 0
        };
        function rcfunc($$, $1, $2, $3, $4, $5) {
            var R = $3.length > 0 ? parseInt($3, 10) | 0 : 0, C = $5.length > 0 ? parseInt($5, 10) | 0 : 0;
            if (C < 0 && $4.length === 0) C = 0;
            var cRel = false, rRel = false;
            if ($4.length > 0 || $5.length == 0) cRel = true;
            if (cRel) C += rcbase.c; else --C;
            if ($2.length > 0 || $3.length == 0) rRel = true;
            if (rRel) R += rcbase.r; else --R;
            return $1 + (cRel ? "" : "$") + encode_col(C) + (rRel ? "" : "$") + encode_row(R);
        }
        return function rc_to_a1(fstr, base) {
            rcbase = base;
            return fstr.replace(rcregex, rcfunc);
        };
    }();
    var crefregex = /(^|[^._A-Z0-9])([$]?)([A-Z]{1,2}|[A-W][A-Z]{2}|X[A-E][A-Z]|XF[A-D])([$]?)([1-9]\d{0,5}|10[0-3]\d{4}|104[0-7]\d{3}|1048[0-4]\d{2}|10485[0-6]\d|104857[0-6])(?![_.\(A-Za-z0-9])/g;
    var a1_to_rc = function() {
        return function a1_to_rc(fstr, base) {
            return fstr.replace(crefregex, function($0, $1, $2, $3, $4, $5) {
                var c = decode_col($3) - ($2 ? 0 : base.c);
                var r = decode_row($5) - ($4 ? 0 : base.r);
                var R = r == 0 ? "" : !$4 ? "[" + r + "]" : r + 1;
                var C = c == 0 ? "" : !$2 ? "[" + c + "]" : c + 1;
                return $1 + "R" + R + "C" + C;
            });
        };
    }();
    function shift_formula_str(f, delta) {
        return f.replace(crefregex, function($0, $1, $2, $3, $4, $5) {
            return $1 + ($2 == "$" ? $2 + $3 : encode_col(decode_col($3) + delta.c)) + ($4 == "$" ? $4 + $5 : encode_row(decode_row($5) + delta.r));
        });
    }
    function shift_formula_xlsx(f, range, cell) {
        var r = decode_range(range), s = r.s, c = decode_cell(cell);
        var delta = {
            "r": c.r - s.r,
            "c": c.c - s.c
        };
        return shift_formula_str(f, delta);
    }
    function fuzzyfmla(f) {
        if (f.length == 1) return false;
        return true;
    }
    function _xlfn(f) {
        return f.replace(/_xlfn\./g, "");
    }
    function parseread1(blob) {
        blob.l += 1;
        return;
    }
    function parse_ColRelU(blob, length) {
        var c = blob.read_shift(length == 1 ? 1 : 2);
        return [ c & 16383, c >> 14 & 1, c >> 15 & 1 ];
    }
    function parse_RgceArea(blob, length, opts) {
        var w = 2;
        if (opts) {
            if (opts.biff >= 2 && opts.biff <= 5) return parse_RgceArea_BIFF2(blob, length, opts); else if (opts.biff == 12) w = 4;
        }
        var r = blob.read_shift(w), R = blob.read_shift(w);
        var c = parse_ColRelU(blob, 2);
        var C = parse_ColRelU(blob, 2);
        return {
            "s": {
                "r": r,
                "c": c[0],
                "cRel": c[1],
                "rRel": c[2]
            },
            "e": {
                "r": R,
                "c": C[0],
                "cRel": C[1],
                "rRel": C[2]
            }
        };
    }
    function parse_RgceArea_BIFF2(blob) {
        var r = parse_ColRelU(blob, 2), R = parse_ColRelU(blob, 2);
        var c = blob.read_shift(1);
        var C = blob.read_shift(1);
        return {
            "s": {
                "r": r[0],
                "c": c,
                "cRel": r[1],
                "rRel": r[2]
            },
            "e": {
                "r": R[0],
                "c": C,
                "cRel": R[1],
                "rRel": R[2]
            }
        };
    }
    function parse_RgceAreaRel(blob, length, opts) {
        if (opts.biff < 8) return parse_RgceArea_BIFF2(blob, length, opts);
        var r = blob.read_shift(opts.biff == 12 ? 4 : 2), R = blob.read_shift(opts.biff == 12 ? 4 : 2);
        var c = parse_ColRelU(blob, 2);
        var C = parse_ColRelU(blob, 2);
        return {
            "s": {
                "r": r,
                "c": c[0],
                "cRel": c[1],
                "rRel": c[2]
            },
            "e": {
                "r": R,
                "c": C[0],
                "cRel": C[1],
                "rRel": C[2]
            }
        };
    }
    function parse_RgceLoc(blob, length, opts) {
        if (opts && opts.biff >= 2 && opts.biff <= 5) return parse_RgceLoc_BIFF2(blob, length, opts);
        var r = blob.read_shift(opts && opts.biff == 12 ? 4 : 2);
        var c = parse_ColRelU(blob, 2);
        return {
            "r": r,
            "c": c[0],
            "cRel": c[1],
            "rRel": c[2]
        };
    }
    function parse_RgceLoc_BIFF2(blob) {
        var r = parse_ColRelU(blob, 2);
        var c = blob.read_shift(1);
        return {
            "r": r[0],
            "c": c,
            "cRel": r[1],
            "rRel": r[2]
        };
    }
    function parse_RgceElfLoc(blob) {
        var r = blob.read_shift(2);
        var c = blob.read_shift(2);
        return {
            "r": r,
            "c": c & 255,
            "fQuoted": !!(c & 16384),
            "cRel": c >> 15,
            "rRel": c >> 15
        };
    }
    function parse_RgceLocRel(blob, length, opts) {
        var biff = opts && opts.biff ? opts.biff : 8;
        if (biff >= 2 && biff <= 5) return parse_RgceLocRel_BIFF2(blob, length, opts);
        var r = blob.read_shift(biff >= 12 ? 4 : 2);
        var cl = blob.read_shift(2);
        var cRel = (cl & 16384) >> 14, rRel = (cl & 32768) >> 15;
        cl &= 16383;
        if (rRel == 1) while (r > 524287) r -= 1048576;
        if (cRel == 1) while (cl > 8191) cl = cl - 16384;
        return {
            "r": r,
            "c": cl,
            "cRel": cRel,
            "rRel": rRel
        };
    }
    function parse_RgceLocRel_BIFF2(blob) {
        var rl = blob.read_shift(2);
        var c = blob.read_shift(1);
        var rRel = (rl & 32768) >> 15, cRel = (rl & 16384) >> 14;
        rl &= 16383;
        if (rRel == 1 && rl >= 8192) rl = rl - 16384;
        if (cRel == 1 && c >= 128) c = c - 256;
        return {
            "r": rl,
            "c": c,
            "cRel": cRel,
            "rRel": rRel
        };
    }
    function parse_PtgArea(blob, length, opts) {
        var type = (blob[blob.l++] & 96) >> 5;
        var area = parse_RgceArea(blob, opts.biff >= 2 && opts.biff <= 5 ? 6 : 8, opts);
        return [ type, area ];
    }
    function parse_PtgArea3d(blob, length, opts) {
        var type = (blob[blob.l++] & 96) >> 5;
        var ixti = blob.read_shift(2, "i");
        var w = 8;
        if (opts) switch (opts.biff) {
          case 5:
            blob.l += 12;
            w = 6;
            break;

          case 12:
            w = 12;
            break;
        }
        var area = parse_RgceArea(blob, w, opts);
        return [ type, ixti, area ];
    }
    function parse_PtgAreaErr(blob, length, opts) {
        var type = (blob[blob.l++] & 96) >> 5;
        blob.l += opts && opts.biff > 8 ? 12 : opts.biff < 8 ? 6 : 8;
        return [ type ];
    }
    function parse_PtgAreaErr3d(blob, length, opts) {
        var type = (blob[blob.l++] & 96) >> 5;
        var ixti = blob.read_shift(2);
        var w = 8;
        if (opts) switch (opts.biff) {
          case 5:
            blob.l += 12;
            w = 6;
            break;

          case 12:
            w = 12;
            break;
        }
        blob.l += w;
        return [ type, ixti ];
    }
    function parse_PtgAreaN(blob, length, opts) {
        var type = (blob[blob.l++] & 96) >> 5;
        var area = parse_RgceAreaRel(blob, length - 1, opts);
        return [ type, area ];
    }
    function parse_PtgArray(blob, length, opts) {
        var type = (blob[blob.l++] & 96) >> 5;
        blob.l += opts.biff == 2 ? 6 : opts.biff == 12 ? 14 : 7;
        return [ type ];
    }
    function parse_PtgAttrBaxcel(blob) {
        var bitSemi = blob[blob.l + 1] & 1;
        var bitBaxcel = 1;
        blob.l += 4;
        return [ bitSemi, bitBaxcel ];
    }
    function parse_PtgAttrChoose(blob, length, opts) {
        blob.l += 2;
        var offset = blob.read_shift(opts && opts.biff == 2 ? 1 : 2);
        var o = [];
        for (var i = 0; i <= offset; ++i) o.push(blob.read_shift(opts && opts.biff == 2 ? 1 : 2));
        return o;
    }
    function parse_PtgAttrGoto(blob, length, opts) {
        var bitGoto = blob[blob.l + 1] & 255 ? 1 : 0;
        blob.l += 2;
        return [ bitGoto, blob.read_shift(opts && opts.biff == 2 ? 1 : 2) ];
    }
    function parse_PtgAttrIf(blob, length, opts) {
        var bitIf = blob[blob.l + 1] & 255 ? 1 : 0;
        blob.l += 2;
        return [ bitIf, blob.read_shift(opts && opts.biff == 2 ? 1 : 2) ];
    }
    function parse_PtgAttrIfError(blob) {
        var bitIf = blob[blob.l + 1] & 255 ? 1 : 0;
        blob.l += 2;
        return [ bitIf, blob.read_shift(2) ];
    }
    function parse_PtgAttrSemi(blob, length, opts) {
        var bitSemi = blob[blob.l + 1] & 255 ? 1 : 0;
        blob.l += opts && opts.biff == 2 ? 3 : 4;
        return [ bitSemi ];
    }
    function parse_PtgAttrSpaceType(blob) {
        var type = blob.read_shift(1), cch = blob.read_shift(1);
        return [ type, cch ];
    }
    function parse_PtgAttrSpace(blob) {
        blob.read_shift(2);
        return parse_PtgAttrSpaceType(blob, 2);
    }
    function parse_PtgAttrSpaceSemi(blob) {
        blob.read_shift(2);
        return parse_PtgAttrSpaceType(blob, 2);
    }
    function parse_PtgRef(blob, length, opts) {
        var type = (blob[blob.l] & 96) >> 5;
        blob.l += 1;
        var loc = parse_RgceLoc(blob, 0, opts);
        return [ type, loc ];
    }
    function parse_PtgRefN(blob, length, opts) {
        var type = (blob[blob.l] & 96) >> 5;
        blob.l += 1;
        var loc = parse_RgceLocRel(blob, 0, opts);
        return [ type, loc ];
    }
    function parse_PtgRef3d(blob, length, opts) {
        var type = (blob[blob.l] & 96) >> 5;
        blob.l += 1;
        var ixti = blob.read_shift(2);
        if (opts && opts.biff == 5) blob.l += 12;
        var loc = parse_RgceLoc(blob, 0, opts);
        return [ type, ixti, loc ];
    }
    function parse_PtgFunc(blob, length, opts) {
        var type = (blob[blob.l] & 96) >> 5;
        blob.l += 1;
        var iftab = blob.read_shift(opts && opts.biff <= 3 ? 1 : 2);
        return [ FtabArgc[iftab], Ftab[iftab], type ];
    }
    function parse_PtgFuncVar(blob, length, opts) {
        var type = blob[blob.l++];
        var cparams = blob.read_shift(1), tab = opts && opts.biff <= 3 ? [ type == 88 ? -1 : 0, blob.read_shift(1) ] : parsetab(blob);
        return [ cparams, (tab[0] === 0 ? Ftab : Cetab)[tab[1]] ];
    }
    function parsetab(blob) {
        return [ blob[blob.l + 1] >> 7, blob.read_shift(2) & 32767 ];
    }
    function parse_PtgAttrSum(blob, length, opts) {
        blob.l += opts && opts.biff == 2 ? 3 : 4;
        return;
    }
    function parse_PtgExp(blob, length, opts) {
        blob.l++;
        if (opts && opts.biff == 12) return [ blob.read_shift(4, "i"), 0 ];
        var row = blob.read_shift(2);
        var col = blob.read_shift(opts && opts.biff == 2 ? 1 : 2);
        return [ row, col ];
    }
    function parse_PtgErr(blob) {
        blob.l++;
        return BErr[blob.read_shift(1)];
    }
    function parse_PtgInt(blob) {
        blob.l++;
        return blob.read_shift(2);
    }
    function parse_PtgBool(blob) {
        blob.l++;
        return blob.read_shift(1) !== 0;
    }
    function parse_PtgNum(blob) {
        blob.l++;
        return parse_Xnum(blob, 8);
    }
    function parse_PtgStr(blob, length, opts) {
        blob.l++;
        return parse_ShortXLUnicodeString(blob, length - 1, opts);
    }
    function parse_SerAr(blob, biff) {
        var val = [ blob.read_shift(1) ];
        if (biff == 12) switch (val[0]) {
          case 2:
            val[0] = 4;
            break;

          case 4:
            val[0] = 16;
            break;

          case 0:
            val[0] = 1;
            break;

          case 1:
            val[0] = 2;
            break;
        }
        switch (val[0]) {
          case 4:
            val[1] = parsebool(blob, 1) ? "TRUE" : "FALSE";
            if (biff != 12) blob.l += 7;
            break;

          case 37:
          case 16:
            val[1] = BErr[blob[blob.l]];
            blob.l += biff == 12 ? 4 : 8;
            break;

          case 0:
            blob.l += 8;
            break;

          case 1:
            val[1] = parse_Xnum(blob, 8);
            break;

          case 2:
            val[1] = parse_XLUnicodeString2(blob, 0, {
                "biff": biff > 0 && biff < 8 ? 2 : biff
            });
            break;

          default:
            throw new Error("Bad SerAr: " + val[0]);
        }
        return val;
    }
    function parse_PtgExtraMem(blob, cce, opts) {
        var count = blob.read_shift(opts.biff == 12 ? 4 : 2);
        var out = [];
        for (var i = 0; i != count; ++i) out.push((opts.biff == 12 ? parse_UncheckedRfX : parse_Ref8U)(blob, 8));
        return out;
    }
    function parse_PtgExtraArray(blob, length, opts) {
        var rows = 0, cols = 0;
        if (opts.biff == 12) {
            rows = blob.read_shift(4);
            cols = blob.read_shift(4);
        } else {
            cols = 1 + blob.read_shift(1);
            rows = 1 + blob.read_shift(2);
        }
        if (opts.biff >= 2 && opts.biff < 8) {
            --rows;
            if (--cols == 0) cols = 256;
        }
        for (var i = 0, o = []; i != rows && (o[i] = []); ++i) for (var j = 0; j != cols; ++j) o[i][j] = parse_SerAr(blob, opts.biff);
        return o;
    }
    function parse_PtgName(blob, length, opts) {
        var type = blob.read_shift(1) >>> 5 & 3;
        var w = !opts || opts.biff >= 8 ? 4 : 2;
        var nameindex = blob.read_shift(w);
        switch (opts.biff) {
          case 2:
            blob.l += 5;
            break;

          case 3:
          case 4:
            blob.l += 8;
            break;

          case 5:
            blob.l += 12;
            break;
        }
        return [ type, 0, nameindex ];
    }
    function parse_PtgNameX(blob, length, opts) {
        if (opts.biff == 5) return parse_PtgNameX_BIFF5(blob, length, opts);
        var type = blob.read_shift(1) >>> 5 & 3;
        var ixti = blob.read_shift(2);
        var nameindex = blob.read_shift(4);
        return [ type, ixti, nameindex ];
    }
    function parse_PtgNameX_BIFF5(blob) {
        var type = blob.read_shift(1) >>> 5 & 3;
        var ixti = blob.read_shift(2, "i");
        blob.l += 8;
        var nameindex = blob.read_shift(2);
        blob.l += 12;
        return [ type, ixti, nameindex ];
    }
    function parse_PtgMemArea(blob, length, opts) {
        var type = blob.read_shift(1) >>> 5 & 3;
        blob.l += opts && opts.biff == 2 ? 3 : 4;
        var cce = blob.read_shift(opts && opts.biff == 2 ? 1 : 2);
        return [ type, cce ];
    }
    function parse_PtgMemFunc(blob, length, opts) {
        var type = blob.read_shift(1) >>> 5 & 3;
        var cce = blob.read_shift(opts && opts.biff == 2 ? 1 : 2);
        return [ type, cce ];
    }
    function parse_PtgRefErr(blob, length, opts) {
        var type = blob.read_shift(1) >>> 5 & 3;
        blob.l += 4;
        if (opts.biff < 8) blob.l--;
        if (opts.biff == 12) blob.l += 2;
        return [ type ];
    }
    function parse_PtgRefErr3d(blob, length, opts) {
        var type = (blob[blob.l++] & 96) >> 5;
        var ixti = blob.read_shift(2);
        var w = 4;
        if (opts) switch (opts.biff) {
          case 5:
            w = 15;
            break;

          case 12:
            w = 6;
            break;
        }
        blob.l += w;
        return [ type, ixti ];
    }
    var parse_PtgMemErr = parsenoop;
    var parse_PtgMemNoMem = parsenoop;
    var parse_PtgTbl = parsenoop;
    function parse_PtgElfLoc(blob, length, opts) {
        blob.l += 2;
        return [ parse_RgceElfLoc(blob, 4, opts) ];
    }
    function parse_PtgElfNoop(blob) {
        blob.l += 6;
        return [];
    }
    var parse_PtgElfCol = parse_PtgElfLoc;
    var parse_PtgElfColS = parse_PtgElfNoop;
    var parse_PtgElfColSV = parse_PtgElfNoop;
    var parse_PtgElfColV = parse_PtgElfLoc;
    function parse_PtgElfLel(blob) {
        blob.l += 2;
        return [ parseuint16(blob), blob.read_shift(2) & 1 ];
    }
    var parse_PtgElfRadical = parse_PtgElfLoc;
    var parse_PtgElfRadicalLel = parse_PtgElfLel;
    var parse_PtgElfRadicalS = parse_PtgElfNoop;
    var parse_PtgElfRw = parse_PtgElfLoc;
    var parse_PtgElfRwV = parse_PtgElfLoc;
    var PtgListRT = [ "Data", "All", "Headers", "??", "?Data2", "??", "?DataHeaders", "??", "Totals", "??", "??", "??", "?DataTotals", "??", "??", "??", "?Current" ];
    function parse_PtgList(blob) {
        blob.l += 2;
        var ixti = blob.read_shift(2);
        var flags = blob.read_shift(2);
        var idx = blob.read_shift(4);
        var c = blob.read_shift(2);
        var C = blob.read_shift(2);
        var rt = PtgListRT[flags >> 2 & 31];
        return {
            "ixti": ixti,
            "coltype": flags & 3,
            "rt": rt,
            "idx": idx,
            "c": c,
            "C": C
        };
    }
    function parse_PtgSxName(blob) {
        blob.l += 2;
        return [ blob.read_shift(4) ];
    }
    function parse_PtgSheet(blob, length, opts) {
        blob.l += 5;
        blob.l += 2;
        blob.l += opts.biff == 2 ? 1 : 4;
        return [ "PTGSHEET" ];
    }
    function parse_PtgEndSheet(blob, length, opts) {
        blob.l += opts.biff == 2 ? 4 : 5;
        return [ "PTGENDSHEET" ];
    }
    function parse_PtgMemAreaN(blob) {
        var type = blob.read_shift(1) >>> 5 & 3;
        var cce = blob.read_shift(2);
        return [ type, cce ];
    }
    function parse_PtgMemNoMemN(blob) {
        var type = blob.read_shift(1) >>> 5 & 3;
        var cce = blob.read_shift(2);
        return [ type, cce ];
    }
    function parse_PtgAttrNoop(blob) {
        blob.l += 4;
        return [ 0, 0 ];
    }
    var PtgTypes = {
        "1": {
            "n": "PtgExp",
            "f": parse_PtgExp
        },
        "2": {
            "n": "PtgTbl",
            "f": parse_PtgTbl
        },
        "3": {
            "n": "PtgAdd",
            "f": parseread1
        },
        "4": {
            "n": "PtgSub",
            "f": parseread1
        },
        "5": {
            "n": "PtgMul",
            "f": parseread1
        },
        "6": {
            "n": "PtgDiv",
            "f": parseread1
        },
        "7": {
            "n": "PtgPower",
            "f": parseread1
        },
        "8": {
            "n": "PtgConcat",
            "f": parseread1
        },
        "9": {
            "n": "PtgLt",
            "f": parseread1
        },
        "10": {
            "n": "PtgLe",
            "f": parseread1
        },
        "11": {
            "n": "PtgEq",
            "f": parseread1
        },
        "12": {
            "n": "PtgGe",
            "f": parseread1
        },
        "13": {
            "n": "PtgGt",
            "f": parseread1
        },
        "14": {
            "n": "PtgNe",
            "f": parseread1
        },
        "15": {
            "n": "PtgIsect",
            "f": parseread1
        },
        "16": {
            "n": "PtgUnion",
            "f": parseread1
        },
        "17": {
            "n": "PtgRange",
            "f": parseread1
        },
        "18": {
            "n": "PtgUplus",
            "f": parseread1
        },
        "19": {
            "n": "PtgUminus",
            "f": parseread1
        },
        "20": {
            "n": "PtgPercent",
            "f": parseread1
        },
        "21": {
            "n": "PtgParen",
            "f": parseread1
        },
        "22": {
            "n": "PtgMissArg",
            "f": parseread1
        },
        "23": {
            "n": "PtgStr",
            "f": parse_PtgStr
        },
        "26": {
            "n": "PtgSheet",
            "f": parse_PtgSheet
        },
        "27": {
            "n": "PtgEndSheet",
            "f": parse_PtgEndSheet
        },
        "28": {
            "n": "PtgErr",
            "f": parse_PtgErr
        },
        "29": {
            "n": "PtgBool",
            "f": parse_PtgBool
        },
        "30": {
            "n": "PtgInt",
            "f": parse_PtgInt
        },
        "31": {
            "n": "PtgNum",
            "f": parse_PtgNum
        },
        "32": {
            "n": "PtgArray",
            "f": parse_PtgArray
        },
        "33": {
            "n": "PtgFunc",
            "f": parse_PtgFunc
        },
        "34": {
            "n": "PtgFuncVar",
            "f": parse_PtgFuncVar
        },
        "35": {
            "n": "PtgName",
            "f": parse_PtgName
        },
        "36": {
            "n": "PtgRef",
            "f": parse_PtgRef
        },
        "37": {
            "n": "PtgArea",
            "f": parse_PtgArea
        },
        "38": {
            "n": "PtgMemArea",
            "f": parse_PtgMemArea
        },
        "39": {
            "n": "PtgMemErr",
            "f": parse_PtgMemErr
        },
        "40": {
            "n": "PtgMemNoMem",
            "f": parse_PtgMemNoMem
        },
        "41": {
            "n": "PtgMemFunc",
            "f": parse_PtgMemFunc
        },
        "42": {
            "n": "PtgRefErr",
            "f": parse_PtgRefErr
        },
        "43": {
            "n": "PtgAreaErr",
            "f": parse_PtgAreaErr
        },
        "44": {
            "n": "PtgRefN",
            "f": parse_PtgRefN
        },
        "45": {
            "n": "PtgAreaN",
            "f": parse_PtgAreaN
        },
        "46": {
            "n": "PtgMemAreaN",
            "f": parse_PtgMemAreaN
        },
        "47": {
            "n": "PtgMemNoMemN",
            "f": parse_PtgMemNoMemN
        },
        "57": {
            "n": "PtgNameX",
            "f": parse_PtgNameX
        },
        "58": {
            "n": "PtgRef3d",
            "f": parse_PtgRef3d
        },
        "59": {
            "n": "PtgArea3d",
            "f": parse_PtgArea3d
        },
        "60": {
            "n": "PtgRefErr3d",
            "f": parse_PtgRefErr3d
        },
        "61": {
            "n": "PtgAreaErr3d",
            "f": parse_PtgAreaErr3d
        },
        "255": {}
    };
    var PtgDupes = {
        "64": 32,
        "96": 32,
        "65": 33,
        "97": 33,
        "66": 34,
        "98": 34,
        "67": 35,
        "99": 35,
        "68": 36,
        "100": 36,
        "69": 37,
        "101": 37,
        "70": 38,
        "102": 38,
        "71": 39,
        "103": 39,
        "72": 40,
        "104": 40,
        "73": 41,
        "105": 41,
        "74": 42,
        "106": 42,
        "75": 43,
        "107": 43,
        "76": 44,
        "108": 44,
        "77": 45,
        "109": 45,
        "78": 46,
        "110": 46,
        "79": 47,
        "111": 47,
        "88": 34,
        "120": 34,
        "89": 57,
        "121": 57,
        "90": 58,
        "122": 58,
        "91": 59,
        "123": 59,
        "92": 60,
        "124": 60,
        "93": 61,
        "125": 61
    };
    (function() {
        for (var y in PtgDupes) PtgTypes[y] = PtgTypes[PtgDupes[y]];
    })();
    var Ptg18 = {
        "1": {
            "n": "PtgElfLel",
            "f": parse_PtgElfLel
        },
        "2": {
            "n": "PtgElfRw",
            "f": parse_PtgElfRw
        },
        "3": {
            "n": "PtgElfCol",
            "f": parse_PtgElfCol
        },
        "6": {
            "n": "PtgElfRwV",
            "f": parse_PtgElfRwV
        },
        "7": {
            "n": "PtgElfColV",
            "f": parse_PtgElfColV
        },
        "10": {
            "n": "PtgElfRadical",
            "f": parse_PtgElfRadical
        },
        "11": {
            "n": "PtgElfRadicalS",
            "f": parse_PtgElfRadicalS
        },
        "13": {
            "n": "PtgElfColS",
            "f": parse_PtgElfColS
        },
        "15": {
            "n": "PtgElfColSV",
            "f": parse_PtgElfColSV
        },
        "16": {
            "n": "PtgElfRadicalLel",
            "f": parse_PtgElfRadicalLel
        },
        "25": {
            "n": "PtgList",
            "f": parse_PtgList
        },
        "29": {
            "n": "PtgSxName",
            "f": parse_PtgSxName
        },
        "255": {}
    };
    var Ptg19 = {
        "0": {
            "n": "PtgAttrNoop",
            "f": parse_PtgAttrNoop
        },
        "1": {
            "n": "PtgAttrSemi",
            "f": parse_PtgAttrSemi
        },
        "2": {
            "n": "PtgAttrIf",
            "f": parse_PtgAttrIf
        },
        "4": {
            "n": "PtgAttrChoose",
            "f": parse_PtgAttrChoose
        },
        "8": {
            "n": "PtgAttrGoto",
            "f": parse_PtgAttrGoto
        },
        "16": {
            "n": "PtgAttrSum",
            "f": parse_PtgAttrSum
        },
        "32": {
            "n": "PtgAttrBaxcel",
            "f": parse_PtgAttrBaxcel
        },
        "64": {
            "n": "PtgAttrSpace",
            "f": parse_PtgAttrSpace
        },
        "65": {
            "n": "PtgAttrSpaceSemi",
            "f": parse_PtgAttrSpaceSemi
        },
        "128": {
            "n": "PtgAttrIfError",
            "f": parse_PtgAttrIfError
        },
        "255": {}
    };
    Ptg19[33] = Ptg19[32];
    function parse_RgbExtra(blob, length, rgce, opts) {
        if (opts.biff < 8) return parsenoop(blob, length);
        var target = blob.l + length;
        var o = [];
        for (var i = 0; i !== rgce.length; ++i) {
            switch (rgce[i][0]) {
              case "PtgArray":
                rgce[i][1] = parse_PtgExtraArray(blob, 0, opts);
                o.push(rgce[i][1]);
                break;

              case "PtgMemArea":
                rgce[i][2] = parse_PtgExtraMem(blob, rgce[i][1], opts);
                o.push(rgce[i][2]);
                break;

              case "PtgExp":
                if (opts && opts.biff == 12) {
                    rgce[i][1][1] = blob.read_shift(4);
                    o.push(rgce[i][1]);
                }
                break;

              case "PtgList":
              case "PtgElfRadicalS":
              case "PtgElfColS":
              case "PtgElfColSV":
                throw "Unsupported " + rgce[i][0];

              default:
                break;
            }
        }
        length = target - blob.l;
        if (length !== 0) o.push(parsenoop(blob, length));
        return o;
    }
    function parse_Rgce(blob, length, opts) {
        var target = blob.l + length;
        var R, id, ptgs = [];
        while (target != blob.l) {
            length = target - blob.l;
            id = blob[blob.l];
            R = PtgTypes[id];
            if (id === 24 || id === 25) R = (id === 24 ? Ptg18 : Ptg19)[blob[blob.l + 1]];
            if (!R || !R.f) {
                parsenoop(blob, length);
            } else {
                ptgs.push([ R.n, R.f(blob, length, opts) ]);
            }
        }
        return ptgs;
    }
    function stringify_array(f) {
        var o = [];
        for (var i = 0; i < f.length; ++i) {
            var x = f[i], r = [];
            for (var j = 0; j < x.length; ++j) {
                var y = x[j];
                if (y) switch (y[0]) {
                  case 2:
                    r.push('"' + y[1].replace(/"/g, '""') + '"');
                    break;

                  default:
                    r.push(y[1]);
                } else r.push("");
            }
            o.push(r.join(","));
        }
        return o.join(";");
    }
    var PtgBinOp = {
        "PtgAdd": "+",
        "PtgConcat": "&",
        "PtgDiv": "/",
        "PtgEq": "=",
        "PtgGe": ">=",
        "PtgGt": ">",
        "PtgLe": "<=",
        "PtgLt": "<",
        "PtgMul": "*",
        "PtgNe": "<>",
        "PtgPower": "^",
        "PtgSub": "-"
    };
    function formula_quote_sheet_name(sname, opts) {
        if (!sname && !(opts && opts.biff <= 5 && opts.biff >= 2)) throw new Error("empty sheet name");
        if (sname.indexOf(" ") > -1) return "'" + sname + "'";
        return sname;
    }
    function get_ixti_raw(supbooks, ixti, opts) {
        if (!supbooks) return "SH33TJSERR0";
        if (!supbooks.XTI) return "SH33TJSERR6";
        var XTI = supbooks.XTI[ixti];
        if (opts.biff > 8 && !supbooks.XTI[ixti]) return supbooks.SheetNames[ixti];
        if (opts.biff < 8) {
            if (ixti > 1e4) ixti -= 65536;
            if (ixti < 0) ixti = -ixti;
            return ixti == 0 ? "" : supbooks.XTI[ixti - 1];
        }
        if (!XTI) return "SH33TJSERR1";
        var o = "";
        if (opts.biff > 8) switch (supbooks[XTI[0]][0]) {
          case 357:
            o = XTI[1] == -1 ? "#REF" : supbooks.SheetNames[XTI[1]];
            return XTI[1] == XTI[2] ? o : o + ":" + supbooks.SheetNames[XTI[2]];

          case 358:
            if (opts.SID != null) return supbooks.SheetNames[opts.SID];
            return "SH33TJSSAME" + supbooks[XTI[0]][0];

          case 355:
          default:
            return "SH33TJSSRC" + supbooks[XTI[0]][0];
        }
        switch (supbooks[XTI[0]][0][0]) {
          case 1025:
            o = XTI[1] == -1 ? "#REF" : supbooks.SheetNames[XTI[1]] || "SH33TJSERR3";
            return XTI[1] == XTI[2] ? o : o + ":" + supbooks.SheetNames[XTI[2]];

          case 14849:
            return "SH33TJSERR8";

          default:
            if (!supbooks[XTI[0]][0][3]) return "SH33TJSERR2";
            o = XTI[1] == -1 ? "#REF" : supbooks[XTI[0]][0][3][XTI[1]] || "SH33TJSERR4";
            return XTI[1] == XTI[2] ? o : o + ":" + supbooks[XTI[0]][0][3][XTI[2]];
        }
    }
    function get_ixti(supbooks, ixti, opts) {
        return formula_quote_sheet_name(get_ixti_raw(supbooks, ixti, opts), opts);
    }
    function stringify_formula(formula, range, cell, supbooks, opts) {
        var biff = opts && opts.biff || 8;
        var _range = {
            "s": {
                "c": 0,
                "r": 0
            },
            "e": {
                "c": 0,
                "r": 0
            }
        };
        var stack = [], e1, e2, c, ixti = 0, nameidx = 0, r, sname = "";
        if (!formula[0] || !formula[0][0]) return "";
        var last_sp = -1, sp = "";
        for (var ff = 0, fflen = formula[0].length; ff < fflen; ++ff) {
            var f = formula[0][ff];
            switch (f[0]) {
              case "PtgUminus":
                stack.push("-" + stack.pop());
                break;

              case "PtgUplus":
                stack.push("+" + stack.pop());
                break;

              case "PtgPercent":
                stack.push(stack.pop() + "%");
                break;

              case "PtgAdd":
              case "PtgConcat":
              case "PtgDiv":
              case "PtgEq":
              case "PtgGe":
              case "PtgGt":
              case "PtgLe":
              case "PtgLt":
              case "PtgMul":
              case "PtgNe":
              case "PtgPower":
              case "PtgSub":
                e1 = stack.pop();
                e2 = stack.pop();
                if (last_sp >= 0) {
                    switch (formula[0][last_sp][1][0]) {
                      case 0:
                        sp = fill(" ", formula[0][last_sp][1][1]);
                        break;

                      case 1:
                        sp = fill("\r", formula[0][last_sp][1][1]);
                        break;

                      default:
                        sp = "";
                        if (opts.WTF) throw new Error("Unexpected PtgAttrSpaceType " + formula[0][last_sp][1][0]);
                    }
                    e2 = e2 + sp;
                    last_sp = -1;
                }
                stack.push(e2 + PtgBinOp[f[0]] + e1);
                break;

              case "PtgIsect":
                e1 = stack.pop();
                e2 = stack.pop();
                stack.push(e2 + " " + e1);
                break;

              case "PtgUnion":
                e1 = stack.pop();
                e2 = stack.pop();
                stack.push(e2 + "," + e1);
                break;

              case "PtgRange":
                e1 = stack.pop();
                e2 = stack.pop();
                stack.push(e2 + ":" + e1);
                break;

              case "PtgAttrChoose":
                break;

              case "PtgAttrGoto":
                break;

              case "PtgAttrIf":
                break;

              case "PtgAttrIfError":
                break;

              case "PtgRef":
                c = shift_cell_xls(f[1][1], _range, opts);
                stack.push(encode_cell_xls(c, biff));
                break;

              case "PtgRefN":
                c = cell ? shift_cell_xls(f[1][1], cell, opts) : f[1][1];
                stack.push(encode_cell_xls(c, biff));
                break;

              case "PtgRef3d":
                ixti = f[1][1];
                c = shift_cell_xls(f[1][2], _range, opts);
                sname = get_ixti(supbooks, ixti, opts);
                var w = sname;
                stack.push(sname + "!" + encode_cell_xls(c, biff));
                break;

              case "PtgFunc":
              case "PtgFuncVar":
                var argc = f[1][0], func = f[1][1];
                if (!argc) argc = 0;
                argc &= 127;
                var args = argc == 0 ? [] : stack.slice(-argc);
                stack.length -= argc;
                if (func === "User") func = args.shift();
                stack.push(func + "(" + args.join(",") + ")");
                break;

              case "PtgBool":
                stack.push(f[1] ? "TRUE" : "FALSE");
                break;

              case "PtgInt":
                stack.push(f[1]);
                break;

              case "PtgNum":
                stack.push(String(f[1]));
                break;

              case "PtgStr":
                stack.push('"' + f[1] + '"');
                break;

              case "PtgErr":
                stack.push(f[1]);
                break;

              case "PtgAreaN":
                r = shift_range_xls(f[1][1], cell ? {
                    "s": cell
                } : _range, opts);
                stack.push(encode_range_xls(r, opts));
                break;

              case "PtgArea":
                r = shift_range_xls(f[1][1], _range, opts);
                stack.push(encode_range_xls(r, opts));
                break;

              case "PtgArea3d":
                ixti = f[1][1];
                r = f[1][2];
                sname = get_ixti(supbooks, ixti, opts);
                stack.push(sname + "!" + encode_range_xls(r, opts));
                break;

              case "PtgAttrSum":
                stack.push("SUM(" + stack.pop() + ")");
                break;

              case "PtgAttrBaxcel":
              case "PtgAttrSemi":
                break;

              case "PtgName":
                nameidx = f[1][2];
                var lbl = (supbooks.names || [])[nameidx - 1] || (supbooks[0] || [])[nameidx];
                var name = lbl ? lbl.Name : "SH33TJSNAME" + String(nameidx);
                if (name in XLSXFutureFunctions) name = XLSXFutureFunctions[name];
                stack.push(name);
                break;

              case "PtgNameX":
                var bookidx = f[1][1];
                nameidx = f[1][2];
                var externbook;
                if (opts.biff <= 5) {
                    if (bookidx < 0) bookidx = -bookidx;
                    if (supbooks[bookidx]) externbook = supbooks[bookidx][nameidx];
                } else {
                    var o = "";
                    if (((supbooks[bookidx] || [])[0] || [])[0] == 14849) {} else if (((supbooks[bookidx] || [])[0] || [])[0] == 1025) {
                        if (supbooks[bookidx][nameidx] && supbooks[bookidx][nameidx].itab > 0) {
                            o = supbooks.SheetNames[supbooks[bookidx][nameidx].itab - 1] + "!";
                        }
                    } else o = supbooks.SheetNames[nameidx - 1] + "!";
                    if (supbooks[bookidx] && supbooks[bookidx][nameidx]) o += supbooks[bookidx][nameidx].Name; else if (supbooks[0] && supbooks[0][nameidx]) o += supbooks[0][nameidx].Name; else o += "SH33TJSERRX";
                    stack.push(o);
                    break;
                }
                if (!externbook) externbook = {
                    "Name": "SH33TJSERRY"
                };
                stack.push(externbook.Name);
                break;

              case "PtgParen":
                var lp = "(", rp = ")";
                if (last_sp >= 0) {
                    sp = "";
                    switch (formula[0][last_sp][1][0]) {
                      case 2:
                        lp = fill(" ", formula[0][last_sp][1][1]) + lp;
                        break;

                      case 3:
                        lp = fill("\r", formula[0][last_sp][1][1]) + lp;
                        break;

                      case 4:
                        rp = fill(" ", formula[0][last_sp][1][1]) + rp;
                        break;

                      case 5:
                        rp = fill("\r", formula[0][last_sp][1][1]) + rp;
                        break;

                      default:
                        if (opts.WTF) throw new Error("Unexpected PtgAttrSpaceType " + formula[0][last_sp][1][0]);
                    }
                    last_sp = -1;
                }
                stack.push(lp + stack.pop() + rp);
                break;

              case "PtgRefErr":
                stack.push("#REF!");
                break;

              case "PtgRefErr3d":
                stack.push("#REF!");
                break;

              case "PtgExp":
                c = {
                    "c": f[1][1],
                    "r": f[1][0]
                };
                var q = {
                    "c": cell.c,
                    "r": cell.r
                };
                if (supbooks.sharedf[encode_cell(c)]) {
                    var parsedf = supbooks.sharedf[encode_cell(c)];
                    stack.push(stringify_formula(parsedf, _range, q, supbooks, opts));
                } else {
                    var fnd = false;
                    for (e1 = 0; e1 != supbooks.arrayf.length; ++e1) {
                        e2 = supbooks.arrayf[e1];
                        if (c.c < e2[0].s.c || c.c > e2[0].e.c) continue;
                        if (c.r < e2[0].s.r || c.r > e2[0].e.r) continue;
                        stack.push(stringify_formula(e2[1], _range, q, supbooks, opts));
                        fnd = true;
                        break;
                    }
                    if (!fnd) stack.push(f[1]);
                }
                break;

              case "PtgArray":
                stack.push("{" + stringify_array(f[1]) + "}");
                break;

              case "PtgMemArea":
                break;

              case "PtgAttrSpace":
              case "PtgAttrSpaceSemi":
                last_sp = ff;
                break;

              case "PtgTbl":
                break;

              case "PtgMemErr":
                break;

              case "PtgMissArg":
                stack.push("");
                break;

              case "PtgAreaErr":
                stack.push("#REF!");
                break;

              case "PtgAreaErr3d":
                stack.push("#REF!");
                break;

              case "PtgList":
                stack.push("Table" + f[1].idx + "[#" + f[1].rt + "]");
                break;

              case "PtgMemAreaN":
              case "PtgMemNoMemN":
              case "PtgAttrNoop":
              case "PtgSheet":
              case "PtgEndSheet":
                break;

              case "PtgMemFunc":
                break;

              case "PtgMemNoMem":
                break;

              case "PtgElfCol":
              case "PtgElfColS":
              case "PtgElfColSV":
              case "PtgElfColV":
              case "PtgElfLel":
              case "PtgElfRadical":
              case "PtgElfRadicalLel":
              case "PtgElfRadicalS":
              case "PtgElfRw":
              case "PtgElfRwV":
                throw new Error("Unsupported ELFs");

              case "PtgSxName":
                throw new Error("Unrecognized Formula Token: " + String(f));

              default:
                throw new Error("Unrecognized Formula Token: " + String(f));
            }
            var PtgNonDisp = [ "PtgAttrSpace", "PtgAttrSpaceSemi", "PtgAttrGoto" ];
            if (opts.biff != 3) if (last_sp >= 0 && PtgNonDisp.indexOf(formula[0][ff][0]) == -1) {
                f = formula[0][last_sp];
                var _left = true;
                switch (f[1][0]) {
                  case 4:
                    _left = false;

                  case 0:
                    sp = fill(" ", f[1][1]);
                    break;

                  case 5:
                    _left = false;

                  case 1:
                    sp = fill("\r", f[1][1]);
                    break;

                  default:
                    sp = "";
                    if (opts.WTF) throw new Error("Unexpected PtgAttrSpaceType " + f[1][0]);
                }
                stack.push((_left ? sp : "") + stack.pop() + (_left ? "" : sp));
                last_sp = -1;
            }
        }
        if (stack.length > 1 && opts.WTF) throw new Error("bad formula stack");
        return stack[0];
    }
    function parse_ArrayParsedFormula(blob, length, opts) {
        var target = blob.l + length, len = opts.biff == 2 ? 1 : 2;
        var rgcb, cce = blob.read_shift(len);
        if (cce == 65535) return [ [], parsenoop(blob, length - 2) ];
        var rgce = parse_Rgce(blob, cce, opts);
        if (length !== cce + len) rgcb = parse_RgbExtra(blob, length - cce - len, rgce, opts);
        blob.l = target;
        return [ rgce, rgcb ];
    }
    function parse_XLSCellParsedFormula(blob, length, opts) {
        var target = blob.l + length, len = opts.biff == 2 ? 1 : 2;
        var rgcb, cce = blob.read_shift(len);
        if (cce == 65535) return [ [], parsenoop(blob, length - 2) ];
        var rgce = parse_Rgce(blob, cce, opts);
        if (length !== cce + len) rgcb = parse_RgbExtra(blob, length - cce - len, rgce, opts);
        blob.l = target;
        return [ rgce, rgcb ];
    }
    function parse_NameParsedFormula(blob, length, opts, cce) {
        var target = blob.l + length;
        var rgce = parse_Rgce(blob, cce, opts);
        var rgcb;
        if (target !== blob.l) rgcb = parse_RgbExtra(blob, target - blob.l, rgce, opts);
        return [ rgce, rgcb ];
    }
    function parse_SharedParsedFormula(blob, length, opts) {
        var target = blob.l + length;
        var rgcb, cce = blob.read_shift(2);
        var rgce = parse_Rgce(blob, cce, opts);
        if (cce == 65535) return [ [], parsenoop(blob, length - 2) ];
        if (length !== cce + 2) rgcb = parse_RgbExtra(blob, target - cce - 2, rgce, opts);
        return [ rgce, rgcb ];
    }
    function parse_FormulaValue(blob) {
        var b;
        if (__readUInt16LE(blob, blob.l + 6) !== 65535) return [ parse_Xnum(blob), "n" ];
        switch (blob[blob.l]) {
          case 0:
            blob.l += 8;
            return [ "String", "s" ];

          case 1:
            b = blob[blob.l + 2] === 1;
            blob.l += 8;
            return [ b, "b" ];

          case 2:
            b = blob[blob.l + 2];
            blob.l += 8;
            return [ b, "e" ];

          case 3:
            blob.l += 8;
            return [ "", "s" ];
        }
        return [];
    }
    function parse_Formula(blob, length, opts) {
        var end = blob.l + length;
        var cell = parse_XLSCell(blob, 6);
        if (opts.biff == 2) ++blob.l;
        var val = parse_FormulaValue(blob, 8);
        var flags = blob.read_shift(1);
        if (opts.biff != 2) {
            blob.read_shift(1);
            if (opts.biff >= 5) {
                blob.read_shift(4);
            }
        }
        var cbf = parse_XLSCellParsedFormula(blob, end - blob.l, opts);
        return {
            "cell": cell,
            "val": val[0],
            "formula": cbf,
            "shared": flags >> 3 & 1,
            "tt": val[1]
        };
    }
    function parse_XLSBParsedFormula(data, length, opts) {
        var cce = data.read_shift(4);
        var rgce = parse_Rgce(data, cce, opts);
        var cb = data.read_shift(4);
        var rgcb = cb > 0 ? parse_RgbExtra(data, cb, rgce, opts) : null;
        return [ rgce, rgcb ];
    }
    var parse_XLSBArrayParsedFormula = parse_XLSBParsedFormula;
    var parse_XLSBCellParsedFormula = parse_XLSBParsedFormula;
    var parse_XLSBNameParsedFormula = parse_XLSBParsedFormula;
    var parse_XLSBSharedParsedFormula = parse_XLSBParsedFormula;
    var Cetab = {
        "0": "BEEP",
        "1": "OPEN",
        "2": "OPEN.LINKS",
        "3": "CLOSE.ALL",
        "4": "SAVE",
        "5": "SAVE.AS",
        "6": "FILE.DELETE",
        "7": "PAGE.SETUP",
        "8": "PRINT",
        "9": "PRINTER.SETUP",
        "10": "QUIT",
        "11": "NEW.WINDOW",
        "12": "ARRANGE.ALL",
        "13": "WINDOW.SIZE",
        "14": "WINDOW.MOVE",
        "15": "FULL",
        "16": "CLOSE",
        "17": "RUN",
        "22": "SET.PRINT.AREA",
        "23": "SET.PRINT.TITLES",
        "24": "SET.PAGE.BREAK",
        "25": "REMOVE.PAGE.BREAK",
        "26": "FONT",
        "27": "DISPLAY",
        "28": "PROTECT.DOCUMENT",
        "29": "PRECISION",
        "30": "A1.R1C1",
        "31": "CALCULATE.NOW",
        "32": "CALCULATION",
        "34": "DATA.FIND",
        "35": "EXTRACT",
        "36": "DATA.DELETE",
        "37": "SET.DATABASE",
        "38": "SET.CRITERIA",
        "39": "SORT",
        "40": "DATA.SERIES",
        "41": "TABLE",
        "42": "FORMAT.NUMBER",
        "43": "ALIGNMENT",
        "44": "STYLE",
        "45": "BORDER",
        "46": "CELL.PROTECTION",
        "47": "COLUMN.WIDTH",
        "48": "UNDO",
        "49": "CUT",
        "50": "COPY",
        "51": "PASTE",
        "52": "CLEAR",
        "53": "PASTE.SPECIAL",
        "54": "EDIT.DELETE",
        "55": "INSERT",
        "56": "FILL.RIGHT",
        "57": "FILL.DOWN",
        "61": "DEFINE.NAME",
        "62": "CREATE.NAMES",
        "63": "FORMULA.GOTO",
        "64": "FORMULA.FIND",
        "65": "SELECT.LAST.CELL",
        "66": "SHOW.ACTIVE.CELL",
        "67": "GALLERY.AREA",
        "68": "GALLERY.BAR",
        "69": "GALLERY.COLUMN",
        "70": "GALLERY.LINE",
        "71": "GALLERY.PIE",
        "72": "GALLERY.SCATTER",
        "73": "COMBINATION",
        "74": "PREFERRED",
        "75": "ADD.OVERLAY",
        "76": "GRIDLINES",
        "77": "SET.PREFERRED",
        "78": "AXES",
        "79": "LEGEND",
        "80": "ATTACH.TEXT",
        "81": "ADD.ARROW",
        "82": "SELECT.CHART",
        "83": "SELECT.PLOT.AREA",
        "84": "PATTERNS",
        "85": "MAIN.CHART",
        "86": "OVERLAY",
        "87": "SCALE",
        "88": "FORMAT.LEGEND",
        "89": "FORMAT.TEXT",
        "90": "EDIT.REPEAT",
        "91": "PARSE",
        "92": "JUSTIFY",
        "93": "HIDE",
        "94": "UNHIDE",
        "95": "WORKSPACE",
        "96": "FORMULA",
        "97": "FORMULA.FILL",
        "98": "FORMULA.ARRAY",
        "99": "DATA.FIND.NEXT",
        "100": "DATA.FIND.PREV",
        "101": "FORMULA.FIND.NEXT",
        "102": "FORMULA.FIND.PREV",
        "103": "ACTIVATE",
        "104": "ACTIVATE.NEXT",
        "105": "ACTIVATE.PREV",
        "106": "UNLOCKED.NEXT",
        "107": "UNLOCKED.PREV",
        "108": "COPY.PICTURE",
        "109": "SELECT",
        "110": "DELETE.NAME",
        "111": "DELETE.FORMAT",
        "112": "VLINE",
        "113": "HLINE",
        "114": "VPAGE",
        "115": "HPAGE",
        "116": "VSCROLL",
        "117": "HSCROLL",
        "118": "ALERT",
        "119": "NEW",
        "120": "CANCEL.COPY",
        "121": "SHOW.CLIPBOARD",
        "122": "MESSAGE",
        "124": "PASTE.LINK",
        "125": "APP.ACTIVATE",
        "126": "DELETE.ARROW",
        "127": "ROW.HEIGHT",
        "128": "FORMAT.MOVE",
        "129": "FORMAT.SIZE",
        "130": "FORMULA.REPLACE",
        "131": "SEND.KEYS",
        "132": "SELECT.SPECIAL",
        "133": "APPLY.NAMES",
        "134": "REPLACE.FONT",
        "135": "FREEZE.PANES",
        "136": "SHOW.INFO",
        "137": "SPLIT",
        "138": "ON.WINDOW",
        "139": "ON.DATA",
        "140": "DISABLE.INPUT",
        "142": "OUTLINE",
        "143": "LIST.NAMES",
        "144": "FILE.CLOSE",
        "145": "SAVE.WORKBOOK",
        "146": "DATA.FORM",
        "147": "COPY.CHART",
        "148": "ON.TIME",
        "149": "WAIT",
        "150": "FORMAT.FONT",
        "151": "FILL.UP",
        "152": "FILL.LEFT",
        "153": "DELETE.OVERLAY",
        "155": "SHORT.MENUS",
        "159": "SET.UPDATE.STATUS",
        "161": "COLOR.PALETTE",
        "162": "DELETE.STYLE",
        "163": "WINDOW.RESTORE",
        "164": "WINDOW.MAXIMIZE",
        "166": "CHANGE.LINK",
        "167": "CALCULATE.DOCUMENT",
        "168": "ON.KEY",
        "169": "APP.RESTORE",
        "170": "APP.MOVE",
        "171": "APP.SIZE",
        "172": "APP.MINIMIZE",
        "173": "APP.MAXIMIZE",
        "174": "BRING.TO.FRONT",
        "175": "SEND.TO.BACK",
        "185": "MAIN.CHART.TYPE",
        "186": "OVERLAY.CHART.TYPE",
        "187": "SELECT.END",
        "188": "OPEN.MAIL",
        "189": "SEND.MAIL",
        "190": "STANDARD.FONT",
        "191": "CONSOLIDATE",
        "192": "SORT.SPECIAL",
        "193": "GALLERY.3D.AREA",
        "194": "GALLERY.3D.COLUMN",
        "195": "GALLERY.3D.LINE",
        "196": "GALLERY.3D.PIE",
        "197": "VIEW.3D",
        "198": "GOAL.SEEK",
        "199": "WORKGROUP",
        "200": "FILL.GROUP",
        "201": "UPDATE.LINK",
        "202": "PROMOTE",
        "203": "DEMOTE",
        "204": "SHOW.DETAIL",
        "206": "UNGROUP",
        "207": "OBJECT.PROPERTIES",
        "208": "SAVE.NEW.OBJECT",
        "209": "SHARE",
        "210": "SHARE.NAME",
        "211": "DUPLICATE",
        "212": "APPLY.STYLE",
        "213": "ASSIGN.TO.OBJECT",
        "214": "OBJECT.PROTECTION",
        "215": "HIDE.OBJECT",
        "216": "SET.EXTRACT",
        "217": "CREATE.PUBLISHER",
        "218": "SUBSCRIBE.TO",
        "219": "ATTRIBUTES",
        "220": "SHOW.TOOLBAR",
        "222": "PRINT.PREVIEW",
        "223": "EDIT.COLOR",
        "224": "SHOW.LEVELS",
        "225": "FORMAT.MAIN",
        "226": "FORMAT.OVERLAY",
        "227": "ON.RECALC",
        "228": "EDIT.SERIES",
        "229": "DEFINE.STYLE",
        "240": "LINE.PRINT",
        "243": "ENTER.DATA",
        "249": "GALLERY.RADAR",
        "250": "MERGE.STYLES",
        "251": "EDITION.OPTIONS",
        "252": "PASTE.PICTURE",
        "253": "PASTE.PICTURE.LINK",
        "254": "SPELLING",
        "256": "ZOOM",
        "259": "INSERT.OBJECT",
        "260": "WINDOW.MINIMIZE",
        "265": "SOUND.NOTE",
        "266": "SOUND.PLAY",
        "267": "FORMAT.SHAPE",
        "268": "EXTEND.POLYGON",
        "269": "FORMAT.AUTO",
        "272": "GALLERY.3D.BAR",
        "273": "GALLERY.3D.SURFACE",
        "274": "FILL.AUTO",
        "276": "CUSTOMIZE.TOOLBAR",
        "277": "ADD.TOOL",
        "278": "EDIT.OBJECT",
        "279": "ON.DOUBLECLICK",
        "280": "ON.ENTRY",
        "281": "WORKBOOK.ADD",
        "282": "WORKBOOK.MOVE",
        "283": "WORKBOOK.COPY",
        "284": "WORKBOOK.OPTIONS",
        "285": "SAVE.WORKSPACE",
        "288": "CHART.WIZARD",
        "289": "DELETE.TOOL",
        "290": "MOVE.TOOL",
        "291": "WORKBOOK.SELECT",
        "292": "WORKBOOK.ACTIVATE",
        "293": "ASSIGN.TO.TOOL",
        "295": "COPY.TOOL",
        "296": "RESET.TOOL",
        "297": "CONSTRAIN.NUMERIC",
        "298": "PASTE.TOOL",
        "302": "WORKBOOK.NEW",
        "305": "SCENARIO.CELLS",
        "306": "SCENARIO.DELETE",
        "307": "SCENARIO.ADD",
        "308": "SCENARIO.EDIT",
        "309": "SCENARIO.SHOW",
        "310": "SCENARIO.SHOW.NEXT",
        "311": "SCENARIO.SUMMARY",
        "312": "PIVOT.TABLE.WIZARD",
        "313": "PIVOT.FIELD.PROPERTIES",
        "314": "PIVOT.FIELD",
        "315": "PIVOT.ITEM",
        "316": "PIVOT.ADD.FIELDS",
        "318": "OPTIONS.CALCULATION",
        "319": "OPTIONS.EDIT",
        "320": "OPTIONS.VIEW",
        "321": "ADDIN.MANAGER",
        "322": "MENU.EDITOR",
        "323": "ATTACH.TOOLBARS",
        "324": "VBAActivate",
        "325": "OPTIONS.CHART",
        "328": "VBA.INSERT.FILE",
        "330": "VBA.PROCEDURE.DEFINITION",
        "336": "ROUTING.SLIP",
        "338": "ROUTE.DOCUMENT",
        "339": "MAIL.LOGON",
        "342": "INSERT.PICTURE",
        "343": "EDIT.TOOL",
        "344": "GALLERY.DOUGHNUT",
        "350": "CHART.TREND",
        "352": "PIVOT.ITEM.PROPERTIES",
        "354": "WORKBOOK.INSERT",
        "355": "OPTIONS.TRANSITION",
        "356": "OPTIONS.GENERAL",
        "370": "FILTER.ADVANCED",
        "373": "MAIL.ADD.MAILER",
        "374": "MAIL.DELETE.MAILER",
        "375": "MAIL.REPLY",
        "376": "MAIL.REPLY.ALL",
        "377": "MAIL.FORWARD",
        "378": "MAIL.NEXT.LETTER",
        "379": "DATA.LABEL",
        "380": "INSERT.TITLE",
        "381": "FONT.PROPERTIES",
        "382": "MACRO.OPTIONS",
        "383": "WORKBOOK.HIDE",
        "384": "WORKBOOK.UNHIDE",
        "385": "WORKBOOK.DELETE",
        "386": "WORKBOOK.NAME",
        "388": "GALLERY.CUSTOM",
        "390": "ADD.CHART.AUTOFORMAT",
        "391": "DELETE.CHART.AUTOFORMAT",
        "392": "CHART.ADD.DATA",
        "393": "AUTO.OUTLINE",
        "394": "TAB.ORDER",
        "395": "SHOW.DIALOG",
        "396": "SELECT.ALL",
        "397": "UNGROUP.SHEETS",
        "398": "SUBTOTAL.CREATE",
        "399": "SUBTOTAL.REMOVE",
        "400": "RENAME.OBJECT",
        "412": "WORKBOOK.SCROLL",
        "413": "WORKBOOK.NEXT",
        "414": "WORKBOOK.PREV",
        "415": "WORKBOOK.TAB.SPLIT",
        "416": "FULL.SCREEN",
        "417": "WORKBOOK.PROTECT",
        "420": "SCROLLBAR.PROPERTIES",
        "421": "PIVOT.SHOW.PAGES",
        "422": "TEXT.TO.COLUMNS",
        "423": "FORMAT.CHARTTYPE",
        "424": "LINK.FORMAT",
        "425": "TRACER.DISPLAY",
        "430": "TRACER.NAVIGATE",
        "431": "TRACER.CLEAR",
        "432": "TRACER.ERROR",
        "433": "PIVOT.FIELD.GROUP",
        "434": "PIVOT.FIELD.UNGROUP",
        "435": "CHECKBOX.PROPERTIES",
        "436": "LABEL.PROPERTIES",
        "437": "LISTBOX.PROPERTIES",
        "438": "EDITBOX.PROPERTIES",
        "439": "PIVOT.REFRESH",
        "440": "LINK.COMBO",
        "441": "OPEN.TEXT",
        "442": "HIDE.DIALOG",
        "443": "SET.DIALOG.FOCUS",
        "444": "ENABLE.OBJECT",
        "445": "PUSHBUTTON.PROPERTIES",
        "446": "SET.DIALOG.DEFAULT",
        "447": "FILTER",
        "448": "FILTER.SHOW.ALL",
        "449": "CLEAR.OUTLINE",
        "450": "FUNCTION.WIZARD",
        "451": "ADD.LIST.ITEM",
        "452": "SET.LIST.ITEM",
        "453": "REMOVE.LIST.ITEM",
        "454": "SELECT.LIST.ITEM",
        "455": "SET.CONTROL.VALUE",
        "456": "SAVE.COPY.AS",
        "458": "OPTIONS.LISTS.ADD",
        "459": "OPTIONS.LISTS.DELETE",
        "460": "SERIES.AXES",
        "461": "SERIES.X",
        "462": "SERIES.Y",
        "463": "ERRORBAR.X",
        "464": "ERRORBAR.Y",
        "465": "FORMAT.CHART",
        "466": "SERIES.ORDER",
        "467": "MAIL.LOGOFF",
        "468": "CLEAR.ROUTING.SLIP",
        "469": "APP.ACTIVATE.MICROSOFT",
        "470": "MAIL.EDIT.MAILER",
        "471": "ON.SHEET",
        "472": "STANDARD.WIDTH",
        "473": "SCENARIO.MERGE",
        "474": "SUMMARY.INFO",
        "475": "FIND.FILE",
        "476": "ACTIVE.CELL.FONT",
        "477": "ENABLE.TIPWIZARD",
        "478": "VBA.MAKE.ADDIN",
        "480": "INSERTDATATABLE",
        "481": "WORKGROUP.OPTIONS",
        "482": "MAIL.SEND.MAILER",
        "485": "AUTOCORRECT",
        "489": "POST.DOCUMENT",
        "491": "PICKLIST",
        "493": "VIEW.SHOW",
        "494": "VIEW.DEFINE",
        "495": "VIEW.DELETE",
        "509": "SHEET.BACKGROUND",
        "510": "INSERT.MAP.OBJECT",
        "511": "OPTIONS.MENONO",
        "517": "MSOCHECKS",
        "518": "NORMAL",
        "519": "LAYOUT",
        "520": "RM.PRINT.AREA",
        "521": "CLEAR.PRINT.AREA",
        "522": "ADD.PRINT.AREA",
        "523": "MOVE.BRK",
        "545": "HIDECURR.NOTE",
        "546": "HIDEALL.NOTES",
        "547": "DELETE.NOTE",
        "548": "TRAVERSE.NOTES",
        "549": "ACTIVATE.NOTES",
        "620": "PROTECT.REVISIONS",
        "621": "UNPROTECT.REVISIONS",
        "647": "OPTIONS.ME",
        "653": "WEB.PUBLISH",
        "667": "NEWWEBQUERY",
        "673": "PIVOT.TABLE.CHART",
        "753": "OPTIONS.SAVE",
        "755": "OPTIONS.SPELL",
        "808": "HIDEALL.INKANNOTS"
    };
    var Ftab = {
        "0": "COUNT",
        "1": "IF",
        "2": "ISNA",
        "3": "ISERROR",
        "4": "SUM",
        "5": "AVERAGE",
        "6": "MIN",
        "7": "MAX",
        "8": "ROW",
        "9": "COLUMN",
        "10": "NA",
        "11": "NPV",
        "12": "STDEV",
        "13": "DOLLAR",
        "14": "FIXED",
        "15": "SIN",
        "16": "COS",
        "17": "TAN",
        "18": "ATAN",
        "19": "PI",
        "20": "SQRT",
        "21": "EXP",
        "22": "LN",
        "23": "LOG10",
        "24": "ABS",
        "25": "INT",
        "26": "SIGN",
        "27": "ROUND",
        "28": "LOOKUP",
        "29": "INDEX",
        "30": "REPT",
        "31": "MID",
        "32": "LEN",
        "33": "VALUE",
        "34": "TRUE",
        "35": "FALSE",
        "36": "AND",
        "37": "OR",
        "38": "NOT",
        "39": "MOD",
        "40": "DCOUNT",
        "41": "DSUM",
        "42": "DAVERAGE",
        "43": "DMIN",
        "44": "DMAX",
        "45": "DSTDEV",
        "46": "VAR",
        "47": "DVAR",
        "48": "TEXT",
        "49": "LINEST",
        "50": "TREND",
        "51": "LOGEST",
        "52": "GROWTH",
        "53": "GOTO",
        "54": "HALT",
        "55": "RETURN",
        "56": "PV",
        "57": "FV",
        "58": "NPER",
        "59": "PMT",
        "60": "RATE",
        "61": "MIRR",
        "62": "IRR",
        "63": "RAND",
        "64": "MATCH",
        "65": "DATE",
        "66": "TIME",
        "67": "DAY",
        "68": "MONTH",
        "69": "YEAR",
        "70": "WEEKDAY",
        "71": "HOUR",
        "72": "MINUTE",
        "73": "SECOND",
        "74": "NOW",
        "75": "AREAS",
        "76": "ROWS",
        "77": "COLUMNS",
        "78": "OFFSET",
        "79": "ABSREF",
        "80": "RELREF",
        "81": "ARGUMENT",
        "82": "SEARCH",
        "83": "TRANSPOSE",
        "84": "ERROR",
        "85": "STEP",
        "86": "TYPE",
        "87": "ECHO",
        "88": "SET.NAME",
        "89": "CALLER",
        "90": "DEREF",
        "91": "WINDOWS",
        "92": "SERIES",
        "93": "DOCUMENTS",
        "94": "ACTIVE.CELL",
        "95": "SELECTION",
        "96": "RESULT",
        "97": "ATAN2",
        "98": "ASIN",
        "99": "ACOS",
        "100": "CHOOSE",
        "101": "HLOOKUP",
        "102": "VLOOKUP",
        "103": "LINKS",
        "104": "INPUT",
        "105": "ISREF",
        "106": "GET.FORMULA",
        "107": "GET.NAME",
        "108": "SET.VALUE",
        "109": "LOG",
        "110": "EXEC",
        "111": "CHAR",
        "112": "LOWER",
        "113": "UPPER",
        "114": "PROPER",
        "115": "LEFT",
        "116": "RIGHT",
        "117": "EXACT",
        "118": "TRIM",
        "119": "REPLACE",
        "120": "SUBSTITUTE",
        "121": "CODE",
        "122": "NAMES",
        "123": "DIRECTORY",
        "124": "FIND",
        "125": "CELL",
        "126": "ISERR",
        "127": "ISTEXT",
        "128": "ISNUMBER",
        "129": "ISBLANK",
        "130": "T",
        "131": "N",
        "132": "FOPEN",
        "133": "FCLOSE",
        "134": "FSIZE",
        "135": "FREADLN",
        "136": "FREAD",
        "137": "FWRITELN",
        "138": "FWRITE",
        "139": "FPOS",
        "140": "DATEVALUE",
        "141": "TIMEVALUE",
        "142": "SLN",
        "143": "SYD",
        "144": "DDB",
        "145": "GET.DEF",
        "146": "REFTEXT",
        "147": "TEXTREF",
        "148": "INDIRECT",
        "149": "REGISTER",
        "150": "CALL",
        "151": "ADD.BAR",
        "152": "ADD.MENU",
        "153": "ADD.COMMAND",
        "154": "ENABLE.COMMAND",
        "155": "CHECK.COMMAND",
        "156": "RENAME.COMMAND",
        "157": "SHOW.BAR",
        "158": "DELETE.MENU",
        "159": "DELETE.COMMAND",
        "160": "GET.CHART.ITEM",
        "161": "DIALOG.BOX",
        "162": "CLEAN",
        "163": "MDETERM",
        "164": "MINVERSE",
        "165": "MMULT",
        "166": "FILES",
        "167": "IPMT",
        "168": "PPMT",
        "169": "COUNTA",
        "170": "CANCEL.KEY",
        "171": "FOR",
        "172": "WHILE",
        "173": "BREAK",
        "174": "NEXT",
        "175": "INITIATE",
        "176": "REQUEST",
        "177": "POKE",
        "178": "EXECUTE",
        "179": "TERMINATE",
        "180": "RESTART",
        "181": "HELP",
        "182": "GET.BAR",
        "183": "PRODUCT",
        "184": "FACT",
        "185": "GET.CELL",
        "186": "GET.WORKSPACE",
        "187": "GET.WINDOW",
        "188": "GET.DOCUMENT",
        "189": "DPRODUCT",
        "190": "ISNONTEXT",
        "191": "GET.NOTE",
        "192": "NOTE",
        "193": "STDEVP",
        "194": "VARP",
        "195": "DSTDEVP",
        "196": "DVARP",
        "197": "TRUNC",
        "198": "ISLOGICAL",
        "199": "DCOUNTA",
        "200": "DELETE.BAR",
        "201": "UNREGISTER",
        "204": "USDOLLAR",
        "205": "FINDB",
        "206": "SEARCHB",
        "207": "REPLACEB",
        "208": "LEFTB",
        "209": "RIGHTB",
        "210": "MIDB",
        "211": "LENB",
        "212": "ROUNDUP",
        "213": "ROUNDDOWN",
        "214": "ASC",
        "215": "DBCS",
        "216": "RANK",
        "219": "ADDRESS",
        "220": "DAYS360",
        "221": "TODAY",
        "222": "VDB",
        "223": "ELSE",
        "224": "ELSE.IF",
        "225": "END.IF",
        "226": "FOR.CELL",
        "227": "MEDIAN",
        "228": "SUMPRODUCT",
        "229": "SINH",
        "230": "COSH",
        "231": "TANH",
        "232": "ASINH",
        "233": "ACOSH",
        "234": "ATANH",
        "235": "DGET",
        "236": "CREATE.OBJECT",
        "237": "VOLATILE",
        "238": "LAST.ERROR",
        "239": "CUSTOM.UNDO",
        "240": "CUSTOM.REPEAT",
        "241": "FORMULA.CONVERT",
        "242": "GET.LINK.INFO",
        "243": "TEXT.BOX",
        "244": "INFO",
        "245": "GROUP",
        "246": "GET.OBJECT",
        "247": "DB",
        "248": "PAUSE",
        "251": "RESUME",
        "252": "FREQUENCY",
        "253": "ADD.TOOLBAR",
        "254": "DELETE.TOOLBAR",
        "255": "User",
        "256": "RESET.TOOLBAR",
        "257": "EVALUATE",
        "258": "GET.TOOLBAR",
        "259": "GET.TOOL",
        "260": "SPELLING.CHECK",
        "261": "ERROR.TYPE",
        "262": "APP.TITLE",
        "263": "WINDOW.TITLE",
        "264": "SAVE.TOOLBAR",
        "265": "ENABLE.TOOL",
        "266": "PRESS.TOOL",
        "267": "REGISTER.ID",
        "268": "GET.WORKBOOK",
        "269": "AVEDEV",
        "270": "BETADIST",
        "271": "GAMMALN",
        "272": "BETAINV",
        "273": "BINOMDIST",
        "274": "CHIDIST",
        "275": "CHIINV",
        "276": "COMBIN",
        "277": "CONFIDENCE",
        "278": "CRITBINOM",
        "279": "EVEN",
        "280": "EXPONDIST",
        "281": "FDIST",
        "282": "FINV",
        "283": "FISHER",
        "284": "FISHERINV",
        "285": "FLOOR",
        "286": "GAMMADIST",
        "287": "GAMMAINV",
        "288": "CEILING",
        "289": "HYPGEOMDIST",
        "290": "LOGNORMDIST",
        "291": "LOGINV",
        "292": "NEGBINOMDIST",
        "293": "NORMDIST",
        "294": "NORMSDIST",
        "295": "NORMINV",
        "296": "NORMSINV",
        "297": "STANDARDIZE",
        "298": "ODD",
        "299": "PERMUT",
        "300": "POISSON",
        "301": "TDIST",
        "302": "WEIBULL",
        "303": "SUMXMY2",
        "304": "SUMX2MY2",
        "305": "SUMX2PY2",
        "306": "CHITEST",
        "307": "CORREL",
        "308": "COVAR",
        "309": "FORECAST",
        "310": "FTEST",
        "311": "INTERCEPT",
        "312": "PEARSON",
        "313": "RSQ",
        "314": "STEYX",
        "315": "SLOPE",
        "316": "TTEST",
        "317": "PROB",
        "318": "DEVSQ",
        "319": "GEOMEAN",
        "320": "HARMEAN",
        "321": "SUMSQ",
        "322": "KURT",
        "323": "SKEW",
        "324": "ZTEST",
        "325": "LARGE",
        "326": "SMALL",
        "327": "QUARTILE",
        "328": "PERCENTILE",
        "329": "PERCENTRANK",
        "330": "MODE",
        "331": "TRIMMEAN",
        "332": "TINV",
        "334": "MOVIE.COMMAND",
        "335": "GET.MOVIE",
        "336": "CONCATENATE",
        "337": "POWER",
        "338": "PIVOT.ADD.DATA",
        "339": "GET.PIVOT.TABLE",
        "340": "GET.PIVOT.FIELD",
        "341": "GET.PIVOT.ITEM",
        "342": "RADIANS",
        "343": "DEGREES",
        "344": "SUBTOTAL",
        "345": "SUMIF",
        "346": "COUNTIF",
        "347": "COUNTBLANK",
        "348": "SCENARIO.GET",
        "349": "OPTIONS.LISTS.GET",
        "350": "ISPMT",
        "351": "DATEDIF",
        "352": "DATESTRING",
        "353": "NUMBERSTRING",
        "354": "ROMAN",
        "355": "OPEN.DIALOG",
        "356": "SAVE.DIALOG",
        "357": "VIEW.GET",
        "358": "GETPIVOTDATA",
        "359": "HYPERLINK",
        "360": "PHONETIC",
        "361": "AVERAGEA",
        "362": "MAXA",
        "363": "MINA",
        "364": "STDEVPA",
        "365": "VARPA",
        "366": "STDEVA",
        "367": "VARA",
        "368": "BAHTTEXT",
        "369": "THAIDAYOFWEEK",
        "370": "THAIDIGIT",
        "371": "THAIMONTHOFYEAR",
        "372": "THAINUMSOUND",
        "373": "THAINUMSTRING",
        "374": "THAISTRINGLENGTH",
        "375": "ISTHAIDIGIT",
        "376": "ROUNDBAHTDOWN",
        "377": "ROUNDBAHTUP",
        "378": "THAIYEAR",
        "379": "RTD",
        "380": "CUBEVALUE",
        "381": "CUBEMEMBER",
        "382": "CUBEMEMBERPROPERTY",
        "383": "CUBERANKEDMEMBER",
        "384": "HEX2BIN",
        "385": "HEX2DEC",
        "386": "HEX2OCT",
        "387": "DEC2BIN",
        "388": "DEC2HEX",
        "389": "DEC2OCT",
        "390": "OCT2BIN",
        "391": "OCT2HEX",
        "392": "OCT2DEC",
        "393": "BIN2DEC",
        "394": "BIN2OCT",
        "395": "BIN2HEX",
        "396": "IMSUB",
        "397": "IMDIV",
        "398": "IMPOWER",
        "399": "IMABS",
        "400": "IMSQRT",
        "401": "IMLN",
        "402": "IMLOG2",
        "403": "IMLOG10",
        "404": "IMSIN",
        "405": "IMCOS",
        "406": "IMEXP",
        "407": "IMARGUMENT",
        "408": "IMCONJUGATE",
        "409": "IMAGINARY",
        "410": "IMREAL",
        "411": "COMPLEX",
        "412": "IMSUM",
        "413": "IMPRODUCT",
        "414": "SERIESSUM",
        "415": "FACTDOUBLE",
        "416": "SQRTPI",
        "417": "QUOTIENT",
        "418": "DELTA",
        "419": "GESTEP",
        "420": "ISEVEN",
        "421": "ISODD",
        "422": "MROUND",
        "423": "ERF",
        "424": "ERFC",
        "425": "BESSELJ",
        "426": "BESSELK",
        "427": "BESSELY",
        "428": "BESSELI",
        "429": "XIRR",
        "430": "XNPV",
        "431": "PRICEMAT",
        "432": "YIELDMAT",
        "433": "INTRATE",
        "434": "RECEIVED",
        "435": "DISC",
        "436": "PRICEDISC",
        "437": "YIELDDISC",
        "438": "TBILLEQ",
        "439": "TBILLPRICE",
        "440": "TBILLYIELD",
        "441": "PRICE",
        "442": "YIELD",
        "443": "DOLLARDE",
        "444": "DOLLARFR",
        "445": "NOMINAL",
        "446": "EFFECT",
        "447": "CUMPRINC",
        "448": "CUMIPMT",
        "449": "EDATE",
        "450": "EOMONTH",
        "451": "YEARFRAC",
        "452": "COUPDAYBS",
        "453": "COUPDAYS",
        "454": "COUPDAYSNC",
        "455": "COUPNCD",
        "456": "COUPNUM",
        "457": "COUPPCD",
        "458": "DURATION",
        "459": "MDURATION",
        "460": "ODDLPRICE",
        "461": "ODDLYIELD",
        "462": "ODDFPRICE",
        "463": "ODDFYIELD",
        "464": "RANDBETWEEN",
        "465": "WEEKNUM",
        "466": "AMORDEGRC",
        "467": "AMORLINC",
        "468": "CONVERT",
        "724": "SHEETJS",
        "469": "ACCRINT",
        "470": "ACCRINTM",
        "471": "WORKDAY",
        "472": "NETWORKDAYS",
        "473": "GCD",
        "474": "MULTINOMIAL",
        "475": "LCM",
        "476": "FVSCHEDULE",
        "477": "CUBEKPIMEMBER",
        "478": "CUBESET",
        "479": "CUBESETCOUNT",
        "480": "IFERROR",
        "481": "COUNTIFS",
        "482": "SUMIFS",
        "483": "AVERAGEIF",
        "484": "AVERAGEIFS"
    };
    var FtabArgc = {
        "2": 1,
        "3": 1,
        "10": 0,
        "15": 1,
        "16": 1,
        "17": 1,
        "18": 1,
        "19": 0,
        "20": 1,
        "21": 1,
        "22": 1,
        "23": 1,
        "24": 1,
        "25": 1,
        "26": 1,
        "27": 2,
        "30": 2,
        "31": 3,
        "32": 1,
        "33": 1,
        "34": 0,
        "35": 0,
        "38": 1,
        "39": 2,
        "40": 3,
        "41": 3,
        "42": 3,
        "43": 3,
        "44": 3,
        "45": 3,
        "47": 3,
        "48": 2,
        "53": 1,
        "61": 3,
        "63": 0,
        "65": 3,
        "66": 3,
        "67": 1,
        "68": 1,
        "69": 1,
        "70": 1,
        "71": 1,
        "72": 1,
        "73": 1,
        "74": 0,
        "75": 1,
        "76": 1,
        "77": 1,
        "79": 2,
        "80": 2,
        "83": 1,
        "85": 0,
        "86": 1,
        "89": 0,
        "90": 1,
        "94": 0,
        "95": 0,
        "97": 2,
        "98": 1,
        "99": 1,
        "101": 3,
        "102": 3,
        "105": 1,
        "106": 1,
        "108": 2,
        "111": 1,
        "112": 1,
        "113": 1,
        "114": 1,
        "117": 2,
        "118": 1,
        "119": 4,
        "121": 1,
        "126": 1,
        "127": 1,
        "128": 1,
        "129": 1,
        "130": 1,
        "131": 1,
        "133": 1,
        "134": 1,
        "135": 1,
        "136": 2,
        "137": 2,
        "138": 2,
        "140": 1,
        "141": 1,
        "142": 3,
        "143": 4,
        "144": 4,
        "161": 1,
        "162": 1,
        "163": 1,
        "164": 1,
        "165": 2,
        "172": 1,
        "175": 2,
        "176": 2,
        "177": 3,
        "178": 2,
        "179": 1,
        "184": 1,
        "186": 1,
        "189": 3,
        "190": 1,
        "195": 3,
        "196": 3,
        "197": 1,
        "198": 1,
        "199": 3,
        "201": 1,
        "207": 4,
        "210": 3,
        "211": 1,
        "212": 2,
        "213": 2,
        "214": 1,
        "215": 1,
        "225": 0,
        "229": 1,
        "230": 1,
        "231": 1,
        "232": 1,
        "233": 1,
        "234": 1,
        "235": 3,
        "244": 1,
        "247": 4,
        "252": 2,
        "257": 1,
        "261": 1,
        "271": 1,
        "273": 4,
        "274": 2,
        "275": 2,
        "276": 2,
        "277": 3,
        "278": 3,
        "279": 1,
        "280": 3,
        "281": 3,
        "282": 3,
        "283": 1,
        "284": 1,
        "285": 2,
        "286": 4,
        "287": 3,
        "288": 2,
        "289": 4,
        "290": 3,
        "291": 3,
        "292": 3,
        "293": 4,
        "294": 1,
        "295": 3,
        "296": 1,
        "297": 3,
        "298": 1,
        "299": 2,
        "300": 3,
        "301": 3,
        "302": 4,
        "303": 2,
        "304": 2,
        "305": 2,
        "306": 2,
        "307": 2,
        "308": 2,
        "309": 3,
        "310": 2,
        "311": 2,
        "312": 2,
        "313": 2,
        "314": 2,
        "315": 2,
        "316": 4,
        "325": 2,
        "326": 2,
        "327": 2,
        "328": 2,
        "331": 2,
        "332": 2,
        "337": 2,
        "342": 1,
        "343": 1,
        "346": 2,
        "347": 1,
        "350": 4,
        "351": 3,
        "352": 1,
        "353": 2,
        "360": 1,
        "368": 1,
        "369": 1,
        "370": 1,
        "371": 1,
        "372": 1,
        "373": 1,
        "374": 1,
        "375": 1,
        "376": 1,
        "377": 1,
        "378": 1,
        "382": 3,
        "385": 1,
        "392": 1,
        "393": 1,
        "396": 2,
        "397": 2,
        "398": 2,
        "399": 1,
        "400": 1,
        "401": 1,
        "402": 1,
        "403": 1,
        "404": 1,
        "405": 1,
        "406": 1,
        "407": 1,
        "408": 1,
        "409": 1,
        "410": 1,
        "414": 4,
        "415": 1,
        "416": 1,
        "417": 2,
        "420": 1,
        "421": 1,
        "422": 2,
        "424": 1,
        "425": 2,
        "426": 2,
        "427": 2,
        "428": 2,
        "430": 3,
        "438": 3,
        "439": 3,
        "440": 3,
        "443": 2,
        "444": 2,
        "445": 2,
        "446": 2,
        "447": 6,
        "448": 6,
        "449": 2,
        "450": 2,
        "464": 2,
        "468": 3,
        "476": 2,
        "479": 1,
        "480": 2,
        "65535": 0
    };
    var XLSXFutureFunctions = {
        "_xlfn.ACOT": "ACOT",
        "_xlfn.ACOTH": "ACOTH",
        "_xlfn.AGGREGATE": "AGGREGATE",
        "_xlfn.ARABIC": "ARABIC",
        "_xlfn.AVERAGEIF": "AVERAGEIF",
        "_xlfn.AVERAGEIFS": "AVERAGEIFS",
        "_xlfn.BASE": "BASE",
        "_xlfn.BETA.DIST": "BETA.DIST",
        "_xlfn.BETA.INV": "BETA.INV",
        "_xlfn.BINOM.DIST": "BINOM.DIST",
        "_xlfn.BINOM.DIST.RANGE": "BINOM.DIST.RANGE",
        "_xlfn.BINOM.INV": "BINOM.INV",
        "_xlfn.BITAND": "BITAND",
        "_xlfn.BITLSHIFT": "BITLSHIFT",
        "_xlfn.BITOR": "BITOR",
        "_xlfn.BITRSHIFT": "BITRSHIFT",
        "_xlfn.BITXOR": "BITXOR",
        "_xlfn.CEILING.MATH": "CEILING.MATH",
        "_xlfn.CEILING.PRECISE": "CEILING.PRECISE",
        "_xlfn.CHISQ.DIST": "CHISQ.DIST",
        "_xlfn.CHISQ.DIST.RT": "CHISQ.DIST.RT",
        "_xlfn.CHISQ.INV": "CHISQ.INV",
        "_xlfn.CHISQ.INV.RT": "CHISQ.INV.RT",
        "_xlfn.CHISQ.TEST": "CHISQ.TEST",
        "_xlfn.COMBINA": "COMBINA",
        "_xlfn.CONCAT": "CONCAT",
        "_xlfn.CONFIDENCE.NORM": "CONFIDENCE.NORM",
        "_xlfn.CONFIDENCE.T": "CONFIDENCE.T",
        "_xlfn.COT": "COT",
        "_xlfn.COTH": "COTH",
        "_xlfn.COUNTIFS": "COUNTIFS",
        "_xlfn.COVARIANCE.P": "COVARIANCE.P",
        "_xlfn.COVARIANCE.S": "COVARIANCE.S",
        "_xlfn.CSC": "CSC",
        "_xlfn.CSCH": "CSCH",
        "_xlfn.DAYS": "DAYS",
        "_xlfn.DECIMAL": "DECIMAL",
        "_xlfn.ECMA.CEILING": "ECMA.CEILING",
        "_xlfn.ERF.PRECISE": "ERF.PRECISE",
        "_xlfn.ERFC.PRECISE": "ERFC.PRECISE",
        "_xlfn.EXPON.DIST": "EXPON.DIST",
        "_xlfn.F.DIST": "F.DIST",
        "_xlfn.F.DIST.RT": "F.DIST.RT",
        "_xlfn.F.INV": "F.INV",
        "_xlfn.F.INV.RT": "F.INV.RT",
        "_xlfn.F.TEST": "F.TEST",
        "_xlfn.FILTERXML": "FILTERXML",
        "_xlfn.FLOOR.MATH": "FLOOR.MATH",
        "_xlfn.FLOOR.PRECISE": "FLOOR.PRECISE",
        "_xlfn.FORECAST.ETS": "FORECAST.ETS",
        "_xlfn.FORECAST.ETS.CONFINT": "FORECAST.ETS.CONFINT",
        "_xlfn.FORECAST.ETS.SEASONALITY": "FORECAST.ETS.SEASONALITY",
        "_xlfn.FORECAST.ETS.STAT": "FORECAST.ETS.STAT",
        "_xlfn.FORECAST.LINEAR": "FORECAST.LINEAR",
        "_xlfn.FORMULATEXT": "FORMULATEXT",
        "_xlfn.GAMMA": "GAMMA",
        "_xlfn.GAMMA.DIST": "GAMMA.DIST",
        "_xlfn.GAMMA.INV": "GAMMA.INV",
        "_xlfn.GAMMALN.PRECISE": "GAMMALN.PRECISE",
        "_xlfn.GAUSS": "GAUSS",
        "_xlfn.HYPGEOM.DIST": "HYPGEOM.DIST",
        "_xlfn.IFERROR": "IFERROR",
        "_xlfn.IFNA": "IFNA",
        "_xlfn.IFS": "IFS",
        "_xlfn.IMCOSH": "IMCOSH",
        "_xlfn.IMCOT": "IMCOT",
        "_xlfn.IMCSC": "IMCSC",
        "_xlfn.IMCSCH": "IMCSCH",
        "_xlfn.IMSEC": "IMSEC",
        "_xlfn.IMSECH": "IMSECH",
        "_xlfn.IMSINH": "IMSINH",
        "_xlfn.IMTAN": "IMTAN",
        "_xlfn.ISFORMULA": "ISFORMULA",
        "_xlfn.ISO.CEILING": "ISO.CEILING",
        "_xlfn.ISOWEEKNUM": "ISOWEEKNUM",
        "_xlfn.LOGNORM.DIST": "LOGNORM.DIST",
        "_xlfn.LOGNORM.INV": "LOGNORM.INV",
        "_xlfn.MAXIFS": "MAXIFS",
        "_xlfn.MINIFS": "MINIFS",
        "_xlfn.MODE.MULT": "MODE.MULT",
        "_xlfn.MODE.SNGL": "MODE.SNGL",
        "_xlfn.MUNIT": "MUNIT",
        "_xlfn.NEGBINOM.DIST": "NEGBINOM.DIST",
        "_xlfn.NETWORKDAYS.INTL": "NETWORKDAYS.INTL",
        "_xlfn.NIGBINOM": "NIGBINOM",
        "_xlfn.NORM.DIST": "NORM.DIST",
        "_xlfn.NORM.INV": "NORM.INV",
        "_xlfn.NORM.S.DIST": "NORM.S.DIST",
        "_xlfn.NORM.S.INV": "NORM.S.INV",
        "_xlfn.NUMBERVALUE": "NUMBERVALUE",
        "_xlfn.PDURATION": "PDURATION",
        "_xlfn.PERCENTILE.EXC": "PERCENTILE.EXC",
        "_xlfn.PERCENTILE.INC": "PERCENTILE.INC",
        "_xlfn.PERCENTRANK.EXC": "PERCENTRANK.EXC",
        "_xlfn.PERCENTRANK.INC": "PERCENTRANK.INC",
        "_xlfn.PERMUTATIONA": "PERMUTATIONA",
        "_xlfn.PHI": "PHI",
        "_xlfn.POISSON.DIST": "POISSON.DIST",
        "_xlfn.QUARTILE.EXC": "QUARTILE.EXC",
        "_xlfn.QUARTILE.INC": "QUARTILE.INC",
        "_xlfn.QUERYSTRING": "QUERYSTRING",
        "_xlfn.RANK.AVG": "RANK.AVG",
        "_xlfn.RANK.EQ": "RANK.EQ",
        "_xlfn.RRI": "RRI",
        "_xlfn.SEC": "SEC",
        "_xlfn.SECH": "SECH",
        "_xlfn.SHEET": "SHEET",
        "_xlfn.SHEETS": "SHEETS",
        "_xlfn.SKEW.P": "SKEW.P",
        "_xlfn.STDEV.P": "STDEV.P",
        "_xlfn.STDEV.S": "STDEV.S",
        "_xlfn.SUMIFS": "SUMIFS",
        "_xlfn.SWITCH": "SWITCH",
        "_xlfn.T.DIST": "T.DIST",
        "_xlfn.T.DIST.2T": "T.DIST.2T",
        "_xlfn.T.DIST.RT": "T.DIST.RT",
        "_xlfn.T.INV": "T.INV",
        "_xlfn.T.INV.2T": "T.INV.2T",
        "_xlfn.T.TEST": "T.TEST",
        "_xlfn.TEXTJOIN": "TEXTJOIN",
        "_xlfn.UNICHAR": "UNICHAR",
        "_xlfn.UNICODE": "UNICODE",
        "_xlfn.VAR.P": "VAR.P",
        "_xlfn.VAR.S": "VAR.S",
        "_xlfn.WEBSERVICE": "WEBSERVICE",
        "_xlfn.WEIBULL.DIST": "WEIBULL.DIST",
        "_xlfn.WORKDAY.INTL": "WORKDAY.INTL",
        "_xlfn.XOR": "XOR",
        "_xlfn.Z.TEST": "Z.TEST"
    };
    function ods_to_csf_formula(f) {
        if (f.slice(0, 3) == "of:") f = f.slice(3);
        if (f.charCodeAt(0) == 61) {
            f = f.slice(1);
            if (f.charCodeAt(0) == 61) f = f.slice(1);
        }
        f = f.replace(/COM\.MICROSOFT\./g, "");
        f = f.replace(/\[((?:\.[A-Z]+[0-9]+)(?::\.[A-Z]+[0-9]+)?)\]/g, function($$, $1) {
            return $1.replace(/\./g, "");
        });
        f = f.replace(/\[.(#[A-Z]*[?!])\]/g, "$1");
        return f.replace(/[;~]/g, ",").replace(/\|/g, ";");
    }
    function csf_to_ods_formula(f) {
        var o = "of:=" + f.replace(crefregex, "$1[.$2$3$4$5]").replace(/\]:\[/g, ":");
        return o.replace(/;/g, "|").replace(/,/g, ";");
    }
    function ods_to_csf_3D(r) {
        var a = r.split(":");
        var s = a[0].split(".")[0];
        return [ s, a[0].split(".")[1] + (a.length > 1 ? ":" + (a[1].split(".")[1] || a[1].split(".")[0]) : "") ];
    }
    function csf_to_ods_3D(r) {
        return r.replace(/\./, "!");
    }
    var strs = {};
    var _ssfopts = {};
    RELS.WS = [ "http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet", "http://purl.oclc.org/ooxml/officeDocument/relationships/worksheet" ];
    var browser_has_Map = typeof Map !== "undefined";
    function get_sst_id(sst, str, rev) {
        var i = 0, len = sst.length;
        if (rev) {
            if (browser_has_Map ? rev.has(str) : rev.hasOwnProperty(str)) {
                var revarr = browser_has_Map ? rev.get(str) : rev[str];
                for (;i < revarr.length; ++i) {
                    if (sst[revarr[i]].t === str) {
                        sst.Count++;
                        return revarr[i];
                    }
                }
            }
        } else for (;i < len; ++i) {
            if (sst[i].t === str) {
                sst.Count++;
                return i;
            }
        }
        sst[len] = {
            "t": str
        };
        sst.Count++;
        sst.Unique++;
        if (rev) {
            if (browser_has_Map) {
                if (!rev.has(str)) rev.set(str, []);
                rev.get(str).push(len);
            } else {
                if (!rev.hasOwnProperty(str)) rev[str] = [];
                rev[str].push(len);
            }
        }
        return len;
    }
    function col_obj_w(C, col) {
        var p = {
            "min": C + 1,
            "max": C + 1
        };
        var wch = -1;
        if (col.MDW) MDW = col.MDW;
        if (col.width != null) p.customWidth = 1; else if (col.wpx != null) wch = px2char(col.wpx); else if (col.wch != null) wch = col.wch;
        if (wch > -1) {
            p.width = char2width(wch);
            p.customWidth = 1;
        } else if (col.width != null) p.width = col.width;
        if (col.hidden) p.hidden = true;
        return p;
    }
    function default_margins(margins, mode) {
        if (!margins) return;
        var defs = [ .7, .7, .75, .75, .3, .3 ];
        if (mode == "xlml") defs = [ 1, 1, 1, 1, .5, .5 ];
        if (margins.left == null) margins.left = defs[0];
        if (margins.right == null) margins.right = defs[1];
        if (margins.top == null) margins.top = defs[2];
        if (margins.bottom == null) margins.bottom = defs[3];
        if (margins.header == null) margins.header = defs[4];
        if (margins.footer == null) margins.footer = defs[5];
    }
    function get_cell_style(styles, cell, opts) {
        var z = opts.revssf[cell.z != null ? cell.z : "General"];
        var i = 60, len = styles.length;
        if (z == null && opts.ssf) {
            for (;i < 392; ++i) if (opts.ssf[i] == null) {
                SSF.load(cell.z, i);
                opts.ssf[i] = cell.z;
                opts.revssf[cell.z] = z = i;
                break;
            }
        }
        for (i = 0; i != len; ++i) if (styles[i].numFmtId === z) return i;
        styles[len] = {
            "numFmtId": z,
            "fontId": 0,
            "fillId": 0,
            "borderId": 0,
            "xfId": 0,
            "applyNumberFormat": 1
        };
        return len;
    }
    function safe_format(p, fmtid, fillid, opts, themes, styles) {
        if (p.t === "z") return;
        if (p.t === "d" && typeof p.v === "string") p.v = parseDate(p.v);
        try {
            if (opts.cellNF) p.z = SSF._table[fmtid];
        } catch (e) {
            if (opts.WTF) throw e;
        }
        if (!opts || opts.cellText !== false) try {
            if (SSF._table[fmtid] == null) SSF.load(SSFImplicit[fmtid] || "General", fmtid);
            if (p.t === "e") p.w = p.w || BErr[p.v]; else if (fmtid === 0) {
                if (p.t === "n") {
                    if ((p.v | 0) === p.v) p.w = SSF._general_int(p.v); else p.w = SSF._general_num(p.v);
                } else if (p.t === "d") {
                    var dd = datenum(p.v);
                    if ((dd | 0) === dd) p.w = SSF._general_int(dd); else p.w = SSF._general_num(dd);
                } else if (p.v === undefined) return ""; else p.w = SSF._general(p.v, _ssfopts);
            } else if (p.t === "d") p.w = SSF.format(fmtid, datenum(p.v), _ssfopts); else p.w = SSF.format(fmtid, p.v, _ssfopts);
        } catch (e) {
            if (opts.WTF) throw e;
        }
        if (!opts.cellStyles) return;
        if (fillid != null) try {
            p.s = styles.Fills[fillid];
            if (p.s.fgColor && p.s.fgColor.theme && !p.s.fgColor.rgb) {
                p.s.fgColor.rgb = rgb_tint(themes.themeElements.clrScheme[p.s.fgColor.theme].rgb, p.s.fgColor.tint || 0);
                if (opts.WTF) p.s.fgColor.raw_rgb = themes.themeElements.clrScheme[p.s.fgColor.theme].rgb;
            }
            if (p.s.bgColor && p.s.bgColor.theme) {
                p.s.bgColor.rgb = rgb_tint(themes.themeElements.clrScheme[p.s.bgColor.theme].rgb, p.s.bgColor.tint || 0);
                if (opts.WTF) p.s.bgColor.raw_rgb = themes.themeElements.clrScheme[p.s.bgColor.theme].rgb;
            }
        } catch (e) {
            if (opts.WTF && styles.Fills) throw e;
        }
    }
    function check_ws(ws, sname, i) {
        if (ws && ws["!ref"]) {
            var range = safe_decode_range(ws["!ref"]);
            if (range.e.c < range.s.c || range.e.r < range.s.r) throw new Error("Bad range (" + i + "): " + ws["!ref"]);
        }
    }
    function parse_ws_xml_dim(ws, s) {
        var d = safe_decode_range(s);
        if (d.s.r <= d.e.r && d.s.c <= d.e.c && d.s.r >= 0 && d.s.c >= 0) ws["!ref"] = encode_range(d);
    }
    var mergecregex = /<(?:\w:)?mergeCell ref="[A-Z0-9:]+"\s*[\/]?>/g;
    var sheetdataregex = /<(?:\w+:)?sheetData>([\s\S]*)<\/(?:\w+:)?sheetData>/;
    var hlinkregex = /<(?:\w:)?hyperlink [^>]*>/gm;
    var dimregex = /"(\w*:\w*)"/;
    var colregex = /<(?:\w:)?col[^>]*[\/]?>/g;
    var afregex = /<(?:\w:)?autoFilter[^>]*([\/]|>([\s\S]*)<\/(?:\w:)?autoFilter)>/g;
    var marginregex = /<(?:\w:)?pageMargins[^>]*\/>/g;
    var sheetprregex = /<(?:\w:)?sheetPr(?:[^>a-z][^>]*)?\/>/;
    var svsregex = /<(?:\w:)?sheetViews[^>]*(?:[\/]|>([\s\S]*)<\/(?:\w:)?sheetViews)>/;
    function parse_ws_xml(data, opts, idx, rels, wb, themes, styles) {
        if (!data) return data;
        if (DENSE != null && opts.dense == null) opts.dense = DENSE;
        var s = opts.dense ? [] : {};
        var refguess = {
            "s": {
                "r": 2e6,
                "c": 2e6
            },
            "e": {
                "r": 0,
                "c": 0
            }
        };
        var data1 = "", data2 = "";
        var mtch = data.match(sheetdataregex);
        if (mtch) {
            data1 = data.slice(0, mtch.index);
            data2 = data.slice(mtch.index + mtch[0].length);
        } else data1 = data2 = data;
        var sheetPr = data1.match(sheetprregex);
        if (sheetPr) parse_ws_xml_sheetpr(sheetPr[0], s, wb, idx);
        var ridx = (data1.match(/<(?:\w*:)?dimension/) || {
            "index": -1
        }).index;
        if (ridx > 0) {
            var ref = data1.slice(ridx, ridx + 50).match(dimregex);
            if (ref) parse_ws_xml_dim(s, ref[1]);
        }
        var svs = data1.match(svsregex);
        if (svs && svs[1]) parse_ws_xml_sheetviews(svs[1], wb);
        var columns = [];
        if (opts.cellStyles) {
            var cols = data1.match(colregex);
            if (cols) parse_ws_xml_cols(columns, cols);
        }
        if (mtch) parse_ws_xml_data(mtch[1], s, opts, refguess, themes, styles);
        var afilter = data2.match(afregex);
        if (afilter) s["!autofilter"] = parse_ws_xml_autofilter(afilter[0]);
        var merges = [];
        var _merge = data2.match(mergecregex);
        if (_merge) for (ridx = 0; ridx != _merge.length; ++ridx) merges[ridx] = safe_decode_range(_merge[ridx].slice(_merge[ridx].indexOf('"') + 1));
        var hlink = data2.match(hlinkregex);
        if (hlink) parse_ws_xml_hlinks(s, hlink, rels);
        var margins = data2.match(marginregex);
        if (margins) s["!margins"] = parse_ws_xml_margins(parsexmltag(margins[0]));
        if (!s["!ref"] && refguess.e.c >= refguess.s.c && refguess.e.r >= refguess.s.r) s["!ref"] = encode_range(refguess);
        if (opts.sheetRows > 0 && s["!ref"]) {
            var tmpref = safe_decode_range(s["!ref"]);
            if (opts.sheetRows <= +tmpref.e.r) {
                tmpref.e.r = opts.sheetRows - 1;
                if (tmpref.e.r > refguess.e.r) tmpref.e.r = refguess.e.r;
                if (tmpref.e.r < tmpref.s.r) tmpref.s.r = tmpref.e.r;
                if (tmpref.e.c > refguess.e.c) tmpref.e.c = refguess.e.c;
                if (tmpref.e.c < tmpref.s.c) tmpref.s.c = tmpref.e.c;
                s["!fullref"] = s["!ref"];
                s["!ref"] = encode_range(tmpref);
            }
        }
        if (columns.length > 0) s["!cols"] = columns;
        if (merges.length > 0) s["!merges"] = merges;
        return s;
    }
    function write_ws_xml_merges(merges) {
        if (merges.length === 0) return "";
        var o = '<mergeCells count="' + merges.length + '">';
        for (var i = 0; i != merges.length; ++i) o += '<mergeCell ref="' + encode_range(merges[i]) + '"/>';
        return o + "</mergeCells>";
    }
    function parse_ws_xml_sheetpr(sheetPr, s, wb, idx) {
        var data = parsexmltag(sheetPr);
        if (!wb.Sheets[idx]) wb.Sheets[idx] = {};
        if (data.codeName) wb.Sheets[idx].CodeName = data.codeName;
    }
    function write_ws_xml_protection(sp) {
        var o = {
            "sheet": 1
        };
        var deffalse = [ "objects", "scenarios", "selectLockedCells", "selectUnlockedCells" ];
        var deftrue = [ "formatColumns", "formatRows", "formatCells", "insertColumns", "insertRows", "insertHyperlinks", "deleteColumns", "deleteRows", "sort", "autoFilter", "pivotTables" ];
        deffalse.forEach(function(n) {
            if (sp[n] != null && sp[n]) o[n] = "1";
        });
        deftrue.forEach(function(n) {
            if (sp[n] != null && !sp[n]) o[n] = "0";
        });
        if (sp.password) o.password = crypto_CreatePasswordVerifier_Method1(sp.password).toString(16).toUpperCase();
        return writextag("sheetProtection", null, o);
    }
    function parse_ws_xml_hlinks(s, data, rels) {
        var dense = Array.isArray(s);
        for (var i = 0; i != data.length; ++i) {
            var val = parsexmltag(utf8read(data[i]), true);
            if (!val.ref) return;
            var rel = ((rels || {})["!id"] || [])[val.id];
            if (rel) {
                val.Target = rel.Target;
                if (val.location) val.Target += "#" + val.location;
            } else {
                val.Target = "#" + val.location;
                rel = {
                    "Target": val.Target,
                    "TargetMode": "Internal"
                };
            }
            val.Rel = rel;
            if (val.tooltip) {
                val.Tooltip = val.tooltip;
                delete val.tooltip;
            }
            var rng = safe_decode_range(val.ref);
            for (var R = rng.s.r; R <= rng.e.r; ++R) for (var C = rng.s.c; C <= rng.e.c; ++C) {
                var addr = encode_cell({
                    "c": C,
                    "r": R
                });
                if (dense) {
                    if (!s[R]) s[R] = [];
                    if (!s[R][C]) s[R][C] = {
                        "t": "z",
                        "v": undefined
                    };
                    s[R][C].l = val;
                } else {
                    if (!s[addr]) s[addr] = {
                        "t": "z",
                        "v": undefined
                    };
                    s[addr].l = val;
                }
            }
        }
    }
    function parse_ws_xml_margins(margin) {
        var o = {};
        [ "left", "right", "top", "bottom", "header", "footer" ].forEach(function(k) {
            if (margin[k]) o[k] = parseFloat(margin[k]);
        });
        return o;
    }
    function write_ws_xml_margins(margin) {
        default_margins(margin);
        return writextag("pageMargins", null, margin);
    }
    function parse_ws_xml_cols(columns, cols) {
        var seencol = false;
        for (var coli = 0; coli != cols.length; ++coli) {
            var coll = parsexmltag(cols[coli], true);
            if (coll.hidden) coll.hidden = parsexmlbool(coll.hidden);
            var colm = parseInt(coll.min, 10) - 1, colM = parseInt(coll.max, 10) - 1;
            delete coll.min;
            delete coll.max;
            coll.width = +coll.width;
            if (!seencol && coll.width) {
                seencol = true;
                find_mdw_colw(coll.width);
            }
            process_col(coll);
            while (colm <= colM) columns[colm++] = dup(coll);
        }
    }
    function write_ws_xml_cols(ws, cols) {
        var o = [ "<cols>" ], col;
        for (var i = 0; i != cols.length; ++i) {
            if (!(col = cols[i])) continue;
            o[o.length] = writextag("col", null, col_obj_w(i, col));
        }
        o[o.length] = "</cols>";
        return o.join("");
    }
    function parse_ws_xml_autofilter(data) {
        var o = {
            "ref": (data.match(/ref="([^"]*)"/) || [])[1]
        };
        return o;
    }
    function write_ws_xml_autofilter(data) {
        return writextag("autoFilter", null, {
            "ref": data.ref
        });
    }
    var sviewregex = /<(?:\w:)?sheetView(?:[^>a-z][^>]*)?\/>/;
    function parse_ws_xml_sheetviews(data, wb) {
        (data.match(sviewregex) || []).forEach(function(r) {
            var tag = parsexmltag(r);
            if (parsexmlbool(tag.rightToLeft)) {
                if (!wb.Views) wb.Views = [ {} ];
                if (!wb.Views[0]) wb.Views[0] = {};
                wb.Views[0].RTL = true;
            }
        });
    }
    function write_ws_xml_sheetviews(ws, opts, idx, wb) {
        var sview = {
            "workbookViewId": "0"
        };
        if ((((wb || {}).Workbook || {}).Views || [])[0]) sview.rightToLeft = wb.Workbook.Views[0].RTL ? "1" : "0";
        return writextag("sheetViews", writextag("sheetView", null, sview), {});
    }
    function write_ws_xml_cell(cell, ref, ws, opts) {
        if (cell.v === undefined && cell.f === undefined || cell.t === "z") return "";
        var vv = "";
        var oldt = cell.t, oldv = cell.v;
        switch (cell.t) {
          case "b":
            vv = cell.v ? "1" : "0";
            break;

          case "n":
            vv = "" + cell.v;
            break;

          case "e":
            vv = BErr[cell.v];
            break;

          case "d":
            if (opts.cellDates) vv = parseDate(cell.v, -1).toISOString(); else {
                cell = dup(cell);
                cell.t = "n";
                vv = "" + (cell.v = datenum(parseDate(cell.v)));
            }
            if (typeof cell.z === "undefined") cell.z = SSF._table[14];
            break;

          default:
            vv = cell.v;
            break;
        }
        var v = writetag("v", escapexml(vv)), o = {
            "r": ref
        };
        var os = get_cell_style(opts.cellXfs, cell, opts);
        if (os !== 0) o.s = os;
        switch (cell.t) {
          case "n":
            break;

          case "d":
            o.t = "d";
            break;

          case "b":
            o.t = "b";
            break;

          case "e":
            o.t = "e";
            break;

          default:
            if (cell.v == null) {
                delete cell.t;
                break;
            }
            if (opts.bookSST) {
                v = writetag("v", "" + get_sst_id(opts.Strings, cell.v, opts.revStrings));
                o.t = "s";
                break;
            }
            o.t = "str";
            break;
        }
        if (cell.t != oldt) {
            cell.t = oldt;
            cell.v = oldv;
        }
        if (cell.f) {
            var ff = cell.F && cell.F.slice(0, ref.length) == ref ? {
                "t": "array",
                "ref": cell.F
            } : null;
            v = writextag("f", escapexml(cell.f), ff) + (cell.v != null ? v : "");
        }
        if (cell.l) ws["!links"].push([ ref, cell.l ]);
        if (cell.c) ws["!comments"].push([ ref, cell.c ]);
        return writextag("c", v, o);
    }
    var parse_ws_xml_data = function() {
        var cellregex = /<(?:\w+:)?c[ >]/, rowregex = /<\/(?:\w+:)?row>/;
        var rregex = /r=["']([^"']*)["']/, isregex = /<(?:\w+:)?is>([\S\s]*?)<\/(?:\w+:)?is>/;
        var refregex = /ref=["']([^"']*)["']/;
        var match_v = matchtag("v"), match_f = matchtag("f");
        return function parse_ws_xml_data(sdata, s, opts, guess, themes, styles) {
            var ri = 0, x = "", cells = [], cref = [], idx = 0, i = 0, cc = 0, d = "", p;
            var tag, tagr = 0, tagc = 0;
            var sstr, ftag;
            var fmtid = 0, fillid = 0;
            var do_format = Array.isArray(styles.CellXf), cf;
            var arrayf = [];
            var sharedf = [];
            var dense = Array.isArray(s);
            var rows = [], rowobj = {}, rowrite = false;
            for (var marr = sdata.split(rowregex), mt = 0, marrlen = marr.length; mt != marrlen; ++mt) {
                x = marr[mt].trim();
                var xlen = x.length;
                if (xlen === 0) continue;
                for (ri = 0; ri < xlen; ++ri) if (x.charCodeAt(ri) === 62) break;
                ++ri;
                tag = parsexmltag(x.slice(0, ri), true);
                tagr = tag.r != null ? parseInt(tag.r, 10) : tagr + 1;
                tagc = -1;
                if (opts.sheetRows && opts.sheetRows < tagr) continue;
                if (guess.s.r > tagr - 1) guess.s.r = tagr - 1;
                if (guess.e.r < tagr - 1) guess.e.r = tagr - 1;
                if (opts && opts.cellStyles) {
                    rowobj = {};
                    rowrite = false;
                    if (tag.ht) {
                        rowrite = true;
                        rowobj.hpt = parseFloat(tag.ht);
                        rowobj.hpx = pt2px(rowobj.hpt);
                    }
                    if (tag.hidden == "1") {
                        rowrite = true;
                        rowobj.hidden = true;
                    }
                    if (tag.outlineLevel != null) {
                        rowrite = true;
                        rowobj.level = +tag.outlineLevel;
                    }
                    if (rowrite) rows[tagr - 1] = rowobj;
                }
                cells = x.slice(ri).split(cellregex);
                for (ri = 0; ri != cells.length; ++ri) {
                    x = cells[ri].trim();
                    if (x.length === 0) continue;
                    cref = x.match(rregex);
                    idx = ri;
                    i = 0;
                    cc = 0;
                    x = "<c " + (x.slice(0, 1) == "<" ? ">" : "") + x;
                    if (cref != null && cref.length === 2) {
                        idx = 0;
                        d = cref[1];
                        for (i = 0; i != d.length; ++i) {
                            if ((cc = d.charCodeAt(i) - 64) < 1 || cc > 26) break;
                            idx = 26 * idx + cc;
                        }
                        --idx;
                        tagc = idx;
                    } else ++tagc;
                    for (i = 0; i != x.length; ++i) if (x.charCodeAt(i) === 62) break;
                    ++i;
                    tag = parsexmltag(x.slice(0, i), true);
                    if (!tag.r) tag.r = encode_cell({
                        "r": tagr - 1,
                        "c": tagc
                    });
                    d = x.slice(i);
                    p = {
                        "t": ""
                    };
                    if ((cref = d.match(match_v)) != null && cref[1] !== "") p.v = unescapexml(cref[1]);
                    if (opts.cellFormula) {
                        if ((cref = d.match(match_f)) != null && cref[1] !== "") {
                            p.f = _xlfn(unescapexml(utf8read(cref[1])));
                            if (cref[0].indexOf('t="array"') > -1) {
                                p.F = (d.match(refregex) || [])[1];
                                if (p.F.indexOf(":") > -1) arrayf.push([ safe_decode_range(p.F), p.F ]);
                            } else if (cref[0].indexOf('t="shared"') > -1) {
                                ftag = parsexmltag(cref[0]);
                                sharedf[parseInt(ftag.si, 10)] = [ ftag, _xlfn(unescapexml(utf8read(cref[1]))) ];
                            }
                        } else if (cref = d.match(/<f[^>]*\/>/)) {
                            ftag = parsexmltag(cref[0]);
                            if (sharedf[ftag.si]) p.f = shift_formula_xlsx(sharedf[ftag.si][1], sharedf[ftag.si][0].ref, tag.r);
                        }
                        var _tag = decode_cell(tag.r);
                        for (i = 0; i < arrayf.length; ++i) if (_tag.r >= arrayf[i][0].s.r && _tag.r <= arrayf[i][0].e.r) if (_tag.c >= arrayf[i][0].s.c && _tag.c <= arrayf[i][0].e.c) p.F = arrayf[i][1];
                    }
                    if (tag.t == null && p.v === undefined) {
                        if (p.f || p.F) {
                            p.v = 0;
                            p.t = "n";
                        } else if (!opts.sheetStubs) continue; else p.t = "z";
                    } else p.t = tag.t || "n";
                    if (guess.s.c > tagc) guess.s.c = tagc;
                    if (guess.e.c < tagc) guess.e.c = tagc;
                    switch (p.t) {
                      case "n":
                        if (p.v == "" || p.v == null) {
                            if (!opts.sheetStubs) continue;
                            p.t = "z";
                        } else p.v = parseFloat(p.v);
                        break;

                      case "s":
                        if (typeof p.v == "undefined") {
                            if (!opts.sheetStubs) continue;
                            p.t = "z";
                        } else {
                            sstr = strs[parseInt(p.v, 10)];
                            p.v = sstr.t;
                            p.r = sstr.r;
                            if (opts.cellHTML) p.h = sstr.h;
                        }
                        break;

                      case "str":
                        p.t = "s";
                        p.v = p.v != null ? utf8read(p.v) : "";
                        if (opts.cellHTML) p.h = escapehtml(p.v);
                        break;

                      case "inlineStr":
                        cref = d.match(isregex);
                        p.t = "s";
                        if (cref != null && (sstr = parse_si(cref[1]))) p.v = sstr.t; else p.v = "";
                        break;

                      case "b":
                        p.v = parsexmlbool(p.v);
                        break;

                      case "d":
                        if (opts.cellDates) p.v = parseDate(p.v, 1); else {
                            p.v = datenum(parseDate(p.v, 1));
                            p.t = "n";
                        }
                        break;

                      case "e":
                        if (!opts || opts.cellText !== false) p.w = p.v;
                        p.v = RBErr[p.v];
                        break;
                    }
                    fmtid = fillid = 0;
                    if (do_format && tag.s !== undefined) {
                        cf = styles.CellXf[tag.s];
                        if (cf != null) {
                            if (cf.numFmtId != null) fmtid = cf.numFmtId;
                            if (opts.cellStyles) {
                                if (cf.fillId != null) fillid = cf.fillId;
                            }
                        }
                    }
                    safe_format(p, fmtid, fillid, opts, themes, styles);
                    if (opts.cellDates && do_format && p.t == "n" && SSF.is_date(SSF._table[fmtid])) {
                        p.t = "d";
                        p.v = numdate(p.v);
                    }
                    if (dense) {
                        var _r = decode_cell(tag.r);
                        if (!s[_r.r]) s[_r.r] = [];
                        s[_r.r][_r.c] = p;
                    } else s[tag.r] = p;
                }
            }
            if (rows.length > 0) s["!rows"] = rows;
        };
    }();
    function write_ws_xml_data(ws, opts, idx, wb) {
        var o = [], r = [], range = safe_decode_range(ws["!ref"]), cell = "", ref, rr = "", cols = [], R = 0, C = 0, rows = ws["!rows"];
        var dense = Array.isArray(ws);
        var params = {
            "r": rr
        }, row, height = -1;
        for (C = range.s.c; C <= range.e.c; ++C) cols[C] = encode_col(C);
        for (R = range.s.r; R <= range.e.r; ++R) {
            r = [];
            rr = encode_row(R);
            for (C = range.s.c; C <= range.e.c; ++C) {
                ref = cols[C] + rr;
                var _cell = dense ? (ws[R] || [])[C] : ws[ref];
                if (_cell === undefined) continue;
                if ((cell = write_ws_xml_cell(_cell, ref, ws, opts, idx, wb)) != null) r.push(cell);
            }
            if (r.length > 0 || rows && rows[R]) {
                params = {
                    "r": rr
                };
                if (rows && rows[R]) {
                    row = rows[R];
                    if (row.hidden) params.hidden = 1;
                    height = -1;
                    if (row.hpx) height = px2pt(row.hpx); else if (row.hpt) height = row.hpt;
                    if (height > -1) {
                        params.ht = height;
                        params.customHeight = 1;
                    }
                    if (row.level) {
                        params.outlineLevel = row.level;
                    }
                }
                o[o.length] = writextag("row", r.join(""), params);
            }
        }
        if (rows) for (;R < rows.length; ++R) {
            if (rows && rows[R]) {
                params = {
                    "r": R + 1
                };
                row = rows[R];
                if (row.hidden) params.hidden = 1;
                height = -1;
                if (row.hpx) height = px2pt(row.hpx); else if (row.hpt) height = row.hpt;
                if (height > -1) {
                    params.ht = height;
                    params.customHeight = 1;
                }
                if (row.level) {
                    params.outlineLevel = row.level;
                }
                o[o.length] = writextag("row", "", params);
            }
        }
        return o.join("");
    }
    var WS_XML_ROOT = writextag("worksheet", null, {
        "xmlns": XMLNS.main[0],
        "xmlns:r": XMLNS.r
    });
    function write_ws_xml(idx, opts, wb, rels) {
        var o = [ XML_HEADER, WS_XML_ROOT ];
        var s = wb.SheetNames[idx], sidx = 0, rdata = "";
        var ws = wb.Sheets[s];
        if (ws == null) ws = {};
        var ref = ws["!ref"] || "A1";
        var range = safe_decode_range(ref);
        if (range.e.c > 16383 || range.e.r > 1048575) {
            if (opts.WTF) throw new Error("Range " + ref + " exceeds format limit A1:XFD1048576");
            range.e.c = Math.min(range.e.c, 16383);
            range.e.r = Math.min(range.e.c, 1048575);
            ref = encode_range(range);
        }
        if (!rels) rels = {};
        ws["!comments"] = [];
        ws["!drawing"] = [];
        if (opts.bookType !== "xlsx" && wb.vbaraw) {
            var cname = wb.SheetNames[idx];
            try {
                if (wb.Workbook) cname = wb.Workbook.Sheets[idx].CodeName || cname;
            } catch (e) {}
            o[o.length] = writextag("sheetPr", null, {
                "codeName": escapexml(cname)
            });
        }
        o[o.length] = writextag("dimension", null, {
            "ref": ref
        });
        o[o.length] = write_ws_xml_sheetviews(ws, opts, idx, wb);
        if (opts.sheetFormat) o[o.length] = writextag("sheetFormatPr", null, {
            "defaultRowHeight": opts.sheetFormat.defaultRowHeight || "16",
            "baseColWidth": opts.sheetFormat.baseColWidth || "10",
            "outlineLevelRow": opts.sheetFormat.outlineLevelRow || "7"
        });
        if (ws["!cols"] != null && ws["!cols"].length > 0) o[o.length] = write_ws_xml_cols(ws, ws["!cols"]);
        o[sidx = o.length] = "<sheetData/>";
        ws["!links"] = [];
        if (ws["!ref"] != null) {
            rdata = write_ws_xml_data(ws, opts, idx, wb, rels);
            if (rdata.length > 0) o[o.length] = rdata;
        }
        if (o.length > sidx + 1) {
            o[o.length] = "</sheetData>";
            o[sidx] = o[sidx].replace("/>", ">");
        }
        if (ws["!protect"] != null) o[o.length] = write_ws_xml_protection(ws["!protect"]);
        if (ws["!autofilter"] != null) o[o.length] = write_ws_xml_autofilter(ws["!autofilter"]);
        if (ws["!merges"] != null && ws["!merges"].length > 0) o[o.length] = write_ws_xml_merges(ws["!merges"]);
        var relc = -1, rel, rId = -1;
        if (ws["!links"].length > 0) {
            o[o.length] = "<hyperlinks>";
            ws["!links"].forEach(function(l) {
                if (!l[1].Target) return;
                rel = {
                    "ref": l[0]
                };
                if (l[1].Target.charAt(0) != "#") {
                    rId = add_rels(rels, -1, escapexml(l[1].Target).replace(/#.*$/, ""), RELS.HLINK);
                    rel["r:id"] = "rId" + rId;
                }
                if ((relc = l[1].Target.indexOf("#")) > -1) rel.location = escapexml(l[1].Target.slice(relc + 1));
                if (l[1].Tooltip) rel.tooltip = escapexml(l[1].Tooltip);
                o[o.length] = writextag("hyperlink", null, rel);
            });
            o[o.length] = "</hyperlinks>";
        }
        delete ws["!links"];
        if (ws["!margins"] != null) o[o.length] = write_ws_xml_margins(ws["!margins"]);
        o[o.length] = "";
        if (!opts || opts.ignoreEC || opts.ignoreEC == void 0) o[o.length] = writetag("ignoredErrors", writextag("ignoredError", null, {
            "numberStoredAsText": 1,
            "sqref": ref
        }));
        if (ws["!drawing"].length > 0) {
            rId = add_rels(rels, -1, "../drawings/drawing" + (idx + 1) + ".xml", RELS.DRAW);
            o[o.length] = writextag("drawing", null, {
                "r:id": "rId" + rId
            });
        } else delete ws["!drawing"];
        if (ws["!comments"].length > 0) {
            rId = add_rels(rels, -1, "../drawings/vmlDrawing" + (idx + 1) + ".vml", RELS.VML);
            o[o.length] = writextag("legacyDrawing", null, {
                "r:id": "rId" + rId
            });
            ws["!legacy"] = rId;
        }
        if (o.length > 2) {
            o[o.length] = "</worksheet>";
            o[1] = o[1].replace("/>", ">");
        }
        return o.join("");
    }
    function parse_BrtRowHdr(data, length) {
        var z = {};
        var tgt = data.l + length;
        z.r = data.read_shift(4);
        data.l += 4;
        var miyRw = data.read_shift(2);
        data.l += 1;
        var flags = data.read_shift(1);
        data.l = tgt;
        if (flags & 7) z.level = flags & 7;
        if (flags & 16) z.hidden = true;
        if (flags & 32) z.hpt = miyRw / 20;
        return z;
    }
    function write_BrtRowHdr(R, range, ws) {
        var o = new_buf(17 + 8 * 16);
        var row = (ws["!rows"] || [])[R] || {};
        o.write_shift(4, R);
        o.write_shift(4, 0);
        var miyRw = 320;
        if (row.hpx) miyRw = px2pt(row.hpx) * 20; else if (row.hpt) miyRw = row.hpt * 20;
        o.write_shift(2, miyRw);
        o.write_shift(1, 0);
        var flags = 0;
        if (row.level) flags |= row.level;
        if (row.hidden) flags |= 16;
        if (row.hpx || row.hpt) flags |= 32;
        o.write_shift(1, flags);
        o.write_shift(1, 0);
        var ncolspan = 0, lcs = o.l;
        o.l += 4;
        var caddr = {
            "r": R,
            "c": 0
        };
        for (var i = 0; i < 16; ++i) {
            if (range.s.c > i + 1 << 10 || range.e.c < i << 10) continue;
            var first = -1, last = -1;
            for (var j = i << 10; j < i + 1 << 10; ++j) {
                caddr.c = j;
                var cell = Array.isArray(ws) ? (ws[caddr.r] || [])[caddr.c] : ws[encode_cell(caddr)];
                if (cell) {
                    if (first < 0) first = j;
                    last = j;
                }
            }
            if (first < 0) continue;
            ++ncolspan;
            o.write_shift(4, first);
            o.write_shift(4, last);
        }
        var l = o.l;
        o.l = lcs;
        o.write_shift(4, ncolspan);
        o.l = l;
        return o.length > o.l ? o.slice(0, o.l) : o;
    }
    function write_row_header(ba, ws, range, R) {
        var o = write_BrtRowHdr(R, range, ws);
        if (o.length > 17 || (ws["!rows"] || [])[R]) write_record(ba, "BrtRowHdr", o);
    }
    var parse_BrtWsDim = parse_UncheckedRfX;
    var write_BrtWsDim = write_UncheckedRfX;
    function parse_BrtWsFmtInfo() {}
    function parse_BrtWsProp(data, length) {
        var z = {};
        data.l += 19;
        z.name = parse_XLSBCodeName(data, length - 19);
        return z;
    }
    function write_BrtWsProp(str, o) {
        if (o == null) o = new_buf(84 + 4 * str.length);
        for (var i = 0; i < 3; ++i) o.write_shift(1, 0);
        write_BrtColor({
            "auto": 1
        }, o);
        o.write_shift(-4, -1);
        o.write_shift(-4, -1);
        write_XLSBCodeName(str, o);
        return o.slice(0, o.l);
    }
    function parse_BrtCellBlank(data) {
        var cell = parse_XLSBCell(data);
        return [ cell ];
    }
    function write_BrtCellBlank(cell, ncell, o) {
        if (o == null) o = new_buf(8);
        return write_XLSBCell(ncell, o);
    }
    function parse_BrtCellBool(data) {
        var cell = parse_XLSBCell(data);
        var fBool = data.read_shift(1);
        return [ cell, fBool, "b" ];
    }
    function write_BrtCellBool(cell, ncell, o) {
        if (o == null) o = new_buf(9);
        write_XLSBCell(ncell, o);
        o.write_shift(1, cell.v ? 1 : 0);
        return o;
    }
    function parse_BrtCellError(data) {
        var cell = parse_XLSBCell(data);
        var bError = data.read_shift(1);
        return [ cell, bError, "e" ];
    }
    function parse_BrtCellIsst(data) {
        var cell = parse_XLSBCell(data);
        var isst = data.read_shift(4);
        return [ cell, isst, "s" ];
    }
    function write_BrtCellIsst(cell, ncell, o) {
        if (o == null) o = new_buf(12);
        write_XLSBCell(ncell, o);
        o.write_shift(4, ncell.v);
        return o;
    }
    function parse_BrtCellReal(data) {
        var cell = parse_XLSBCell(data);
        var value = parse_Xnum(data);
        return [ cell, value, "n" ];
    }
    function write_BrtCellReal(cell, ncell, o) {
        if (o == null) o = new_buf(16);
        write_XLSBCell(ncell, o);
        write_Xnum(cell.v, o);
        return o;
    }
    function parse_BrtCellRk(data) {
        var cell = parse_XLSBCell(data);
        var value = parse_RkNumber(data);
        return [ cell, value, "n" ];
    }
    function write_BrtCellRk(cell, ncell, o) {
        if (o == null) o = new_buf(12);
        write_XLSBCell(ncell, o);
        write_RkNumber(cell.v, o);
        return o;
    }
    function parse_BrtCellSt(data) {
        var cell = parse_XLSBCell(data);
        var value = parse_XLWideString(data);
        return [ cell, value, "str" ];
    }
    function write_BrtCellSt(cell, ncell, o) {
        if (o == null) o = new_buf(12 + 4 * cell.v.length);
        write_XLSBCell(ncell, o);
        write_XLWideString(cell.v, o);
        return o.length > o.l ? o.slice(0, o.l) : o;
    }
    function parse_BrtFmlaBool(data, length, opts) {
        var end = data.l + length;
        var cell = parse_XLSBCell(data);
        cell.r = opts["!row"];
        var value = data.read_shift(1);
        var o = [ cell, value, "b" ];
        if (opts.cellFormula) {
            data.l += 2;
            var formula = parse_XLSBCellParsedFormula(data, end - data.l, opts);
            o[3] = stringify_formula(formula, null, cell, opts.supbooks, opts);
        } else data.l = end;
        return o;
    }
    function parse_BrtFmlaError(data, length, opts) {
        var end = data.l + length;
        var cell = parse_XLSBCell(data);
        cell.r = opts["!row"];
        var value = data.read_shift(1);
        var o = [ cell, value, "e" ];
        if (opts.cellFormula) {
            data.l += 2;
            var formula = parse_XLSBCellParsedFormula(data, end - data.l, opts);
            o[3] = stringify_formula(formula, null, cell, opts.supbooks, opts);
        } else data.l = end;
        return o;
    }
    function parse_BrtFmlaNum(data, length, opts) {
        var end = data.l + length;
        var cell = parse_XLSBCell(data);
        cell.r = opts["!row"];
        var value = parse_Xnum(data);
        var o = [ cell, value, "n" ];
        if (opts.cellFormula) {
            data.l += 2;
            var formula = parse_XLSBCellParsedFormula(data, end - data.l, opts);
            o[3] = stringify_formula(formula, null, cell, opts.supbooks, opts);
        } else data.l = end;
        return o;
    }
    function parse_BrtFmlaString(data, length, opts) {
        var end = data.l + length;
        var cell = parse_XLSBCell(data);
        cell.r = opts["!row"];
        var value = parse_XLWideString(data);
        var o = [ cell, value, "str" ];
        if (opts.cellFormula) {
            data.l += 2;
            var formula = parse_XLSBCellParsedFormula(data, end - data.l, opts);
            o[3] = stringify_formula(formula, null, cell, opts.supbooks, opts);
        } else data.l = end;
        return o;
    }
    var parse_BrtMergeCell = parse_UncheckedRfX;
    var write_BrtMergeCell = write_UncheckedRfX;
    function write_BrtBeginMergeCells(cnt, o) {
        if (o == null) o = new_buf(4);
        o.write_shift(4, cnt);
        return o;
    }
    function parse_BrtHLink(data, length) {
        var end = data.l + length;
        var rfx = parse_UncheckedRfX(data, 16);
        var relId = parse_XLNullableWideString(data);
        var loc = parse_XLWideString(data);
        var tooltip = parse_XLWideString(data);
        var display = parse_XLWideString(data);
        data.l = end;
        var o = {
            "rfx": rfx,
            "relId": relId,
            "loc": loc,
            "display": display
        };
        if (tooltip) o.Tooltip = tooltip;
        return o;
    }
    function write_BrtHLink(l, rId) {
        var o = new_buf(50 + 4 * (l[1].Target.length + (l[1].Tooltip || "").length));
        write_UncheckedRfX({
            "s": decode_cell(l[0]),
            "e": decode_cell(l[0])
        }, o);
        write_RelID("rId" + rId, o);
        var locidx = l[1].Target.indexOf("#");
        var loc = locidx == -1 ? "" : l[1].Target.slice(locidx + 1);
        write_XLWideString(loc || "", o);
        write_XLWideString(l[1].Tooltip || "", o);
        write_XLWideString("", o);
        return o.slice(0, o.l);
    }
    function parse_BrtArrFmla(data, length, opts) {
        var end = data.l + length;
        var rfx = parse_RfX(data, 16);
        var fAlwaysCalc = data.read_shift(1);
        var o = [ rfx ];
        o[2] = fAlwaysCalc;
        if (opts.cellFormula) {
            var formula = parse_XLSBArrayParsedFormula(data, end - data.l, opts);
            o[1] = formula;
        } else data.l = end;
        return o;
    }
    function parse_BrtShrFmla(data, length, opts) {
        var end = data.l + length;
        var rfx = parse_UncheckedRfX(data, 16);
        var o = [ rfx ];
        if (opts.cellFormula) {
            var formula = parse_XLSBSharedParsedFormula(data, end - data.l, opts);
            o[1] = formula;
            data.l = end;
        } else data.l = end;
        return o;
    }
    function write_BrtColInfo(C, col, o) {
        if (o == null) o = new_buf(18);
        var p = col_obj_w(C, col);
        o.write_shift(-4, C);
        o.write_shift(-4, C);
        o.write_shift(4, (p.width || 10) * 256);
        o.write_shift(4, 0);
        var flags = 0;
        if (col.hidden) flags |= 1;
        if (typeof p.width == "number") flags |= 2;
        o.write_shift(1, flags);
        o.write_shift(1, 0);
        return o;
    }
    var BrtMarginKeys = [ "left", "right", "top", "bottom", "header", "footer" ];
    function parse_BrtMargins(data) {
        var margins = {};
        BrtMarginKeys.forEach(function(k) {
            margins[k] = parse_Xnum(data, 8);
        });
        return margins;
    }
    function write_BrtMargins(margins, o) {
        if (o == null) o = new_buf(6 * 8);
        default_margins(margins);
        BrtMarginKeys.forEach(function(k) {
            write_Xnum(margins[k], o);
        });
        return o;
    }
    function parse_BrtBeginWsView(data) {
        var f = data.read_shift(2);
        data.l += 28;
        return {
            "RTL": f & 32
        };
    }
    function write_BrtBeginWsView(ws, Workbook, o) {
        if (o == null) o = new_buf(30);
        var f = 924;
        if ((((Workbook || {}).Views || [])[0] || {}).RTL) f |= 32;
        o.write_shift(2, f);
        o.write_shift(4, 0);
        o.write_shift(4, 0);
        o.write_shift(4, 0);
        o.write_shift(1, 0);
        o.write_shift(1, 0);
        o.write_shift(2, 0);
        o.write_shift(2, 100);
        o.write_shift(2, 0);
        o.write_shift(2, 0);
        o.write_shift(2, 0);
        o.write_shift(4, 0);
        return o;
    }
    function write_BrtCellIgnoreEC(ref) {
        var o = new_buf(24);
        o.write_shift(4, 4);
        o.write_shift(4, 1);
        write_UncheckedRfX(ref, o);
        return o;
    }
    function write_BrtSheetProtection(sp, o) {
        if (o == null) o = new_buf(16 * 4 + 2);
        o.write_shift(2, sp.password ? crypto_CreatePasswordVerifier_Method1(sp.password) : 0);
        o.write_shift(4, 1);
        [ [ "objects", false ], [ "scenarios", false ], [ "formatCells", true ], [ "formatColumns", true ], [ "formatRows", true ], [ "insertColumns", true ], [ "insertRows", true ], [ "insertHyperlinks", true ], [ "deleteColumns", true ], [ "deleteRows", true ], [ "selectLockedCells", false ], [ "sort", true ], [ "autoFilter", true ], [ "pivotTables", true ], [ "selectUnlockedCells", false ] ].forEach(function(n) {
            if (n[1]) o.write_shift(4, sp[n[0]] != null && !sp[n[0]] ? 1 : 0); else o.write_shift(4, sp[n[0]] != null && sp[n[0]] ? 0 : 1);
        });
        return o;
    }
    function parse_ws_bin(data, _opts, idx, rels, wb, themes, styles) {
        if (!data) return data;
        var opts = _opts || {};
        if (!rels) rels = {
            "!id": {}
        };
        if (DENSE != null && opts.dense == null) opts.dense = DENSE;
        var s = opts.dense ? [] : {};
        var ref;
        var refguess = {
            "s": {
                "r": 2e6,
                "c": 2e6
            },
            "e": {
                "r": 0,
                "c": 0
            }
        };
        var pass = false, end = false;
        var row, p, cf, R, C, addr, sstr, rr, cell;
        var merges = [];
        opts.biff = 12;
        opts["!row"] = 0;
        var ai = 0, af = false;
        var arrayf = [];
        var sharedf = {};
        var supbooks = opts.supbooks || [ [] ];
        supbooks.sharedf = sharedf;
        supbooks.arrayf = arrayf;
        supbooks.SheetNames = wb.SheetNames || wb.Sheets.map(function(x) {
            return x.name;
        });
        if (!opts.supbooks) {
            opts.supbooks = supbooks;
            if (wb.Names) for (var i = 0; i < wb.Names.length; ++i) supbooks[0][i + 1] = wb.Names[i];
        }
        var colinfo = [], rowinfo = [];
        var seencol = false;
        recordhopper(data, function ws_parse(val, R_n, RT) {
            if (end) return;
            switch (RT) {
              case 148:
                ref = val;
                break;

              case 0:
                row = val;
                if (opts.sheetRows && opts.sheetRows <= row.r) end = true;
                rr = encode_row(R = row.r);
                opts["!row"] = row.r;
                if (val.hidden || val.hpt || val.level != null) {
                    if (val.hpt) val.hpx = pt2px(val.hpt);
                    rowinfo[val.r] = val;
                }
                break;

              case 2:
              case 3:
              case 4:
              case 5:
              case 6:
              case 7:
              case 8:
              case 9:
              case 10:
              case 11:
                p = {
                    "t": val[2]
                };
                switch (val[2]) {
                  case "n":
                    p.v = val[1];
                    break;

                  case "s":
                    sstr = strs[val[1]];
                    p.v = sstr.t;
                    p.r = sstr.r;
                    break;

                  case "b":
                    p.v = val[1] ? true : false;
                    break;

                  case "e":
                    p.v = val[1];
                    if (opts.cellText !== false) p.w = BErr[p.v];
                    break;

                  case "str":
                    p.t = "s";
                    p.v = val[1];
                    break;
                }
                if (cf = styles.CellXf[val[0].iStyleRef]) safe_format(p, cf.numFmtId, null, opts, themes, styles);
                C = val[0].c;
                if (opts.dense) {
                    if (!s[R]) s[R] = [];
                    s[R][C] = p;
                } else s[encode_col(C) + rr] = p;
                if (opts.cellFormula) {
                    af = false;
                    for (ai = 0; ai < arrayf.length; ++ai) {
                        var aii = arrayf[ai];
                        if (row.r >= aii[0].s.r && row.r <= aii[0].e.r) if (C >= aii[0].s.c && C <= aii[0].e.c) {
                            p.F = encode_range(aii[0]);
                            af = true;
                        }
                    }
                    if (!af && val.length > 3) p.f = val[3];
                }
                if (refguess.s.r > row.r) refguess.s.r = row.r;
                if (refguess.s.c > C) refguess.s.c = C;
                if (refguess.e.r < row.r) refguess.e.r = row.r;
                if (refguess.e.c < C) refguess.e.c = C;
                if (opts.cellDates && cf && p.t == "n" && SSF.is_date(SSF._table[cf.numFmtId])) {
                    var _d = SSF.parse_date_code(p.v);
                    if (_d) {
                        p.t = "d";
                        p.v = new Date(_d.y, _d.m - 1, _d.d, _d.H, _d.M, _d.S, _d.u);
                    }
                }
                break;

              case 1:
                if (!opts.sheetStubs || pass) break;
                p = {
                    "t": "z",
                    "v": undefined
                };
                C = val[0].c;
                if (opts.dense) {
                    if (!s[R]) s[R] = [];
                    s[R][C] = p;
                } else s[encode_col(C) + rr] = p;
                if (refguess.s.r > row.r) refguess.s.r = row.r;
                if (refguess.s.c > C) refguess.s.c = C;
                if (refguess.e.r < row.r) refguess.e.r = row.r;
                if (refguess.e.c < C) refguess.e.c = C;
                break;

              case 176:
                merges.push(val);
                break;

              case 494:
                var rel = rels["!id"][val.relId];
                if (rel) {
                    val.Target = rel.Target;
                    if (val.loc) val.Target += "#" + val.loc;
                    val.Rel = rel;
                } else if (val.relId == "") {
                    val.Target = "#" + val.loc;
                }
                for (R = val.rfx.s.r; R <= val.rfx.e.r; ++R) for (C = val.rfx.s.c; C <= val.rfx.e.c; ++C) {
                    if (opts.dense) {
                        if (!s[R]) s[R] = [];
                        if (!s[R][C]) s[R][C] = {
                            "t": "z",
                            "v": undefined
                        };
                        s[R][C].l = val;
                    } else {
                        addr = encode_cell({
                            "c": C,
                            "r": R
                        });
                        if (!s[addr]) s[addr] = {
                            "t": "z",
                            "v": undefined
                        };
                        s[addr].l = val;
                    }
                }
                break;

              case 426:
                if (!opts.cellFormula) break;
                arrayf.push(val);
                cell = opts.dense ? s[R][C] : s[encode_col(C) + rr];
                cell.f = stringify_formula(val[1], refguess, {
                    "r": row.r,
                    "c": C
                }, supbooks, opts);
                cell.F = encode_range(val[0]);
                break;

              case 427:
                if (!opts.cellFormula) break;
                sharedf[encode_cell(val[0].s)] = val[1];
                cell = opts.dense ? s[R][C] : s[encode_col(C) + rr];
                cell.f = stringify_formula(val[1], refguess, {
                    "r": row.r,
                    "c": C
                }, supbooks, opts);
                break;

              case 60:
                if (!opts.cellStyles) break;
                while (val.e >= val.s) {
                    colinfo[val.e--] = {
                        "width": val.w / 256,
                        "hidden": !!(val.flags & 1)
                    };
                    if (!seencol) {
                        seencol = true;
                        find_mdw_colw(val.w / 256);
                    }
                    process_col(colinfo[val.e + 1]);
                }
                break;

              case 161:
                s["!autofilter"] = {
                    "ref": encode_range(val)
                };
                break;

              case 476:
                s["!margins"] = val;
                break;

              case 147:
                if (!wb.Sheets[idx]) wb.Sheets[idx] = {};
                if (val.name) wb.Sheets[idx].CodeName = val.name;
                break;

              case 137:
                if (!wb.Views) wb.Views = [ {} ];
                if (!wb.Views[0]) wb.Views[0] = {};
                if (val.RTL) wb.Views[0].RTL = true;
                break;

              case 485:
                break;

              case 175:
              case 644:
              case 625:
              case 562:
              case 396:
              case 1112:
              case 1146:
              case 471:
              case 1050:
              case 649:
              case 1105:
              case 49:
              case 589:
              case 607:
              case 564:
              case 1055:
              case 168:
              case 174:
              case 1180:
              case 499:
              case 64:
              case 1053:
              case 550:
              case 171:
              case 167:
              case 1177:
              case 169:
              case 1181:
              case 551:
              case 552:
              case 661:
              case 639:
              case 478:
              case 151:
              case 537:
              case 477:
              case 536:
              case 1103:
              case 680:
              case 1104:
              case 1024:
              case 152:
              case 663:
              case 535:
              case 678:
              case 504:
              case 1043:
              case 428:
              case 170:
              case 3072:
              case 50:
              case 2070:
              case 1045:
                break;

              case 35:
                pass = true;
                break;

              case 36:
                pass = false;
                break;

              case 37:
                break;

              case 38:
                break;

              default:
                if ((R_n || "").indexOf("Begin") > 0) {} else if ((R_n || "").indexOf("End") > 0) {} else if (!pass || opts.WTF) throw new Error("Unexpected record " + RT + " " + R_n);
            }
        }, opts);
        delete opts.supbooks;
        delete opts["!row"];
        if (!s["!ref"] && (refguess.s.r < 2e6 || ref && (ref.e.r > 0 || ref.e.c > 0 || ref.s.r > 0 || ref.s.c > 0))) s["!ref"] = encode_range(ref || refguess);
        if (opts.sheetRows && s["!ref"]) {
            var tmpref = safe_decode_range(s["!ref"]);
            if (opts.sheetRows <= +tmpref.e.r) {
                tmpref.e.r = opts.sheetRows - 1;
                if (tmpref.e.r > refguess.e.r) tmpref.e.r = refguess.e.r;
                if (tmpref.e.r < tmpref.s.r) tmpref.s.r = tmpref.e.r;
                if (tmpref.e.c > refguess.e.c) tmpref.e.c = refguess.e.c;
                if (tmpref.e.c < tmpref.s.c) tmpref.s.c = tmpref.e.c;
                s["!fullref"] = s["!ref"];
                s["!ref"] = encode_range(tmpref);
            }
        }
        if (merges.length > 0) s["!merges"] = merges;
        if (colinfo.length > 0) s["!cols"] = colinfo;
        if (rowinfo.length > 0) s["!rows"] = rowinfo;
        return s;
    }
    function write_ws_bin_cell(ba, cell, R, C, opts, ws) {
        if (cell.v === undefined) return "";
        var vv = "";
        switch (cell.t) {
          case "b":
            vv = cell.v ? "1" : "0";
            break;

          case "d":
            cell = dup(cell);
            cell.z = cell.z || SSF._table[14];
            cell.v = datenum(parseDate(cell.v));
            cell.t = "n";
            break;

          case "n":
          case "e":
            vv = "" + cell.v;
            break;

          default:
            vv = cell.v;
            break;
        }
        var o = {
            "r": R,
            "c": C
        };
        o.s = get_cell_style(opts.cellXfs, cell, opts);
        if (cell.l) ws["!links"].push([ encode_cell(o), cell.l ]);
        if (cell.c) ws["!comments"].push([ encode_cell(o), cell.c ]);
        switch (cell.t) {
          case "s":
          case "str":
            if (opts.bookSST) {
                vv = get_sst_id(opts.Strings, cell.v, opts.revStrings);
                o.t = "s";
                o.v = vv;
                write_record(ba, "BrtCellIsst", write_BrtCellIsst(cell, o));
            } else {
                o.t = "str";
                write_record(ba, "BrtCellSt", write_BrtCellSt(cell, o));
            }
            return;

          case "n":
            if (cell.v == (cell.v | 0) && cell.v > -1e3 && cell.v < 1e3) write_record(ba, "BrtCellRk", write_BrtCellRk(cell, o)); else write_record(ba, "BrtCellReal", write_BrtCellReal(cell, o));
            return;

          case "b":
            o.t = "b";
            write_record(ba, "BrtCellBool", write_BrtCellBool(cell, o));
            return;

          case "e":
            o.t = "e";
            break;
        }
        write_record(ba, "BrtCellBlank", write_BrtCellBlank(cell, o));
    }
    function write_CELLTABLE(ba, ws, idx, opts) {
        var range = safe_decode_range(ws["!ref"] || "A1"), ref, rr = "", cols = [];
        write_record(ba, "BrtBeginSheetData");
        var dense = Array.isArray(ws);
        var cap = range.e.r;
        if (ws["!rows"]) cap = Math.max(range.e.r, ws["!rows"].length - 1);
        for (var R = range.s.r; R <= cap; ++R) {
            rr = encode_row(R);
            write_row_header(ba, ws, range, R);
            if (R <= range.e.r) for (var C = range.s.c; C <= range.e.c; ++C) {
                if (R === range.s.r) cols[C] = encode_col(C);
                ref = cols[C] + rr;
                var cell = dense ? (ws[R] || [])[C] : ws[ref];
                if (!cell) continue;
                write_ws_bin_cell(ba, cell, R, C, opts, ws);
            }
        }
        write_record(ba, "BrtEndSheetData");
    }
    function write_MERGECELLS(ba, ws) {
        if (!ws || !ws["!merges"]) return;
        write_record(ba, "BrtBeginMergeCells", write_BrtBeginMergeCells(ws["!merges"].length));
        ws["!merges"].forEach(function(m) {
            write_record(ba, "BrtMergeCell", write_BrtMergeCell(m));
        });
        write_record(ba, "BrtEndMergeCells");
    }
    function write_COLINFOS(ba, ws) {
        if (!ws || !ws["!cols"]) return;
        write_record(ba, "BrtBeginColInfos");
        ws["!cols"].forEach(function(m, i) {
            if (m) write_record(ba, "BrtColInfo", write_BrtColInfo(i, m));
        });
        write_record(ba, "BrtEndColInfos");
    }
    function write_IGNOREECS(ba, ws) {
        if (!ws || !ws["!ref"]) return;
        write_record(ba, "BrtBeginCellIgnoreECs");
        write_record(ba, "BrtCellIgnoreEC", write_BrtCellIgnoreEC(safe_decode_range(ws["!ref"])));
        write_record(ba, "BrtEndCellIgnoreECs");
    }
    function write_HLINKS(ba, ws, rels) {
        ws["!links"].forEach(function(l) {
            if (!l[1].Target) return;
            var rId = add_rels(rels, -1, l[1].Target.replace(/#.*$/, ""), RELS.HLINK);
            write_record(ba, "BrtHLink", write_BrtHLink(l, rId));
        });
        delete ws["!links"];
    }
    function write_LEGACYDRAWING(ba, ws, idx, rels) {
        if (ws["!comments"].length > 0) {
            var rId = add_rels(rels, -1, "../drawings/vmlDrawing" + (idx + 1) + ".vml", RELS.VML);
            write_record(ba, "BrtLegacyDrawing", write_RelID("rId" + rId));
            ws["!legacy"] = rId;
        }
    }
    function write_AUTOFILTER(ba, ws) {
        if (!ws["!autofilter"]) return;
        write_record(ba, "BrtBeginAFilter", write_UncheckedRfX(safe_decode_range(ws["!autofilter"].ref)));
        write_record(ba, "BrtEndAFilter");
    }
    function write_WSVIEWS2(ba, ws, Workbook) {
        write_record(ba, "BrtBeginWsViews");
        {
            write_record(ba, "BrtBeginWsView", write_BrtBeginWsView(ws, Workbook));
            write_record(ba, "BrtEndWsView");
        }
        write_record(ba, "BrtEndWsViews");
    }
    function write_WSFMTINFO() {}
    function write_SHEETPROTECT(ba, ws) {
        if (!ws["!protect"]) return;
        write_record(ba, "BrtSheetProtection", write_BrtSheetProtection(ws["!protect"]));
    }
    function write_ws_bin(idx, opts, wb, rels) {
        var ba = buf_array();
        var s = wb.SheetNames[idx], ws = wb.Sheets[s] || {};
        var c = s;
        try {
            if (wb && wb.Workbook) c = wb.Workbook.Sheets[idx].CodeName || c;
        } catch (e) {}
        var r = safe_decode_range(ws["!ref"] || "A1");
        if (r.e.c > 16383 || r.e.r > 1048575) {
            if (opts.WTF) throw new Error("Range " + (ws["!ref"] || "A1") + " exceeds format limit A1:XFD1048576");
            r.e.c = Math.min(r.e.c, 16383);
            r.e.r = Math.min(r.e.c, 1048575);
        }
        ws["!links"] = [];
        ws["!comments"] = [];
        write_record(ba, "BrtBeginSheet");
        if (wb.vbaraw) write_record(ba, "BrtWsProp", write_BrtWsProp(c));
        write_record(ba, "BrtWsDim", write_BrtWsDim(r));
        write_WSVIEWS2(ba, ws, wb.Workbook);
        write_WSFMTINFO(ba, ws);
        write_COLINFOS(ba, ws, idx, opts, wb);
        write_CELLTABLE(ba, ws, idx, opts, wb);
        write_SHEETPROTECT(ba, ws);
        write_AUTOFILTER(ba, ws);
        write_MERGECELLS(ba, ws);
        write_HLINKS(ba, ws, rels);
        if (ws["!margins"]) write_record(ba, "BrtMargins", write_BrtMargins(ws["!margins"]));
        if (!opts || opts.ignoreEC || opts.ignoreEC == void 0) write_IGNOREECS(ba, ws);
        write_LEGACYDRAWING(ba, ws, idx, rels);
        write_record(ba, "BrtEndSheet");
        return ba.end();
    }
    function parse_numCache(data) {
        var col = [];
        (data.match(/<c:pt idx="(\d*)">(.*?)<\/c:pt>/gm) || []).forEach(function(pt) {
            var q = pt.match(/<c:pt idx="(\d*?)"><c:v>(.*)<\/c:v><\/c:pt>/);
            if (!q) return;
            col[+q[1]] = +q[2];
        });
        var nf = unescapexml((data.match(/<c:formatCode>([\s\S]*?)<\/c:formatCode>/) || [ "", "General" ])[1]);
        return [ col, nf ];
    }
    function parse_chart(data, name, opts, rels, wb, csheet) {
        var cs = csheet || {
            "!type": "chart"
        };
        if (!data) return csheet;
        var C = 0, R = 0, col = "A";
        var refguess = {
            "s": {
                "r": 2e6,
                "c": 2e6
            },
            "e": {
                "r": 0,
                "c": 0
            }
        };
        (data.match(/<c:numCache>[\s\S]*?<\/c:numCache>/gm) || []).forEach(function(nc) {
            var cache = parse_numCache(nc);
            refguess.s.r = refguess.s.c = 0;
            refguess.e.c = C;
            col = encode_col(C);
            cache[0].forEach(function(n, i) {
                cs[col + encode_row(i)] = {
                    "t": "n",
                    "v": n,
                    "z": cache[1]
                };
                R = i;
            });
            if (refguess.e.r < R) refguess.e.r = R;
            ++C;
        });
        if (C > 0) cs["!ref"] = encode_range(refguess);
        return cs;
    }
    RELS.CS = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/chartsheet";
    var CS_XML_ROOT = writextag("chartsheet", null, {
        "xmlns": XMLNS.main[0],
        "xmlns:r": XMLNS.r
    });
    function parse_cs_xml(data, opts, idx, rels, wb) {
        if (!data) return data;
        if (!rels) rels = {
            "!id": {}
        };
        var s = {
            "!type": "chart",
            "!chart": null,
            "!rel": ""
        };
        var m;
        var sheetPr = data.match(sheetprregex);
        if (sheetPr) parse_ws_xml_sheetpr(sheetPr[0], s, wb, idx);
        if (m = data.match(/drawing r:id="(.*?)"/)) s["!rel"] = m[1];
        if (rels["!id"][s["!rel"]]) s["!chart"] = rels["!id"][s["!rel"]];
        return s;
    }
    function write_cs_xml(idx, opts, wb, rels) {
        var o = [ XML_HEADER, CS_XML_ROOT ];
        o[o.length] = writextag("drawing", null, {
            "r:id": "rId1"
        });
        add_rels(rels, -1, "../drawings/drawing" + (idx + 1) + ".xml", RELS.DRAW);
        if (o.length > 2) {
            o[o.length] = "</chartsheet>";
            o[1] = o[1].replace("/>", ">");
        }
        return o.join("");
    }
    function parse_BrtCsProp(data, length) {
        data.l += 10;
        var name = parse_XLWideString(data, length - 10);
        return {
            "name": name
        };
    }
    function parse_cs_bin(data, opts, idx, rels, wb) {
        if (!data) return data;
        if (!rels) rels = {
            "!id": {}
        };
        var s = {
            "!type": "chart",
            "!chart": null,
            "!rel": ""
        };
        var state = [];
        var pass = false;
        recordhopper(data, function cs_parse(val, R_n, RT) {
            switch (RT) {
              case 550:
                s["!rel"] = val;
                break;

              case 651:
                if (!wb.Sheets[idx]) wb.Sheets[idx] = {};
                if (val.name) wb.Sheets[idx].CodeName = val.name;
                break;

              case 562:
              case 652:
              case 669:
              case 679:
              case 551:
              case 552:
              case 476:
              case 3072:
                break;

              case 35:
                pass = true;
                break;

              case 36:
                pass = false;
                break;

              case 37:
                state.push(R_n);
                break;

              case 38:
                state.pop();
                break;

              default:
                if ((R_n || "").indexOf("Begin") > 0) state.push(R_n); else if ((R_n || "").indexOf("End") > 0) state.pop(); else if (!pass || opts.WTF) throw new Error("Unexpected record " + RT + " " + R_n);
            }
        }, opts);
        if (rels["!id"][s["!rel"]]) s["!chart"] = rels["!id"][s["!rel"]];
        return s;
    }
    function write_cs_bin() {
        var ba = buf_array();
        write_record(ba, "BrtBeginSheet");
        write_record(ba, "BrtEndSheet");
        return ba.end();
    }
    var WBPropsDef = [ [ "allowRefreshQuery", false, "bool" ], [ "autoCompressPictures", true, "bool" ], [ "backupFile", false, "bool" ], [ "checkCompatibility", false, "bool" ], [ "CodeName", "" ], [ "date1904", false, "bool" ], [ "defaultThemeVersion", 0, "int" ], [ "filterPrivacy", false, "bool" ], [ "hidePivotFieldList", false, "bool" ], [ "promptedSolutions", false, "bool" ], [ "publishItems", false, "bool" ], [ "refreshAllConnections", false, "bool" ], [ "saveExternalLinkValues", true, "bool" ], [ "showBorderUnselectedTables", true, "bool" ], [ "showInkAnnotation", true, "bool" ], [ "showObjects", "all" ], [ "showPivotChartFilter", false, "bool" ], [ "updateLinks", "userSet" ] ];
    var WBViewDef = [ [ "activeTab", 0, "int" ], [ "autoFilterDateGrouping", true, "bool" ], [ "firstSheet", 0, "int" ], [ "minimized", false, "bool" ], [ "showHorizontalScroll", true, "bool" ], [ "showSheetTabs", true, "bool" ], [ "showVerticalScroll", true, "bool" ], [ "tabRatio", 600, "int" ], [ "visibility", "visible" ] ];
    var SheetDef = [];
    var CalcPrDef = [ [ "calcCompleted", "true" ], [ "calcMode", "auto" ], [ "calcOnSave", "true" ], [ "concurrentCalc", "true" ], [ "fullCalcOnLoad", "false" ], [ "fullPrecision", "true" ], [ "iterate", "false" ], [ "iterateCount", "100" ], [ "iterateDelta", "0.001" ], [ "refMode", "A1" ] ];
    function push_defaults_array(target, defaults) {
        for (var j = 0; j != target.length; ++j) {
            var w = target[j];
            for (var i = 0; i != defaults.length; ++i) {
                var z = defaults[i];
                if (w[z[0]] == null) w[z[0]] = z[1]; else switch (z[2]) {
                  case "bool":
                    if (typeof w[z[0]] == "string") w[z[0]] = parsexmlbool(w[z[0]]);
                    break;

                  case "int":
                    if (typeof w[z[0]] == "string") w[z[0]] = parseInt(w[z[0]], 10);
                    break;
                }
            }
        }
    }
    function push_defaults(target, defaults) {
        for (var i = 0; i != defaults.length; ++i) {
            var z = defaults[i];
            if (target[z[0]] == null) target[z[0]] = z[1]; else switch (z[2]) {
              case "bool":
                if (typeof target[z[0]] == "string") target[z[0]] = parsexmlbool(target[z[0]]);
                break;

              case "int":
                if (typeof target[z[0]] == "string") target[z[0]] = parseInt(target[z[0]], 10);
                break;
            }
        }
    }
    function parse_wb_defaults(wb) {
        push_defaults(wb.WBProps, WBPropsDef);
        push_defaults(wb.CalcPr, CalcPrDef);
        push_defaults_array(wb.WBView, WBViewDef);
        push_defaults_array(wb.Sheets, SheetDef);
        _ssfopts.date1904 = parsexmlbool(wb.WBProps.date1904);
    }
    function safe1904(wb) {
        if (!wb.Workbook) return "false";
        if (!wb.Workbook.WBProps) return "false";
        return parsexmlbool(wb.Workbook.WBProps.date1904) ? "true" : "false";
    }
    var badchars = "][*?/\\".split("");
    function check_ws_name(n, safe) {
        if (n.length > 31) {
            if (safe) return false;
            throw new Error("Sheet names cannot exceed 31 chars");
        }
        var _good = true;
        badchars.forEach(function(c) {
            if (n.indexOf(c) == -1) return;
            if (!safe) throw new Error("Sheet name cannot contain : \\ / ? * [ ]");
            _good = false;
        });
        return _good;
    }
    function check_wb_names(N, S, codes) {
        N.forEach(function(n, i) {
            check_ws_name(n);
            for (var j = 0; j < i; ++j) if (n == N[j]) throw new Error("Duplicate Sheet Name: " + n);
            if (codes) {
                var cn = S && S[i] && S[i].CodeName || n;
                if (cn.charCodeAt(0) == 95 && cn.length > 22) throw new Error("Bad Code Name: Worksheet" + cn);
            }
        });
    }
    function check_wb(wb) {
        if (!wb || !wb.SheetNames || !wb.Sheets) throw new Error("Invalid Workbook");
        if (!wb.SheetNames.length) throw new Error("Workbook is empty");
        var Sheets = wb.Workbook && wb.Workbook.Sheets || [];
        check_wb_names(wb.SheetNames, Sheets, !!wb.vbaraw);
        for (var i = 0; i < wb.SheetNames.length; ++i) check_ws(wb.Sheets[wb.SheetNames[i]], wb.SheetNames[i], i);
    }
    var wbnsregex = /<\w+:workbook/;
    function parse_wb_xml(data, opts) {
        if (!data) throw new Error("Could not find file");
        var wb = {
            "AppVersion": {},
            "WBProps": {},
            "WBView": [],
            "Sheets": [],
            "CalcPr": {},
            "Names": [],
            "xmlns": ""
        };
        var pass = false, xmlns = "xmlns";
        var dname = {}, dnstart = 0;
        data.replace(tagregex, function xml_wb(x, idx) {
            var y = parsexmltag(x);
            switch (strip_ns(y[0])) {
              case "<?xml":
                break;

              case "<workbook":
                if (x.match(wbnsregex)) xmlns = "xmlns" + x.match(/<(\w+):/)[1];
                wb.xmlns = y[xmlns];
                break;

              case "</workbook>":
                break;

              case "<fileVersion":
                delete y[0];
                wb.AppVersion = y;
                break;

              case "<fileVersion/>":
              case "</fileVersion>":
                break;

              case "<fileSharing":
              case "<fileSharing/>":
                break;

              case "<workbookPr":
              case "<workbookPr/>":
                WBPropsDef.forEach(function(w) {
                    if (y[w[0]] == null) return;
                    switch (w[2]) {
                      case "bool":
                        wb.WBProps[w[0]] = parsexmlbool(y[w[0]]);
                        break;

                      case "int":
                        wb.WBProps[w[0]] = parseInt(y[w[0]], 10);
                        break;

                      default:
                        wb.WBProps[w[0]] = y[w[0]];
                    }
                });
                if (y.codeName) wb.WBProps.CodeName = y.codeName;
                break;

              case "</workbookPr>":
                break;

              case "<workbookProtection":
                break;

              case "<workbookProtection/>":
                break;

              case "<bookViews":
              case "<bookViews>":
              case "</bookViews>":
                break;

              case "<workbookView":
              case "<workbookView/>":
                delete y[0];
                wb.WBView.push(y);
                break;

              case "</workbookView>":
                break;

              case "<sheets":
              case "<sheets>":
              case "</sheets>":
                break;

              case "<sheet":
                switch (y.state) {
                  case "hidden":
                    y.Hidden = 1;
                    break;

                  case "veryHidden":
                    y.Hidden = 2;
                    break;

                  default:
                    y.Hidden = 0;
                }
                delete y.state;
                y.name = unescapexml(utf8read(y.name));
                delete y[0];
                wb.Sheets.push(y);
                break;

              case "</sheet>":
                break;

              case "<functionGroups":
              case "<functionGroups/>":
                break;

              case "<functionGroup":
                break;

              case "<externalReferences":
              case "</externalReferences>":
              case "<externalReferences>":
                break;

              case "<externalReference":
                break;

              case "<definedNames/>":
                break;

              case "<definedNames>":
              case "<definedNames":
                pass = true;
                break;

              case "</definedNames>":
                pass = false;
                break;

              case "<definedName":
                {
                    dname = {};
                    dname.Name = utf8read(y.name);
                    if (y.comment) dname.Comment = y.comment;
                    if (y.localSheetId) dname.Sheet = +y.localSheetId;
                    dnstart = idx + x.length;
                }
                break;

              case "</definedName>":
                {
                    dname.Ref = unescapexml(utf8read(data.slice(dnstart, idx)));
                    wb.Names.push(dname);
                }
                break;

              case "<definedName/>":
                break;

              case "<calcPr":
                delete y[0];
                wb.CalcPr = y;
                break;

              case "<calcPr/>":
                delete y[0];
                wb.CalcPr = y;
                break;

              case "</calcPr>":
                break;

              case "<oleSize":
                break;

              case "<customWorkbookViews>":
              case "</customWorkbookViews>":
              case "<customWorkbookViews":
                break;

              case "<customWorkbookView":
              case "</customWorkbookView>":
                break;

              case "<pivotCaches>":
              case "</pivotCaches>":
              case "<pivotCaches":
                break;

              case "<pivotCache":
                break;

              case "<smartTagPr":
              case "<smartTagPr/>":
                break;

              case "<smartTagTypes":
              case "<smartTagTypes>":
              case "</smartTagTypes>":
                break;

              case "<smartTagType":
                break;

              case "<webPublishing":
              case "<webPublishing/>":
                break;

              case "<fileRecoveryPr":
              case "<fileRecoveryPr/>":
                break;

              case "<webPublishObjects>":
              case "<webPublishObjects":
              case "</webPublishObjects>":
                break;

              case "<webPublishObject":
                break;

              case "<extLst":
              case "<extLst>":
              case "</extLst>":
              case "<extLst/>":
                break;

              case "<ext":
                pass = true;
                break;

              case "</ext>":
                pass = false;
                break;

              case "<ArchID":
                break;

              case "<AlternateContent":
              case "<AlternateContent>":
                pass = true;
                break;

              case "</AlternateContent>":
                pass = false;
                break;

              case "<revisionPtr":
                break;

              default:
                if (!pass && opts.WTF) throw new Error("unrecognized " + y[0] + " in workbook");
            }
            return x;
        });
        if (XMLNS.main.indexOf(wb.xmlns) === -1) throw new Error("Unknown Namespace: " + wb.xmlns);
        parse_wb_defaults(wb);
        return wb;
    }
    var WB_XML_ROOT = writextag("workbook", null, {
        "xmlns": XMLNS.main[0],
        "xmlns:r": XMLNS.r
    });
    function write_wb_xml(wb) {
        var o = [ XML_HEADER ];
        o[o.length] = WB_XML_ROOT;
        var write_names = wb.Workbook && (wb.Workbook.Names || []).length > 0;
        var workbookPr = {
            "codeName": "ThisWorkbook"
        };
        if (wb.Workbook && wb.Workbook.WBProps) {
            WBPropsDef.forEach(function(x) {
                if (wb.Workbook.WBProps[x[0]] == null) return;
                if (wb.Workbook.WBProps[x[0]] == x[1]) return;
                workbookPr[x[0]] = wb.Workbook.WBProps[x[0]];
            });
            if (wb.Workbook.WBProps.CodeName) {
                workbookPr.codeName = wb.Workbook.WBProps.CodeName;
                delete workbookPr.CodeName;
            }
        }
        o[o.length] = writextag("workbookPr", null, workbookPr);
        o[o.length] = "<sheets>";
        var sheets = wb.Workbook && wb.Workbook.Sheets || [];
        for (var i = 0; i != wb.SheetNames.length; ++i) {
            var sht = {
                "name": escapexml(wb.SheetNames[i].slice(0, 31))
            };
            sht.sheetId = "" + (i + 1);
            sht["r:id"] = "rId" + (i + 1);
            if (sheets[i]) switch (sheets[i].Hidden) {
              case 1:
                sht.state = "hidden";
                break;

              case 2:
                sht.state = "veryHidden";
                break;
            }
            o[o.length] = writextag("sheet", null, sht);
        }
        o[o.length] = "</sheets>";
        if (write_names) {
            o[o.length] = "<definedNames>";
            if (wb.Workbook && wb.Workbook.Names) wb.Workbook.Names.forEach(function(n) {
                var d = {
                    "name": n.Name
                };
                if (n.Comment) d.comment = n.Comment;
                if (n.Sheet != null) d.localSheetId = "" + n.Sheet;
                if (!n.Ref) return;
                o[o.length] = writextag("definedName", String(n.Ref), d);
            });
            o[o.length] = "</definedNames>";
        }
        if (o.length > 2) {
            o[o.length] = "</workbook>";
            o[1] = o[1].replace("/>", ">");
        }
        return o.join("");
    }
    function parse_BrtBundleSh(data, length) {
        var z = {};
        z.Hidden = data.read_shift(4);
        z.iTabID = data.read_shift(4);
        z.strRelID = parse_RelID(data, length - 8);
        z.name = parse_XLWideString(data);
        return z;
    }
    function write_BrtBundleSh(data, o) {
        if (!o) o = new_buf(127);
        o.write_shift(4, data.Hidden);
        o.write_shift(4, data.iTabID);
        write_RelID(data.strRelID, o);
        write_XLWideString(data.name.slice(0, 31), o);
        return o.length > o.l ? o.slice(0, o.l) : o;
    }
    function parse_BrtWbProp(data, length) {
        var o = {};
        var flags = data.read_shift(4);
        o.defaultThemeVersion = data.read_shift(4);
        var strName = length > 8 ? parse_XLWideString(data) : "";
        if (strName.length > 0) o.CodeName = strName;
        o.autoCompressPictures = !!(flags & 65536);
        o.backupFile = !!(flags & 64);
        o.checkCompatibility = !!(flags & 4096);
        o.date1904 = !!(flags & 1);
        o.filterPrivacy = !!(flags & 8);
        o.hidePivotFieldList = !!(flags & 1024);
        o.promptedSolutions = !!(flags & 16);
        o.publishItems = !!(flags & 2048);
        o.refreshAllConnections = !!(flags & 262144);
        o.saveExternalLinkValues = !!(flags & 128);
        o.showBorderUnselectedTables = !!(flags & 4);
        o.showInkAnnotation = !!(flags & 32);
        o.showObjects = [ "all", "placeholders", "none" ][flags >> 13 & 3];
        o.showPivotChartFilter = !!(flags & 32768);
        o.updateLinks = [ "userSet", "never", "always" ][flags >> 8 & 3];
        return o;
    }
    function write_BrtWbProp(data, o) {
        if (!o) o = new_buf(72);
        var flags = 0;
        if (data) {
            if (data.filterPrivacy) flags |= 8;
        }
        o.write_shift(4, flags);
        o.write_shift(4, 0);
        write_XLSBCodeName(data && data.CodeName || "ThisWorkbook", o);
        return o.slice(0, o.l);
    }
    function parse_BrtFRTArchID$(data, length) {
        var o = {};
        data.read_shift(4);
        o.ArchID = data.read_shift(4);
        data.l += length - 8;
        return o;
    }
    function parse_BrtName(data, length, opts) {
        var end = data.l + length;
        data.l += 4;
        data.l += 1;
        var itab = data.read_shift(4);
        var name = parse_XLNameWideString(data);
        var formula = parse_XLSBNameParsedFormula(data, 0, opts);
        var comment = parse_XLNullableWideString(data);
        data.l = end;
        var out = {
            "Name": name,
            "Ptg": formula
        };
        if (itab < 268435455) out.Sheet = itab;
        if (comment) out.Comment = comment;
        return out;
    }
    function parse_wb_bin(data, opts) {
        var wb = {
            "AppVersion": {},
            "WBProps": {},
            "WBView": [],
            "Sheets": [],
            "CalcPr": {},
            "xmlns": ""
        };
        var pass = false;
        if (!opts) opts = {};
        opts.biff = 12;
        var Names = [];
        var supbooks = [ [] ];
        supbooks.SheetNames = [];
        supbooks.XTI = [];
        recordhopper(data, function hopper_wb(val, R_n, RT) {
            switch (RT) {
              case 156:
                supbooks.SheetNames.push(val.name);
                wb.Sheets.push(val);
                break;

              case 153:
                wb.WBProps = val;
                break;

              case 39:
                if (val.Sheet != null) opts.SID = val.Sheet;
                val.Ref = stringify_formula(val.Ptg, null, null, supbooks, opts);
                delete opts.SID;
                delete val.Ptg;
                Names.push(val);
                break;

              case 1036:
                break;

              case 357:
              case 358:
              case 355:
              case 667:
                if (!supbooks[0].length) supbooks[0] = [ RT, val ]; else supbooks.push([ RT, val ]);
                supbooks[supbooks.length - 1].XTI = [];
                break;

              case 362:
                if (supbooks.length === 0) {
                    supbooks[0] = [];
                    supbooks[0].XTI = [];
                }
                supbooks[supbooks.length - 1].XTI = supbooks[supbooks.length - 1].XTI.concat(val);
                supbooks.XTI = supbooks.XTI.concat(val);
                break;

              case 361:
                break;

              case 3072:
              case 3073:
              case 2071:
              case 534:
              case 677:
              case 158:
              case 157:
              case 610:
              case 2050:
              case 155:
              case 548:
              case 676:
              case 128:
              case 665:
              case 2128:
              case 2125:
              case 549:
              case 2053:
              case 596:
              case 2076:
              case 2075:
              case 2082:
              case 397:
              case 154:
              case 1117:
              case 553:
              case 2091:
                break;

              case 35:
                pass = true;
                break;

              case 36:
                pass = false;
                break;

              case 37:
                break;

              case 38:
                break;

              case 16:
                break;

              default:
                if ((R_n || "").indexOf("Begin") > 0) {} else if ((R_n || "").indexOf("End") > 0) {} else if (!pass || opts.WTF) throw new Error("Unexpected record " + RT + " " + R_n);
            }
        }, opts);
        parse_wb_defaults(wb);
        wb.Names = Names;
        wb.supbooks = supbooks;
        return wb;
    }
    function write_BUNDLESHS(ba, wb) {
        write_record(ba, "BrtBeginBundleShs");
        for (var idx = 0; idx != wb.SheetNames.length; ++idx) {
            var viz = wb.Workbook && wb.Workbook.Sheets && wb.Workbook.Sheets[idx] && wb.Workbook.Sheets[idx].Hidden || 0;
            var d = {
                "Hidden": viz,
                "iTabID": idx + 1,
                "strRelID": "rId" + (idx + 1),
                "name": wb.SheetNames[idx]
            };
            write_record(ba, "BrtBundleSh", write_BrtBundleSh(d));
        }
        write_record(ba, "BrtEndBundleShs");
    }
    function write_BrtFileVersion(data, o) {
        if (!o) o = new_buf(127);
        for (var i = 0; i != 4; ++i) o.write_shift(4, 0);
        write_XLWideString("SheetJS", o);
        write_XLWideString(XLSX.version, o);
        write_XLWideString(XLSX.version, o);
        write_XLWideString("7262", o);
        o.length = o.l;
        return o.length > o.l ? o.slice(0, o.l) : o;
    }
    function write_BrtBookView(idx, o) {
        if (!o) o = new_buf(29);
        o.write_shift(-4, 0);
        o.write_shift(-4, 460);
        o.write_shift(4, 28800);
        o.write_shift(4, 17600);
        o.write_shift(4, 500);
        o.write_shift(4, idx);
        o.write_shift(4, idx);
        var flags = 120;
        o.write_shift(1, flags);
        return o.length > o.l ? o.slice(0, o.l) : o;
    }
    function write_BOOKVIEWS(ba, wb) {
        if (!wb.Workbook || !wb.Workbook.Sheets) return;
        var sheets = wb.Workbook.Sheets;
        var i = 0, vistab = -1, hidden = -1;
        for (;i < sheets.length; ++i) {
            if (!sheets[i] || !sheets[i].Hidden && vistab == -1) vistab = i; else if (sheets[i].Hidden == 1 && hidden == -1) hidden = i;
        }
        if (hidden > vistab) return;
        write_record(ba, "BrtBeginBookViews");
        write_record(ba, "BrtBookView", write_BrtBookView(vistab));
        write_record(ba, "BrtEndBookViews");
    }
    function write_wb_bin(wb, opts) {
        var ba = buf_array();
        write_record(ba, "BrtBeginBook");
        write_record(ba, "BrtFileVersion", write_BrtFileVersion());
        write_record(ba, "BrtWbProp", write_BrtWbProp(wb.Workbook && wb.Workbook.WBProps || null));
        write_BOOKVIEWS(ba, wb, opts);
        write_BUNDLESHS(ba, wb, opts);
        write_record(ba, "BrtEndBook");
        return ba.end();
    }
    function parse_wb(data, name, opts) {
        if (name.slice(-4) === ".bin") return parse_wb_bin(data, opts);
        return parse_wb_xml(data, opts);
    }
    function parse_ws(data, name, idx, opts, rels, wb, themes, styles) {
        if (name.slice(-4) === ".bin") return parse_ws_bin(data, opts, idx, rels, wb, themes, styles);
        return parse_ws_xml(data, opts, idx, rels, wb, themes, styles);
    }
    function parse_cs(data, name, idx, opts, rels, wb, themes, styles) {
        if (name.slice(-4) === ".bin") return parse_cs_bin(data, opts, idx, rels, wb, themes, styles);
        return parse_cs_xml(data, opts, idx, rels, wb, themes, styles);
    }
    function parse_ms(data, name, idx, opts, rels, wb, themes, styles) {
        if (name.slice(-4) === ".bin") return parse_ms_bin(data, opts, idx, rels, wb, themes, styles);
        return parse_ms_xml(data, opts, idx, rels, wb, themes, styles);
    }
    function parse_ds(data, name, idx, opts, rels, wb, themes, styles) {
        if (name.slice(-4) === ".bin") return parse_ds_bin(data, opts, idx, rels, wb, themes, styles);
        return parse_ds_xml(data, opts, idx, rels, wb, themes, styles);
    }
    function parse_sty(data, name, themes, opts) {
        if (name.slice(-4) === ".bin") return parse_sty_bin(data, themes, opts);
        return parse_sty_xml(data, themes, opts);
    }
    function parse_theme(data, name, opts) {
        return parse_theme_xml(data, opts);
    }
    function parse_sst(data, name, opts) {
        if (name.slice(-4) === ".bin") return parse_sst_bin(data, opts);
        return parse_sst_xml(data, opts);
    }
    function parse_cmnt(data, name, opts) {
        if (name.slice(-4) === ".bin") return parse_comments_bin(data, opts);
        return parse_comments_xml(data, opts);
    }
    function parse_cc(data, name, opts) {
        if (name.slice(-4) === ".bin") return parse_cc_bin(data, name, opts);
        return parse_cc_xml(data, name, opts);
    }
    function parse_xlink(data, name, opts) {
        if (name.slice(-4) === ".bin") return parse_xlink_bin(data, name, opts);
        return parse_xlink_xml(data, name, opts);
    }
    function write_wb(wb, name, opts) {
        return (name.slice(-4) === ".bin" ? write_wb_bin : write_wb_xml)(wb, opts);
    }
    function write_ws(data, name, opts, wb, rels) {
        return (name.slice(-4) === ".bin" ? write_ws_bin : write_ws_xml)(data, opts, wb, rels);
    }
    function write_cs(data, name, opts, wb, rels) {
        return (name.slice(-4) === ".bin" ? write_cs_bin : write_cs_xml)(data, opts, wb, rels);
    }
    function write_sty(data, name, opts) {
        return (name.slice(-4) === ".bin" ? write_sty_bin : write_sty_xml)(data, opts);
    }
    function write_sst(data, name, opts) {
        return (name.slice(-4) === ".bin" ? write_sst_bin : write_sst_xml)(data, opts);
    }
    function write_cmnt(data, name, opts) {
        return (name.slice(-4) === ".bin" ? write_comments_bin : write_comments_xml)(data, opts);
    }
    var attregexg2 = /([\w:]+)=((?:")([^"]*)(?:")|(?:')([^']*)(?:'))/g;
    var attregex2 = /([\w:]+)=((?:")(?:[^"]*)(?:")|(?:')(?:[^']*)(?:'))/;
    var _chr = function(c) {
        return String.fromCharCode(c);
    };
    function xlml_parsexmltag(tag, skip_root) {
        var words = tag.split(/\s+/);
        var z = [];
        if (!skip_root) z[0] = words[0];
        if (words.length === 1) return z;
        var m = tag.match(attregexg2), y, j, w, i;
        if (m) for (i = 0; i != m.length; ++i) {
            y = m[i].match(attregex2);
            if ((j = y[1].indexOf(":")) === -1) z[y[1]] = y[2].slice(1, y[2].length - 1); else {
                if (y[1].slice(0, 6) === "xmlns:") w = "xmlns" + y[1].slice(6); else w = y[1].slice(j + 1);
                z[w] = y[2].slice(1, y[2].length - 1);
            }
        }
        return z;
    }
    function xlml_parsexmltagobj(tag) {
        var words = tag.split(/\s+/);
        var z = {};
        if (words.length === 1) return z;
        var m = tag.match(attregexg2), y, j, w, i;
        if (m) for (i = 0; i != m.length; ++i) {
            y = m[i].match(attregex2);
            if ((j = y[1].indexOf(":")) === -1) z[y[1]] = y[2].slice(1, y[2].length - 1); else {
                if (y[1].slice(0, 6) === "xmlns:") w = "xmlns" + y[1].slice(6); else w = y[1].slice(j + 1);
                z[w] = y[2].slice(1, y[2].length - 1);
            }
        }
        return z;
    }
    function xlml_format(format, value) {
        var fmt = XLMLFormatMap[format] || unescapexml(format);
        if (fmt === "General") return SSF._general(value);
        return SSF.format(fmt, value);
    }
    function xlml_set_custprop(Custprops, key, cp, val) {
        var oval = val;
        switch ((cp[0].match(/dt:dt="([\w.]+)"/) || [ "", "" ])[1]) {
          case "boolean":
            oval = parsexmlbool(val);
            break;

          case "i2":
          case "int":
            oval = parseInt(val, 10);
            break;

          case "r4":
          case "float":
            oval = parseFloat(val);
            break;

          case "date":
          case "dateTime.tz":
            oval = parseDate(val);
            break;

          case "i8":
          case "string":
          case "fixed":
          case "uuid":
          case "bin.base64":
            break;

          default:
            throw new Error("bad custprop:" + cp[0]);
        }
        Custprops[unescapexml(key)] = oval;
    }
    function safe_format_xlml(cell, nf, o) {
        if (cell.t === "z") return;
        if (!o || o.cellText !== false) try {
            if (cell.t === "e") {
                cell.w = cell.w || BErr[cell.v];
            } else if (nf === "General") {
                if (cell.t === "n") {
                    if ((cell.v | 0) === cell.v) cell.w = SSF._general_int(cell.v); else cell.w = SSF._general_num(cell.v);
                } else cell.w = SSF._general(cell.v);
            } else cell.w = xlml_format(nf || "General", cell.v);
        } catch (e) {
            if (o.WTF) throw e;
        }
        try {
            var z = XLMLFormatMap[nf] || nf || "General";
            if (o.cellNF) cell.z = z;
            if (o.cellDates && cell.t == "n" && SSF.is_date(z)) {
                var _d = SSF.parse_date_code(cell.v);
                if (_d) {
                    cell.t = "d";
                    cell.v = new Date(_d.y, _d.m - 1, _d.d, _d.H, _d.M, _d.S, _d.u);
                }
            }
        } catch (e) {
            if (o.WTF) throw e;
        }
    }
    function process_style_xlml(styles, stag, opts) {
        if (opts.cellStyles) {
            if (stag.Interior) {
                var I = stag.Interior;
                if (I.Pattern) I.patternType = XLMLPatternTypeMap[I.Pattern] || I.Pattern;
            }
        }
        styles[stag.ID] = stag;
    }
    function parse_xlml_data(xml, ss, data, cell, base, styles, csty, row, arrayf, o) {
        var nf = "General", sid = cell.StyleID, S = {};
        o = o || {};
        var interiors = [];
        var i = 0;
        if (sid === undefined && row) sid = row.StyleID;
        if (sid === undefined && csty) sid = csty.StyleID;
        while (styles[sid] !== undefined) {
            if (styles[sid].nf) nf = styles[sid].nf;
            if (styles[sid].Interior) interiors.push(styles[sid].Interior);
            if (!styles[sid].Parent) break;
            sid = styles[sid].Parent;
        }
        switch (data.Type) {
          case "Boolean":
            cell.t = "b";
            cell.v = parsexmlbool(xml);
            break;

          case "String":
            cell.t = "s";
            cell.r = xlml_fixstr(unescapexml(xml));
            cell.v = xml.indexOf("<") > -1 ? unescapexml(ss) : cell.r;
            break;

          case "DateTime":
            if (xml.slice(-1) != "Z") xml += "Z";
            cell.v = (parseDate(xml) - new Date(Date.UTC(1899, 11, 30))) / (24 * 60 * 60 * 1e3);
            if (cell.v !== cell.v) cell.v = unescapexml(xml); else if (cell.v < 60) cell.v = cell.v - 1;
            if (!nf || nf == "General") nf = "yyyy-mm-dd";

          case "Number":
            if (cell.v === undefined) cell.v = +xml;
            if (!cell.t) cell.t = "n";
            break;

          case "Error":
            cell.t = "e";
            cell.v = RBErr[xml];
            if (o.cellText !== false) cell.w = xml;
            break;

          default:
            cell.t = "s";
            cell.v = xlml_fixstr(ss || xml);
            break;
        }
        safe_format_xlml(cell, nf, o);
        if (o.cellFormula !== false) {
            if (cell.Formula) {
                var fstr = unescapexml(cell.Formula);
                if (fstr.charCodeAt(0) == 61) fstr = fstr.slice(1);
                cell.f = rc_to_a1(fstr, base);
                delete cell.Formula;
                if (cell.ArrayRange == "RC") cell.F = rc_to_a1("RC:RC", base); else if (cell.ArrayRange) {
                    cell.F = rc_to_a1(cell.ArrayRange, base);
                    arrayf.push([ safe_decode_range(cell.F), cell.F ]);
                }
            } else {
                for (i = 0; i < arrayf.length; ++i) if (base.r >= arrayf[i][0].s.r && base.r <= arrayf[i][0].e.r) if (base.c >= arrayf[i][0].s.c && base.c <= arrayf[i][0].e.c) cell.F = arrayf[i][1];
            }
        }
        if (o.cellStyles) {
            interiors.forEach(function(x) {
                if (!S.patternType && x.patternType) S.patternType = x.patternType;
            });
            cell.s = S;
        }
        if (cell.StyleID !== undefined) cell.ixfe = cell.StyleID;
    }
    function xlml_clean_comment(comment) {
        comment.t = comment.v || "";
        comment.t = comment.t.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
        comment.v = comment.w = comment.ixfe = undefined;
    }
    function xlml_normalize(d) {
        if (has_buf && Buffer.isBuffer(d)) return d.toString("utf8");
        if (typeof d === "string") return d;
        if (typeof Uint8Array !== "undefined" && d instanceof Uint8Array) return utf8read(a2s(ab2a(d)));
        throw new Error("Bad input format: expected Buffer or string");
    }
    var xlmlregex = /<(\/?)([^\s?>!\/:]*:|)([^\s?>:\/]+)[^>]*>/gm;
    function parse_xlml_xml(d, _opts) {
        var opts = _opts || {};
        make_ssf(SSF);
        var str = debom(xlml_normalize(d));
        if (opts.type == "binary" || opts.type == "array" || opts.type == "base64") {
            if (typeof cptable !== "undefined") str = cptable.utils.decode(65001, char_codes(str)); else str = utf8read(str);
        }
        var opening = str.slice(0, 1024).toLowerCase(), ishtml = false;
        if (opening.indexOf("<?xml") == -1) [ "html", "table", "head", "meta", "script", "style", "div" ].forEach(function(tag) {
            if (opening.indexOf("<" + tag) >= 0) ishtml = true;
        });
        if (ishtml) return HTML_.to_workbook(str, opts);
        var Rn;
        var state = [], tmp;
        if (DENSE != null && opts.dense == null) opts.dense = DENSE;
        var sheets = {}, sheetnames = [], cursheet = opts.dense ? [] : {}, sheetname = "";
        var table = {}, cell = {}, row = {};
        var dtag = xlml_parsexmltag('<Data ss:Type="String">'), didx = 0;
        var c = 0, r = 0;
        var refguess = {
            "s": {
                "r": 2e6,
                "c": 2e6
            },
            "e": {
                "r": 0,
                "c": 0
            }
        };
        var styles = {}, stag = {};
        var ss = "", fidx = 0;
        var merges = [];
        var Props = {}, Custprops = {}, pidx = 0, cp = [];
        var comments = [], comment = {};
        var cstys = [], csty, seencol = false;
        var arrayf = [];
        var rowinfo = [], rowobj = {}, cc = 0, rr = 0;
        var Workbook = {
            "Sheets": [],
            "WBProps": {
                "date1904": false
            }
        }, wsprops = {};
        xlmlregex.lastIndex = 0;
        str = str.replace(/<!--([\s\S]*?)-->/gm, "");
        while (Rn = xlmlregex.exec(str)) switch (Rn[3]) {
          case "Data":
            if (state[state.length - 1][1]) break;
            if (Rn[1] === "/") parse_xlml_data(str.slice(didx, Rn.index), ss, dtag, state[state.length - 1][0] == "Comment" ? comment : cell, {
                "c": c,
                "r": r
            }, styles, cstys[c], row, arrayf, opts); else {
                ss = "";
                dtag = xlml_parsexmltag(Rn[0]);
                didx = Rn.index + Rn[0].length;
            }
            break;

          case "Cell":
            if (Rn[1] === "/") {
                if (comments.length > 0) cell.c = comments;
                if ((!opts.sheetRows || opts.sheetRows > r) && cell.v !== undefined) {
                    if (opts.dense) {
                        if (!cursheet[r]) cursheet[r] = [];
                        cursheet[r][c] = cell;
                    } else cursheet[encode_col(c) + encode_row(r)] = cell;
                }
                if (cell.HRef) {
                    cell.l = {
                        "Target": cell.HRef
                    };
                    if (cell.HRefScreenTip) cell.l.Tooltip = cell.HRefScreenTip;
                    delete cell.HRef;
                    delete cell.HRefScreenTip;
                }
                if (cell.MergeAcross || cell.MergeDown) {
                    cc = c + (parseInt(cell.MergeAcross, 10) | 0);
                    rr = r + (parseInt(cell.MergeDown, 10) | 0);
                    merges.push({
                        "s": {
                            "c": c,
                            "r": r
                        },
                        "e": {
                            "c": cc,
                            "r": rr
                        }
                    });
                }
                if (!opts.sheetStubs) {
                    if (cell.MergeAcross) c = cc + 1; else ++c;
                } else if (cell.MergeAcross || cell.MergeDown) {
                    for (var cma = c; cma <= cc; ++cma) {
                        for (var cmd = r; cmd <= rr; ++cmd) {
                            if (cma > c || cmd > r) {
                                if (opts.dense) {
                                    if (!cursheet[cmd]) cursheet[cmd] = [];
                                    cursheet[cmd][cma] = {
                                        "t": "z"
                                    };
                                } else cursheet[encode_col(cma) + encode_row(cmd)] = {
                                    "t": "z"
                                };
                            }
                        }
                    }
                    c = cc + 1;
                } else ++c;
            } else {
                cell = xlml_parsexmltagobj(Rn[0]);
                if (cell.Index) c = +cell.Index - 1;
                if (c < refguess.s.c) refguess.s.c = c;
                if (c > refguess.e.c) refguess.e.c = c;
                if (Rn[0].slice(-2) === "/>") ++c;
                comments = [];
            }
            break;

          case "Row":
            if (Rn[1] === "/" || Rn[0].slice(-2) === "/>") {
                if (r < refguess.s.r) refguess.s.r = r;
                if (r > refguess.e.r) refguess.e.r = r;
                if (Rn[0].slice(-2) === "/>") {
                    row = xlml_parsexmltag(Rn[0]);
                    if (row.Index) r = +row.Index - 1;
                }
                c = 0;
                ++r;
            } else {
                row = xlml_parsexmltag(Rn[0]);
                if (row.Index) r = +row.Index - 1;
                rowobj = {};
                if (row.AutoFitHeight == "0" || row.Height) {
                    rowobj.hpx = parseInt(row.Height, 10);
                    rowobj.hpt = px2pt(rowobj.hpx);
                    rowinfo[r] = rowobj;
                }
                if (row.Hidden == "1") {
                    rowobj.hidden = true;
                    rowinfo[r] = rowobj;
                }
            }
            break;

          case "Worksheet":
            if (Rn[1] === "/") {
                if ((tmp = state.pop())[0] !== Rn[3]) throw new Error("Bad state: " + tmp.join("|"));
                sheetnames.push(sheetname);
                if (refguess.s.r <= refguess.e.r && refguess.s.c <= refguess.e.c) {
                    cursheet["!ref"] = encode_range(refguess);
                    if (opts.sheetRows && opts.sheetRows <= refguess.e.r) {
                        cursheet["!fullref"] = cursheet["!ref"];
                        refguess.e.r = opts.sheetRows - 1;
                        cursheet["!ref"] = encode_range(refguess);
                    }
                }
                if (merges.length) cursheet["!merges"] = merges;
                if (cstys.length > 0) cursheet["!cols"] = cstys;
                if (rowinfo.length > 0) cursheet["!rows"] = rowinfo;
                sheets[sheetname] = cursheet;
            } else {
                refguess = {
                    "s": {
                        "r": 2e6,
                        "c": 2e6
                    },
                    "e": {
                        "r": 0,
                        "c": 0
                    }
                };
                r = c = 0;
                state.push([ Rn[3], false ]);
                tmp = xlml_parsexmltag(Rn[0]);
                sheetname = unescapexml(tmp.Name);
                cursheet = opts.dense ? [] : {};
                merges = [];
                arrayf = [];
                rowinfo = [];
                wsprops = {
                    "name": sheetname,
                    "Hidden": 0
                };
                Workbook.Sheets.push(wsprops);
            }
            break;

          case "Table":
            if (Rn[1] === "/") {
                if ((tmp = state.pop())[0] !== Rn[3]) throw new Error("Bad state: " + tmp.join("|"));
            } else if (Rn[0].slice(-2) == "/>") break; else {
                table = xlml_parsexmltag(Rn[0]);
                state.push([ Rn[3], false ]);
                cstys = [];
                seencol = false;
            }
            break;

          case "Style":
            if (Rn[1] === "/") process_style_xlml(styles, stag, opts); else stag = xlml_parsexmltag(Rn[0]);
            break;

          case "NumberFormat":
            stag.nf = unescapexml(xlml_parsexmltag(Rn[0]).Format || "General");
            if (XLMLFormatMap[stag.nf]) stag.nf = XLMLFormatMap[stag.nf];
            for (var ssfidx = 0; ssfidx != 392; ++ssfidx) if (SSF._table[ssfidx] == stag.nf) break;
            if (ssfidx == 392) for (ssfidx = 57; ssfidx != 392; ++ssfidx) if (SSF._table[ssfidx] == null) {
                SSF.load(stag.nf, ssfidx);
                break;
            }
            break;

          case "Column":
            if (state[state.length - 1][0] !== "Table") break;
            csty = xlml_parsexmltag(Rn[0]);
            if (csty.Hidden) {
                csty.hidden = true;
                delete csty.Hidden;
            }
            if (csty.Width) csty.wpx = parseInt(csty.Width, 10);
            if (!seencol && csty.wpx > 10) {
                seencol = true;
                MDW = DEF_MDW;
                for (var _col = 0; _col < cstys.length; ++_col) if (cstys[_col]) process_col(cstys[_col]);
            }
            if (seencol) process_col(csty);
            cstys[csty.Index - 1 || cstys.length] = csty;
            for (var i = 0; i < +csty.Span; ++i) cstys[cstys.length] = dup(csty);
            break;

          case "NamedRange":
            if (!Workbook.Names) Workbook.Names = [];
            var _NamedRange = parsexmltag(Rn[0]);
            var _DefinedName = {
                "Name": _NamedRange.Name,
                "Ref": rc_to_a1(_NamedRange.RefersTo.slice(1), {
                    "r": 0,
                    "c": 0
                })
            };
            if (Workbook.Sheets.length > 0) _DefinedName.Sheet = Workbook.Sheets.length - 1;
            Workbook.Names.push(_DefinedName);
            break;

          case "NamedCell":
            break;

          case "B":
            break;

          case "I":
            break;

          case "U":
            break;

          case "S":
            break;

          case "Sub":
            break;

          case "Sup":
            break;

          case "Span":
            break;

          case "Border":
            break;

          case "Alignment":
            break;

          case "Borders":
            break;

          case "Font":
            if (Rn[0].slice(-2) === "/>") break; else if (Rn[1] === "/") ss += str.slice(fidx, Rn.index); else fidx = Rn.index + Rn[0].length;
            break;

          case "Interior":
            if (!opts.cellStyles) break;
            stag.Interior = xlml_parsexmltag(Rn[0]);
            break;

          case "Protection":
            break;

          case "Author":
          case "Title":
          case "Description":
          case "Created":
          case "Keywords":
          case "Subject":
          case "Category":
          case "Company":
          case "LastAuthor":
          case "LastSaved":
          case "LastPrinted":
          case "Version":
          case "Revision":
          case "TotalTime":
          case "HyperlinkBase":
          case "Manager":
          case "ContentStatus":
          case "Identifier":
          case "Language":
          case "AppName":
            if (Rn[0].slice(-2) === "/>") break; else if (Rn[1] === "/") xlml_set_prop(Props, Rn[3], str.slice(pidx, Rn.index)); else pidx = Rn.index + Rn[0].length;
            break;

          case "Paragraphs":
            break;

          case "Styles":
          case "Workbook":
            if (Rn[1] === "/") {
                if ((tmp = state.pop())[0] !== Rn[3]) throw new Error("Bad state: " + tmp.join("|"));
            } else state.push([ Rn[3], false ]);
            break;

          case "Comment":
            if (Rn[1] === "/") {
                if ((tmp = state.pop())[0] !== Rn[3]) throw new Error("Bad state: " + tmp.join("|"));
                xlml_clean_comment(comment);
                comments.push(comment);
            } else {
                state.push([ Rn[3], false ]);
                tmp = xlml_parsexmltag(Rn[0]);
                comment = {
                    "a": tmp.Author
                };
            }
            break;

          case "AutoFilter":
            if (Rn[1] === "/") {
                if ((tmp = state.pop())[0] !== Rn[3]) throw new Error("Bad state: " + tmp.join("|"));
            } else if (Rn[0].charAt(Rn[0].length - 2) !== "/") {
                var AutoFilter = xlml_parsexmltag(Rn[0]);
                cursheet["!autofilter"] = {
                    "ref": rc_to_a1(AutoFilter.Range).replace(/\$/g, "")
                };
                state.push([ Rn[3], true ]);
            }
            break;

          case "Name":
            break;

          case "ComponentOptions":
          case "DocumentProperties":
          case "CustomDocumentProperties":
          case "OfficeDocumentSettings":
          case "PivotTable":
          case "PivotCache":
          case "Names":
          case "MapInfo":
          case "PageBreaks":
          case "QueryTable":
          case "DataValidation":
          case "Sorting":
          case "Schema":
          case "data":
          case "ConditionalFormatting":
          case "SmartTagType":
          case "SmartTags":
          case "ExcelWorkbook":
          case "WorkbookOptions":
          case "WorksheetOptions":
            if (Rn[1] === "/") {
                if ((tmp = state.pop())[0] !== Rn[3]) throw new Error("Bad state: " + tmp.join("|"));
            } else if (Rn[0].charAt(Rn[0].length - 2) !== "/") state.push([ Rn[3], true ]);
            break;

          default:
            if (state.length == 0 && Rn[3] == "document") return parse_fods(str, opts);
            if (state.length == 0 && Rn[3] == "UOF") return parse_fods(str, opts);
            var seen = true;
            switch (state[state.length - 1][0]) {
              case "OfficeDocumentSettings":
                switch (Rn[3]) {
                  case "AllowPNG":
                    break;

                  case "RemovePersonalInformation":
                    break;

                  case "DownloadComponents":
                    break;

                  case "LocationOfComponents":
                    break;

                  case "Colors":
                    break;

                  case "Color":
                    break;

                  case "Index":
                    break;

                  case "RGB":
                    break;

                  case "PixelsPerInch":
                    break;

                  case "TargetScreenSize":
                    break;

                  case "ReadOnlyRecommended":
                    break;

                  default:
                    seen = false;
                }
                break;

              case "ComponentOptions":
                switch (Rn[3]) {
                  case "Toolbar":
                    break;

                  case "HideOfficeLogo":
                    break;

                  case "SpreadsheetAutoFit":
                    break;

                  case "Label":
                    break;

                  case "Caption":
                    break;

                  case "MaxHeight":
                    break;

                  case "MaxWidth":
                    break;

                  case "NextSheetNumber":
                    break;

                  default:
                    seen = false;
                }
                break;

              case "ExcelWorkbook":
                switch (Rn[3]) {
                  case "Date1904":
                    Workbook.WBProps.date1904 = true;
                    break;

                  case "WindowHeight":
                    break;

                  case "WindowWidth":
                    break;

                  case "WindowTopX":
                    break;

                  case "WindowTopY":
                    break;

                  case "TabRatio":
                    break;

                  case "ProtectStructure":
                    break;

                  case "ProtectWindows":
                    break;

                  case "ActiveSheet":
                    break;

                  case "DisplayInkNotes":
                    break;

                  case "FirstVisibleSheet":
                    break;

                  case "SupBook":
                    break;

                  case "SheetName":
                    break;

                  case "SheetIndex":
                    break;

                  case "SheetIndexFirst":
                    break;

                  case "SheetIndexLast":
                    break;

                  case "Dll":
                    break;

                  case "AcceptLabelsInFormulas":
                    break;

                  case "DoNotSaveLinkValues":
                    break;

                  case "Iteration":
                    break;

                  case "MaxIterations":
                    break;

                  case "MaxChange":
                    break;

                  case "Path":
                    break;

                  case "Xct":
                    break;

                  case "Count":
                    break;

                  case "SelectedSheets":
                    break;

                  case "Calculation":
                    break;

                  case "Uncalced":
                    break;

                  case "StartupPrompt":
                    break;

                  case "Crn":
                    break;

                  case "ExternName":
                    break;

                  case "Formula":
                    break;

                  case "ColFirst":
                    break;

                  case "ColLast":
                    break;

                  case "WantAdvise":
                    break;

                  case "Boolean":
                    break;

                  case "Error":
                    break;

                  case "Text":
                    break;

                  case "OLE":
                    break;

                  case "NoAutoRecover":
                    break;

                  case "PublishObjects":
                    break;

                  case "DoNotCalculateBeforeSave":
                    break;

                  case "Number":
                    break;

                  case "RefModeR1C1":
                    break;

                  case "EmbedSaveSmartTags":
                    break;

                  default:
                    seen = false;
                }
                break;

              case "WorkbookOptions":
                switch (Rn[3]) {
                  case "OWCVersion":
                    break;

                  case "Height":
                    break;

                  case "Width":
                    break;

                  default:
                    seen = false;
                }
                break;

              case "WorksheetOptions":
                switch (Rn[3]) {
                  case "Visible":
                    if (Rn[0].slice(-2) === "/>") {} else if (Rn[1] === "/") switch (str.slice(pidx, Rn.index)) {
                      case "SheetHidden":
                        wsprops.Hidden = 1;
                        break;

                      case "SheetVeryHidden":
                        wsprops.Hidden = 2;
                        break;
                    } else pidx = Rn.index + Rn[0].length;
                    break;

                  case "Header":
                    if (!cursheet["!margins"]) default_margins(cursheet["!margins"] = {}, "xlml");
                    cursheet["!margins"].header = parsexmltag(Rn[0]).Margin;
                    break;

                  case "Footer":
                    if (!cursheet["!margins"]) default_margins(cursheet["!margins"] = {}, "xlml");
                    cursheet["!margins"].footer = parsexmltag(Rn[0]).Margin;
                    break;

                  case "PageMargins":
                    var pagemargins = parsexmltag(Rn[0]);
                    if (!cursheet["!margins"]) default_margins(cursheet["!margins"] = {}, "xlml");
                    if (pagemargins.Top) cursheet["!margins"].top = pagemargins.Top;
                    if (pagemargins.Left) cursheet["!margins"].left = pagemargins.Left;
                    if (pagemargins.Right) cursheet["!margins"].right = pagemargins.Right;
                    if (pagemargins.Bottom) cursheet["!margins"].bottom = pagemargins.Bottom;
                    break;

                  case "DisplayRightToLeft":
                    if (!Workbook.Views) Workbook.Views = [];
                    if (!Workbook.Views[0]) Workbook.Views[0] = {};
                    Workbook.Views[0].RTL = true;
                    break;

                  case "Unsynced":
                    break;

                  case "Print":
                    break;

                  case "Panes":
                    break;

                  case "Scale":
                    break;

                  case "Pane":
                    break;

                  case "Number":
                    break;

                  case "Layout":
                    break;

                  case "PageSetup":
                    break;

                  case "Selected":
                    break;

                  case "ProtectObjects":
                    break;

                  case "EnableSelection":
                    break;

                  case "ProtectScenarios":
                    break;

                  case "ValidPrinterInfo":
                    break;

                  case "HorizontalResolution":
                    break;

                  case "VerticalResolution":
                    break;

                  case "NumberofCopies":
                    break;

                  case "ActiveRow":
                    break;

                  case "ActiveCol":
                    break;

                  case "ActivePane":
                    break;

                  case "TopRowVisible":
                    break;

                  case "TopRowBottomPane":
                    break;

                  case "LeftColumnVisible":
                    break;

                  case "LeftColumnRightPane":
                    break;

                  case "FitToPage":
                    break;

                  case "RangeSelection":
                    break;

                  case "PaperSizeIndex":
                    break;

                  case "PageLayoutZoom":
                    break;

                  case "PageBreakZoom":
                    break;

                  case "FilterOn":
                    break;

                  case "DoNotDisplayGridlines":
                    break;

                  case "SplitHorizontal":
                    break;

                  case "SplitVertical":
                    break;

                  case "FreezePanes":
                    break;

                  case "FrozenNoSplit":
                    break;

                  case "FitWidth":
                    break;

                  case "FitHeight":
                    break;

                  case "CommentsLayout":
                    break;

                  case "Zoom":
                    break;

                  case "LeftToRight":
                    break;

                  case "Gridlines":
                    break;

                  case "AllowSort":
                    break;

                  case "AllowFilter":
                    break;

                  case "AllowInsertRows":
                    break;

                  case "AllowDeleteRows":
                    break;

                  case "AllowInsertCols":
                    break;

                  case "AllowDeleteCols":
                    break;

                  case "AllowInsertHyperlinks":
                    break;

                  case "AllowFormatCells":
                    break;

                  case "AllowSizeCols":
                    break;

                  case "AllowSizeRows":
                    break;

                  case "NoSummaryRowsBelowDetail":
                    break;

                  case "TabColorIndex":
                    break;

                  case "DoNotDisplayHeadings":
                    break;

                  case "ShowPageLayoutZoom":
                    break;

                  case "NoSummaryColumnsRightDetail":
                    break;

                  case "BlackAndWhite":
                    break;

                  case "DoNotDisplayZeros":
                    break;

                  case "DisplayPageBreak":
                    break;

                  case "RowColHeadings":
                    break;

                  case "DoNotDisplayOutline":
                    break;

                  case "NoOrientation":
                    break;

                  case "AllowUsePivotTables":
                    break;

                  case "ZeroHeight":
                    break;

                  case "ViewableRange":
                    break;

                  case "Selection":
                    break;

                  case "ProtectContents":
                    break;

                  default:
                    seen = false;
                }
                break;

              case "PivotTable":
              case "PivotCache":
                switch (Rn[3]) {
                  case "ImmediateItemsOnDrop":
                    break;

                  case "ShowPageMultipleItemLabel":
                    break;

                  case "CompactRowIndent":
                    break;

                  case "Location":
                    break;

                  case "PivotField":
                    break;

                  case "Orientation":
                    break;

                  case "LayoutForm":
                    break;

                  case "LayoutSubtotalLocation":
                    break;

                  case "LayoutCompactRow":
                    break;

                  case "Position":
                    break;

                  case "PivotItem":
                    break;

                  case "DataType":
                    break;

                  case "DataField":
                    break;

                  case "SourceName":
                    break;

                  case "ParentField":
                    break;

                  case "PTLineItems":
                    break;

                  case "PTLineItem":
                    break;

                  case "CountOfSameItems":
                    break;

                  case "Item":
                    break;

                  case "ItemType":
                    break;

                  case "PTSource":
                    break;

                  case "CacheIndex":
                    break;

                  case "ConsolidationReference":
                    break;

                  case "FileName":
                    break;

                  case "Reference":
                    break;

                  case "NoColumnGrand":
                    break;

                  case "NoRowGrand":
                    break;

                  case "BlankLineAfterItems":
                    break;

                  case "Hidden":
                    break;

                  case "Subtotal":
                    break;

                  case "BaseField":
                    break;

                  case "MapChildItems":
                    break;

                  case "Function":
                    break;

                  case "RefreshOnFileOpen":
                    break;

                  case "PrintSetTitles":
                    break;

                  case "MergeLabels":
                    break;

                  case "DefaultVersion":
                    break;

                  case "RefreshName":
                    break;

                  case "RefreshDate":
                    break;

                  case "RefreshDateCopy":
                    break;

                  case "VersionLastRefresh":
                    break;

                  case "VersionLastUpdate":
                    break;

                  case "VersionUpdateableMin":
                    break;

                  case "VersionRefreshableMin":
                    break;

                  case "Calculation":
                    break;

                  default:
                    seen = false;
                }
                break;

              case "PageBreaks":
                switch (Rn[3]) {
                  case "ColBreaks":
                    break;

                  case "ColBreak":
                    break;

                  case "RowBreaks":
                    break;

                  case "RowBreak":
                    break;

                  case "ColStart":
                    break;

                  case "ColEnd":
                    break;

                  case "RowEnd":
                    break;

                  default:
                    seen = false;
                }
                break;

              case "AutoFilter":
                switch (Rn[3]) {
                  case "AutoFilterColumn":
                    break;

                  case "AutoFilterCondition":
                    break;

                  case "AutoFilterAnd":
                    break;

                  case "AutoFilterOr":
                    break;

                  default:
                    seen = false;
                }
                break;

              case "QueryTable":
                switch (Rn[3]) {
                  case "Id":
                    break;

                  case "AutoFormatFont":
                    break;

                  case "AutoFormatPattern":
                    break;

                  case "QuerySource":
                    break;

                  case "QueryType":
                    break;

                  case "EnableRedirections":
                    break;

                  case "RefreshedInXl9":
                    break;

                  case "URLString":
                    break;

                  case "HTMLTables":
                    break;

                  case "Connection":
                    break;

                  case "CommandText":
                    break;

                  case "RefreshInfo":
                    break;

                  case "NoTitles":
                    break;

                  case "NextId":
                    break;

                  case "ColumnInfo":
                    break;

                  case "OverwriteCells":
                    break;

                  case "DoNotPromptForFile":
                    break;

                  case "TextWizardSettings":
                    break;

                  case "Source":
                    break;

                  case "Number":
                    break;

                  case "Decimal":
                    break;

                  case "ThousandSeparator":
                    break;

                  case "TrailingMinusNumbers":
                    break;

                  case "FormatSettings":
                    break;

                  case "FieldType":
                    break;

                  case "Delimiters":
                    break;

                  case "Tab":
                    break;

                  case "Comma":
                    break;

                  case "AutoFormatName":
                    break;

                  case "VersionLastEdit":
                    break;

                  case "VersionLastRefresh":
                    break;

                  default:
                    seen = false;
                }
                break;

              case "Sorting":
              case "ConditionalFormatting":
              case "DataValidation":
                switch (Rn[3]) {
                  case "Range":
                    break;

                  case "Type":
                    break;

                  case "Min":
                    break;

                  case "Max":
                    break;

                  case "Sort":
                    break;

                  case "Descending":
                    break;

                  case "Order":
                    break;

                  case "CaseSensitive":
                    break;

                  case "Value":
                    break;

                  case "ErrorStyle":
                    break;

                  case "ErrorMessage":
                    break;

                  case "ErrorTitle":
                    break;

                  case "CellRangeList":
                    break;

                  case "InputMessage":
                    break;

                  case "InputTitle":
                    break;

                  case "ComboHide":
                    break;

                  case "InputHide":
                    break;

                  case "Condition":
                    break;

                  case "Qualifier":
                    break;

                  case "UseBlank":
                    break;

                  case "Value1":
                    break;

                  case "Value2":
                    break;

                  case "Format":
                    break;

                  default:
                    seen = false;
                }
                break;

              case "MapInfo":
              case "Schema":
              case "data":
                switch (Rn[3]) {
                  case "Map":
                    break;

                  case "Entry":
                    break;

                  case "Range":
                    break;

                  case "XPath":
                    break;

                  case "Field":
                    break;

                  case "XSDType":
                    break;

                  case "FilterOn":
                    break;

                  case "Aggregate":
                    break;

                  case "ElementType":
                    break;

                  case "AttributeType":
                    break;

                  case "schema":
                  case "element":
                  case "complexType":
                  case "datatype":
                  case "all":
                  case "attribute":
                  case "extends":
                    break;

                  case "row":
                    break;

                  default:
                    seen = false;
                }
                break;

              case "SmartTags":
                break;

              default:
                seen = false;
                break;
            }
            if (seen) break;
            if (!state[state.length - 1][1]) throw "Unrecognized tag: " + Rn[3] + "|" + state.join("|");
            if (state[state.length - 1][0] === "CustomDocumentProperties") {
                if (Rn[0].slice(-2) === "/>") break; else if (Rn[1] === "/") xlml_set_custprop(Custprops, Rn[3], cp, str.slice(pidx, Rn.index)); else {
                    cp = Rn;
                    pidx = Rn.index + Rn[0].length;
                }
                break;
            }
            if (opts.WTF) throw "Unrecognized tag: " + Rn[3] + "|" + state.join("|");
        }
        var out = {};
        if (!opts.bookSheets && !opts.bookProps) out.Sheets = sheets;
        out.SheetNames = sheetnames;
        out.Workbook = Workbook;
        out.SSF = SSF.get_table();
        out.Props = Props;
        out.Custprops = Custprops;
        return out;
    }
    function parse_xlml(data, opts) {
        fix_read_opts(opts = opts || {});
        switch (opts.type || "base64") {
          case "base64":
            return parse_xlml_xml(Base64.decode(data), opts);

          case "binary":
          case "buffer":
          case "file":
            return parse_xlml_xml(data, opts);

          case "array":
            return parse_xlml_xml(a2s(data), opts);
        }
    }
    function write_props_xlml(wb, opts) {
        var o = [];
        if (wb.Props) o.push(xlml_write_docprops(wb.Props, opts));
        if (wb.Custprops) o.push(xlml_write_custprops(wb.Props, wb.Custprops, opts));
        return o.join("");
    }
    function write_wb_xlml() {
        return "";
    }
    function write_sty_xlml(wb, opts) {
        var styles = [ '<Style ss:ID="Default" ss:Name="Normal"><NumberFormat/></Style>' ];
        opts.cellXfs.forEach(function(xf, id) {
            var payload = [];
            payload.push(writextag("NumberFormat", null, {
                "ss:Format": escapexml(SSF._table[xf.numFmtId])
            }));
            styles.push(writextag("Style", payload.join(""), {
                "ss:ID": "s" + (21 + id)
            }));
        });
        return writextag("Styles", styles.join(""));
    }
    function write_name_xlml(n) {
        return writextag("NamedRange", null, {
            "ss:Name": n.Name,
            "ss:RefersTo": "=" + a1_to_rc(n.Ref, {
                "r": 0,
                "c": 0
            })
        });
    }
    function write_names_xlml(wb) {
        if (!((wb || {}).Workbook || {}).Names) return "";
        var names = wb.Workbook.Names;
        var out = [];
        for (var i = 0; i < names.length; ++i) {
            var n = names[i];
            if (n.Sheet != null) continue;
            if (n.Name.match(/^_xlfn\./)) continue;
            out.push(write_name_xlml(n));
        }
        return writextag("Names", out.join(""));
    }
    function write_ws_xlml_names(ws, opts, idx, wb) {
        if (!ws) return "";
        if (!((wb || {}).Workbook || {}).Names) return "";
        var names = wb.Workbook.Names;
        var out = [];
        for (var i = 0; i < names.length; ++i) {
            var n = names[i];
            if (n.Sheet != idx) continue;
            if (n.Name.match(/^_xlfn\./)) continue;
            out.push(write_name_xlml(n));
        }
        return out.join("");
    }
    function write_ws_xlml_wsopts(ws, opts, idx, wb) {
        if (!ws) return "";
        var o = [];
        if (ws["!margins"]) {
            o.push("<PageSetup>");
            if (ws["!margins"].header) o.push(writextag("Header", null, {
                "x:Margin": ws["!margins"].header
            }));
            if (ws["!margins"].footer) o.push(writextag("Footer", null, {
                "x:Margin": ws["!margins"].footer
            }));
            o.push(writextag("PageMargins", null, {
                "x:Bottom": ws["!margins"].bottom || "0.75",
                "x:Left": ws["!margins"].left || "0.7",
                "x:Right": ws["!margins"].right || "0.7",
                "x:Top": ws["!margins"].top || "0.75"
            }));
            o.push("</PageSetup>");
        }
        if (wb && wb.Workbook && wb.Workbook.Sheets && wb.Workbook.Sheets[idx]) {
            if (wb.Workbook.Sheets[idx].Hidden) o.push(writextag("Visible", wb.Workbook.Sheets[idx].Hidden == 1 ? "SheetHidden" : "SheetVeryHidden", {})); else {
                for (var i = 0; i < idx; ++i) if (wb.Workbook.Sheets[i] && !wb.Workbook.Sheets[i].Hidden) break;
                if (i == idx) o.push("<Selected/>");
            }
        }
        if (((((wb || {}).Workbook || {}).Views || [])[0] || {}).RTL) o.push("<DisplayRightToLeft/>");
        if (ws["!protect"]) {
            o.push(writetag("ProtectContents", "True"));
            if (ws["!protect"].objects) o.push(writetag("ProtectObjects", "True"));
            if (ws["!protect"].scenarios) o.push(writetag("ProtectScenarios", "True"));
            if (ws["!protect"].selectLockedCells != null && !ws["!protect"].selectLockedCells) o.push(writetag("EnableSelection", "NoSelection")); else if (ws["!protect"].selectUnlockedCells != null && !ws["!protect"].selectUnlockedCells) o.push(writetag("EnableSelection", "UnlockedCells"));
            [ [ "formatCells", "AllowFormatCells" ], [ "formatColumns", "AllowSizeCols" ], [ "formatRows", "AllowSizeRows" ], [ "insertColumns", "AllowInsertCols" ], [ "insertRows", "AllowInsertRows" ], [ "insertHyperlinks", "AllowInsertHyperlinks" ], [ "deleteColumns", "AllowDeleteCols" ], [ "deleteRows", "AllowDeleteRows" ], [ "sort", "AllowSort" ], [ "autoFilter", "AllowFilter" ], [ "pivotTables", "AllowUsePivotTables" ] ].forEach(function(x) {
                if (ws["!protect"][x[0]]) o.push("<" + x[1] + "/>");
            });
        }
        if (o.length == 0) return "";
        return writextag("WorksheetOptions", o.join(""), {
            "xmlns": XLMLNS.x
        });
    }
    function write_ws_xlml_comment(comments) {
        return comments.map(function(c) {
            var t = xlml_unfixstr(c.t || "");
            var d = writextag("ss:Data", t, {
                "xmlns": "http://www.w3.org/TR/REC-html40"
            });
            return writextag("Comment", d, {
                "ss:Author": c.a
            });
        }).join("");
    }
    function write_ws_xlml_cell(cell, ref, ws, opts, idx, wb, addr) {
        if (!cell || cell.v == undefined && cell.f == undefined) return "";
        var attr = {};
        if (cell.f) attr["ss:Formula"] = "=" + escapexml(a1_to_rc(cell.f, addr));
        if (cell.F && cell.F.slice(0, ref.length) == ref) {
            var end = decode_cell(cell.F.slice(ref.length + 1));
            attr["ss:ArrayRange"] = "RC:R" + (end.r == addr.r ? "" : "[" + (end.r - addr.r) + "]") + "C" + (end.c == addr.c ? "" : "[" + (end.c - addr.c) + "]");
        }
        if (cell.l && cell.l.Target) {
            attr["ss:HRef"] = escapexml(cell.l.Target);
            if (cell.l.Tooltip) attr["x:HRefScreenTip"] = escapexml(cell.l.Tooltip);
        }
        if (ws["!merges"]) {
            var marr = ws["!merges"];
            for (var mi = 0; mi != marr.length; ++mi) {
                if (marr[mi].s.c != addr.c || marr[mi].s.r != addr.r) continue;
                if (marr[mi].e.c > marr[mi].s.c) attr["ss:MergeAcross"] = marr[mi].e.c - marr[mi].s.c;
                if (marr[mi].e.r > marr[mi].s.r) attr["ss:MergeDown"] = marr[mi].e.r - marr[mi].s.r;
            }
        }
        var t = "", p = "";
        switch (cell.t) {
          case "z":
            return "";

          case "n":
            t = "Number";
            p = String(cell.v);
            break;

          case "b":
            t = "Boolean";
            p = cell.v ? "1" : "0";
            break;

          case "e":
            t = "Error";
            p = BErr[cell.v];
            break;

          case "d":
            t = "DateTime";
            p = new Date(cell.v).toISOString();
            if (cell.z == null) cell.z = cell.z || SSF._table[14];
            break;

          case "s":
            t = "String";
            p = escapexlml(cell.v || "");
            break;
        }
        var os = get_cell_style(opts.cellXfs, cell, opts);
        attr["ss:StyleID"] = "s" + (21 + os);
        attr["ss:Index"] = addr.c + 1;
        var _v = cell.v != null ? p : "";
        var m = '<Data ss:Type="' + t + '">' + _v + "</Data>";
        if ((cell.c || []).length > 0) m += write_ws_xlml_comment(cell.c);
        return writextag("Cell", m, attr);
    }
    function write_ws_xlml_row(R, row) {
        var o = '<Row ss:Index="' + (R + 1) + '"';
        if (row) {
            if (row.hpt && !row.hpx) row.hpx = pt2px(row.hpt);
            if (row.hpx) o += ' ss:AutoFitHeight="0" ss:Height="' + row.hpx + '"';
            if (row.hidden) o += ' ss:Hidden="1"';
        }
        return o + ">";
    }
    function write_ws_xlml_table(ws, opts, idx, wb) {
        if (!ws["!ref"]) return "";
        var range = safe_decode_range(ws["!ref"]);
        var marr = ws["!merges"] || [], mi = 0;
        var o = [];
        if (ws["!cols"]) ws["!cols"].forEach(function(n, i) {
            process_col(n);
            var w = !!n.width;
            var p = col_obj_w(i, n);
            var k = {
                "ss:Index": i + 1
            };
            if (w) k["ss:Width"] = width2px(p.width);
            if (n.hidden) k["ss:Hidden"] = "1";
            o.push(writextag("Column", null, k));
        });
        var dense = Array.isArray(ws);
        for (var R = range.s.r; R <= range.e.r; ++R) {
            var row = [ write_ws_xlml_row(R, (ws["!rows"] || [])[R]) ];
            for (var C = range.s.c; C <= range.e.c; ++C) {
                var skip = false;
                for (mi = 0; mi != marr.length; ++mi) {
                    if (marr[mi].s.c > C) continue;
                    if (marr[mi].s.r > R) continue;
                    if (marr[mi].e.c < C) continue;
                    if (marr[mi].e.r < R) continue;
                    if (marr[mi].s.c != C || marr[mi].s.r != R) skip = true;
                    break;
                }
                if (skip) continue;
                var addr = {
                    "r": R,
                    "c": C
                };
                var ref = encode_cell(addr), cell = dense ? (ws[R] || [])[C] : ws[ref];
                row.push(write_ws_xlml_cell(cell, ref, ws, opts, idx, wb, addr));
            }
            row.push("</Row>");
            if (row.length > 2) o.push(row.join(""));
        }
        return o.join("");
    }
    function write_ws_xlml(idx, opts, wb) {
        var o = [];
        var s = wb.SheetNames[idx];
        var ws = wb.Sheets[s];
        var t = ws ? write_ws_xlml_names(ws, opts, idx, wb) : "";
        if (t.length > 0) o.push("<Names>" + t + "</Names>");
        t = ws ? write_ws_xlml_table(ws, opts, idx, wb) : "";
        if (t.length > 0) o.push("<Table>" + t + "</Table>");
        o.push(write_ws_xlml_wsopts(ws, opts, idx, wb));
        return o.join("");
    }
    function write_xlml(wb, opts) {
        if (!opts) opts = {};
        if (!wb.SSF) wb.SSF = SSF.get_table();
        if (wb.SSF) {
            make_ssf(SSF);
            SSF.load_table(wb.SSF);
            opts.revssf = evert_num(wb.SSF);
            opts.revssf[wb.SSF[65535]] = 0;
            opts.ssf = wb.SSF;
            opts.cellXfs = [];
            get_cell_style(opts.cellXfs, {}, {
                "revssf": {
                    "General": 0
                }
            });
        }
        var d = [];
        d.push(write_props_xlml(wb, opts));
        d.push(write_wb_xlml(wb, opts));
        d.push("");
        d.push("");
        for (var i = 0; i < wb.SheetNames.length; ++i) d.push(writextag("Worksheet", write_ws_xlml(i, opts, wb), {
            "ss:Name": escapexml(wb.SheetNames[i])
        }));
        d[2] = write_sty_xlml(wb, opts);
        d[3] = write_names_xlml(wb, opts);
        return XML_HEADER + writextag("Workbook", d.join(""), {
            "xmlns": XLMLNS.ss,
            "xmlns:o": XLMLNS.o,
            "xmlns:x": XLMLNS.x,
            "xmlns:ss": XLMLNS.ss,
            "xmlns:dt": XLMLNS.dt,
            "xmlns:html": XLMLNS.html
        });
    }
    function parse_compobj(obj) {
        var v = {};
        var o = obj.content;
        o.l = 28;
        v.AnsiUserType = o.read_shift(0, "lpstr-ansi");
        v.AnsiClipboardFormat = parse_ClipboardFormatOrAnsiString(o);
        if (o.length - o.l <= 4) return v;
        var m = o.read_shift(4);
        if (m == 0 || m > 40) return v;
        o.l -= 4;
        v.Reserved1 = o.read_shift(0, "lpstr-ansi");
        if (o.length - o.l <= 4) return v;
        m = o.read_shift(4);
        if (m !== 1907505652) return v;
        v.UnicodeClipboardFormat = parse_ClipboardFormatOrUnicodeString(o);
        m = o.read_shift(4);
        if (m == 0 || m > 40) return v;
        o.l -= 4;
        v.Reserved2 = o.read_shift(0, "lpwstr");
    }
    function slurp(R, blob, length, opts) {
        var l = length;
        var bufs = [];
        var d = blob.slice(blob.l, blob.l + l);
        if (opts && opts.enc && opts.enc.insitu) switch (R.n) {
          case "BOF":
          case "FilePass":
          case "FileLock":
          case "InterfaceHdr":
          case "RRDInfo":
          case "RRDHead":
          case "UsrExcl":
            break;

          default:
            if (d.length === 0) break;
            opts.enc.insitu(d);
        }
        bufs.push(d);
        blob.l += l;
        var next = XLSRecordEnum[__readUInt16LE(blob, blob.l)];
        var start = 0;
        while (next != null && next.n.slice(0, 8) === "Continue") {
            l = __readUInt16LE(blob, blob.l + 2);
            start = blob.l + 4;
            if (next.n == "ContinueFrt") start += 4; else if (next.n.slice(0, 11) == "ContinueFrt") start += 12;
            bufs.push(blob.slice(start, blob.l + 4 + l));
            blob.l += 4 + l;
            next = XLSRecordEnum[__readUInt16LE(blob, blob.l)];
        }
        var b = bconcat(bufs);
        prep_blob(b, 0);
        var ll = 0;
        b.lens = [];
        for (var j = 0; j < bufs.length; ++j) {
            b.lens.push(ll);
            ll += bufs[j].length;
        }
        return R.f(b, b.length, opts);
    }
    function safe_format_xf(p, opts, date1904) {
        if (p.t === "z") return;
        if (!p.XF) return;
        var fmtid = 0;
        try {
            fmtid = p.z || p.XF.numFmtId || 0;
            if (opts.cellNF) p.z = SSF._table[fmtid];
        } catch (e) {
            if (opts.WTF) throw e;
        }
        if (!opts || opts.cellText !== false) try {
            if (p.t === "e") {
                p.w = p.w || BErr[p.v];
            } else if (fmtid === 0 || fmtid == "General") {
                if (p.t === "n") {
                    if ((p.v | 0) === p.v) p.w = SSF._general_int(p.v); else p.w = SSF._general_num(p.v);
                } else p.w = SSF._general(p.v);
            } else p.w = SSF.format(fmtid, p.v, {
                "date1904": !!date1904
            });
        } catch (e) {
            if (opts.WTF) throw e;
        }
        if (opts.cellDates && fmtid && p.t == "n" && SSF.is_date(SSF._table[fmtid] || String(fmtid))) {
            var _d = SSF.parse_date_code(p.v);
            if (_d) {
                p.t = "d";
                p.v = new Date(_d.y, _d.m - 1, _d.d, _d.H, _d.M, _d.S, _d.u);
            }
        }
    }
    function make_cell(val, ixfe, t) {
        return {
            "v": val,
            "ixfe": ixfe,
            "t": t
        };
    }
    function parse_workbook(blob, options) {
        var wb = {
            "opts": {}
        };
        var Sheets = {};
        if (DENSE != null && options.dense == null) options.dense = DENSE;
        var out = options.dense ? [] : {};
        var Directory = {};
        var range = {};
        var last_formula = null;
        var sst = [];
        var cur_sheet = "";
        var Preamble = {};
        var lastcell, last_cell = "", cc, cmnt, rngC, rngR;
        var sharedf = {};
        var arrayf = [];
        var temp_val;
        var country;
        var cell_valid = true;
        var XFs = [];
        var palette = [];
        var Workbook = {
            "Sheets": [],
            "WBProps": {
                "date1904": false
            },
            "Views": [ {} ]
        }, wsprops = {};
        var get_rgb = function getrgb(icv) {
            if (icv < 8) return XLSIcv[icv];
            if (icv < 64) return palette[icv - 8] || XLSIcv[icv];
            return XLSIcv[icv];
        };
        var process_cell_style = function pcs(cell, line, options) {
            var xfd = line.XF.data;
            if (!xfd || !xfd.patternType || !options || !options.cellStyles) return;
            line.s = {};
            line.s.patternType = xfd.patternType;
            var t;
            if (t = rgb2Hex(get_rgb(xfd.icvFore))) {
                line.s.fgColor = {
                    "rgb": t
                };
            }
            if (t = rgb2Hex(get_rgb(xfd.icvBack))) {
                line.s.bgColor = {
                    "rgb": t
                };
            }
        };
        var addcell = function addcell(cell, line, options) {
            if (file_depth > 1) return;
            if (options.sheetRows && cell.r >= options.sheetRows) cell_valid = false;
            if (!cell_valid) return;
            if (options.cellStyles && line.XF && line.XF.data) process_cell_style(cell, line, options);
            delete line.ixfe;
            delete line.XF;
            lastcell = cell;
            last_cell = encode_cell(cell);
            if (range.s) {
                if (cell.r < range.s.r) range.s.r = cell.r;
                if (cell.c < range.s.c) range.s.c = cell.c;
            }
            if (range.e) {
                if (cell.r + 1 > range.e.r) range.e.r = cell.r + 1;
                if (cell.c + 1 > range.e.c) range.e.c = cell.c + 1;
            }
            if (options.cellFormula && line.f) {
                for (var afi = 0; afi < arrayf.length; ++afi) {
                    if (arrayf[afi][0].s.c > cell.c || arrayf[afi][0].s.r > cell.r) continue;
                    if (arrayf[afi][0].e.c < cell.c || arrayf[afi][0].e.r < cell.r) continue;
                    line.F = encode_range(arrayf[afi][0]);
                    if (arrayf[afi][0].s.c != cell.c || arrayf[afi][0].s.r != cell.r) delete line.f;
                    if (line.f) line.f = "" + stringify_formula(arrayf[afi][1], range, cell, supbooks, opts);
                    break;
                }
            }
            {
                if (options.dense) {
                    if (!out[cell.r]) out[cell.r] = [];
                    out[cell.r][cell.c] = line;
                } else out[last_cell] = line;
            }
        };
        var opts = {
            "enc": false,
            "sbcch": 0,
            "snames": [],
            "sharedf": sharedf,
            "arrayf": arrayf,
            "rrtabid": [],
            "lastuser": "",
            "biff": 8,
            "codepage": 0,
            "winlocked": 0,
            "cellStyles": !!options && !!options.cellStyles,
            "WTF": !!options && !!options.wtf
        };
        if (options.password) opts.password = options.password;
        var themes;
        var merges = [];
        var objects = [];
        var colinfo = [], rowinfo = [];
        var defwidth = 0, defheight = 0;
        var seencol = false;
        var supbooks = [];
        supbooks.SheetNames = opts.snames;
        supbooks.sharedf = opts.sharedf;
        supbooks.arrayf = opts.arrayf;
        supbooks.names = [];
        supbooks.XTI = [];
        var last_Rn = "";
        var file_depth = 0;
        var BIFF2Fmt = 0, BIFF2FmtTable = [];
        var FilterDatabases = [];
        var last_lbl;
        opts.codepage = 1200;
        set_cp(1200);
        var seen_codepage = false;
        while (blob.l < blob.length - 1) {
            var s = blob.l;
            var RecordType = blob.read_shift(2);
            if (RecordType === 0 && last_Rn === "EOF") break;
            var length = blob.l === blob.length ? 0 : blob.read_shift(2);
            var R = XLSRecordEnum[RecordType];
            if (R && R.f) {
                if (options.bookSheets) {
                    if (last_Rn === "BoundSheet8" && R.n !== "BoundSheet8") break;
                }
                last_Rn = R.n;
                if (R.r === 2 || R.r == 12) {
                    var rt = blob.read_shift(2);
                    length -= 2;
                    if (!opts.enc && rt !== RecordType && ((rt & 255) << 8 | rt >> 8) !== RecordType) throw new Error("rt mismatch: " + rt + "!=" + RecordType);
                    if (R.r == 12) {
                        blob.l += 10;
                        length -= 10;
                    }
                }
                var val;
                if (R.n === "EOF") val = R.f(blob, length, opts); else val = slurp(R, blob, length, opts);
                var Rn = R.n;
                if (file_depth == 0 && Rn != "BOF") continue;
                switch (Rn) {
                  case "Date1904":
                    wb.opts.Date1904 = Workbook.WBProps.date1904 = val;
                    break;

                  case "WriteProtect":
                    wb.opts.WriteProtect = true;
                    break;

                  case "FilePass":
                    if (!opts.enc) blob.l = 0;
                    opts.enc = val;
                    if (!options.password) throw new Error("File is password-protected");
                    if (val.valid == null) throw new Error("Encryption scheme unsupported");
                    if (!val.valid) throw new Error("Password is incorrect");
                    break;

                  case "WriteAccess":
                    opts.lastuser = val;
                    break;

                  case "FileSharing":
                    break;

                  case "CodePage":
                    switch (val) {
                      case 21010:
                        val = 1200;
                        break;

                      case 32768:
                        val = 1e4;
                        break;

                      case 32769:
                        val = 1252;
                        break;
                    }
                    set_cp(opts.codepage = val);
                    seen_codepage = true;
                    break;

                  case "RRTabId":
                    opts.rrtabid = val;
                    break;

                  case "WinProtect":
                    opts.winlocked = val;
                    break;

                  case "Template":
                    break;

                  case "BookBool":
                    break;

                  case "UsesELFs":
                    break;

                  case "MTRSettings":
                    break;

                  case "RefreshAll":
                  case "CalcCount":
                  case "CalcDelta":
                  case "CalcIter":
                  case "CalcMode":
                  case "CalcPrecision":
                  case "CalcSaveRecalc":
                    wb.opts[Rn] = val;
                    break;

                  case "CalcRefMode":
                    opts.CalcRefMode = val;
                    break;

                  case "Uncalced":
                    break;

                  case "ForceFullCalculation":
                    wb.opts.FullCalc = val;
                    break;

                  case "WsBool":
                    if (val.fDialog) out["!type"] = "dialog";
                    break;

                  case "XF":
                    XFs.push(val);
                    break;

                  case "ExtSST":
                    break;

                  case "BookExt":
                    break;

                  case "RichTextStream":
                    break;

                  case "BkHim":
                    break;

                  case "SupBook":
                    supbooks.push([ val ]);
                    supbooks[supbooks.length - 1].XTI = [];
                    break;

                  case "ExternName":
                    supbooks[supbooks.length - 1].push(val);
                    break;

                  case "Index":
                    break;

                  case "Lbl":
                    last_lbl = {
                        "Name": val.Name,
                        "Ref": stringify_formula(val.rgce, range, null, supbooks, opts)
                    };
                    if (val.itab > 0) last_lbl.Sheet = val.itab - 1;
                    supbooks.names.push(last_lbl);
                    if (!supbooks[0]) {
                        supbooks[0] = [];
                        supbooks[0].XTI = [];
                    }
                    supbooks[supbooks.length - 1].push(val);
                    if (val.Name == "_xlnm._FilterDatabase" && val.itab > 0) if (val.rgce && val.rgce[0] && val.rgce[0][0] && val.rgce[0][0][0] == "PtgArea3d") FilterDatabases[val.itab - 1] = {
                        "ref": encode_range(val.rgce[0][0][1][2])
                    };
                    break;

                  case "ExternCount":
                    opts.ExternCount = val;
                    break;

                  case "ExternSheet":
                    if (supbooks.length == 0) {
                        supbooks[0] = [];
                        supbooks[0].XTI = [];
                    }
                    supbooks[supbooks.length - 1].XTI = supbooks[supbooks.length - 1].XTI.concat(val);
                    supbooks.XTI = supbooks.XTI.concat(val);
                    break;

                  case "NameCmt":
                    if (opts.biff < 8) break;
                    if (last_lbl != null) last_lbl.Comment = val[1];
                    break;

                  case "Protect":
                    out["!protect"] = val;
                    break;

                  case "Password":
                    if (val !== 0 && opts.WTF) console.error("Password verifier: " + val);
                    break;

                  case "Prot4Rev":
                  case "Prot4RevPass":
                    break;

                  case "BoundSheet8":
                    {
                        Directory[val.pos] = val;
                        opts.snames.push(val.name);
                    }
                    break;

                  case "EOF":
                    {
                        if (--file_depth) break;
                        if (range.e) {
                            if (range.e.r > 0 && range.e.c > 0) {
                                range.e.r--;
                                range.e.c--;
                                out["!ref"] = encode_range(range);
                                if (options.sheetRows && options.sheetRows <= range.e.r) {
                                    var tmpri = range.e.r;
                                    range.e.r = options.sheetRows - 1;
                                    out["!fullref"] = out["!ref"];
                                    out["!ref"] = encode_range(range);
                                    range.e.r = tmpri;
                                }
                                range.e.r++;
                                range.e.c++;
                            }
                            if (merges.length > 0) out["!merges"] = merges;
                            if (objects.length > 0) out["!objects"] = objects;
                            if (colinfo.length > 0) out["!cols"] = colinfo;
                            if (rowinfo.length > 0) out["!rows"] = rowinfo;
                            Workbook.Sheets.push(wsprops);
                        }
                        if (cur_sheet === "") Preamble = out; else Sheets[cur_sheet] = out;
                        out = options.dense ? [] : {};
                    }
                    break;

                  case "BOF":
                    {
                        if (opts.biff === 8) opts.biff = {
                            "9": 2,
                            "521": 3,
                            "1033": 4
                        }[RecordType] || {
                            "512": 2,
                            "768": 3,
                            "1024": 4,
                            "1280": 5,
                            "1536": 8,
                            "2": 2,
                            "7": 2
                        }[val.BIFFVer] || 8;
                        if (opts.biff == 8 && val.BIFFVer == 0 && val.dt == 16) opts.biff = 2;
                        if (file_depth++) break;
                        cell_valid = true;
                        out = options.dense ? [] : {};
                        if (opts.biff < 8 && !seen_codepage) {
                            seen_codepage = true;
                            set_cp(opts.codepage = options.codepage || 1252);
                        }
                        if (opts.biff < 5) {
                            if (cur_sheet === "") cur_sheet = "Sheet1";
                            range = {
                                "s": {
                                    "r": 0,
                                    "c": 0
                                },
                                "e": {
                                    "r": 0,
                                    "c": 0
                                }
                            };
                            var fakebs8 = {
                                "pos": blob.l - length,
                                "name": cur_sheet
                            };
                            Directory[fakebs8.pos] = fakebs8;
                            opts.snames.push(cur_sheet);
                        } else cur_sheet = (Directory[s] || {
                            "name": ""
                        }).name;
                        if (val.dt == 32) out["!type"] = "chart";
                        if (val.dt == 64) out["!type"] = "macro";
                        merges = [];
                        objects = [];
                        opts.arrayf = arrayf = [];
                        colinfo = [];
                        rowinfo = [];
                        defwidth = defheight = 0;
                        seencol = false;
                        wsprops = {
                            "Hidden": (Directory[s] || {
                                "hs": 0
                            }).hs,
                            "name": cur_sheet
                        };
                    }
                    break;

                  case "Number":
                  case "BIFF2NUM":
                  case "BIFF2INT":
                    {
                        if (out["!type"] == "chart") if (options.dense ? (out[val.r] || [])[val.c] : out[encode_cell({
                            "c": val.c,
                            "r": val.r
                        })]) ++val.c;
                        temp_val = {
                            "ixfe": val.ixfe,
                            "XF": XFs[val.ixfe] || {},
                            "v": val.val,
                            "t": "n"
                        };
                        if (BIFF2Fmt > 0) temp_val.z = BIFF2FmtTable[temp_val.ixfe >> 8 & 31];
                        safe_format_xf(temp_val, options, wb.opts.Date1904);
                        addcell({
                            "c": val.c,
                            "r": val.r
                        }, temp_val, options);
                    }
                    break;

                  case "BoolErr":
                    {
                        temp_val = {
                            "ixfe": val.ixfe,
                            "XF": XFs[val.ixfe],
                            "v": val.val,
                            "t": val.t
                        };
                        if (BIFF2Fmt > 0) temp_val.z = BIFF2FmtTable[temp_val.ixfe >> 8 & 31];
                        safe_format_xf(temp_val, options, wb.opts.Date1904);
                        addcell({
                            "c": val.c,
                            "r": val.r
                        }, temp_val, options);
                    }
                    break;

                  case "RK":
                    {
                        temp_val = {
                            "ixfe": val.ixfe,
                            "XF": XFs[val.ixfe],
                            "v": val.rknum,
                            "t": "n"
                        };
                        if (BIFF2Fmt > 0) temp_val.z = BIFF2FmtTable[temp_val.ixfe >> 8 & 31];
                        safe_format_xf(temp_val, options, wb.opts.Date1904);
                        addcell({
                            "c": val.c,
                            "r": val.r
                        }, temp_val, options);
                    }
                    break;

                  case "MulRk":
                    {
                        for (var j = val.c; j <= val.C; ++j) {
                            var ixfe = val.rkrec[j - val.c][0];
                            temp_val = {
                                "ixfe": ixfe,
                                "XF": XFs[ixfe],
                                "v": val.rkrec[j - val.c][1],
                                "t": "n"
                            };
                            if (BIFF2Fmt > 0) temp_val.z = BIFF2FmtTable[temp_val.ixfe >> 8 & 31];
                            safe_format_xf(temp_val, options, wb.opts.Date1904);
                            addcell({
                                "c": j,
                                "r": val.r
                            }, temp_val, options);
                        }
                    }
                    break;

                  case "Formula":
                    {
                        if (val.val == "String") {
                            last_formula = val;
                            break;
                        }
                        temp_val = make_cell(val.val, val.cell.ixfe, val.tt);
                        temp_val.XF = XFs[temp_val.ixfe];
                        if (options.cellFormula) {
                            var _f = val.formula;
                            if (_f && _f[0] && _f[0][0] && _f[0][0][0] == "PtgExp") {
                                var _fr = _f[0][0][1][0], _fc = _f[0][0][1][1];
                                var _fe = encode_cell({
                                    "r": _fr,
                                    "c": _fc
                                });
                                if (sharedf[_fe]) temp_val.f = "" + stringify_formula(val.formula, range, val.cell, supbooks, opts); else temp_val.F = ((options.dense ? (out[_fr] || [])[_fc] : out[_fe]) || {}).F;
                            } else temp_val.f = "" + stringify_formula(val.formula, range, val.cell, supbooks, opts);
                        }
                        if (BIFF2Fmt > 0) temp_val.z = BIFF2FmtTable[temp_val.ixfe >> 8 & 31];
                        safe_format_xf(temp_val, options, wb.opts.Date1904);
                        addcell(val.cell, temp_val, options);
                        last_formula = val;
                    }
                    break;

                  case "String":
                    {
                        if (last_formula) {
                            last_formula.val = val;
                            temp_val = make_cell(val, last_formula.cell.ixfe, "s");
                            temp_val.XF = XFs[temp_val.ixfe];
                            if (options.cellFormula) {
                                temp_val.f = "" + stringify_formula(last_formula.formula, range, last_formula.cell, supbooks, opts);
                            }
                            if (BIFF2Fmt > 0) temp_val.z = BIFF2FmtTable[temp_val.ixfe >> 8 & 31];
                            safe_format_xf(temp_val, options, wb.opts.Date1904);
                            addcell(last_formula.cell, temp_val, options);
                            last_formula = null;
                        } else throw new Error("String record expects Formula");
                    }
                    break;

                  case "Array":
                    {
                        arrayf.push(val);
                        var _arraystart = encode_cell(val[0].s);
                        cc = options.dense ? (out[val[0].s.r] || [])[val[0].s.c] : out[_arraystart];
                        if (options.cellFormula && cc) {
                            if (!last_formula) break;
                            if (!_arraystart || !cc) break;
                            cc.f = "" + stringify_formula(val[1], range, val[0], supbooks, opts);
                            cc.F = encode_range(val[0]);
                        }
                    }
                    break;

                  case "ShrFmla":
                    {
                        if (!cell_valid) break;
                        if (!options.cellFormula) break;
                        if (last_cell) {
                            if (!last_formula) break;
                            sharedf[encode_cell(last_formula.cell)] = val[0];
                            cc = options.dense ? (out[last_formula.cell.r] || [])[last_formula.cell.c] : out[encode_cell(last_formula.cell)];
                            (cc || {}).f = "" + stringify_formula(val[0], range, lastcell, supbooks, opts);
                        }
                    }
                    break;

                  case "LabelSst":
                    temp_val = make_cell(sst[val.isst].t, val.ixfe, "s");
                    temp_val.XF = XFs[temp_val.ixfe];
                    if (BIFF2Fmt > 0) temp_val.z = BIFF2FmtTable[temp_val.ixfe >> 8 & 31];
                    safe_format_xf(temp_val, options, wb.opts.Date1904);
                    addcell({
                        "c": val.c,
                        "r": val.r
                    }, temp_val, options);
                    break;

                  case "Blank":
                    if (options.sheetStubs) {
                        temp_val = {
                            "ixfe": val.ixfe,
                            "XF": XFs[val.ixfe],
                            "t": "z"
                        };
                        if (BIFF2Fmt > 0) temp_val.z = BIFF2FmtTable[temp_val.ixfe >> 8 & 31];
                        safe_format_xf(temp_val, options, wb.opts.Date1904);
                        addcell({
                            "c": val.c,
                            "r": val.r
                        }, temp_val, options);
                    }
                    break;

                  case "MulBlank":
                    if (options.sheetStubs) {
                        for (var _j = val.c; _j <= val.C; ++_j) {
                            var _ixfe = val.ixfe[_j - val.c];
                            temp_val = {
                                "ixfe": _ixfe,
                                "XF": XFs[_ixfe],
                                "t": "z"
                            };
                            if (BIFF2Fmt > 0) temp_val.z = BIFF2FmtTable[temp_val.ixfe >> 8 & 31];
                            safe_format_xf(temp_val, options, wb.opts.Date1904);
                            addcell({
                                "c": _j,
                                "r": val.r
                            }, temp_val, options);
                        }
                    }
                    break;

                  case "RString":
                  case "Label":
                  case "BIFF2STR":
                    temp_val = make_cell(val.val, val.ixfe, "s");
                    temp_val.XF = XFs[temp_val.ixfe];
                    if (BIFF2Fmt > 0) temp_val.z = BIFF2FmtTable[temp_val.ixfe >> 8 & 31];
                    safe_format_xf(temp_val, options, wb.opts.Date1904);
                    addcell({
                        "c": val.c,
                        "r": val.r
                    }, temp_val, options);
                    break;

                  case "Dimensions":
                    {
                        if (file_depth === 1) range = val;
                    }
                    break;

                  case "SST":
                    {
                        sst = val;
                    }
                    break;

                  case "Format":
                    {
                        if (opts.biff == 4) {
                            BIFF2FmtTable[BIFF2Fmt++] = val[1];
                            for (var b4idx = 0; b4idx < BIFF2Fmt + 163; ++b4idx) if (SSF._table[b4idx] == val[1]) break;
                            if (b4idx >= 163) SSF.load(val[1], BIFF2Fmt + 163);
                        } else SSF.load(val[1], val[0]);
                    }
                    break;

                  case "BIFF2FORMAT":
                    {
                        BIFF2FmtTable[BIFF2Fmt++] = val;
                        for (var b2idx = 0; b2idx < BIFF2Fmt + 163; ++b2idx) if (SSF._table[b2idx] == val) break;
                        if (b2idx >= 163) SSF.load(val, BIFF2Fmt + 163);
                    }
                    break;

                  case "MergeCells":
                    merges = merges.concat(val);
                    break;

                  case "Obj":
                    objects[val.cmo[0]] = opts.lastobj = val;
                    break;

                  case "TxO":
                    opts.lastobj.TxO = val;
                    break;

                  case "ImData":
                    opts.lastobj.ImData = val;
                    break;

                  case "HLink":
                    {
                        for (rngR = val[0].s.r; rngR <= val[0].e.r; ++rngR) for (rngC = val[0].s.c; rngC <= val[0].e.c; ++rngC) {
                            cc = options.dense ? (out[rngR] || [])[rngC] : out[encode_cell({
                                "c": rngC,
                                "r": rngR
                            })];
                            if (cc) cc.l = val[1];
                        }
                    }
                    break;

                  case "HLinkTooltip":
                    {
                        for (rngR = val[0].s.r; rngR <= val[0].e.r; ++rngR) for (rngC = val[0].s.c; rngC <= val[0].e.c; ++rngC) {
                            cc = options.dense ? (out[rngR] || [])[rngC] : out[encode_cell({
                                "c": rngC,
                                "r": rngR
                            })];
                            if (cc && cc.l) cc.l.Tooltip = val[1];
                        }
                    }
                    break;

                  case "Note":
                    {
                        if (opts.biff <= 5 && opts.biff >= 2) break;
                        cc = options.dense ? (out[val[0].r] || [])[val[0].c] : out[encode_cell(val[0])];
                        var noteobj = objects[val[2]];
                        if (!cc) break;
                        if (!cc.c) cc.c = [];
                        cmnt = {
                            "a": val[1],
                            "t": noteobj.TxO.t
                        };
                        cc.c.push(cmnt);
                    }
                    break;

                  default:
                    switch (R.n) {
                      case "ClrtClient":
                        break;

                      case "XFExt":
                        update_xfext(XFs[val.ixfe], val.ext);
                        break;

                      case "DefColWidth":
                        defwidth = val;
                        break;

                      case "DefaultRowHeight":
                        defheight = val[1];
                        break;

                      case "ColInfo":
                        {
                            if (!opts.cellStyles) break;
                            while (val.e >= val.s) {
                                colinfo[val.e--] = {
                                    "width": val.w / 256
                                };
                                if (!seencol) {
                                    seencol = true;
                                    find_mdw_colw(val.w / 256);
                                }
                                process_col(colinfo[val.e + 1]);
                            }
                        }
                        break;

                      case "Row":
                        {
                            var rowobj = {};
                            if (val.level != null) {
                                rowinfo[val.r] = rowobj;
                                rowobj.level = val.level;
                            }
                            if (val.hidden) {
                                rowinfo[val.r] = rowobj;
                                rowobj.hidden = true;
                            }
                            if (val.hpt) {
                                rowinfo[val.r] = rowobj;
                                rowobj.hpt = val.hpt;
                                rowobj.hpx = pt2px(val.hpt);
                            }
                        }
                        break;

                      case "LeftMargin":
                      case "RightMargin":
                      case "TopMargin":
                      case "BottomMargin":
                        if (!out["!margins"]) default_margins(out["!margins"] = {});
                        out["!margins"][Rn.slice(0, -6).toLowerCase()] = val;
                        break;

                      case "Setup":
                        if (!out["!margins"]) default_margins(out["!margins"] = {});
                        out["!margins"].header = val.header;
                        out["!margins"].footer = val.footer;
                        break;

                      case "Window2":
                        if (val.RTL) Workbook.Views[0].RTL = true;
                        break;

                      case "Header":
                        break;

                      case "Footer":
                        break;

                      case "HCenter":
                        break;

                      case "VCenter":
                        break;

                      case "Pls":
                        break;

                      case "GCW":
                        break;

                      case "LHRecord":
                        break;

                      case "DBCell":
                        break;

                      case "EntExU2":
                        break;

                      case "SxView":
                        break;

                      case "Sxvd":
                        break;

                      case "SXVI":
                        break;

                      case "SXVDEx":
                        break;

                      case "SxIvd":
                        break;

                      case "SXString":
                        break;

                      case "Sync":
                        break;

                      case "Addin":
                        break;

                      case "SXDI":
                        break;

                      case "SXLI":
                        break;

                      case "SXEx":
                        break;

                      case "QsiSXTag":
                        break;

                      case "Selection":
                        break;

                      case "Feat":
                        break;

                      case "FeatHdr":
                      case "FeatHdr11":
                        break;

                      case "Feature11":
                      case "Feature12":
                      case "List12":
                        break;

                      case "Country":
                        country = val;
                        break;

                      case "RecalcId":
                        break;

                      case "DxGCol":
                        break;

                      case "Fbi":
                      case "Fbi2":
                      case "GelFrame":
                        break;

                      case "Font":
                        break;

                      case "XFCRC":
                        break;

                      case "Style":
                        break;

                      case "StyleExt":
                        break;

                      case "Palette":
                        palette = val;
                        break;

                      case "Theme":
                        themes = val;
                        break;

                      case "ScenarioProtect":
                        break;

                      case "ObjProtect":
                        break;

                      case "CondFmt12":
                        break;

                      case "Table":
                        break;

                      case "TableStyles":
                        break;

                      case "TableStyle":
                        break;

                      case "TableStyleElement":
                        break;

                      case "SXStreamID":
                        break;

                      case "SXVS":
                        break;

                      case "DConRef":
                        break;

                      case "SXAddl":
                        break;

                      case "DConBin":
                        break;

                      case "DConName":
                        break;

                      case "SXPI":
                        break;

                      case "SxFormat":
                        break;

                      case "SxSelect":
                        break;

                      case "SxRule":
                        break;

                      case "SxFilt":
                        break;

                      case "SxItm":
                        break;

                      case "SxDXF":
                        break;

                      case "ScenMan":
                        break;

                      case "DCon":
                        break;

                      case "CellWatch":
                        break;

                      case "PrintRowCol":
                        break;

                      case "PrintGrid":
                        break;

                      case "PrintSize":
                        break;

                      case "XCT":
                        break;

                      case "CRN":
                        break;

                      case "Scl":
                        {}
                        break;

                      case "SheetExt":
                        {}
                        break;

                      case "SheetExtOptional":
                        {}
                        break;

                      case "ObNoMacros":
                        {}
                        break;

                      case "ObProj":
                        {}
                        break;

                      case "CodeName":
                        {
                            if (!cur_sheet) Workbook.WBProps.CodeName = val || "ThisWorkbook"; else wsprops.CodeName = val || wsprops.name;
                        }
                        break;

                      case "GUIDTypeLib":
                        {}
                        break;

                      case "WOpt":
                        break;

                      case "PhoneticInfo":
                        break;

                      case "OleObjectSize":
                        break;

                      case "DXF":
                      case "DXFN":
                      case "DXFN12":
                      case "DXFN12List":
                      case "DXFN12NoCB":
                        break;

                      case "Dv":
                      case "DVal":
                        break;

                      case "BRAI":
                      case "Series":
                      case "SeriesText":
                        break;

                      case "DConn":
                        break;

                      case "DbOrParamQry":
                        break;

                      case "DBQueryExt":
                        break;

                      case "OleDbConn":
                        break;

                      case "ExtString":
                        break;

                      case "IFmtRecord":
                        break;

                      case "CondFmt":
                      case "CF":
                      case "CF12":
                      case "CFEx":
                        break;

                      case "Excel9File":
                        break;

                      case "Units":
                        break;

                      case "InterfaceHdr":
                      case "Mms":
                      case "InterfaceEnd":
                      case "DSF":
                        break;

                      case "BuiltInFnGroupCount":
                        break;

                      case "Window1":
                      case "HideObj":
                      case "GridSet":
                      case "Guts":
                      case "UserBView":
                      case "UserSViewBegin":
                      case "UserSViewEnd":
                      case "Pane":
                        break;

                      default:
                        switch (R.n) {
                          case "Dat":
                          case "Begin":
                          case "End":
                          case "StartBlock":
                          case "EndBlock":
                          case "Frame":
                          case "Area":
                          case "Axis":
                          case "AxisLine":
                          case "Tick":
                            break;

                          case "AxesUsed":
                          case "CrtLayout12":
                          case "CrtLayout12A":
                          case "CrtLink":
                          case "CrtLine":
                          case "CrtMlFrt":
                          case "CrtMlFrtContinue":
                            break;

                          case "LineFormat":
                          case "AreaFormat":
                          case "Chart":
                          case "Chart3d":
                          case "Chart3DBarShape":
                          case "ChartFormat":
                          case "ChartFrtInfo":
                            break;

                          case "PlotArea":
                          case "PlotGrowth":
                            break;

                          case "SeriesList":
                          case "SerParent":
                          case "SerAuxTrend":
                            break;

                          case "DataFormat":
                          case "SerToCrt":
                          case "FontX":
                            break;

                          case "CatSerRange":
                          case "AxcExt":
                          case "SerFmt":
                            break;

                          case "ShtProps":
                            break;

                          case "DefaultText":
                          case "Text":
                          case "CatLab":
                            break;

                          case "DataLabExtContents":
                            break;

                          case "Legend":
                          case "LegendException":
                            break;

                          case "Pie":
                          case "Scatter":
                            break;

                          case "PieFormat":
                          case "MarkerFormat":
                            break;

                          case "StartObject":
                          case "EndObject":
                            break;

                          case "AlRuns":
                          case "ObjectLink":
                            break;

                          case "SIIndex":
                            break;

                          case "AttachedLabel":
                          case "YMult":
                            break;

                          case "Line":
                          case "Bar":
                            break;

                          case "Surf":
                            break;

                          case "AxisParent":
                            break;

                          case "Pos":
                            break;

                          case "ValueRange":
                            break;

                          case "SXViewEx9":
                            break;

                          case "SXViewLink":
                            break;

                          case "PivotChartBits":
                            break;

                          case "SBaseRef":
                            break;

                          case "TextPropsStream":
                            break;

                          case "LnExt":
                            break;

                          case "MkrExt":
                            break;

                          case "CrtCoopt":
                            break;

                          case "Qsi":
                          case "Qsif":
                          case "Qsir":
                          case "QsiSXTag":
                            break;

                          case "TxtQry":
                            break;

                          case "FilterMode":
                            break;

                          case "AutoFilter":
                          case "AutoFilterInfo":
                            break;

                          case "AutoFilter12":
                            break;

                          case "DropDownObjIds":
                            break;

                          case "Sort":
                            break;

                          case "SortData":
                            break;

                          case "ShapePropsStream":
                            break;

                          case "MsoDrawing":
                          case "MsoDrawingGroup":
                          case "MsoDrawingSelection":
                            break;

                          case "WebPub":
                          case "AutoWebPub":
                            break;

                          case "HeaderFooter":
                          case "HFPicture":
                          case "PLV":
                          case "HorizontalPageBreaks":
                          case "VerticalPageBreaks":
                            break;

                          case "Backup":
                          case "CompressPictures":
                          case "Compat12":
                            break;

                          case "Continue":
                          case "ContinueFrt12":
                            break;

                          case "FrtFontList":
                          case "FrtWrapper":
                            break;

                          default:
                            switch (R.n) {
                              case "TabIdConf":
                              case "Radar":
                              case "RadarArea":
                              case "DropBar":
                              case "Intl":
                              case "CoordList":
                              case "SerAuxErrBar":
                                break;

                              case "BIFF2FONTCLR":
                              case "BIFF2FMTCNT":
                              case "BIFF2FONTXTRA":
                                break;

                              case "BIFF2XF":
                              case "BIFF3XF":
                              case "BIFF4XF":
                                break;

                              case "BIFF4FMTCNT":
                              case "BIFF2ROW":
                              case "BIFF2WINDOW2":
                                break;

                              case "SCENARIO":
                              case "DConBin":
                              case "PicF":
                              case "DataLabExt":
                              case "Lel":
                              case "BopPop":
                              case "BopPopCustom":
                              case "RealTimeData":
                              case "Name":
                                break;

                              case "LHNGraph":
                              case "FnGroupName":
                              case "AddMenu":
                              case "LPr":
                                break;

                              case "ListObj":
                              case "ListField":
                                break;

                              case "RRSort":
                                break;

                              case "BigName":
                                break;

                              case "ToolbarHdr":
                              case "ToolbarEnd":
                                break;

                              case "DDEObjName":
                                break;

                              case "FRTArchId$":
                                break;

                              default:
                                if (options.WTF) throw "Unrecognized Record " + R.n;
                            }
                        }
                    }
                }
            } else blob.l += length;
        }
        wb.SheetNames = keys(Directory).sort(function(a, b) {
            return Number(a) - Number(b);
        }).map(function(x) {
            return Directory[x].name;
        });
        if (!options.bookSheets) wb.Sheets = Sheets;
        if (wb.Sheets) FilterDatabases.forEach(function(r, i) {
            wb.Sheets[wb.SheetNames[i]]["!autofilter"] = r;
        });
        wb.Preamble = Preamble;
        wb.Strings = sst;
        wb.SSF = SSF.get_table();
        if (opts.enc) wb.Encryption = opts.enc;
        if (themes) wb.Themes = themes;
        wb.Metadata = {};
        if (country !== undefined) wb.Metadata.Country = country;
        if (supbooks.names.length > 0) Workbook.Names = supbooks.names;
        wb.Workbook = Workbook;
        return wb;
    }
    var PSCLSID = {
        "SI": "e0859ff2f94f6810ab9108002b27b3d9",
        "DSI": "02d5cdd59c2e1b10939708002b2cf9ae",
        "UDI": "05d5cdd59c2e1b10939708002b2cf9ae"
    };
    function parse_xls_props(cfb, props, o) {
        var DSI = CFB.find(cfb, "!DocumentSummaryInformation");
        if (DSI && DSI.size > 0) try {
            var DocSummary = parse_PropertySetStream(DSI, DocSummaryPIDDSI, PSCLSID.DSI);
            for (var d in DocSummary) props[d] = DocSummary[d];
        } catch (e) {
            if (o.WTF) throw e;
        }
        var SI = CFB.find(cfb, "!SummaryInformation");
        if (SI && SI.size > 0) try {
            var Summary = parse_PropertySetStream(SI, SummaryPIDSI, PSCLSID.SI);
            for (var s in Summary) if (props[s] == null) props[s] = Summary[s];
        } catch (e) {
            if (o.WTF) throw e;
        }
        if (props.HeadingPairs && props.TitlesOfParts) {
            load_props_pairs(props.HeadingPairs, props.TitlesOfParts, props, o);
            delete props.HeadingPairs;
            delete props.TitlesOfParts;
        }
    }
    function write_xls_props(wb, cfb) {
        var DSEntries = [], SEntries = [], CEntries = [];
        var i = 0, Keys;
        if (wb.Props) {
            Keys = keys(wb.Props);
            for (i = 0; i < Keys.length; ++i) (DocSummaryRE.hasOwnProperty(Keys[i]) ? DSEntries : SummaryRE.hasOwnProperty(Keys[i]) ? SEntries : CEntries).push([ Keys[i], wb.Props[Keys[i]] ]);
        }
        if (wb.Custprops) {
            Keys = keys(wb.Custprops);
            for (i = 0; i < Keys.length; ++i) if (!(wb.Props || {}).hasOwnProperty(Keys[i])) (DocSummaryRE.hasOwnProperty(Keys[i]) ? DSEntries : SummaryRE.hasOwnProperty(Keys[i]) ? SEntries : CEntries).push([ Keys[i], wb.Custprops[Keys[i]] ]);
        }
        var CEntries2 = [];
        for (i = 0; i < CEntries.length; ++i) {
            if (XLSPSSkip.indexOf(CEntries[i][0]) > -1) continue;
            if (CEntries[i][1] == null) continue;
            CEntries2.push(CEntries[i]);
        }
        if (SEntries.length) CFB.utils.cfb_add(cfb, "/\x05SummaryInformation", write_PropertySetStream(SEntries, PSCLSID.SI, SummaryRE, SummaryPIDSI));
        if (DSEntries.length || CEntries2.length) CFB.utils.cfb_add(cfb, "/\x05DocumentSummaryInformation", write_PropertySetStream(DSEntries, PSCLSID.DSI, DocSummaryRE, DocSummaryPIDDSI, CEntries2.length ? CEntries2 : null, PSCLSID.UDI));
    }
    function parse_xlscfb(cfb, options) {
        if (!options) options = {};
        fix_read_opts(options);
        reset_cp();
        if (options.codepage) set_ansi(options.codepage);
        var CompObj, WB;
        if (cfb.FullPaths) {
            if (CFB.find(cfb, "/encryption")) throw new Error("File is password-protected");
            CompObj = CFB.find(cfb, "!CompObj");
            WB = CFB.find(cfb, "/Workbook") || CFB.find(cfb, "/Book");
        } else {
            switch (options.type) {
              case "base64":
                cfb = s2a(Base64.decode(cfb));
                break;

              case "binary":
                cfb = s2a(cfb);
                break;

              case "buffer":
                break;

              case "array":
                if (!Array.isArray(cfb)) cfb = Array.prototype.slice.call(cfb);
                break;
            }
            prep_blob(cfb, 0);
            WB = {
                "content": cfb
            };
        }
        var WorkbookP;
        var _data;
        if (CompObj) parse_compobj(CompObj);
        if (options.bookProps && !options.bookSheets) WorkbookP = {}; else {
            var T = has_buf ? "buffer" : "array";
            if (WB && WB.content) WorkbookP = parse_workbook(WB.content, options); else if ((_data = CFB.find(cfb, "PerfectOffice_MAIN")) && _data.content) WorkbookP = WK_.to_workbook(_data.content, (options.type = T, 
            options)); else if ((_data = CFB.find(cfb, "NativeContent_MAIN")) && _data.content) WorkbookP = WK_.to_workbook(_data.content, (options.type = T, 
            options)); else throw new Error("Cannot find Workbook stream");
            if (options.bookVBA && cfb.FullPaths && CFB.find(cfb, "/_VBA_PROJECT_CUR/VBA/dir")) WorkbookP.vbaraw = make_vba_xls(cfb);
        }
        var props = {};
        if (cfb.FullPaths) parse_xls_props(cfb, props, options);
        WorkbookP.Props = WorkbookP.Custprops = props;
        if (options.bookFiles) WorkbookP.cfb = cfb;
        return WorkbookP;
    }
    function write_xlscfb(wb, opts) {
        var o = opts || {};
        var cfb = CFB.utils.cfb_new({
            "root": "R"
        });
        var wbpath = "/Workbook";
        switch (o.bookType || "xls") {
          case "xls":
            o.bookType = "biff8";

          case "xla":
            if (!o.bookType) o.bookType = "xla";

          case "biff8":
            wbpath = "/Workbook";
            o.biff = 8;
            break;

          case "biff5":
            wbpath = "/Book";
            o.biff = 5;
            break;

          default:
            throw new Error("invalid type " + o.bookType + " for XLS CFB");
        }
        CFB.utils.cfb_add(cfb, wbpath, write_biff_buf(wb, o));
        if (o.biff == 8 && (wb.Props || wb.Custprops)) write_xls_props(wb, cfb);
        if (o.biff == 8 && wb.vbaraw) fill_vba_xls(cfb, CFB.read(wb.vbaraw, {
            "type": typeof wb.vbaraw == "string" ? "binary" : "buffer"
        }));
        return cfb;
    }
    var XLSBRecordEnum = {
        "0": {
            "n": "BrtRowHdr",
            "f": parse_BrtRowHdr
        },
        "1": {
            "n": "BrtCellBlank",
            "f": parse_BrtCellBlank
        },
        "2": {
            "n": "BrtCellRk",
            "f": parse_BrtCellRk
        },
        "3": {
            "n": "BrtCellError",
            "f": parse_BrtCellError
        },
        "4": {
            "n": "BrtCellBool",
            "f": parse_BrtCellBool
        },
        "5": {
            "n": "BrtCellReal",
            "f": parse_BrtCellReal
        },
        "6": {
            "n": "BrtCellSt",
            "f": parse_BrtCellSt
        },
        "7": {
            "n": "BrtCellIsst",
            "f": parse_BrtCellIsst
        },
        "8": {
            "n": "BrtFmlaString",
            "f": parse_BrtFmlaString
        },
        "9": {
            "n": "BrtFmlaNum",
            "f": parse_BrtFmlaNum
        },
        "10": {
            "n": "BrtFmlaBool",
            "f": parse_BrtFmlaBool
        },
        "11": {
            "n": "BrtFmlaError",
            "f": parse_BrtFmlaError
        },
        "16": {
            "n": "BrtFRTArchID$",
            "f": parse_BrtFRTArchID$
        },
        "19": {
            "n": "BrtSSTItem",
            "f": parse_RichStr
        },
        "20": {
            "n": "BrtPCDIMissing"
        },
        "21": {
            "n": "BrtPCDINumber"
        },
        "22": {
            "n": "BrtPCDIBoolean"
        },
        "23": {
            "n": "BrtPCDIError"
        },
        "24": {
            "n": "BrtPCDIString"
        },
        "25": {
            "n": "BrtPCDIDatetime"
        },
        "26": {
            "n": "BrtPCDIIndex"
        },
        "27": {
            "n": "BrtPCDIAMissing"
        },
        "28": {
            "n": "BrtPCDIANumber"
        },
        "29": {
            "n": "BrtPCDIABoolean"
        },
        "30": {
            "n": "BrtPCDIAError"
        },
        "31": {
            "n": "BrtPCDIAString"
        },
        "32": {
            "n": "BrtPCDIADatetime"
        },
        "33": {
            "n": "BrtPCRRecord"
        },
        "34": {
            "n": "BrtPCRRecordDt"
        },
        "35": {
            "n": "BrtFRTBegin"
        },
        "36": {
            "n": "BrtFRTEnd"
        },
        "37": {
            "n": "BrtACBegin"
        },
        "38": {
            "n": "BrtACEnd"
        },
        "39": {
            "n": "BrtName",
            "f": parse_BrtName
        },
        "40": {
            "n": "BrtIndexRowBlock"
        },
        "42": {
            "n": "BrtIndexBlock"
        },
        "43": {
            "n": "BrtFont",
            "f": parse_BrtFont
        },
        "44": {
            "n": "BrtFmt",
            "f": parse_BrtFmt
        },
        "45": {
            "n": "BrtFill",
            "f": parse_BrtFill
        },
        "46": {
            "n": "BrtBorder",
            "f": parse_BrtBorder
        },
        "47": {
            "n": "BrtXF",
            "f": parse_BrtXF
        },
        "48": {
            "n": "BrtStyle"
        },
        "49": {
            "n": "BrtCellMeta"
        },
        "50": {
            "n": "BrtValueMeta"
        },
        "51": {
            "n": "BrtMdb"
        },
        "52": {
            "n": "BrtBeginFmd"
        },
        "53": {
            "n": "BrtEndFmd"
        },
        "54": {
            "n": "BrtBeginMdx"
        },
        "55": {
            "n": "BrtEndMdx"
        },
        "56": {
            "n": "BrtBeginMdxTuple"
        },
        "57": {
            "n": "BrtEndMdxTuple"
        },
        "58": {
            "n": "BrtMdxMbrIstr"
        },
        "59": {
            "n": "BrtStr"
        },
        "60": {
            "n": "BrtColInfo",
            "f": parse_ColInfo
        },
        "62": {
            "n": "BrtCellRString"
        },
        "63": {
            "n": "BrtCalcChainItem$",
            "f": parse_BrtCalcChainItem$
        },
        "64": {
            "n": "BrtDVal"
        },
        "65": {
            "n": "BrtSxvcellNum"
        },
        "66": {
            "n": "BrtSxvcellStr"
        },
        "67": {
            "n": "BrtSxvcellBool"
        },
        "68": {
            "n": "BrtSxvcellErr"
        },
        "69": {
            "n": "BrtSxvcellDate"
        },
        "70": {
            "n": "BrtSxvcellNil"
        },
        "128": {
            "n": "BrtFileVersion"
        },
        "129": {
            "n": "BrtBeginSheet"
        },
        "130": {
            "n": "BrtEndSheet"
        },
        "131": {
            "n": "BrtBeginBook",
            "f": parsenoop,
            "p": 0
        },
        "132": {
            "n": "BrtEndBook"
        },
        "133": {
            "n": "BrtBeginWsViews"
        },
        "134": {
            "n": "BrtEndWsViews"
        },
        "135": {
            "n": "BrtBeginBookViews"
        },
        "136": {
            "n": "BrtEndBookViews"
        },
        "137": {
            "n": "BrtBeginWsView",
            "f": parse_BrtBeginWsView
        },
        "138": {
            "n": "BrtEndWsView"
        },
        "139": {
            "n": "BrtBeginCsViews"
        },
        "140": {
            "n": "BrtEndCsViews"
        },
        "141": {
            "n": "BrtBeginCsView"
        },
        "142": {
            "n": "BrtEndCsView"
        },
        "143": {
            "n": "BrtBeginBundleShs"
        },
        "144": {
            "n": "BrtEndBundleShs"
        },
        "145": {
            "n": "BrtBeginSheetData"
        },
        "146": {
            "n": "BrtEndSheetData"
        },
        "147": {
            "n": "BrtWsProp",
            "f": parse_BrtWsProp
        },
        "148": {
            "n": "BrtWsDim",
            "f": parse_BrtWsDim,
            "p": 16
        },
        "151": {
            "n": "BrtPane"
        },
        "152": {
            "n": "BrtSel"
        },
        "153": {
            "n": "BrtWbProp",
            "f": parse_BrtWbProp
        },
        "154": {
            "n": "BrtWbFactoid"
        },
        "155": {
            "n": "BrtFileRecover"
        },
        "156": {
            "n": "BrtBundleSh",
            "f": parse_BrtBundleSh
        },
        "157": {
            "n": "BrtCalcProp"
        },
        "158": {
            "n": "BrtBookView"
        },
        "159": {
            "n": "BrtBeginSst",
            "f": parse_BrtBeginSst
        },
        "160": {
            "n": "BrtEndSst"
        },
        "161": {
            "n": "BrtBeginAFilter",
            "f": parse_UncheckedRfX
        },
        "162": {
            "n": "BrtEndAFilter"
        },
        "163": {
            "n": "BrtBeginFilterColumn"
        },
        "164": {
            "n": "BrtEndFilterColumn"
        },
        "165": {
            "n": "BrtBeginFilters"
        },
        "166": {
            "n": "BrtEndFilters"
        },
        "167": {
            "n": "BrtFilter"
        },
        "168": {
            "n": "BrtColorFilter"
        },
        "169": {
            "n": "BrtIconFilter"
        },
        "170": {
            "n": "BrtTop10Filter"
        },
        "171": {
            "n": "BrtDynamicFilter"
        },
        "172": {
            "n": "BrtBeginCustomFilters"
        },
        "173": {
            "n": "BrtEndCustomFilters"
        },
        "174": {
            "n": "BrtCustomFilter"
        },
        "175": {
            "n": "BrtAFilterDateGroupItem"
        },
        "176": {
            "n": "BrtMergeCell",
            "f": parse_BrtMergeCell
        },
        "177": {
            "n": "BrtBeginMergeCells"
        },
        "178": {
            "n": "BrtEndMergeCells"
        },
        "179": {
            "n": "BrtBeginPivotCacheDef"
        },
        "180": {
            "n": "BrtEndPivotCacheDef"
        },
        "181": {
            "n": "BrtBeginPCDFields"
        },
        "182": {
            "n": "BrtEndPCDFields"
        },
        "183": {
            "n": "BrtBeginPCDField"
        },
        "184": {
            "n": "BrtEndPCDField"
        },
        "185": {
            "n": "BrtBeginPCDSource"
        },
        "186": {
            "n": "BrtEndPCDSource"
        },
        "187": {
            "n": "BrtBeginPCDSRange"
        },
        "188": {
            "n": "BrtEndPCDSRange"
        },
        "189": {
            "n": "BrtBeginPCDFAtbl"
        },
        "190": {
            "n": "BrtEndPCDFAtbl"
        },
        "191": {
            "n": "BrtBeginPCDIRun"
        },
        "192": {
            "n": "BrtEndPCDIRun"
        },
        "193": {
            "n": "BrtBeginPivotCacheRecords"
        },
        "194": {
            "n": "BrtEndPivotCacheRecords"
        },
        "195": {
            "n": "BrtBeginPCDHierarchies"
        },
        "196": {
            "n": "BrtEndPCDHierarchies"
        },
        "197": {
            "n": "BrtBeginPCDHierarchy"
        },
        "198": {
            "n": "BrtEndPCDHierarchy"
        },
        "199": {
            "n": "BrtBeginPCDHFieldsUsage"
        },
        "200": {
            "n": "BrtEndPCDHFieldsUsage"
        },
        "201": {
            "n": "BrtBeginExtConnection"
        },
        "202": {
            "n": "BrtEndExtConnection"
        },
        "203": {
            "n": "BrtBeginECDbProps"
        },
        "204": {
            "n": "BrtEndECDbProps"
        },
        "205": {
            "n": "BrtBeginECOlapProps"
        },
        "206": {
            "n": "BrtEndECOlapProps"
        },
        "207": {
            "n": "BrtBeginPCDSConsol"
        },
        "208": {
            "n": "BrtEndPCDSConsol"
        },
        "209": {
            "n": "BrtBeginPCDSCPages"
        },
        "210": {
            "n": "BrtEndPCDSCPages"
        },
        "211": {
            "n": "BrtBeginPCDSCPage"
        },
        "212": {
            "n": "BrtEndPCDSCPage"
        },
        "213": {
            "n": "BrtBeginPCDSCPItem"
        },
        "214": {
            "n": "BrtEndPCDSCPItem"
        },
        "215": {
            "n": "BrtBeginPCDSCSets"
        },
        "216": {
            "n": "BrtEndPCDSCSets"
        },
        "217": {
            "n": "BrtBeginPCDSCSet"
        },
        "218": {
            "n": "BrtEndPCDSCSet"
        },
        "219": {
            "n": "BrtBeginPCDFGroup"
        },
        "220": {
            "n": "BrtEndPCDFGroup"
        },
        "221": {
            "n": "BrtBeginPCDFGItems"
        },
        "222": {
            "n": "BrtEndPCDFGItems"
        },
        "223": {
            "n": "BrtBeginPCDFGRange"
        },
        "224": {
            "n": "BrtEndPCDFGRange"
        },
        "225": {
            "n": "BrtBeginPCDFGDiscrete"
        },
        "226": {
            "n": "BrtEndPCDFGDiscrete"
        },
        "227": {
            "n": "BrtBeginPCDSDTupleCache"
        },
        "228": {
            "n": "BrtEndPCDSDTupleCache"
        },
        "229": {
            "n": "BrtBeginPCDSDTCEntries"
        },
        "230": {
            "n": "BrtEndPCDSDTCEntries"
        },
        "231": {
            "n": "BrtBeginPCDSDTCEMembers"
        },
        "232": {
            "n": "BrtEndPCDSDTCEMembers"
        },
        "233": {
            "n": "BrtBeginPCDSDTCEMember"
        },
        "234": {
            "n": "BrtEndPCDSDTCEMember"
        },
        "235": {
            "n": "BrtBeginPCDSDTCQueries"
        },
        "236": {
            "n": "BrtEndPCDSDTCQueries"
        },
        "237": {
            "n": "BrtBeginPCDSDTCQuery"
        },
        "238": {
            "n": "BrtEndPCDSDTCQuery"
        },
        "239": {
            "n": "BrtBeginPCDSDTCSets"
        },
        "240": {
            "n": "BrtEndPCDSDTCSets"
        },
        "241": {
            "n": "BrtBeginPCDSDTCSet"
        },
        "242": {
            "n": "BrtEndPCDSDTCSet"
        },
        "243": {
            "n": "BrtBeginPCDCalcItems"
        },
        "244": {
            "n": "BrtEndPCDCalcItems"
        },
        "245": {
            "n": "BrtBeginPCDCalcItem"
        },
        "246": {
            "n": "BrtEndPCDCalcItem"
        },
        "247": {
            "n": "BrtBeginPRule"
        },
        "248": {
            "n": "BrtEndPRule"
        },
        "249": {
            "n": "BrtBeginPRFilters"
        },
        "250": {
            "n": "BrtEndPRFilters"
        },
        "251": {
            "n": "BrtBeginPRFilter"
        },
        "252": {
            "n": "BrtEndPRFilter"
        },
        "253": {
            "n": "BrtBeginPNames"
        },
        "254": {
            "n": "BrtEndPNames"
        },
        "255": {
            "n": "BrtBeginPName"
        },
        "256": {
            "n": "BrtEndPName"
        },
        "257": {
            "n": "BrtBeginPNPairs"
        },
        "258": {
            "n": "BrtEndPNPairs"
        },
        "259": {
            "n": "BrtBeginPNPair"
        },
        "260": {
            "n": "BrtEndPNPair"
        },
        "261": {
            "n": "BrtBeginECWebProps"
        },
        "262": {
            "n": "BrtEndECWebProps"
        },
        "263": {
            "n": "BrtBeginEcWpTables"
        },
        "264": {
            "n": "BrtEndECWPTables"
        },
        "265": {
            "n": "BrtBeginECParams"
        },
        "266": {
            "n": "BrtEndECParams"
        },
        "267": {
            "n": "BrtBeginECParam"
        },
        "268": {
            "n": "BrtEndECParam"
        },
        "269": {
            "n": "BrtBeginPCDKPIs"
        },
        "270": {
            "n": "BrtEndPCDKPIs"
        },
        "271": {
            "n": "BrtBeginPCDKPI"
        },
        "272": {
            "n": "BrtEndPCDKPI"
        },
        "273": {
            "n": "BrtBeginDims"
        },
        "274": {
            "n": "BrtEndDims"
        },
        "275": {
            "n": "BrtBeginDim"
        },
        "276": {
            "n": "BrtEndDim"
        },
        "277": {
            "n": "BrtIndexPartEnd"
        },
        "278": {
            "n": "BrtBeginStyleSheet"
        },
        "279": {
            "n": "BrtEndStyleSheet"
        },
        "280": {
            "n": "BrtBeginSXView"
        },
        "281": {
            "n": "BrtEndSXVI"
        },
        "282": {
            "n": "BrtBeginSXVI"
        },
        "283": {
            "n": "BrtBeginSXVIs"
        },
        "284": {
            "n": "BrtEndSXVIs"
        },
        "285": {
            "n": "BrtBeginSXVD"
        },
        "286": {
            "n": "BrtEndSXVD"
        },
        "287": {
            "n": "BrtBeginSXVDs"
        },
        "288": {
            "n": "BrtEndSXVDs"
        },
        "289": {
            "n": "BrtBeginSXPI"
        },
        "290": {
            "n": "BrtEndSXPI"
        },
        "291": {
            "n": "BrtBeginSXPIs"
        },
        "292": {
            "n": "BrtEndSXPIs"
        },
        "293": {
            "n": "BrtBeginSXDI"
        },
        "294": {
            "n": "BrtEndSXDI"
        },
        "295": {
            "n": "BrtBeginSXDIs"
        },
        "296": {
            "n": "BrtEndSXDIs"
        },
        "297": {
            "n": "BrtBeginSXLI"
        },
        "298": {
            "n": "BrtEndSXLI"
        },
        "299": {
            "n": "BrtBeginSXLIRws"
        },
        "300": {
            "n": "BrtEndSXLIRws"
        },
        "301": {
            "n": "BrtBeginSXLICols"
        },
        "302": {
            "n": "BrtEndSXLICols"
        },
        "303": {
            "n": "BrtBeginSXFormat"
        },
        "304": {
            "n": "BrtEndSXFormat"
        },
        "305": {
            "n": "BrtBeginSXFormats"
        },
        "306": {
            "n": "BrtEndSxFormats"
        },
        "307": {
            "n": "BrtBeginSxSelect"
        },
        "308": {
            "n": "BrtEndSxSelect"
        },
        "309": {
            "n": "BrtBeginISXVDRws"
        },
        "310": {
            "n": "BrtEndISXVDRws"
        },
        "311": {
            "n": "BrtBeginISXVDCols"
        },
        "312": {
            "n": "BrtEndISXVDCols"
        },
        "313": {
            "n": "BrtEndSXLocation"
        },
        "314": {
            "n": "BrtBeginSXLocation"
        },
        "315": {
            "n": "BrtEndSXView"
        },
        "316": {
            "n": "BrtBeginSXTHs"
        },
        "317": {
            "n": "BrtEndSXTHs"
        },
        "318": {
            "n": "BrtBeginSXTH"
        },
        "319": {
            "n": "BrtEndSXTH"
        },
        "320": {
            "n": "BrtBeginISXTHRws"
        },
        "321": {
            "n": "BrtEndISXTHRws"
        },
        "322": {
            "n": "BrtBeginISXTHCols"
        },
        "323": {
            "n": "BrtEndISXTHCols"
        },
        "324": {
            "n": "BrtBeginSXTDMPS"
        },
        "325": {
            "n": "BrtEndSXTDMPs"
        },
        "326": {
            "n": "BrtBeginSXTDMP"
        },
        "327": {
            "n": "BrtEndSXTDMP"
        },
        "328": {
            "n": "BrtBeginSXTHItems"
        },
        "329": {
            "n": "BrtEndSXTHItems"
        },
        "330": {
            "n": "BrtBeginSXTHItem"
        },
        "331": {
            "n": "BrtEndSXTHItem"
        },
        "332": {
            "n": "BrtBeginMetadata"
        },
        "333": {
            "n": "BrtEndMetadata"
        },
        "334": {
            "n": "BrtBeginEsmdtinfo"
        },
        "335": {
            "n": "BrtMdtinfo"
        },
        "336": {
            "n": "BrtEndEsmdtinfo"
        },
        "337": {
            "n": "BrtBeginEsmdb"
        },
        "338": {
            "n": "BrtEndEsmdb"
        },
        "339": {
            "n": "BrtBeginEsfmd"
        },
        "340": {
            "n": "BrtEndEsfmd"
        },
        "341": {
            "n": "BrtBeginSingleCells"
        },
        "342": {
            "n": "BrtEndSingleCells"
        },
        "343": {
            "n": "BrtBeginList"
        },
        "344": {
            "n": "BrtEndList"
        },
        "345": {
            "n": "BrtBeginListCols"
        },
        "346": {
            "n": "BrtEndListCols"
        },
        "347": {
            "n": "BrtBeginListCol"
        },
        "348": {
            "n": "BrtEndListCol"
        },
        "349": {
            "n": "BrtBeginListXmlCPr"
        },
        "350": {
            "n": "BrtEndListXmlCPr"
        },
        "351": {
            "n": "BrtListCCFmla"
        },
        "352": {
            "n": "BrtListTrFmla"
        },
        "353": {
            "n": "BrtBeginExternals"
        },
        "354": {
            "n": "BrtEndExternals"
        },
        "355": {
            "n": "BrtSupBookSrc",
            "f": parse_RelID
        },
        "357": {
            "n": "BrtSupSelf"
        },
        "358": {
            "n": "BrtSupSame"
        },
        "359": {
            "n": "BrtSupTabs"
        },
        "360": {
            "n": "BrtBeginSupBook"
        },
        "361": {
            "n": "BrtPlaceholderName"
        },
        "362": {
            "n": "BrtExternSheet",
            "f": parse_ExternSheet
        },
        "363": {
            "n": "BrtExternTableStart"
        },
        "364": {
            "n": "BrtExternTableEnd"
        },
        "366": {
            "n": "BrtExternRowHdr"
        },
        "367": {
            "n": "BrtExternCellBlank"
        },
        "368": {
            "n": "BrtExternCellReal"
        },
        "369": {
            "n": "BrtExternCellBool"
        },
        "370": {
            "n": "BrtExternCellError"
        },
        "371": {
            "n": "BrtExternCellString"
        },
        "372": {
            "n": "BrtBeginEsmdx"
        },
        "373": {
            "n": "BrtEndEsmdx"
        },
        "374": {
            "n": "BrtBeginMdxSet"
        },
        "375": {
            "n": "BrtEndMdxSet"
        },
        "376": {
            "n": "BrtBeginMdxMbrProp"
        },
        "377": {
            "n": "BrtEndMdxMbrProp"
        },
        "378": {
            "n": "BrtBeginMdxKPI"
        },
        "379": {
            "n": "BrtEndMdxKPI"
        },
        "380": {
            "n": "BrtBeginEsstr"
        },
        "381": {
            "n": "BrtEndEsstr"
        },
        "382": {
            "n": "BrtBeginPRFItem"
        },
        "383": {
            "n": "BrtEndPRFItem"
        },
        "384": {
            "n": "BrtBeginPivotCacheIDs"
        },
        "385": {
            "n": "BrtEndPivotCacheIDs"
        },
        "386": {
            "n": "BrtBeginPivotCacheID"
        },
        "387": {
            "n": "BrtEndPivotCacheID"
        },
        "388": {
            "n": "BrtBeginISXVIs"
        },
        "389": {
            "n": "BrtEndISXVIs"
        },
        "390": {
            "n": "BrtBeginColInfos"
        },
        "391": {
            "n": "BrtEndColInfos"
        },
        "392": {
            "n": "BrtBeginRwBrk"
        },
        "393": {
            "n": "BrtEndRwBrk"
        },
        "394": {
            "n": "BrtBeginColBrk"
        },
        "395": {
            "n": "BrtEndColBrk"
        },
        "396": {
            "n": "BrtBrk"
        },
        "397": {
            "n": "BrtUserBookView"
        },
        "398": {
            "n": "BrtInfo"
        },
        "399": {
            "n": "BrtCUsr"
        },
        "400": {
            "n": "BrtUsr"
        },
        "401": {
            "n": "BrtBeginUsers"
        },
        "403": {
            "n": "BrtEOF"
        },
        "404": {
            "n": "BrtUCR"
        },
        "405": {
            "n": "BrtRRInsDel"
        },
        "406": {
            "n": "BrtRREndInsDel"
        },
        "407": {
            "n": "BrtRRMove"
        },
        "408": {
            "n": "BrtRREndMove"
        },
        "409": {
            "n": "BrtRRChgCell"
        },
        "410": {
            "n": "BrtRREndChgCell"
        },
        "411": {
            "n": "BrtRRHeader"
        },
        "412": {
            "n": "BrtRRUserView"
        },
        "413": {
            "n": "BrtRRRenSheet"
        },
        "414": {
            "n": "BrtRRInsertSh"
        },
        "415": {
            "n": "BrtRRDefName"
        },
        "416": {
            "n": "BrtRRNote"
        },
        "417": {
            "n": "BrtRRConflict"
        },
        "418": {
            "n": "BrtRRTQSIF"
        },
        "419": {
            "n": "BrtRRFormat"
        },
        "420": {
            "n": "BrtRREndFormat"
        },
        "421": {
            "n": "BrtRRAutoFmt"
        },
        "422": {
            "n": "BrtBeginUserShViews"
        },
        "423": {
            "n": "BrtBeginUserShView"
        },
        "424": {
            "n": "BrtEndUserShView"
        },
        "425": {
            "n": "BrtEndUserShViews"
        },
        "426": {
            "n": "BrtArrFmla",
            "f": parse_BrtArrFmla
        },
        "427": {
            "n": "BrtShrFmla",
            "f": parse_BrtShrFmla
        },
        "428": {
            "n": "BrtTable"
        },
        "429": {
            "n": "BrtBeginExtConnections"
        },
        "430": {
            "n": "BrtEndExtConnections"
        },
        "431": {
            "n": "BrtBeginPCDCalcMems"
        },
        "432": {
            "n": "BrtEndPCDCalcMems"
        },
        "433": {
            "n": "BrtBeginPCDCalcMem"
        },
        "434": {
            "n": "BrtEndPCDCalcMem"
        },
        "435": {
            "n": "BrtBeginPCDHGLevels"
        },
        "436": {
            "n": "BrtEndPCDHGLevels"
        },
        "437": {
            "n": "BrtBeginPCDHGLevel"
        },
        "438": {
            "n": "BrtEndPCDHGLevel"
        },
        "439": {
            "n": "BrtBeginPCDHGLGroups"
        },
        "440": {
            "n": "BrtEndPCDHGLGroups"
        },
        "441": {
            "n": "BrtBeginPCDHGLGroup"
        },
        "442": {
            "n": "BrtEndPCDHGLGroup"
        },
        "443": {
            "n": "BrtBeginPCDHGLGMembers"
        },
        "444": {
            "n": "BrtEndPCDHGLGMembers"
        },
        "445": {
            "n": "BrtBeginPCDHGLGMember"
        },
        "446": {
            "n": "BrtEndPCDHGLGMember"
        },
        "447": {
            "n": "BrtBeginQSI"
        },
        "448": {
            "n": "BrtEndQSI"
        },
        "449": {
            "n": "BrtBeginQSIR"
        },
        "450": {
            "n": "BrtEndQSIR"
        },
        "451": {
            "n": "BrtBeginDeletedNames"
        },
        "452": {
            "n": "BrtEndDeletedNames"
        },
        "453": {
            "n": "BrtBeginDeletedName"
        },
        "454": {
            "n": "BrtEndDeletedName"
        },
        "455": {
            "n": "BrtBeginQSIFs"
        },
        "456": {
            "n": "BrtEndQSIFs"
        },
        "457": {
            "n": "BrtBeginQSIF"
        },
        "458": {
            "n": "BrtEndQSIF"
        },
        "459": {
            "n": "BrtBeginAutoSortScope"
        },
        "460": {
            "n": "BrtEndAutoSortScope"
        },
        "461": {
            "n": "BrtBeginConditionalFormatting"
        },
        "462": {
            "n": "BrtEndConditionalFormatting"
        },
        "463": {
            "n": "BrtBeginCFRule"
        },
        "464": {
            "n": "BrtEndCFRule"
        },
        "465": {
            "n": "BrtBeginIconSet"
        },
        "466": {
            "n": "BrtEndIconSet"
        },
        "467": {
            "n": "BrtBeginDatabar"
        },
        "468": {
            "n": "BrtEndDatabar"
        },
        "469": {
            "n": "BrtBeginColorScale"
        },
        "470": {
            "n": "BrtEndColorScale"
        },
        "471": {
            "n": "BrtCFVO"
        },
        "472": {
            "n": "BrtExternValueMeta"
        },
        "473": {
            "n": "BrtBeginColorPalette"
        },
        "474": {
            "n": "BrtEndColorPalette"
        },
        "475": {
            "n": "BrtIndexedColor"
        },
        "476": {
            "n": "BrtMargins",
            "f": parse_BrtMargins
        },
        "477": {
            "n": "BrtPrintOptions"
        },
        "478": {
            "n": "BrtPageSetup"
        },
        "479": {
            "n": "BrtBeginHeaderFooter"
        },
        "480": {
            "n": "BrtEndHeaderFooter"
        },
        "481": {
            "n": "BrtBeginSXCrtFormat"
        },
        "482": {
            "n": "BrtEndSXCrtFormat"
        },
        "483": {
            "n": "BrtBeginSXCrtFormats"
        },
        "484": {
            "n": "BrtEndSXCrtFormats"
        },
        "485": {
            "n": "BrtWsFmtInfo",
            "f": parse_BrtWsFmtInfo
        },
        "486": {
            "n": "BrtBeginMgs"
        },
        "487": {
            "n": "BrtEndMGs"
        },
        "488": {
            "n": "BrtBeginMGMaps"
        },
        "489": {
            "n": "BrtEndMGMaps"
        },
        "490": {
            "n": "BrtBeginMG"
        },
        "491": {
            "n": "BrtEndMG"
        },
        "492": {
            "n": "BrtBeginMap"
        },
        "493": {
            "n": "BrtEndMap"
        },
        "494": {
            "n": "BrtHLink",
            "f": parse_BrtHLink
        },
        "495": {
            "n": "BrtBeginDCon"
        },
        "496": {
            "n": "BrtEndDCon"
        },
        "497": {
            "n": "BrtBeginDRefs"
        },
        "498": {
            "n": "BrtEndDRefs"
        },
        "499": {
            "n": "BrtDRef"
        },
        "500": {
            "n": "BrtBeginScenMan"
        },
        "501": {
            "n": "BrtEndScenMan"
        },
        "502": {
            "n": "BrtBeginSct"
        },
        "503": {
            "n": "BrtEndSct"
        },
        "504": {
            "n": "BrtSlc"
        },
        "505": {
            "n": "BrtBeginDXFs"
        },
        "506": {
            "n": "BrtEndDXFs"
        },
        "507": {
            "n": "BrtDXF"
        },
        "508": {
            "n": "BrtBeginTableStyles"
        },
        "509": {
            "n": "BrtEndTableStyles"
        },
        "510": {
            "n": "BrtBeginTableStyle"
        },
        "511": {
            "n": "BrtEndTableStyle"
        },
        "512": {
            "n": "BrtTableStyleElement"
        },
        "513": {
            "n": "BrtTableStyleClient"
        },
        "514": {
            "n": "BrtBeginVolDeps"
        },
        "515": {
            "n": "BrtEndVolDeps"
        },
        "516": {
            "n": "BrtBeginVolType"
        },
        "517": {
            "n": "BrtEndVolType"
        },
        "518": {
            "n": "BrtBeginVolMain"
        },
        "519": {
            "n": "BrtEndVolMain"
        },
        "520": {
            "n": "BrtBeginVolTopic"
        },
        "521": {
            "n": "BrtEndVolTopic"
        },
        "522": {
            "n": "BrtVolSubtopic"
        },
        "523": {
            "n": "BrtVolRef"
        },
        "524": {
            "n": "BrtVolNum"
        },
        "525": {
            "n": "BrtVolErr"
        },
        "526": {
            "n": "BrtVolStr"
        },
        "527": {
            "n": "BrtVolBool"
        },
        "528": {
            "n": "BrtBeginCalcChain$"
        },
        "529": {
            "n": "BrtEndCalcChain$"
        },
        "530": {
            "n": "BrtBeginSortState"
        },
        "531": {
            "n": "BrtEndSortState"
        },
        "532": {
            "n": "BrtBeginSortCond"
        },
        "533": {
            "n": "BrtEndSortCond"
        },
        "534": {
            "n": "BrtBookProtection"
        },
        "535": {
            "n": "BrtSheetProtection"
        },
        "536": {
            "n": "BrtRangeProtection"
        },
        "537": {
            "n": "BrtPhoneticInfo"
        },
        "538": {
            "n": "BrtBeginECTxtWiz"
        },
        "539": {
            "n": "BrtEndECTxtWiz"
        },
        "540": {
            "n": "BrtBeginECTWFldInfoLst"
        },
        "541": {
            "n": "BrtEndECTWFldInfoLst"
        },
        "542": {
            "n": "BrtBeginECTwFldInfo"
        },
        "548": {
            "n": "BrtFileSharing"
        },
        "549": {
            "n": "BrtOleSize"
        },
        "550": {
            "n": "BrtDrawing",
            "f": parse_RelID
        },
        "551": {
            "n": "BrtLegacyDrawing"
        },
        "552": {
            "n": "BrtLegacyDrawingHF"
        },
        "553": {
            "n": "BrtWebOpt"
        },
        "554": {
            "n": "BrtBeginWebPubItems"
        },
        "555": {
            "n": "BrtEndWebPubItems"
        },
        "556": {
            "n": "BrtBeginWebPubItem"
        },
        "557": {
            "n": "BrtEndWebPubItem"
        },
        "558": {
            "n": "BrtBeginSXCondFmt"
        },
        "559": {
            "n": "BrtEndSXCondFmt"
        },
        "560": {
            "n": "BrtBeginSXCondFmts"
        },
        "561": {
            "n": "BrtEndSXCondFmts"
        },
        "562": {
            "n": "BrtBkHim"
        },
        "564": {
            "n": "BrtColor"
        },
        "565": {
            "n": "BrtBeginIndexedColors"
        },
        "566": {
            "n": "BrtEndIndexedColors"
        },
        "569": {
            "n": "BrtBeginMRUColors"
        },
        "570": {
            "n": "BrtEndMRUColors"
        },
        "572": {
            "n": "BrtMRUColor"
        },
        "573": {
            "n": "BrtBeginDVals"
        },
        "574": {
            "n": "BrtEndDVals"
        },
        "577": {
            "n": "BrtSupNameStart"
        },
        "578": {
            "n": "BrtSupNameValueStart"
        },
        "579": {
            "n": "BrtSupNameValueEnd"
        },
        "580": {
            "n": "BrtSupNameNum"
        },
        "581": {
            "n": "BrtSupNameErr"
        },
        "582": {
            "n": "BrtSupNameSt"
        },
        "583": {
            "n": "BrtSupNameNil"
        },
        "584": {
            "n": "BrtSupNameBool"
        },
        "585": {
            "n": "BrtSupNameFmla"
        },
        "586": {
            "n": "BrtSupNameBits"
        },
        "587": {
            "n": "BrtSupNameEnd"
        },
        "588": {
            "n": "BrtEndSupBook"
        },
        "589": {
            "n": "BrtCellSmartTagProperty"
        },
        "590": {
            "n": "BrtBeginCellSmartTag"
        },
        "591": {
            "n": "BrtEndCellSmartTag"
        },
        "592": {
            "n": "BrtBeginCellSmartTags"
        },
        "593": {
            "n": "BrtEndCellSmartTags"
        },
        "594": {
            "n": "BrtBeginSmartTags"
        },
        "595": {
            "n": "BrtEndSmartTags"
        },
        "596": {
            "n": "BrtSmartTagType"
        },
        "597": {
            "n": "BrtBeginSmartTagTypes"
        },
        "598": {
            "n": "BrtEndSmartTagTypes"
        },
        "599": {
            "n": "BrtBeginSXFilters"
        },
        "600": {
            "n": "BrtEndSXFilters"
        },
        "601": {
            "n": "BrtBeginSXFILTER"
        },
        "602": {
            "n": "BrtEndSXFilter"
        },
        "603": {
            "n": "BrtBeginFills"
        },
        "604": {
            "n": "BrtEndFills"
        },
        "605": {
            "n": "BrtBeginCellWatches"
        },
        "606": {
            "n": "BrtEndCellWatches"
        },
        "607": {
            "n": "BrtCellWatch"
        },
        "608": {
            "n": "BrtBeginCRErrs"
        },
        "609": {
            "n": "BrtEndCRErrs"
        },
        "610": {
            "n": "BrtCrashRecErr"
        },
        "611": {
            "n": "BrtBeginFonts"
        },
        "612": {
            "n": "BrtEndFonts"
        },
        "613": {
            "n": "BrtBeginBorders"
        },
        "614": {
            "n": "BrtEndBorders"
        },
        "615": {
            "n": "BrtBeginFmts"
        },
        "616": {
            "n": "BrtEndFmts"
        },
        "617": {
            "n": "BrtBeginCellXFs"
        },
        "618": {
            "n": "BrtEndCellXFs"
        },
        "619": {
            "n": "BrtBeginStyles"
        },
        "620": {
            "n": "BrtEndStyles"
        },
        "625": {
            "n": "BrtBigName"
        },
        "626": {
            "n": "BrtBeginCellStyleXFs"
        },
        "627": {
            "n": "BrtEndCellStyleXFs"
        },
        "628": {
            "n": "BrtBeginComments"
        },
        "629": {
            "n": "BrtEndComments"
        },
        "630": {
            "n": "BrtBeginCommentAuthors"
        },
        "631": {
            "n": "BrtEndCommentAuthors"
        },
        "632": {
            "n": "BrtCommentAuthor",
            "f": parse_BrtCommentAuthor
        },
        "633": {
            "n": "BrtBeginCommentList"
        },
        "634": {
            "n": "BrtEndCommentList"
        },
        "635": {
            "n": "BrtBeginComment",
            "f": parse_BrtBeginComment
        },
        "636": {
            "n": "BrtEndComment"
        },
        "637": {
            "n": "BrtCommentText",
            "f": parse_BrtCommentText
        },
        "638": {
            "n": "BrtBeginOleObjects"
        },
        "639": {
            "n": "BrtOleObject"
        },
        "640": {
            "n": "BrtEndOleObjects"
        },
        "641": {
            "n": "BrtBeginSxrules"
        },
        "642": {
            "n": "BrtEndSxRules"
        },
        "643": {
            "n": "BrtBeginActiveXControls"
        },
        "644": {
            "n": "BrtActiveX"
        },
        "645": {
            "n": "BrtEndActiveXControls"
        },
        "646": {
            "n": "BrtBeginPCDSDTCEMembersSortBy"
        },
        "648": {
            "n": "BrtBeginCellIgnoreECs"
        },
        "649": {
            "n": "BrtCellIgnoreEC"
        },
        "650": {
            "n": "BrtEndCellIgnoreECs"
        },
        "651": {
            "n": "BrtCsProp",
            "f": parse_BrtCsProp
        },
        "652": {
            "n": "BrtCsPageSetup"
        },
        "653": {
            "n": "BrtBeginUserCsViews"
        },
        "654": {
            "n": "BrtEndUserCsViews"
        },
        "655": {
            "n": "BrtBeginUserCsView"
        },
        "656": {
            "n": "BrtEndUserCsView"
        },
        "657": {
            "n": "BrtBeginPcdSFCIEntries"
        },
        "658": {
            "n": "BrtEndPCDSFCIEntries"
        },
        "659": {
            "n": "BrtPCDSFCIEntry"
        },
        "660": {
            "n": "BrtBeginListParts"
        },
        "661": {
            "n": "BrtListPart"
        },
        "662": {
            "n": "BrtEndListParts"
        },
        "663": {
            "n": "BrtSheetCalcProp"
        },
        "664": {
            "n": "BrtBeginFnGroup"
        },
        "665": {
            "n": "BrtFnGroup"
        },
        "666": {
            "n": "BrtEndFnGroup"
        },
        "667": {
            "n": "BrtSupAddin"
        },
        "668": {
            "n": "BrtSXTDMPOrder"
        },
        "669": {
            "n": "BrtCsProtection"
        },
        "671": {
            "n": "BrtBeginWsSortMap"
        },
        "672": {
            "n": "BrtEndWsSortMap"
        },
        "673": {
            "n": "BrtBeginRRSort"
        },
        "674": {
            "n": "BrtEndRRSort"
        },
        "675": {
            "n": "BrtRRSortItem"
        },
        "676": {
            "n": "BrtFileSharingIso"
        },
        "677": {
            "n": "BrtBookProtectionIso"
        },
        "678": {
            "n": "BrtSheetProtectionIso"
        },
        "679": {
            "n": "BrtCsProtectionIso"
        },
        "680": {
            "n": "BrtRangeProtectionIso"
        },
        "1024": {
            "n": "BrtRwDescent"
        },
        "1025": {
            "n": "BrtKnownFonts"
        },
        "1026": {
            "n": "BrtBeginSXTupleSet"
        },
        "1027": {
            "n": "BrtEndSXTupleSet"
        },
        "1028": {
            "n": "BrtBeginSXTupleSetHeader"
        },
        "1029": {
            "n": "BrtEndSXTupleSetHeader"
        },
        "1030": {
            "n": "BrtSXTupleSetHeaderItem"
        },
        "1031": {
            "n": "BrtBeginSXTupleSetData"
        },
        "1032": {
            "n": "BrtEndSXTupleSetData"
        },
        "1033": {
            "n": "BrtBeginSXTupleSetRow"
        },
        "1034": {
            "n": "BrtEndSXTupleSetRow"
        },
        "1035": {
            "n": "BrtSXTupleSetRowItem"
        },
        "1036": {
            "n": "BrtNameExt"
        },
        "1037": {
            "n": "BrtPCDH14"
        },
        "1038": {
            "n": "BrtBeginPCDCalcMem14"
        },
        "1039": {
            "n": "BrtEndPCDCalcMem14"
        },
        "1040": {
            "n": "BrtSXTH14"
        },
        "1041": {
            "n": "BrtBeginSparklineGroup"
        },
        "1042": {
            "n": "BrtEndSparklineGroup"
        },
        "1043": {
            "n": "BrtSparkline"
        },
        "1044": {
            "n": "BrtSXDI14"
        },
        "1045": {
            "n": "BrtWsFmtInfoEx14"
        },
        "1046": {
            "n": "BrtBeginConditionalFormatting14"
        },
        "1047": {
            "n": "BrtEndConditionalFormatting14"
        },
        "1048": {
            "n": "BrtBeginCFRule14"
        },
        "1049": {
            "n": "BrtEndCFRule14"
        },
        "1050": {
            "n": "BrtCFVO14"
        },
        "1051": {
            "n": "BrtBeginDatabar14"
        },
        "1052": {
            "n": "BrtBeginIconSet14"
        },
        "1053": {
            "n": "BrtDVal14"
        },
        "1054": {
            "n": "BrtBeginDVals14"
        },
        "1055": {
            "n": "BrtColor14"
        },
        "1056": {
            "n": "BrtBeginSparklines"
        },
        "1057": {
            "n": "BrtEndSparklines"
        },
        "1058": {
            "n": "BrtBeginSparklineGroups"
        },
        "1059": {
            "n": "BrtEndSparklineGroups"
        },
        "1061": {
            "n": "BrtSXVD14"
        },
        "1062": {
            "n": "BrtBeginSXView14"
        },
        "1063": {
            "n": "BrtEndSXView14"
        },
        "1064": {
            "n": "BrtBeginSXView16"
        },
        "1065": {
            "n": "BrtEndSXView16"
        },
        "1066": {
            "n": "BrtBeginPCD14"
        },
        "1067": {
            "n": "BrtEndPCD14"
        },
        "1068": {
            "n": "BrtBeginExtConn14"
        },
        "1069": {
            "n": "BrtEndExtConn14"
        },
        "1070": {
            "n": "BrtBeginSlicerCacheIDs"
        },
        "1071": {
            "n": "BrtEndSlicerCacheIDs"
        },
        "1072": {
            "n": "BrtBeginSlicerCacheID"
        },
        "1073": {
            "n": "BrtEndSlicerCacheID"
        },
        "1075": {
            "n": "BrtBeginSlicerCache"
        },
        "1076": {
            "n": "BrtEndSlicerCache"
        },
        "1077": {
            "n": "BrtBeginSlicerCacheDef"
        },
        "1078": {
            "n": "BrtEndSlicerCacheDef"
        },
        "1079": {
            "n": "BrtBeginSlicersEx"
        },
        "1080": {
            "n": "BrtEndSlicersEx"
        },
        "1081": {
            "n": "BrtBeginSlicerEx"
        },
        "1082": {
            "n": "BrtEndSlicerEx"
        },
        "1083": {
            "n": "BrtBeginSlicer"
        },
        "1084": {
            "n": "BrtEndSlicer"
        },
        "1085": {
            "n": "BrtSlicerCachePivotTables"
        },
        "1086": {
            "n": "BrtBeginSlicerCacheOlapImpl"
        },
        "1087": {
            "n": "BrtEndSlicerCacheOlapImpl"
        },
        "1088": {
            "n": "BrtBeginSlicerCacheLevelsData"
        },
        "1089": {
            "n": "BrtEndSlicerCacheLevelsData"
        },
        "1090": {
            "n": "BrtBeginSlicerCacheLevelData"
        },
        "1091": {
            "n": "BrtEndSlicerCacheLevelData"
        },
        "1092": {
            "n": "BrtBeginSlicerCacheSiRanges"
        },
        "1093": {
            "n": "BrtEndSlicerCacheSiRanges"
        },
        "1094": {
            "n": "BrtBeginSlicerCacheSiRange"
        },
        "1095": {
            "n": "BrtEndSlicerCacheSiRange"
        },
        "1096": {
            "n": "BrtSlicerCacheOlapItem"
        },
        "1097": {
            "n": "BrtBeginSlicerCacheSelections"
        },
        "1098": {
            "n": "BrtSlicerCacheSelection"
        },
        "1099": {
            "n": "BrtEndSlicerCacheSelections"
        },
        "1100": {
            "n": "BrtBeginSlicerCacheNative"
        },
        "1101": {
            "n": "BrtEndSlicerCacheNative"
        },
        "1102": {
            "n": "BrtSlicerCacheNativeItem"
        },
        "1103": {
            "n": "BrtRangeProtection14"
        },
        "1104": {
            "n": "BrtRangeProtectionIso14"
        },
        "1105": {
            "n": "BrtCellIgnoreEC14"
        },
        "1111": {
            "n": "BrtList14"
        },
        "1112": {
            "n": "BrtCFIcon"
        },
        "1113": {
            "n": "BrtBeginSlicerCachesPivotCacheIDs"
        },
        "1114": {
            "n": "BrtEndSlicerCachesPivotCacheIDs"
        },
        "1115": {
            "n": "BrtBeginSlicers"
        },
        "1116": {
            "n": "BrtEndSlicers"
        },
        "1117": {
            "n": "BrtWbProp14"
        },
        "1118": {
            "n": "BrtBeginSXEdit"
        },
        "1119": {
            "n": "BrtEndSXEdit"
        },
        "1120": {
            "n": "BrtBeginSXEdits"
        },
        "1121": {
            "n": "BrtEndSXEdits"
        },
        "1122": {
            "n": "BrtBeginSXChange"
        },
        "1123": {
            "n": "BrtEndSXChange"
        },
        "1124": {
            "n": "BrtBeginSXChanges"
        },
        "1125": {
            "n": "BrtEndSXChanges"
        },
        "1126": {
            "n": "BrtSXTupleItems"
        },
        "1128": {
            "n": "BrtBeginSlicerStyle"
        },
        "1129": {
            "n": "BrtEndSlicerStyle"
        },
        "1130": {
            "n": "BrtSlicerStyleElement"
        },
        "1131": {
            "n": "BrtBeginStyleSheetExt14"
        },
        "1132": {
            "n": "BrtEndStyleSheetExt14"
        },
        "1133": {
            "n": "BrtBeginSlicerCachesPivotCacheID"
        },
        "1134": {
            "n": "BrtEndSlicerCachesPivotCacheID"
        },
        "1135": {
            "n": "BrtBeginConditionalFormattings"
        },
        "1136": {
            "n": "BrtEndConditionalFormattings"
        },
        "1137": {
            "n": "BrtBeginPCDCalcMemExt"
        },
        "1138": {
            "n": "BrtEndPCDCalcMemExt"
        },
        "1139": {
            "n": "BrtBeginPCDCalcMemsExt"
        },
        "1140": {
            "n": "BrtEndPCDCalcMemsExt"
        },
        "1141": {
            "n": "BrtPCDField14"
        },
        "1142": {
            "n": "BrtBeginSlicerStyles"
        },
        "1143": {
            "n": "BrtEndSlicerStyles"
        },
        "1144": {
            "n": "BrtBeginSlicerStyleElements"
        },
        "1145": {
            "n": "BrtEndSlicerStyleElements"
        },
        "1146": {
            "n": "BrtCFRuleExt"
        },
        "1147": {
            "n": "BrtBeginSXCondFmt14"
        },
        "1148": {
            "n": "BrtEndSXCondFmt14"
        },
        "1149": {
            "n": "BrtBeginSXCondFmts14"
        },
        "1150": {
            "n": "BrtEndSXCondFmts14"
        },
        "1152": {
            "n": "BrtBeginSortCond14"
        },
        "1153": {
            "n": "BrtEndSortCond14"
        },
        "1154": {
            "n": "BrtEndDVals14"
        },
        "1155": {
            "n": "BrtEndIconSet14"
        },
        "1156": {
            "n": "BrtEndDatabar14"
        },
        "1157": {
            "n": "BrtBeginColorScale14"
        },
        "1158": {
            "n": "BrtEndColorScale14"
        },
        "1159": {
            "n": "BrtBeginSxrules14"
        },
        "1160": {
            "n": "BrtEndSxrules14"
        },
        "1161": {
            "n": "BrtBeginPRule14"
        },
        "1162": {
            "n": "BrtEndPRule14"
        },
        "1163": {
            "n": "BrtBeginPRFilters14"
        },
        "1164": {
            "n": "BrtEndPRFilters14"
        },
        "1165": {
            "n": "BrtBeginPRFilter14"
        },
        "1166": {
            "n": "BrtEndPRFilter14"
        },
        "1167": {
            "n": "BrtBeginPRFItem14"
        },
        "1168": {
            "n": "BrtEndPRFItem14"
        },
        "1169": {
            "n": "BrtBeginCellIgnoreECs14"
        },
        "1170": {
            "n": "BrtEndCellIgnoreECs14"
        },
        "1171": {
            "n": "BrtDxf14"
        },
        "1172": {
            "n": "BrtBeginDxF14s"
        },
        "1173": {
            "n": "BrtEndDxf14s"
        },
        "1177": {
            "n": "BrtFilter14"
        },
        "1178": {
            "n": "BrtBeginCustomFilters14"
        },
        "1180": {
            "n": "BrtCustomFilter14"
        },
        "1181": {
            "n": "BrtIconFilter14"
        },
        "1182": {
            "n": "BrtPivotCacheConnectionName"
        },
        "2048": {
            "n": "BrtBeginDecoupledPivotCacheIDs"
        },
        "2049": {
            "n": "BrtEndDecoupledPivotCacheIDs"
        },
        "2050": {
            "n": "BrtDecoupledPivotCacheID"
        },
        "2051": {
            "n": "BrtBeginPivotTableRefs"
        },
        "2052": {
            "n": "BrtEndPivotTableRefs"
        },
        "2053": {
            "n": "BrtPivotTableRef"
        },
        "2054": {
            "n": "BrtSlicerCacheBookPivotTables"
        },
        "2055": {
            "n": "BrtBeginSxvcells"
        },
        "2056": {
            "n": "BrtEndSxvcells"
        },
        "2057": {
            "n": "BrtBeginSxRow"
        },
        "2058": {
            "n": "BrtEndSxRow"
        },
        "2060": {
            "n": "BrtPcdCalcMem15"
        },
        "2067": {
            "n": "BrtQsi15"
        },
        "2068": {
            "n": "BrtBeginWebExtensions"
        },
        "2069": {
            "n": "BrtEndWebExtensions"
        },
        "2070": {
            "n": "BrtWebExtension"
        },
        "2071": {
            "n": "BrtAbsPath15"
        },
        "2072": {
            "n": "BrtBeginPivotTableUISettings"
        },
        "2073": {
            "n": "BrtEndPivotTableUISettings"
        },
        "2075": {
            "n": "BrtTableSlicerCacheIDs"
        },
        "2076": {
            "n": "BrtTableSlicerCacheID"
        },
        "2077": {
            "n": "BrtBeginTableSlicerCache"
        },
        "2078": {
            "n": "BrtEndTableSlicerCache"
        },
        "2079": {
            "n": "BrtSxFilter15"
        },
        "2080": {
            "n": "BrtBeginTimelineCachePivotCacheIDs"
        },
        "2081": {
            "n": "BrtEndTimelineCachePivotCacheIDs"
        },
        "2082": {
            "n": "BrtTimelineCachePivotCacheID"
        },
        "2083": {
            "n": "BrtBeginTimelineCacheIDs"
        },
        "2084": {
            "n": "BrtEndTimelineCacheIDs"
        },
        "2085": {
            "n": "BrtBeginTimelineCacheID"
        },
        "2086": {
            "n": "BrtEndTimelineCacheID"
        },
        "2087": {
            "n": "BrtBeginTimelinesEx"
        },
        "2088": {
            "n": "BrtEndTimelinesEx"
        },
        "2089": {
            "n": "BrtBeginTimelineEx"
        },
        "2090": {
            "n": "BrtEndTimelineEx"
        },
        "2091": {
            "n": "BrtWorkBookPr15"
        },
        "2092": {
            "n": "BrtPCDH15"
        },
        "2093": {
            "n": "BrtBeginTimelineStyle"
        },
        "2094": {
            "n": "BrtEndTimelineStyle"
        },
        "2095": {
            "n": "BrtTimelineStyleElement"
        },
        "2096": {
            "n": "BrtBeginTimelineStylesheetExt15"
        },
        "2097": {
            "n": "BrtEndTimelineStylesheetExt15"
        },
        "2098": {
            "n": "BrtBeginTimelineStyles"
        },
        "2099": {
            "n": "BrtEndTimelineStyles"
        },
        "2100": {
            "n": "BrtBeginTimelineStyleElements"
        },
        "2101": {
            "n": "BrtEndTimelineStyleElements"
        },
        "2102": {
            "n": "BrtDxf15"
        },
        "2103": {
            "n": "BrtBeginDxfs15"
        },
        "2104": {
            "n": "brtEndDxfs15"
        },
        "2105": {
            "n": "BrtSlicerCacheHideItemsWithNoData"
        },
        "2106": {
            "n": "BrtBeginItemUniqueNames"
        },
        "2107": {
            "n": "BrtEndItemUniqueNames"
        },
        "2108": {
            "n": "BrtItemUniqueName"
        },
        "2109": {
            "n": "BrtBeginExtConn15"
        },
        "2110": {
            "n": "BrtEndExtConn15"
        },
        "2111": {
            "n": "BrtBeginOledbPr15"
        },
        "2112": {
            "n": "BrtEndOledbPr15"
        },
        "2113": {
            "n": "BrtBeginDataFeedPr15"
        },
        "2114": {
            "n": "BrtEndDataFeedPr15"
        },
        "2115": {
            "n": "BrtTextPr15"
        },
        "2116": {
            "n": "BrtRangePr15"
        },
        "2117": {
            "n": "BrtDbCommand15"
        },
        "2118": {
            "n": "BrtBeginDbTables15"
        },
        "2119": {
            "n": "BrtEndDbTables15"
        },
        "2120": {
            "n": "BrtDbTable15"
        },
        "2121": {
            "n": "BrtBeginDataModel"
        },
        "2122": {
            "n": "BrtEndDataModel"
        },
        "2123": {
            "n": "BrtBeginModelTables"
        },
        "2124": {
            "n": "BrtEndModelTables"
        },
        "2125": {
            "n": "BrtModelTable"
        },
        "2126": {
            "n": "BrtBeginModelRelationships"
        },
        "2127": {
            "n": "BrtEndModelRelationships"
        },
        "2128": {
            "n": "BrtModelRelationship"
        },
        "2129": {
            "n": "BrtBeginECTxtWiz15"
        },
        "2130": {
            "n": "BrtEndECTxtWiz15"
        },
        "2131": {
            "n": "BrtBeginECTWFldInfoLst15"
        },
        "2132": {
            "n": "BrtEndECTWFldInfoLst15"
        },
        "2133": {
            "n": "BrtBeginECTWFldInfo15"
        },
        "2134": {
            "n": "BrtFieldListActiveItem"
        },
        "2135": {
            "n": "BrtPivotCacheIdVersion"
        },
        "2136": {
            "n": "BrtSXDI15"
        },
        "2137": {
            "n": "BrtBeginModelTimeGroupings"
        },
        "2138": {
            "n": "BrtEndModelTimeGroupings"
        },
        "2139": {
            "n": "BrtBeginModelTimeGrouping"
        },
        "2140": {
            "n": "BrtEndModelTimeGrouping"
        },
        "2141": {
            "n": "BrtModelTimeGroupingCalcCol"
        },
        "3072": {
            "n": "BrtUid"
        },
        "3073": {
            "n": "BrtRevisionPtr"
        },
        "65535": {
            "n": ""
        }
    };
    var XLSBRE = evert_key(XLSBRecordEnum, "n");
    var XLSRecordEnum = {
        "3": {
            "n": "BIFF2NUM",
            "f": parse_BIFF2NUM
        },
        "4": {
            "n": "BIFF2STR",
            "f": parse_BIFF2STR
        },
        "6": {
            "n": "Formula",
            "f": parse_Formula
        },
        "9": {
            "n": "BOF",
            "f": parse_BOF
        },
        "10": {
            "n": "EOF",
            "f": parsenoop2
        },
        "12": {
            "n": "CalcCount",
            "f": parseuint16
        },
        "13": {
            "n": "CalcMode",
            "f": parseuint16
        },
        "14": {
            "n": "CalcPrecision",
            "f": parsebool
        },
        "15": {
            "n": "CalcRefMode",
            "f": parsebool
        },
        "16": {
            "n": "CalcDelta",
            "f": parse_Xnum
        },
        "17": {
            "n": "CalcIter",
            "f": parsebool
        },
        "18": {
            "n": "Protect",
            "f": parsebool
        },
        "19": {
            "n": "Password",
            "f": parseuint16
        },
        "20": {
            "n": "Header",
            "f": parse_XLHeaderFooter
        },
        "21": {
            "n": "Footer",
            "f": parse_XLHeaderFooter
        },
        "23": {
            "n": "ExternSheet",
            "f": parse_ExternSheet
        },
        "24": {
            "n": "Lbl",
            "f": parse_Lbl
        },
        "25": {
            "n": "WinProtect",
            "f": parsebool
        },
        "26": {
            "n": "VerticalPageBreaks"
        },
        "27": {
            "n": "HorizontalPageBreaks"
        },
        "28": {
            "n": "Note",
            "f": parse_Note
        },
        "29": {
            "n": "Selection"
        },
        "34": {
            "n": "Date1904",
            "f": parsebool
        },
        "35": {
            "n": "ExternName",
            "f": parse_ExternName
        },
        "38": {
            "n": "LeftMargin",
            "f": parse_Xnum
        },
        "39": {
            "n": "RightMargin",
            "f": parse_Xnum
        },
        "40": {
            "n": "TopMargin",
            "f": parse_Xnum
        },
        "41": {
            "n": "BottomMargin",
            "f": parse_Xnum
        },
        "42": {
            "n": "PrintRowCol",
            "f": parsebool
        },
        "43": {
            "n": "PrintGrid",
            "f": parsebool
        },
        "47": {
            "n": "FilePass",
            "f": parse_FilePass
        },
        "49": {
            "n": "Font",
            "f": parse_Font
        },
        "51": {
            "n": "PrintSize",
            "f": parseuint16
        },
        "60": {
            "n": "Continue"
        },
        "61": {
            "n": "Window1",
            "f": parse_Window1
        },
        "64": {
            "n": "Backup",
            "f": parsebool
        },
        "65": {
            "n": "Pane"
        },
        "66": {
            "n": "CodePage",
            "f": parseuint16
        },
        "77": {
            "n": "Pls"
        },
        "80": {
            "n": "DCon"
        },
        "81": {
            "n": "DConRef"
        },
        "82": {
            "n": "DConName"
        },
        "85": {
            "n": "DefColWidth",
            "f": parseuint16
        },
        "89": {
            "n": "XCT"
        },
        "90": {
            "n": "CRN"
        },
        "91": {
            "n": "FileSharing"
        },
        "92": {
            "n": "WriteAccess",
            "f": parse_WriteAccess
        },
        "93": {
            "n": "Obj",
            "f": parse_Obj
        },
        "94": {
            "n": "Uncalced"
        },
        "95": {
            "n": "CalcSaveRecalc",
            "f": parsebool
        },
        "96": {
            "n": "Template"
        },
        "97": {
            "n": "Intl"
        },
        "99": {
            "n": "ObjProtect",
            "f": parsebool
        },
        "125": {
            "n": "ColInfo",
            "f": parse_ColInfo
        },
        "128": {
            "n": "Guts",
            "f": parse_Guts
        },
        "129": {
            "n": "WsBool",
            "f": parse_WsBool
        },
        "130": {
            "n": "GridSet",
            "f": parseuint16
        },
        "131": {
            "n": "HCenter",
            "f": parsebool
        },
        "132": {
            "n": "VCenter",
            "f": parsebool
        },
        "133": {
            "n": "BoundSheet8",
            "f": parse_BoundSheet8
        },
        "134": {
            "n": "WriteProtect"
        },
        "140": {
            "n": "Country",
            "f": parse_Country
        },
        "141": {
            "n": "HideObj",
            "f": parseuint16
        },
        "144": {
            "n": "Sort"
        },
        "146": {
            "n": "Palette",
            "f": parse_Palette
        },
        "151": {
            "n": "Sync"
        },
        "152": {
            "n": "LPr"
        },
        "153": {
            "n": "DxGCol"
        },
        "154": {
            "n": "FnGroupName"
        },
        "155": {
            "n": "FilterMode"
        },
        "156": {
            "n": "BuiltInFnGroupCount",
            "f": parseuint16
        },
        "157": {
            "n": "AutoFilterInfo"
        },
        "158": {
            "n": "AutoFilter"
        },
        "160": {
            "n": "Scl",
            "f": parse_Scl
        },
        "161": {
            "n": "Setup",
            "f": parse_Setup
        },
        "174": {
            "n": "ScenMan"
        },
        "175": {
            "n": "SCENARIO"
        },
        "176": {
            "n": "SxView"
        },
        "177": {
            "n": "Sxvd"
        },
        "178": {
            "n": "SXVI"
        },
        "180": {
            "n": "SxIvd"
        },
        "181": {
            "n": "SXLI"
        },
        "182": {
            "n": "SXPI"
        },
        "184": {
            "n": "DocRoute"
        },
        "185": {
            "n": "RecipName"
        },
        "189": {
            "n": "MulRk",
            "f": parse_MulRk
        },
        "190": {
            "n": "MulBlank",
            "f": parse_MulBlank
        },
        "193": {
            "n": "Mms",
            "f": parsenoop2
        },
        "197": {
            "n": "SXDI"
        },
        "198": {
            "n": "SXDB"
        },
        "199": {
            "n": "SXFDB"
        },
        "200": {
            "n": "SXDBB"
        },
        "201": {
            "n": "SXNum"
        },
        "202": {
            "n": "SxBool",
            "f": parsebool
        },
        "203": {
            "n": "SxErr"
        },
        "204": {
            "n": "SXInt"
        },
        "205": {
            "n": "SXString"
        },
        "206": {
            "n": "SXDtr"
        },
        "207": {
            "n": "SxNil"
        },
        "208": {
            "n": "SXTbl"
        },
        "209": {
            "n": "SXTBRGIITM"
        },
        "210": {
            "n": "SxTbpg"
        },
        "211": {
            "n": "ObProj"
        },
        "213": {
            "n": "SXStreamID"
        },
        "215": {
            "n": "DBCell"
        },
        "216": {
            "n": "SXRng"
        },
        "217": {
            "n": "SxIsxoper"
        },
        "218": {
            "n": "BookBool",
            "f": parseuint16
        },
        "220": {
            "n": "DbOrParamQry"
        },
        "221": {
            "n": "ScenarioProtect",
            "f": parsebool
        },
        "222": {
            "n": "OleObjectSize"
        },
        "224": {
            "n": "XF",
            "f": parse_XF
        },
        "225": {
            "n": "InterfaceHdr",
            "f": parse_InterfaceHdr
        },
        "226": {
            "n": "InterfaceEnd",
            "f": parsenoop2
        },
        "227": {
            "n": "SXVS"
        },
        "229": {
            "n": "MergeCells",
            "f": parse_MergeCells
        },
        "233": {
            "n": "BkHim"
        },
        "235": {
            "n": "MsoDrawingGroup"
        },
        "236": {
            "n": "MsoDrawing"
        },
        "237": {
            "n": "MsoDrawingSelection"
        },
        "239": {
            "n": "PhoneticInfo"
        },
        "240": {
            "n": "SxRule"
        },
        "241": {
            "n": "SXEx"
        },
        "242": {
            "n": "SxFilt"
        },
        "244": {
            "n": "SxDXF"
        },
        "245": {
            "n": "SxItm"
        },
        "246": {
            "n": "SxName"
        },
        "247": {
            "n": "SxSelect"
        },
        "248": {
            "n": "SXPair"
        },
        "249": {
            "n": "SxFmla"
        },
        "251": {
            "n": "SxFormat"
        },
        "252": {
            "n": "SST",
            "f": parse_SST
        },
        "253": {
            "n": "LabelSst",
            "f": parse_LabelSst
        },
        "255": {
            "n": "ExtSST",
            "f": parse_ExtSST
        },
        "256": {
            "n": "SXVDEx"
        },
        "259": {
            "n": "SXFormula"
        },
        "290": {
            "n": "SXDBEx"
        },
        "311": {
            "n": "RRDInsDel"
        },
        "312": {
            "n": "RRDHead"
        },
        "315": {
            "n": "RRDChgCell"
        },
        "317": {
            "n": "RRTabId",
            "f": parseuint16a
        },
        "318": {
            "n": "RRDRenSheet"
        },
        "319": {
            "n": "RRSort"
        },
        "320": {
            "n": "RRDMove"
        },
        "330": {
            "n": "RRFormat"
        },
        "331": {
            "n": "RRAutoFmt"
        },
        "333": {
            "n": "RRInsertSh"
        },
        "334": {
            "n": "RRDMoveBegin"
        },
        "335": {
            "n": "RRDMoveEnd"
        },
        "336": {
            "n": "RRDInsDelBegin"
        },
        "337": {
            "n": "RRDInsDelEnd"
        },
        "338": {
            "n": "RRDConflict"
        },
        "339": {
            "n": "RRDDefName"
        },
        "340": {
            "n": "RRDRstEtxp"
        },
        "351": {
            "n": "LRng"
        },
        "352": {
            "n": "UsesELFs",
            "f": parsebool
        },
        "353": {
            "n": "DSF",
            "f": parsenoop2
        },
        "401": {
            "n": "CUsr"
        },
        "402": {
            "n": "CbUsr"
        },
        "403": {
            "n": "UsrInfo"
        },
        "404": {
            "n": "UsrExcl"
        },
        "405": {
            "n": "FileLock"
        },
        "406": {
            "n": "RRDInfo"
        },
        "407": {
            "n": "BCUsrs"
        },
        "408": {
            "n": "UsrChk"
        },
        "425": {
            "n": "UserBView"
        },
        "426": {
            "n": "UserSViewBegin"
        },
        "427": {
            "n": "UserSViewEnd"
        },
        "428": {
            "n": "RRDUserView"
        },
        "429": {
            "n": "Qsi"
        },
        "430": {
            "n": "SupBook",
            "f": parse_SupBook
        },
        "431": {
            "n": "Prot4Rev",
            "f": parsebool
        },
        "432": {
            "n": "CondFmt"
        },
        "433": {
            "n": "CF"
        },
        "434": {
            "n": "DVal"
        },
        "437": {
            "n": "DConBin"
        },
        "438": {
            "n": "TxO",
            "f": parse_TxO
        },
        "439": {
            "n": "RefreshAll",
            "f": parsebool
        },
        "440": {
            "n": "HLink",
            "f": parse_HLink
        },
        "441": {
            "n": "Lel"
        },
        "442": {
            "n": "CodeName",
            "f": parse_XLUnicodeString
        },
        "443": {
            "n": "SXFDBType"
        },
        "444": {
            "n": "Prot4RevPass",
            "f": parseuint16
        },
        "445": {
            "n": "ObNoMacros"
        },
        "446": {
            "n": "Dv"
        },
        "448": {
            "n": "Excel9File",
            "f": parsenoop2
        },
        "449": {
            "n": "RecalcId",
            "f": parse_RecalcId,
            "r": 2
        },
        "450": {
            "n": "EntExU2",
            "f": parsenoop2
        },
        "512": {
            "n": "Dimensions",
            "f": parse_Dimensions
        },
        "513": {
            "n": "Blank",
            "f": parse_Blank
        },
        "515": {
            "n": "Number",
            "f": parse_Number
        },
        "516": {
            "n": "Label",
            "f": parse_Label
        },
        "517": {
            "n": "BoolErr",
            "f": parse_BoolErr
        },
        "518": {
            "n": "Formula",
            "f": parse_Formula
        },
        "519": {
            "n": "String",
            "f": parse_String
        },
        "520": {
            "n": "Row",
            "f": parse_Row
        },
        "523": {
            "n": "Index"
        },
        "545": {
            "n": "Array",
            "f": parse_Array
        },
        "549": {
            "n": "DefaultRowHeight",
            "f": parse_DefaultRowHeight
        },
        "566": {
            "n": "Table"
        },
        "574": {
            "n": "Window2",
            "f": parse_Window2
        },
        "638": {
            "n": "RK",
            "f": parse_RK
        },
        "659": {
            "n": "Style"
        },
        "1030": {
            "n": "Formula",
            "f": parse_Formula
        },
        "1048": {
            "n": "BigName"
        },
        "1054": {
            "n": "Format",
            "f": parse_Format
        },
        "1084": {
            "n": "ContinueBigName"
        },
        "1212": {
            "n": "ShrFmla",
            "f": parse_ShrFmla
        },
        "2048": {
            "n": "HLinkTooltip",
            "f": parse_HLinkTooltip
        },
        "2049": {
            "n": "WebPub"
        },
        "2050": {
            "n": "QsiSXTag"
        },
        "2051": {
            "n": "DBQueryExt"
        },
        "2052": {
            "n": "ExtString"
        },
        "2053": {
            "n": "TxtQry"
        },
        "2054": {
            "n": "Qsir"
        },
        "2055": {
            "n": "Qsif"
        },
        "2056": {
            "n": "RRDTQSIF"
        },
        "2057": {
            "n": "BOF",
            "f": parse_BOF
        },
        "2058": {
            "n": "OleDbConn"
        },
        "2059": {
            "n": "WOpt"
        },
        "2060": {
            "n": "SXViewEx"
        },
        "2061": {
            "n": "SXTH"
        },
        "2062": {
            "n": "SXPIEx"
        },
        "2063": {
            "n": "SXVDTEx"
        },
        "2064": {
            "n": "SXViewEx9"
        },
        "2066": {
            "n": "ContinueFrt"
        },
        "2067": {
            "n": "RealTimeData"
        },
        "2128": {
            "n": "ChartFrtInfo"
        },
        "2129": {
            "n": "FrtWrapper"
        },
        "2130": {
            "n": "StartBlock"
        },
        "2131": {
            "n": "EndBlock"
        },
        "2132": {
            "n": "StartObject"
        },
        "2133": {
            "n": "EndObject"
        },
        "2134": {
            "n": "CatLab"
        },
        "2135": {
            "n": "YMult"
        },
        "2136": {
            "n": "SXViewLink"
        },
        "2137": {
            "n": "PivotChartBits"
        },
        "2138": {
            "n": "FrtFontList"
        },
        "2146": {
            "n": "SheetExt"
        },
        "2147": {
            "n": "BookExt",
            "r": 12
        },
        "2148": {
            "n": "SXAddl"
        },
        "2149": {
            "n": "CrErr"
        },
        "2150": {
            "n": "HFPicture"
        },
        "2151": {
            "n": "FeatHdr",
            "f": parsenoop2
        },
        "2152": {
            "n": "Feat"
        },
        "2154": {
            "n": "DataLabExt"
        },
        "2155": {
            "n": "DataLabExtContents"
        },
        "2156": {
            "n": "CellWatch"
        },
        "2161": {
            "n": "FeatHdr11"
        },
        "2162": {
            "n": "Feature11"
        },
        "2164": {
            "n": "DropDownObjIds"
        },
        "2165": {
            "n": "ContinueFrt11"
        },
        "2166": {
            "n": "DConn"
        },
        "2167": {
            "n": "List12"
        },
        "2168": {
            "n": "Feature12"
        },
        "2169": {
            "n": "CondFmt12"
        },
        "2170": {
            "n": "CF12"
        },
        "2171": {
            "n": "CFEx"
        },
        "2172": {
            "n": "XFCRC",
            "f": parse_XFCRC,
            "r": 12
        },
        "2173": {
            "n": "XFExt",
            "f": parse_XFExt,
            "r": 12
        },
        "2174": {
            "n": "AutoFilter12"
        },
        "2175": {
            "n": "ContinueFrt12"
        },
        "2180": {
            "n": "MDTInfo"
        },
        "2181": {
            "n": "MDXStr"
        },
        "2182": {
            "n": "MDXTuple"
        },
        "2183": {
            "n": "MDXSet"
        },
        "2184": {
            "n": "MDXProp"
        },
        "2185": {
            "n": "MDXKPI"
        },
        "2186": {
            "n": "MDB"
        },
        "2187": {
            "n": "PLV"
        },
        "2188": {
            "n": "Compat12",
            "f": parsebool,
            "r": 12
        },
        "2189": {
            "n": "DXF"
        },
        "2190": {
            "n": "TableStyles",
            "r": 12
        },
        "2191": {
            "n": "TableStyle"
        },
        "2192": {
            "n": "TableStyleElement"
        },
        "2194": {
            "n": "StyleExt"
        },
        "2195": {
            "n": "NamePublish"
        },
        "2196": {
            "n": "NameCmt",
            "f": parse_NameCmt,
            "r": 12
        },
        "2197": {
            "n": "SortData"
        },
        "2198": {
            "n": "Theme",
            "f": parse_Theme,
            "r": 12
        },
        "2199": {
            "n": "GUIDTypeLib"
        },
        "2200": {
            "n": "FnGrp12"
        },
        "2201": {
            "n": "NameFnGrp12"
        },
        "2202": {
            "n": "MTRSettings",
            "f": parse_MTRSettings,
            "r": 12
        },
        "2203": {
            "n": "CompressPictures",
            "f": parsenoop2
        },
        "2204": {
            "n": "HeaderFooter"
        },
        "2205": {
            "n": "CrtLayout12"
        },
        "2206": {
            "n": "CrtMlFrt"
        },
        "2207": {
            "n": "CrtMlFrtContinue"
        },
        "2211": {
            "n": "ForceFullCalculation",
            "f": parse_ForceFullCalculation
        },
        "2212": {
            "n": "ShapePropsStream"
        },
        "2213": {
            "n": "TextPropsStream"
        },
        "2214": {
            "n": "RichTextStream"
        },
        "2215": {
            "n": "CrtLayout12A"
        },
        "4097": {
            "n": "Units"
        },
        "4098": {
            "n": "Chart"
        },
        "4099": {
            "n": "Series"
        },
        "4102": {
            "n": "DataFormat"
        },
        "4103": {
            "n": "LineFormat"
        },
        "4105": {
            "n": "MarkerFormat"
        },
        "4106": {
            "n": "AreaFormat"
        },
        "4107": {
            "n": "PieFormat"
        },
        "4108": {
            "n": "AttachedLabel"
        },
        "4109": {
            "n": "SeriesText"
        },
        "4116": {
            "n": "ChartFormat"
        },
        "4117": {
            "n": "Legend"
        },
        "4118": {
            "n": "SeriesList"
        },
        "4119": {
            "n": "Bar"
        },
        "4120": {
            "n": "Line"
        },
        "4121": {
            "n": "Pie"
        },
        "4122": {
            "n": "Area"
        },
        "4123": {
            "n": "Scatter"
        },
        "4124": {
            "n": "CrtLine"
        },
        "4125": {
            "n": "Axis"
        },
        "4126": {
            "n": "Tick"
        },
        "4127": {
            "n": "ValueRange"
        },
        "4128": {
            "n": "CatSerRange"
        },
        "4129": {
            "n": "AxisLine"
        },
        "4130": {
            "n": "CrtLink"
        },
        "4132": {
            "n": "DefaultText"
        },
        "4133": {
            "n": "Text"
        },
        "4134": {
            "n": "FontX",
            "f": parseuint16
        },
        "4135": {
            "n": "ObjectLink"
        },
        "4146": {
            "n": "Frame"
        },
        "4147": {
            "n": "Begin"
        },
        "4148": {
            "n": "End"
        },
        "4149": {
            "n": "PlotArea"
        },
        "4154": {
            "n": "Chart3d"
        },
        "4156": {
            "n": "PicF"
        },
        "4157": {
            "n": "DropBar"
        },
        "4158": {
            "n": "Radar"
        },
        "4159": {
            "n": "Surf"
        },
        "4160": {
            "n": "RadarArea"
        },
        "4161": {
            "n": "AxisParent"
        },
        "4163": {
            "n": "LegendException"
        },
        "4164": {
            "n": "ShtProps",
            "f": parse_ShtProps
        },
        "4165": {
            "n": "SerToCrt"
        },
        "4166": {
            "n": "AxesUsed"
        },
        "4168": {
            "n": "SBaseRef"
        },
        "4170": {
            "n": "SerParent"
        },
        "4171": {
            "n": "SerAuxTrend"
        },
        "4174": {
            "n": "IFmtRecord"
        },
        "4175": {
            "n": "Pos"
        },
        "4176": {
            "n": "AlRuns"
        },
        "4177": {
            "n": "BRAI"
        },
        "4187": {
            "n": "SerAuxErrBar"
        },
        "4188": {
            "n": "ClrtClient",
            "f": parse_ClrtClient
        },
        "4189": {
            "n": "SerFmt"
        },
        "4191": {
            "n": "Chart3DBarShape"
        },
        "4192": {
            "n": "Fbi"
        },
        "4193": {
            "n": "BopPop"
        },
        "4194": {
            "n": "AxcExt"
        },
        "4195": {
            "n": "Dat"
        },
        "4196": {
            "n": "PlotGrowth"
        },
        "4197": {
            "n": "SIIndex"
        },
        "4198": {
            "n": "GelFrame"
        },
        "4199": {
            "n": "BopPopCustom"
        },
        "4200": {
            "n": "Fbi2"
        },
        "0": {
            "n": "Dimensions",
            "f": parse_Dimensions
        },
        "2": {
            "n": "BIFF2INT",
            "f": parse_BIFF2INT
        },
        "5": {
            "n": "BoolErr",
            "f": parse_BoolErr
        },
        "7": {
            "n": "String",
            "f": parse_BIFF2STRING
        },
        "8": {
            "n": "BIFF2ROW"
        },
        "11": {
            "n": "Index"
        },
        "22": {
            "n": "ExternCount",
            "f": parseuint16
        },
        "30": {
            "n": "BIFF2FORMAT",
            "f": parse_BIFF2Format
        },
        "31": {
            "n": "BIFF2FMTCNT"
        },
        "32": {
            "n": "BIFF2COLINFO"
        },
        "33": {
            "n": "Array",
            "f": parse_Array
        },
        "37": {
            "n": "DefaultRowHeight",
            "f": parse_DefaultRowHeight
        },
        "50": {
            "n": "BIFF2FONTXTRA",
            "f": parse_BIFF2FONTXTRA
        },
        "52": {
            "n": "DDEObjName"
        },
        "62": {
            "n": "BIFF2WINDOW2"
        },
        "67": {
            "n": "BIFF2XF"
        },
        "69": {
            "n": "BIFF2FONTCLR"
        },
        "86": {
            "n": "BIFF4FMTCNT"
        },
        "126": {
            "n": "RK"
        },
        "127": {
            "n": "ImData",
            "f": parse_ImData
        },
        "135": {
            "n": "Addin"
        },
        "136": {
            "n": "Edg"
        },
        "137": {
            "n": "Pub"
        },
        "145": {
            "n": "Sub"
        },
        "148": {
            "n": "LHRecord"
        },
        "149": {
            "n": "LHNGraph"
        },
        "150": {
            "n": "Sound"
        },
        "169": {
            "n": "CoordList"
        },
        "171": {
            "n": "GCW"
        },
        "188": {
            "n": "ShrFmla"
        },
        "191": {
            "n": "ToolbarHdr"
        },
        "192": {
            "n": "ToolbarEnd"
        },
        "194": {
            "n": "AddMenu"
        },
        "195": {
            "n": "DelMenu"
        },
        "214": {
            "n": "RString",
            "f": parse_RString
        },
        "223": {
            "n": "UDDesc"
        },
        "234": {
            "n": "TabIdConf"
        },
        "354": {
            "n": "XL5Modify"
        },
        "421": {
            "n": "FileSharing2"
        },
        "521": {
            "n": "BOF",
            "f": parse_BOF
        },
        "536": {
            "n": "Lbl",
            "f": parse_Lbl
        },
        "547": {
            "n": "ExternName",
            "f": parse_ExternName
        },
        "561": {
            "n": "Font"
        },
        "579": {
            "n": "BIFF3XF"
        },
        "1033": {
            "n": "BOF",
            "f": parse_BOF
        },
        "1091": {
            "n": "BIFF4XF"
        },
        "2157": {
            "n": "FeatInfo"
        },
        "2163": {
            "n": "FeatInfo11"
        },
        "2177": {
            "n": "SXAddl12"
        },
        "2240": {
            "n": "AutoWebPub"
        },
        "2241": {
            "n": "ListObj"
        },
        "2242": {
            "n": "ListField"
        },
        "2243": {
            "n": "ListDV"
        },
        "2244": {
            "n": "ListCondFmt"
        },
        "2245": {
            "n": "ListCF"
        },
        "2246": {
            "n": "FMQry"
        },
        "2247": {
            "n": "FMSQry"
        },
        "2248": {
            "n": "PLV"
        },
        "2249": {
            "n": "LnExt"
        },
        "2250": {
            "n": "MkrExt"
        },
        "2251": {
            "n": "CrtCoopt"
        },
        "2262": {
            "n": "FRTArchId$",
            "r": 12
        },
        "29282": {}
    };
    var XLSRE = evert_key(XLSRecordEnum, "n");
    function write_biff_rec(ba, type, payload, length) {
        var t = +type || +XLSRE[type];
        if (isNaN(t)) return;
        var len = length || (payload || []).length || 0;
        var o = ba.next(4);
        o.write_shift(2, t);
        o.write_shift(2, len);
        if (len > 0 && is_buf(payload)) ba.push(payload);
    }
    function write_BIFF2Cell(out, r, c) {
        if (!out) out = new_buf(7);
        out.write_shift(2, r);
        out.write_shift(2, c);
        out.write_shift(2, 0);
        out.write_shift(1, 0);
        return out;
    }
    function write_BIFF2BERR(r, c, val, t) {
        var out = new_buf(9);
        write_BIFF2Cell(out, r, c);
        if (t == "e") {
            out.write_shift(1, val);
            out.write_shift(1, 1);
        } else {
            out.write_shift(1, val ? 1 : 0);
            out.write_shift(1, 0);
        }
        return out;
    }
    function write_BIFF2LABEL(r, c, val) {
        var out = new_buf(8 + 2 * val.length);
        write_BIFF2Cell(out, r, c);
        out.write_shift(1, val.length);
        out.write_shift(val.length, val, "sbcs");
        return out.l < out.length ? out.slice(0, out.l) : out;
    }
    function write_ws_biff2_cell(ba, cell, R, C) {
        if (cell.v != null) switch (cell.t) {
          case "d":
          case "n":
            var v = cell.t == "d" ? datenum(parseDate(cell.v)) : cell.v;
            if (v == (v | 0) && v >= 0 && v < 65536) write_biff_rec(ba, 2, write_BIFF2INT(R, C, v)); else write_biff_rec(ba, 3, write_BIFF2NUM(R, C, v));
            return;

          case "b":
          case "e":
            write_biff_rec(ba, 5, write_BIFF2BERR(R, C, cell.v, cell.t));
            return;

          case "s":
          case "str":
            write_biff_rec(ba, 4, write_BIFF2LABEL(R, C, cell.v));
            return;
        }
        write_biff_rec(ba, 1, write_BIFF2Cell(null, R, C));
    }
    function write_ws_biff2(ba, ws, idx, opts) {
        var dense = Array.isArray(ws);
        var range = safe_decode_range(ws["!ref"] || "A1"), ref, rr = "", cols = [];
        if (range.e.c > 255 || range.e.r > 16383) {
            if (opts.WTF) throw new Error("Range " + (ws["!ref"] || "A1") + " exceeds format limit A1:IV16384");
            range.e.c = Math.min(range.e.c, 255);
            range.e.r = Math.min(range.e.c, 16383);
            ref = encode_range(range);
        }
        for (var R = range.s.r; R <= range.e.r; ++R) {
            rr = encode_row(R);
            for (var C = range.s.c; C <= range.e.c; ++C) {
                if (R === range.s.r) cols[C] = encode_col(C);
                ref = cols[C] + rr;
                var cell = dense ? (ws[R] || [])[C] : ws[ref];
                if (!cell) continue;
                write_ws_biff2_cell(ba, cell, R, C, opts);
            }
        }
    }
    function write_biff2_buf(wb, opts) {
        var o = opts || {};
        if (DENSE != null && o.dense == null) o.dense = DENSE;
        var ba = buf_array();
        var idx = 0;
        for (var i = 0; i < wb.SheetNames.length; ++i) if (wb.SheetNames[i] == o.sheet) idx = i;
        if (idx == 0 && !!o.sheet && wb.SheetNames[0] != o.sheet) throw new Error("Sheet not found: " + o.sheet);
        write_biff_rec(ba, 9, write_BOF(wb, 16, o));
        write_ws_biff2(ba, wb.Sheets[wb.SheetNames[idx]], idx, o, wb);
        write_biff_rec(ba, 10);
        return ba.end();
    }
    function write_FONTS_biff8(ba, data, opts) {
        write_biff_rec(ba, "Font", write_Font({
            "sz": 12,
            "color": {
                "theme": 1
            },
            "name": "Arial",
            "family": 2,
            "scheme": "minor"
        }, opts));
    }
    function write_FMTS_biff8(ba, NF, opts) {
        if (!NF) return;
        [ [ 5, 8 ], [ 23, 26 ], [ 41, 44 ], [ 50, 392 ] ].forEach(function(r) {
            for (var i = r[0]; i <= r[1]; ++i) if (NF[i] != null) write_biff_rec(ba, "Format", write_Format(i, NF[i], opts));
        });
    }
    function write_FEAT(ba, ws) {
        var o = new_buf(19);
        o.write_shift(4, 2151);
        o.write_shift(4, 0);
        o.write_shift(4, 0);
        o.write_shift(2, 3);
        o.write_shift(1, 1);
        o.write_shift(4, 0);
        write_biff_rec(ba, "FeatHdr", o);
        o = new_buf(39);
        o.write_shift(4, 2152);
        o.write_shift(4, 0);
        o.write_shift(4, 0);
        o.write_shift(2, 3);
        o.write_shift(1, 0);
        o.write_shift(4, 0);
        o.write_shift(2, 1);
        o.write_shift(4, 4);
        o.write_shift(2, 0);
        write_Ref8U(safe_decode_range(ws["!ref"] || "A1"), o);
        o.write_shift(4, 4);
        write_biff_rec(ba, "Feat", o);
    }
    function write_CELLXFS_biff8(ba, opts) {
        for (var i = 0; i < 16; ++i) write_biff_rec(ba, "XF", write_XF({
            "numFmtId": 0,
            "style": true
        }, 0, opts));
        opts.cellXfs.forEach(function(c) {
            write_biff_rec(ba, "XF", write_XF(c, 0, opts));
        });
    }
    function write_ws_biff8_hlinks(ba, ws) {
        for (var R = 0; R < ws["!links"].length; ++R) {
            var HL = ws["!links"][R];
            write_biff_rec(ba, "HLink", write_HLink(HL));
            if (HL[1].Tooltip) write_biff_rec(ba, "HLinkTooltip", write_HLinkTooltip(HL));
        }
        delete ws["!links"];
    }
    function write_ws_biff8_cell(ba, cell, R, C, opts) {
        var os = 16 + get_cell_style(opts.cellXfs, cell, opts);
        if (cell.v != null) switch (cell.t) {
          case "d":
          case "n":
            var v = cell.t == "d" ? datenum(parseDate(cell.v)) : cell.v;
            write_biff_rec(ba, "Number", write_Number(R, C, v, os, opts));
            return;

          case "b":
          case "e":
            write_biff_rec(ba, 517, write_BoolErr(R, C, cell.v, os, opts, cell.t));
            return;

          case "s":
          case "str":
            write_biff_rec(ba, "Label", write_Label(R, C, cell.v, os, opts));
            return;
        }
        write_biff_rec(ba, "Blank", write_XLSCell(R, C, os));
    }
    function write_ws_biff8(idx, opts, wb) {
        var ba = buf_array();
        var s = wb.SheetNames[idx], ws = wb.Sheets[s] || {};
        var _WB = (wb || {}).Workbook || {};
        var _sheet = (_WB.Sheets || [])[idx] || {};
        var dense = Array.isArray(ws);
        var b8 = opts.biff == 8;
        var ref, rr = "", cols = [];
        var range = safe_decode_range(ws["!ref"] || "A1");
        var MAX_ROWS = b8 ? 65536 : 16384;
        if (range.e.c > 255 || range.e.r >= MAX_ROWS) {
            if (opts.WTF) throw new Error("Range " + (ws["!ref"] || "A1") + " exceeds format limit A1:IV16384");
            range.e.c = Math.min(range.e.c, 255);
            range.e.r = Math.min(range.e.c, MAX_ROWS - 1);
        }
        write_biff_rec(ba, 2057, write_BOF(wb, 16, opts));
        write_biff_rec(ba, "CalcMode", writeuint16(1));
        write_biff_rec(ba, "CalcCount", writeuint16(100));
        write_biff_rec(ba, "CalcRefMode", writebool(true));
        write_biff_rec(ba, "CalcIter", writebool(false));
        write_biff_rec(ba, "CalcDelta", write_Xnum(.001));
        write_biff_rec(ba, "CalcSaveRecalc", writebool(true));
        write_biff_rec(ba, "PrintRowCol", writebool(false));
        write_biff_rec(ba, "PrintGrid", writebool(false));
        write_biff_rec(ba, "GridSet", writeuint16(1));
        write_biff_rec(ba, "Guts", write_Guts([ 0, 0 ]));
        write_biff_rec(ba, "HCenter", writebool(false));
        write_biff_rec(ba, "VCenter", writebool(false));
        write_biff_rec(ba, 512, write_Dimensions(range, opts));
        if (b8) ws["!links"] = [];
        for (var R = range.s.r; R <= range.e.r; ++R) {
            rr = encode_row(R);
            for (var C = range.s.c; C <= range.e.c; ++C) {
                if (R === range.s.r) cols[C] = encode_col(C);
                ref = cols[C] + rr;
                var cell = dense ? (ws[R] || [])[C] : ws[ref];
                if (!cell) continue;
                write_ws_biff8_cell(ba, cell, R, C, opts);
                if (b8 && cell.l) ws["!links"].push([ ref, cell.l ]);
            }
        }
        var cname = _sheet.CodeName || _sheet.name || s;
        if (b8 && _WB.Views) write_biff_rec(ba, "Window2", write_Window2(_WB.Views[0]));
        if (b8 && (ws["!merges"] || []).length) write_biff_rec(ba, "MergeCells", write_MergeCells(ws["!merges"]));
        if (b8) write_ws_biff8_hlinks(ba, ws);
        write_biff_rec(ba, "CodeName", write_XLUnicodeString(cname, opts));
        if (b8) write_FEAT(ba, ws);
        write_biff_rec(ba, "EOF");
        return ba.end();
    }
    function write_biff8_global(wb, bufs, opts) {
        var A = buf_array();
        var _WB = (wb || {}).Workbook || {};
        var _sheets = _WB.Sheets || [];
        var _wb = _WB.WBProps || {};
        var b8 = opts.biff == 8, b5 = opts.biff == 5;
        write_biff_rec(A, 2057, write_BOF(wb, 5, opts));
        if (opts.bookType == "xla") write_biff_rec(A, "Addin");
        write_biff_rec(A, "InterfaceHdr", b8 ? writeuint16(1200) : null);
        write_biff_rec(A, "Mms", writezeroes(2));
        if (b5) write_biff_rec(A, "ToolbarHdr");
        if (b5) write_biff_rec(A, "ToolbarEnd");
        write_biff_rec(A, "InterfaceEnd");
        write_biff_rec(A, "WriteAccess", write_WriteAccess("SheetJS", opts));
        write_biff_rec(A, "CodePage", writeuint16(b8 ? 1200 : 1252));
        if (b8) write_biff_rec(A, "DSF", writeuint16(0));
        if (b8) write_biff_rec(A, "Excel9File");
        write_biff_rec(A, "RRTabId", write_RRTabId(wb.SheetNames.length));
        if (b8 && wb.vbaraw) {
            write_biff_rec(A, "ObProj");
            var cname = _wb.CodeName || "ThisWorkbook";
            write_biff_rec(A, "CodeName", write_XLUnicodeString(cname, opts));
        }
        write_biff_rec(A, "BuiltInFnGroupCount", writeuint16(17));
        write_biff_rec(A, "WinProtect", writebool(false));
        write_biff_rec(A, "Protect", writebool(false));
        write_biff_rec(A, "Password", writeuint16(0));
        if (b8) write_biff_rec(A, "Prot4Rev", writebool(false));
        if (b8) write_biff_rec(A, "Prot4RevPass", writeuint16(0));
        write_biff_rec(A, "Window1", write_Window1(opts));
        write_biff_rec(A, "Backup", writebool(false));
        write_biff_rec(A, "HideObj", writeuint16(0));
        write_biff_rec(A, "Date1904", writebool(safe1904(wb) == "true"));
        write_biff_rec(A, "CalcPrecision", writebool(true));
        if (b8) write_biff_rec(A, "RefreshAll", writebool(false));
        write_biff_rec(A, "BookBool", writeuint16(0));
        write_FONTS_biff8(A, wb, opts);
        write_FMTS_biff8(A, wb.SSF, opts);
        write_CELLXFS_biff8(A, opts);
        if (b8) write_biff_rec(A, "UsesELFs", writebool(false));
        var a = A.end();
        var C = buf_array();
        if (b8) write_biff_rec(C, "Country", write_Country());
        write_biff_rec(C, "EOF");
        var c = C.end();
        var B = buf_array();
        var blen = 0, j = 0;
        for (j = 0; j < wb.SheetNames.length; ++j) blen += (b8 ? 12 : 11) + (b8 ? 2 : 1) * wb.SheetNames[j].length;
        var start = a.length + blen + c.length;
        for (j = 0; j < wb.SheetNames.length; ++j) {
            var _sheet = _sheets[j] || {};
            write_biff_rec(B, "BoundSheet8", write_BoundSheet8({
                "pos": start,
                "hs": _sheet.Hidden || 0,
                "dt": 0,
                "name": wb.SheetNames[j]
            }, opts));
            start += bufs[j].length;
        }
        var b = B.end();
        if (blen != b.length) throw new Error("BS8 " + blen + " != " + b.length);
        var out = [];
        if (a.length) out.push(a);
        if (b.length) out.push(b);
        if (c.length) out.push(c);
        return __toBuffer([ out ]);
    }
    function write_biff8_buf(wb, opts) {
        var o = opts || {};
        var bufs = [];
        if (wb && !wb.SSF) {
            wb.SSF = SSF.get_table();
        }
        if (wb && wb.SSF) {
            make_ssf(SSF);
            SSF.load_table(wb.SSF);
            o.revssf = evert_num(wb.SSF);
            o.revssf[wb.SSF[65535]] = 0;
            o.ssf = wb.SSF;
        }
        o.cellXfs = [];
        o.Strings = [];
        o.Strings.Count = 0;
        o.Strings.Unique = 0;
        get_cell_style(o.cellXfs, {}, {
            "revssf": {
                "General": 0
            }
        });
        for (var i = 0; i < wb.SheetNames.length; ++i) bufs[bufs.length] = write_ws_biff8(i, o, wb);
        bufs.unshift(write_biff8_global(wb, bufs, o));
        return __toBuffer([ bufs ]);
    }
    function write_biff_buf(wb, opts) {
        var o = opts || {};
        switch (o.biff || 2) {
          case 8:
          case 5:
            return write_biff8_buf(wb, opts);

          case 4:
          case 3:
          case 2:
            return write_biff2_buf(wb, opts);
        }
        throw new Error("invalid type " + o.bookType + " for BIFF");
    }
    var HTML_ = function() {
        function html_to_sheet(str, _opts) {
            var opts = _opts || {};
            if (DENSE != null && opts.dense == null) opts.dense = DENSE;
            var ws = opts.dense ? [] : {};
            var mtch = str.match(/<table/i);
            if (!mtch) throw new Error("Invalid HTML: could not find <table>");
            var mtch2 = str.match(/<\/table/i);
            var i = mtch.index, j = mtch2 && mtch2.index || str.length;
            var rows = split_regex(str.slice(i, j), /(:?<tr[^>]*>)/i, "<tr>");
            var R = -1, C = 0, RS = 0, CS = 0;
            var range = {
                "s": {
                    "r": 1e7,
                    "c": 1e7
                },
                "e": {
                    "r": 0,
                    "c": 0
                }
            };
            var merges = [];
            for (i = 0; i < rows.length; ++i) {
                var row = rows[i].trim();
                var hd = row.slice(0, 3).toLowerCase();
                if (hd == "<tr") {
                    ++R;
                    if (opts.sheetRows && opts.sheetRows <= R) {
                        --R;
                        break;
                    }
                    C = 0;
                    continue;
                }
                if (hd != "<td" && hd != "<th") continue;
                var cells = row.split(/<\/t[dh]>/i);
                for (j = 0; j < cells.length; ++j) {
                    var cell = cells[j].trim();
                    if (!cell.match(/<t[dh]/i)) continue;
                    var m = cell, cc = 0;
                    while (m.charAt(0) == "<" && (cc = m.indexOf(">")) > -1) m = m.slice(cc + 1);
                    var tag = parsexmltag(cell.slice(0, cell.indexOf(">")));
                    CS = tag.colspan ? +tag.colspan : 1;
                    if ((RS = +tag.rowspan) > 1 || CS > 1) merges.push({
                        "s": {
                            "r": R,
                            "c": C
                        },
                        "e": {
                            "r": R + (RS || 1) - 1,
                            "c": C + CS - 1
                        }
                    });
                    var _t = tag.t || "";
                    if (!m.length) {
                        C += CS;
                        continue;
                    }
                    m = htmldecode(m);
                    if (range.s.r > R) range.s.r = R;
                    if (range.e.r < R) range.e.r = R;
                    if (range.s.c > C) range.s.c = C;
                    if (range.e.c < C) range.e.c = C;
                    if (!m.length) continue;
                    var o = {
                        "t": "s",
                        "v": m
                    };
                    if (opts.raw || !m.trim().length || _t == "s") {} else if (m === "TRUE") o = {
                        "t": "b",
                        "v": true
                    }; else if (m === "FALSE") o = {
                        "t": "b",
                        "v": false
                    }; else if (!isNaN(fuzzynum(m))) o = {
                        "t": "n",
                        "v": fuzzynum(m)
                    }; else if (!isNaN(fuzzydate(m).getDate())) {
                        o = {
                            "t": "d",
                            "v": parseDate(m)
                        };
                        if (!opts.cellDates) o = {
                            "t": "n",
                            "v": datenum(o.v)
                        };
                        o.z = opts.dateNF || SSF._table[14];
                    }
                    if (opts.dense) {
                        if (!ws[R]) ws[R] = [];
                        ws[R][C] = o;
                    } else ws[encode_cell({
                        "r": R,
                        "c": C
                    })] = o;
                    C += CS;
                }
            }
            ws["!ref"] = encode_range(range);
            return ws;
        }
        function html_to_book(str, opts) {
            return sheet_to_workbook(html_to_sheet(str, opts), opts);
        }
        function make_html_row(ws, r, R, o) {
            var M = ws["!merges"] || [];
            var oo = [];
            for (var C = r.s.c; C <= r.e.c; ++C) {
                var RS = 0, CS = 0;
                for (var j = 0; j < M.length; ++j) {
                    if (M[j].s.r > R || M[j].s.c > C) continue;
                    if (M[j].e.r < R || M[j].e.c < C) continue;
                    if (M[j].s.r < R || M[j].s.c < C) {
                        RS = -1;
                        break;
                    }
                    RS = M[j].e.r - M[j].s.r + 1;
                    CS = M[j].e.c - M[j].s.c + 1;
                    break;
                }
                if (RS < 0) continue;
                var coord = encode_cell({
                    "r": R,
                    "c": C
                });
                var cell = o.dense ? (ws[R] || [])[C] : ws[coord];
                var sp = {};
                if (RS > 1) sp.rowspan = RS;
                if (CS > 1) sp.colspan = CS;
                var w = cell && cell.v != null && (cell.h || escapehtml(cell.w || (format_cell(cell), 
                cell.w) || "")) || "";
                sp.t = cell && cell.t || "z";
                if (o.editable) w = '<span contenteditable="true">' + w + "</span>";
                sp.id = "sjs-" + coord;
                oo.push(writextag("td", w, sp));
            }
            var preamble = "<tr>";
            return preamble + oo.join("") + "</tr>";
        }
        function make_html_preamble(ws, R, o) {
            var out = [];
            return out.join("") + "<table" + (o && o.id ? ' id="' + o.id + '"' : "") + ">";
        }
        var _BEGIN = '<html><head><meta charset="utf-8"/><title>SheetJS Table Export</title></head><body>';
        var _END = "</body></html>";
        function sheet_to_html(ws, opts) {
            var o = opts || {};
            var header = o.header != null ? o.header : _BEGIN;
            var footer = o.footer != null ? o.footer : _END;
            var out = [ header ];
            var r = decode_range(ws["!ref"]);
            o.dense = Array.isArray(ws);
            out.push(make_html_preamble(ws, r, o));
            for (var R = r.s.r; R <= r.e.r; ++R) out.push(make_html_row(ws, r, R, o));
            out.push("</table>" + footer);
            return out.join("");
        }
        return {
            "to_workbook": html_to_book,
            "to_sheet": html_to_sheet,
            "_row": make_html_row,
            "BEGIN": _BEGIN,
            "END": _END,
            "_preamble": make_html_preamble,
            "from_sheet": sheet_to_html
        };
    }();
    function parse_dom_table(table, _opts) {
        var opts = _opts || {};
        if (DENSE != null) opts.dense = DENSE;
        var ws = opts.dense ? [] : {};
        var rows = table.getElementsByTagName("tr");
        var sheetRows = opts.sheetRows || 1e7;
        var range = {
            "s": {
                "r": 0,
                "c": 0
            },
            "e": {
                "r": 0,
                "c": 0
            }
        };
        var merges = [], midx = 0;
        var rowinfo = [];
        var _R = 0, R = 0, _C, C, RS, CS;
        for (;_R < rows.length && R < sheetRows; ++_R) {
            var row = rows[_R];
            if (is_dom_element_hidden(row)) {
                if (opts.display) continue;
                rowinfo[R] = {
                    "hidden": true
                };
            }
            var elts = row.children;
            for (_C = C = 0; _C < elts.length; ++_C) {
                var elt = elts[_C];
                if (opts.display && is_dom_element_hidden(elt)) continue;
                var v = htmldecode(elt.innerHTML);
                for (midx = 0; midx < merges.length; ++midx) {
                    var m = merges[midx];
                    if (m.s.c == C && m.s.r <= R && R <= m.e.r) {
                        C = m.e.c + 1;
                        midx = -1;
                    }
                }
                CS = +elt.getAttribute("colspan") || 1;
                if ((RS = +elt.getAttribute("rowspan")) > 0 || CS > 1) merges.push({
                    "s": {
                        "r": R,
                        "c": C
                    },
                    "e": {
                        "r": R + (RS || 1) - 1,
                        "c": C + CS - 1
                    }
                });
                var o = {
                    "t": "s",
                    "v": v
                };
                var _t = elt.getAttribute("t") || "";
                if (v != null) {
                    if (v.length == 0) o.t = _t || "z"; else if (opts.raw || v.trim().length == 0 || _t == "s") {} else if (v === "TRUE") o = {
                        "t": "b",
                        "v": true
                    }; else if (v === "FALSE") o = {
                        "t": "b",
                        "v": false
                    }; else if (!isNaN(fuzzynum(v))) o = {
                        "t": "n",
                        "v": fuzzynum(v)
                    }; else if (!isNaN(fuzzydate(v).getDate())) {
                        o = {
                            "t": "d",
                            "v": parseDate(v)
                        };
                        if (!opts.cellDates) o = {
                            "t": "n",
                            "v": datenum(o.v)
                        };
                        o.z = opts.dateNF || SSF._table[14];
                    }
                }
                if (opts.dense) {
                    if (!ws[R]) ws[R] = [];
                    ws[R][C] = o;
                } else ws[encode_cell({
                    "c": C,
                    "r": R
                })] = o;
                if (range.e.c < C) range.e.c = C;
                C += CS;
            }
            ++R;
        }
        if (merges.length) ws["!merges"] = merges;
        if (rowinfo.length) ws["!rows"] = rowinfo;
        range.e.r = R - 1;
        ws["!ref"] = encode_range(range);
        if (R >= sheetRows) ws["!fullref"] = encode_range((range.e.r = rows.length - _R + R - 1, 
        range));
        return ws;
    }
    function table_to_book(table, opts) {
        return sheet_to_workbook(parse_dom_table(table, opts), opts);
    }
    function is_dom_element_hidden(element) {
        var display = "";
        var get_computed_style = get_get_computed_style_function(element);
        if (get_computed_style) display = get_computed_style(element).getPropertyValue("display");
        if (!display) display = element.style.display;
        return display === "none";
    }
    function get_get_computed_style_function(element) {
        if (element.ownerDocument.defaultView && typeof element.ownerDocument.defaultView.getComputedStyle === "function") return element.ownerDocument.defaultView.getComputedStyle;
        if (typeof getComputedStyle === "function") return getComputedStyle;
        return null;
    }
    var parse_content_xml = function() {
        var parse_text_p = function(text) {
            return unescapexml(text.replace(/[\t\r\n]/g, " ").trim().replace(/ +/g, " ").replace(/<text:s\/>/g, " ").replace(/<text:s text:c="(\d+)"\/>/g, function($$, $1) {
                return Array(parseInt($1, 10) + 1).join(" ");
            }).replace(/<text:tab[^>]*\/>/g, "\t").replace(/<text:line-break\/>/g, "\n").replace(/<[^>]*>/g, ""));
        };
        var number_formats = {
            "day": [ "d", "dd" ],
            "month": [ "m", "mm" ],
            "year": [ "y", "yy" ],
            "hours": [ "h", "hh" ],
            "minutes": [ "m", "mm" ],
            "seconds": [ "s", "ss" ],
            "am-pm": [ "A/P", "AM/PM" ],
            "day-of-week": [ "ddd", "dddd" ],
            "era": [ "e", "ee" ],
            "quarter": [ "\\Qm", 'm\\"th quarter"' ]
        };
        return function pcx(d, _opts) {
            var opts = _opts || {};
            if (DENSE != null && opts.dense == null) opts.dense = DENSE;
            var str = xlml_normalize(d);
            var state = [], tmp;
            var tag;
            var NFtag = {
                "name": ""
            }, NF = "", pidx = 0;
            var sheetag;
            var rowtag;
            var Sheets = {}, SheetNames = [];
            var ws = opts.dense ? [] : {};
            var Rn, q;
            var ctag = {
                "value": ""
            };
            var textp = "", textpidx = 0, textptag;
            var R = -1, C = -1, range = {
                "s": {
                    "r": 1e6,
                    "c": 1e7
                },
                "e": {
                    "r": 0,
                    "c": 0
                }
            };
            var row_ol = 0;
            var number_format_map = {};
            var merges = [], mrange = {}, mR = 0, mC = 0;
            var rowinfo = [], rowpeat = 1, colpeat = 1;
            var arrayf = [];
            var WB = {
                "Names": []
            };
            var atag = {};
            var _Ref = [ "", "" ];
            var comments = [], comment = {};
            var creator = "", creatoridx = 0;
            var isstub = false, intable = false;
            var i = 0;
            xlmlregex.lastIndex = 0;
            str = str.replace(/<!--([\s\S]*?)-->/gm, "").replace(/<!DOCTYPE[^\[]*\[[^\]]*\]>/gm, "");
            while (Rn = xlmlregex.exec(str)) switch (Rn[3] = Rn[3].replace(/_.*$/, "")) {
              case "table":
              case "\u5de5\u4f5c\u8868":
                if (Rn[1] === "/") {
                    if (range.e.c >= range.s.c && range.e.r >= range.s.r) ws["!ref"] = encode_range(range);
                    if (opts.sheetRows > 0 && opts.sheetRows <= range.e.r) {
                        ws["!fullref"] = ws["!ref"];
                        range.e.r = opts.sheetRows - 1;
                        ws["!ref"] = encode_range(range);
                    }
                    if (merges.length) ws["!merges"] = merges;
                    if (rowinfo.length) ws["!rows"] = rowinfo;
                    sheetag.name = sheetag["\u540d\u79f0"] || sheetag.name;
                    if (typeof JSON !== "undefined") JSON.stringify(sheetag);
                    SheetNames.push(sheetag.name);
                    Sheets[sheetag.name] = ws;
                    intable = false;
                } else if (Rn[0].charAt(Rn[0].length - 2) !== "/") {
                    sheetag = parsexmltag(Rn[0], false);
                    R = C = -1;
                    range.s.r = range.s.c = 1e7;
                    range.e.r = range.e.c = 0;
                    ws = opts.dense ? [] : {};
                    merges = [];
                    rowinfo = [];
                    intable = true;
                }
                break;

              case "table-row-group":
                if (Rn[1] === "/") --row_ol; else ++row_ol;
                break;

              case "table-row":
              case "\u884c":
                if (Rn[1] === "/") {
                    R += rowpeat;
                    rowpeat = 1;
                    break;
                }
                rowtag = parsexmltag(Rn[0], false);
                if (rowtag["\u884c\u53f7"]) R = rowtag["\u884c\u53f7"] - 1; else if (R == -1) R = 0;
                rowpeat = +rowtag["number-rows-repeated"] || 1;
                if (rowpeat < 10) for (i = 0; i < rowpeat; ++i) if (row_ol > 0) rowinfo[R + i] = {
                    "level": row_ol
                };
                C = -1;
                break;

              case "covered-table-cell":
                ++C;
                if (opts.sheetStubs) {
                    if (opts.dense) {
                        if (!ws[R]) ws[R] = [];
                        ws[R][C] = {
                            "t": "z"
                        };
                    } else ws[encode_cell({
                        "r": R,
                        "c": C
                    })] = {
                        "t": "z"
                    };
                }
                break;

              case "table-cell":
              case "\u6570\u636e":
                if (Rn[0].charAt(Rn[0].length - 2) === "/") {
                    ++C;
                    ctag = parsexmltag(Rn[0], false);
                    colpeat = parseInt(ctag["number-columns-repeated"] || "1", 10);
                    q = {
                        "t": "z",
                        "v": null
                    };
                    if (ctag.formula && opts.cellFormula != false) q.f = ods_to_csf_formula(unescapexml(ctag.formula));
                    if ((ctag["\u6570\u636e\u7c7b\u578b"] || ctag["value-type"]) == "string") {
                        q.t = "s";
                        q.v = unescapexml(ctag["string-value"] || "");
                        if (opts.dense) {
                            if (!ws[R]) ws[R] = [];
                            ws[R][C] = q;
                        } else {
                            ws[encode_cell({
                                "r": R,
                                "c": C
                            })] = q;
                        }
                    }
                    C += colpeat - 1;
                } else if (Rn[1] !== "/") {
                    ++C;
                    colpeat = 1;
                    var rptR = rowpeat ? R + rowpeat - 1 : R;
                    if (C > range.e.c) range.e.c = C;
                    if (C < range.s.c) range.s.c = C;
                    if (R < range.s.r) range.s.r = R;
                    if (rptR > range.e.r) range.e.r = rptR;
                    ctag = parsexmltag(Rn[0], false);
                    comments = [];
                    comment = {};
                    q = {
                        "t": ctag["\u6570\u636e\u7c7b\u578b"] || ctag["value-type"],
                        "v": null
                    };
                    if (opts.cellFormula) {
                        if (ctag.formula) ctag.formula = unescapexml(ctag.formula);
                        if (ctag["number-matrix-columns-spanned"] && ctag["number-matrix-rows-spanned"]) {
                            mR = parseInt(ctag["number-matrix-rows-spanned"], 10) || 0;
                            mC = parseInt(ctag["number-matrix-columns-spanned"], 10) || 0;
                            mrange = {
                                "s": {
                                    "r": R,
                                    "c": C
                                },
                                "e": {
                                    "r": R + mR - 1,
                                    "c": C + mC - 1
                                }
                            };
                            q.F = encode_range(mrange);
                            arrayf.push([ mrange, q.F ]);
                        }
                        if (ctag.formula) q.f = ods_to_csf_formula(ctag.formula); else for (i = 0; i < arrayf.length; ++i) if (R >= arrayf[i][0].s.r && R <= arrayf[i][0].e.r) if (C >= arrayf[i][0].s.c && C <= arrayf[i][0].e.c) q.F = arrayf[i][1];
                    }
                    if (ctag["number-columns-spanned"] || ctag["number-rows-spanned"]) {
                        mR = parseInt(ctag["number-rows-spanned"], 10) || 0;
                        mC = parseInt(ctag["number-columns-spanned"], 10) || 0;
                        mrange = {
                            "s": {
                                "r": R,
                                "c": C
                            },
                            "e": {
                                "r": R + mR - 1,
                                "c": C + mC - 1
                            }
                        };
                        merges.push(mrange);
                    }
                    if (ctag["number-columns-repeated"]) colpeat = parseInt(ctag["number-columns-repeated"], 10);
                    switch (q.t) {
                      case "boolean":
                        q.t = "b";
                        q.v = parsexmlbool(ctag["boolean-value"]);
                        break;

                      case "float":
                        q.t = "n";
                        q.v = parseFloat(ctag.value);
                        break;

                      case "percentage":
                        q.t = "n";
                        q.v = parseFloat(ctag.value);
                        break;

                      case "currency":
                        q.t = "n";
                        q.v = parseFloat(ctag.value);
                        break;

                      case "date":
                        q.t = "d";
                        q.v = parseDate(ctag["date-value"]);
                        if (!opts.cellDates) {
                            q.t = "n";
                            q.v = datenum(q.v);
                        }
                        q.z = "m/d/yy";
                        break;

                      case "time":
                        q.t = "n";
                        q.v = parse_isodur(ctag["time-value"]) / 86400;
                        break;

                      case "number":
                        q.t = "n";
                        q.v = parseFloat(ctag["\u6570\u636e\u6570\u503c"]);
                        break;

                      default:
                        if (q.t === "string" || q.t === "text" || !q.t) {
                            q.t = "s";
                            if (ctag["string-value"] != null) textp = unescapexml(ctag["string-value"]);
                        } else throw new Error("Unsupported value type " + q.t);
                    }
                } else {
                    isstub = false;
                    if (q.t === "s") {
                        q.v = textp || "";
                        isstub = textpidx == 0;
                    }
                    if (atag.Target) q.l = atag;
                    if (comments.length > 0) {
                        q.c = comments;
                        comments = [];
                    }
                    if (textp && opts.cellText !== false) q.w = textp;
                    if (!isstub || opts.sheetStubs) {
                        if (!(opts.sheetRows && opts.sheetRows <= R)) {
                            for (var rpt = 0; rpt < rowpeat; ++rpt) {
                                colpeat = parseInt(ctag["number-columns-repeated"] || "1", 10);
                                if (opts.dense) {
                                    if (!ws[R + rpt]) ws[R + rpt] = [];
                                    ws[R + rpt][C] = rpt == 0 ? q : dup(q);
                                    while (--colpeat > 0) ws[R + rpt][C + colpeat] = dup(q);
                                } else {
                                    ws[encode_cell({
                                        "r": R + rpt,
                                        "c": C
                                    })] = q;
                                    while (--colpeat > 0) ws[encode_cell({
                                        "r": R + rpt,
                                        "c": C + colpeat
                                    })] = dup(q);
                                }
                                if (range.e.c <= C) range.e.c = C;
                            }
                        }
                    }
                    colpeat = parseInt(ctag["number-columns-repeated"] || "1", 10);
                    C += colpeat - 1;
                    colpeat = 0;
                    q = {};
                    textp = "";
                }
                atag = {};
                break;

              case "document":
              case "document-content":
              case "\u7535\u5b50\u8868\u683c\u6587\u6863":
              case "spreadsheet":
              case "\u4e3b\u4f53":
              case "scripts":
              case "styles":
              case "font-face-decls":
                if (Rn[1] === "/") {
                    if ((tmp = state.pop())[0] !== Rn[3]) throw "Bad state: " + tmp;
                } else if (Rn[0].charAt(Rn[0].length - 2) !== "/") state.push([ Rn[3], true ]);
                break;

              case "annotation":
                if (Rn[1] === "/") {
                    if ((tmp = state.pop())[0] !== Rn[3]) throw "Bad state: " + tmp;
                    comment.t = textp;
                    comment.a = creator;
                    comments.push(comment);
                } else if (Rn[0].charAt(Rn[0].length - 2) !== "/") {
                    state.push([ Rn[3], false ]);
                }
                creator = "";
                creatoridx = 0;
                textp = "";
                textpidx = 0;
                break;

              case "creator":
                if (Rn[1] === "/") {
                    creator = str.slice(creatoridx, Rn.index);
                } else creatoridx = Rn.index + Rn[0].length;
                break;

              case "meta":
              case "\u5143\u6570\u636e":
              case "settings":
              case "config-item-set":
              case "config-item-map-indexed":
              case "config-item-map-entry":
              case "config-item-map-named":
              case "shapes":
              case "frame":
              case "text-box":
              case "image":
              case "data-pilot-tables":
              case "list-style":
              case "form":
              case "dde-links":
              case "event-listeners":
              case "chart":
                if (Rn[1] === "/") {
                    if ((tmp = state.pop())[0] !== Rn[3]) throw "Bad state: " + tmp;
                } else if (Rn[0].charAt(Rn[0].length - 2) !== "/") state.push([ Rn[3], false ]);
                textp = "";
                textpidx = 0;
                break;

              case "scientific-number":
                break;

              case "currency-symbol":
                break;

              case "currency-style":
                break;

              case "number-style":
              case "percentage-style":
              case "date-style":
              case "time-style":
                if (Rn[1] === "/") {
                    number_format_map[NFtag.name] = NF;
                    if ((tmp = state.pop())[0] !== Rn[3]) throw "Bad state: " + tmp;
                } else if (Rn[0].charAt(Rn[0].length - 2) !== "/") {
                    NF = "";
                    NFtag = parsexmltag(Rn[0], false);
                    state.push([ Rn[3], true ]);
                }
                break;

              case "script":
                break;

              case "libraries":
                break;

              case "automatic-styles":
                break;

              case "master-styles":
                break;

              case "default-style":
              case "page-layout":
                break;

              case "style":
                break;

              case "map":
                break;

              case "font-face":
                break;

              case "paragraph-properties":
                break;

              case "table-properties":
                break;

              case "table-column-properties":
                break;

              case "table-row-properties":
                break;

              case "table-cell-properties":
                break;

              case "number":
                switch (state[state.length - 1][0]) {
                  case "time-style":
                  case "date-style":
                    tag = parsexmltag(Rn[0], false);
                    NF += number_formats[Rn[3]][tag.style === "long" ? 1 : 0];
                    break;
                }
                break;

              case "fraction":
                break;

              case "day":
              case "month":
              case "year":
              case "era":
              case "day-of-week":
              case "week-of-year":
              case "quarter":
              case "hours":
              case "minutes":
              case "seconds":
              case "am-pm":
                switch (state[state.length - 1][0]) {
                  case "time-style":
                  case "date-style":
                    tag = parsexmltag(Rn[0], false);
                    NF += number_formats[Rn[3]][tag.style === "long" ? 1 : 0];
                    break;
                }
                break;

              case "boolean-style":
                break;

              case "boolean":
                break;

              case "text-style":
                break;

              case "text":
                if (Rn[0].slice(-2) === "/>") break; else if (Rn[1] === "/") switch (state[state.length - 1][0]) {
                  case "number-style":
                  case "date-style":
                  case "time-style":
                    NF += str.slice(pidx, Rn.index);
                    break;
                } else pidx = Rn.index + Rn[0].length;
                break;

              case "named-range":
                tag = parsexmltag(Rn[0], false);
                _Ref = ods_to_csf_3D(tag["cell-range-address"]);
                var nrange = {
                    "Name": tag.name,
                    "Ref": _Ref[0] + "!" + _Ref[1]
                };
                if (intable) nrange.Sheet = SheetNames.length;
                WB.Names.push(nrange);
                break;

              case "text-content":
                break;

              case "text-properties":
                break;

              case "embedded-text":
                break;

              case "body":
              case "\u7535\u5b50\u8868\u683c":
                break;

              case "forms":
                break;

              case "table-column":
                break;

              case "table-header-rows":
                break;

              case "table-rows":
                break;

              case "table-column-group":
                break;

              case "table-header-columns":
                break;

              case "table-columns":
                break;

              case "null-date":
                break;

              case "graphic-properties":
                break;

              case "calculation-settings":
                break;

              case "named-expressions":
                break;

              case "label-range":
                break;

              case "label-ranges":
                break;

              case "named-expression":
                break;

              case "sort":
                break;

              case "sort-by":
                break;

              case "sort-groups":
                break;

              case "tab":
                break;

              case "line-break":
                break;

              case "span":
                break;

              case "p":
              case "\u6587\u672c\u4e32":
                if (Rn[1] === "/" && (!ctag || !ctag["string-value"])) textp = (textp.length > 0 ? textp + "\n" : "") + parse_text_p(str.slice(textpidx, Rn.index), textptag); else {
                    textptag = parsexmltag(Rn[0], false);
                    textpidx = Rn.index + Rn[0].length;
                }
                break;

              case "s":
                break;

              case "database-range":
                if (Rn[1] === "/") break;
                try {
                    _Ref = ods_to_csf_3D(parsexmltag(Rn[0])["target-range-address"]);
                    Sheets[_Ref[0]]["!autofilter"] = {
                        "ref": _Ref[1]
                    };
                } catch (e) {}
                break;

              case "date":
                break;

              case "object":
                break;

              case "title":
              case "\u6807\u9898":
                break;

              case "desc":
                break;

              case "binary-data":
                break;

              case "table-source":
                break;

              case "scenario":
                break;

              case "iteration":
                break;

              case "content-validations":
                break;

              case "content-validation":
                break;

              case "help-message":
                break;

              case "error-message":
                break;

              case "database-ranges":
                break;

              case "filter":
                break;

              case "filter-and":
                break;

              case "filter-or":
                break;

              case "filter-condition":
                break;

              case "list-level-style-bullet":
                break;

              case "list-level-style-number":
                break;

              case "list-level-properties":
                break;

              case "sender-firstname":
              case "sender-lastname":
              case "sender-initials":
              case "sender-title":
              case "sender-position":
              case "sender-email":
              case "sender-phone-private":
              case "sender-fax":
              case "sender-company":
              case "sender-phone-work":
              case "sender-street":
              case "sender-city":
              case "sender-postal-code":
              case "sender-country":
              case "sender-state-or-province":
              case "author-name":
              case "author-initials":
              case "chapter":
              case "file-name":
              case "template-name":
              case "sheet-name":
                break;

              case "event-listener":
                break;

              case "initial-creator":
              case "creation-date":
              case "print-date":
              case "generator":
              case "document-statistic":
              case "user-defined":
              case "editing-duration":
              case "editing-cycles":
                break;

              case "config-item":
                break;

              case "page-number":
                break;

              case "page-count":
                break;

              case "time":
                break;

              case "cell-range-source":
                break;

              case "detective":
                break;

              case "operation":
                break;

              case "highlighted-range":
                break;

              case "data-pilot-table":
              case "source-cell-range":
              case "source-service":
              case "data-pilot-field":
              case "data-pilot-level":
              case "data-pilot-subtotals":
              case "data-pilot-subtotal":
              case "data-pilot-members":
              case "data-pilot-member":
              case "data-pilot-display-info":
              case "data-pilot-sort-info":
              case "data-pilot-layout-info":
              case "data-pilot-field-reference":
              case "data-pilot-groups":
              case "data-pilot-group":
              case "data-pilot-group-member":
                break;

              case "rect":
                break;

              case "dde-connection-decls":
              case "dde-connection-decl":
              case "dde-link":
              case "dde-source":
                break;

              case "properties":
                break;

              case "property":
                break;

              case "a":
                if (Rn[1] !== "/") {
                    atag = parsexmltag(Rn[0], false);
                    if (!atag.href) break;
                    atag.Target = atag.href;
                    delete atag.href;
                    if (atag.Target.charAt(0) == "#" && atag.Target.indexOf(".") > -1) {
                        _Ref = ods_to_csf_3D(atag.Target.slice(1));
                        atag.Target = "#" + _Ref[0] + "!" + _Ref[1];
                    }
                }
                break;

              case "table-protection":
                break;

              case "data-pilot-grand-total":
                break;

              case "office-document-common-attrs":
                break;

              default:
                switch (Rn[2]) {
                  case "dc:":
                  case "calcext:":
                  case "loext:":
                  case "ooo:":
                  case "chartooo:":
                  case "draw:":
                  case "style:":
                  case "chart:":
                  case "form:":
                  case "uof:":
                  case "\u8868:":
                  case "\u5b57:":
                    break;

                  default:
                    if (opts.WTF) throw new Error(Rn);
                }
            }
            var out = {
                "Sheets": Sheets,
                "SheetNames": SheetNames,
                "Workbook": WB
            };
            if (opts.bookSheets) delete out.Sheets;
            return out;
        };
    }();
    function parse_ods(zip, opts) {
        opts = opts || {};
        var ods = !!safegetzipfile(zip, "objectdata");
        if (ods) parse_manifest(getzipdata(zip, "META-INF/manifest.xml"), opts);
        var content = getzipstr(zip, "content.xml");
        if (!content) throw new Error("Missing content.xml in " + (ods ? "ODS" : "UOF") + " file");
        var wb = parse_content_xml(ods ? content : utf8read(content), opts);
        if (safegetzipfile(zip, "meta.xml")) wb.Props = parse_core_props(getzipdata(zip, "meta.xml"));
        return wb;
    }
    function parse_fods(data, opts) {
        return parse_content_xml(data, opts);
    }
    var write_styles_ods = function() {
        var payload = "<office:document-styles " + wxt_helper({
            "xmlns:office": "urn:oasis:names:tc:opendocument:xmlns:office:1.0",
            "xmlns:table": "urn:oasis:names:tc:opendocument:xmlns:table:1.0",
            "xmlns:style": "urn:oasis:names:tc:opendocument:xmlns:style:1.0",
            "xmlns:text": "urn:oasis:names:tc:opendocument:xmlns:text:1.0",
            "xmlns:draw": "urn:oasis:names:tc:opendocument:xmlns:drawing:1.0",
            "xmlns:fo": "urn:oasis:names:tc:opendocument:xmlns:xsl-fo-compatible:1.0",
            "xmlns:xlink": "http://www.w3.org/1999/xlink",
            "xmlns:dc": "http://purl.org/dc/elements/1.1/",
            "xmlns:number": "urn:oasis:names:tc:opendocument:xmlns:datastyle:1.0",
            "xmlns:svg": "urn:oasis:names:tc:opendocument:xmlns:svg-compatible:1.0",
            "xmlns:of": "urn:oasis:names:tc:opendocument:xmlns:of:1.2",
            "office:version": "1.2"
        }) + "></office:document-styles>";
        return function wso() {
            return XML_HEADER + payload;
        };
    }();
    var write_content_ods = function() {
        var write_text_p = function(text) {
            return escapexml(text).replace(/  +/g, function($$) {
                return '<text:s text:c="' + $$.length + '"/>';
            }).replace(/\t/g, "<text:tab/>").replace(/\n/g, "<text:line-break/>").replace(/^ /, "<text:s/>").replace(/ $/, "<text:s/>");
        };
        var null_cell_xml = "          <table:table-cell />\n";
        var covered_cell_xml = "          <table:covered-table-cell/>\n";
        var write_ws = function(ws, wb, i) {
            var o = [];
            o.push('      <table:table table:name="' + escapexml(wb.SheetNames[i]) + '">\n');
            var R = 0, C = 0, range = decode_range(ws["!ref"]);
            var marr = ws["!merges"] || [], mi = 0;
            var dense = Array.isArray(ws);
            for (R = 0; R < range.s.r; ++R) o.push("        <table:table-row></table:table-row>\n");
            for (;R <= range.e.r; ++R) {
                o.push("        <table:table-row>\n");
                for (C = 0; C < range.s.c; ++C) o.push(null_cell_xml);
                for (;C <= range.e.c; ++C) {
                    var skip = false, ct = {}, textp = "";
                    for (mi = 0; mi != marr.length; ++mi) {
                        if (marr[mi].s.c > C) continue;
                        if (marr[mi].s.r > R) continue;
                        if (marr[mi].e.c < C) continue;
                        if (marr[mi].e.r < R) continue;
                        if (marr[mi].s.c != C || marr[mi].s.r != R) skip = true;
                        ct["table:number-columns-spanned"] = marr[mi].e.c - marr[mi].s.c + 1;
                        ct["table:number-rows-spanned"] = marr[mi].e.r - marr[mi].s.r + 1;
                        break;
                    }
                    if (skip) {
                        o.push(covered_cell_xml);
                        continue;
                    }
                    var ref = encode_cell({
                        "r": R,
                        "c": C
                    }), cell = dense ? (ws[R] || [])[C] : ws[ref];
                    if (cell && cell.f) {
                        ct["table:formula"] = escapexml(csf_to_ods_formula(cell.f));
                        if (cell.F) {
                            if (cell.F.slice(0, ref.length) == ref) {
                                var _Fref = decode_range(cell.F);
                                ct["table:number-matrix-columns-spanned"] = _Fref.e.c - _Fref.s.c + 1;
                                ct["table:number-matrix-rows-spanned"] = _Fref.e.r - _Fref.s.r + 1;
                            }
                        }
                    }
                    if (!cell) {
                        o.push(null_cell_xml);
                        continue;
                    }
                    switch (cell.t) {
                      case "b":
                        textp = cell.v ? "TRUE" : "FALSE";
                        ct["office:value-type"] = "boolean";
                        ct["office:boolean-value"] = cell.v ? "true" : "false";
                        break;

                      case "n":
                        textp = cell.w || String(cell.v || 0);
                        ct["office:value-type"] = "float";
                        ct["office:value"] = cell.v || 0;
                        break;

                      case "s":
                      case "str":
                        textp = cell.v;
                        ct["office:value-type"] = "string";
                        break;

                      case "d":
                        textp = cell.w || parseDate(cell.v).toISOString();
                        ct["office:value-type"] = "date";
                        ct["office:date-value"] = parseDate(cell.v).toISOString();
                        ct["table:style-name"] = "ce1";
                        break;

                      default:
                        o.push(null_cell_xml);
                        continue;
                    }
                    var text_p = write_text_p(textp);
                    if (cell.l && cell.l.Target) {
                        var _tgt = cell.l.Target;
                        _tgt = _tgt.charAt(0) == "#" ? "#" + csf_to_ods_3D(_tgt.slice(1)) : _tgt;
                        text_p = writextag("text:a", text_p, {
                            "xlink:href": _tgt
                        });
                    }
                    o.push("          " + writextag("table:table-cell", writextag("text:p", text_p, {}), ct) + "\n");
                }
                o.push("        </table:table-row>\n");
            }
            o.push("      </table:table>\n");
            return o.join("");
        };
        var write_automatic_styles_ods = function(o) {
            o.push(" <office:automatic-styles>\n");
            o.push('  <number:date-style style:name="N37" number:automatic-order="true">\n');
            o.push('   <number:month number:style="long"/>\n');
            o.push("   <number:text>/</number:text>\n");
            o.push('   <number:day number:style="long"/>\n');
            o.push("   <number:text>/</number:text>\n");
            o.push("   <number:year/>\n");
            o.push("  </number:date-style>\n");
            o.push('  <style:style style:name="ce1" style:family="table-cell" style:parent-style-name="Default" style:data-style-name="N37"/>\n');
            o.push(" </office:automatic-styles>\n");
        };
        return function wcx(wb, opts) {
            var o = [ XML_HEADER ];
            var attr = wxt_helper({
                "xmlns:office": "urn:oasis:names:tc:opendocument:xmlns:office:1.0",
                "xmlns:table": "urn:oasis:names:tc:opendocument:xmlns:table:1.0",
                "xmlns:style": "urn:oasis:names:tc:opendocument:xmlns:style:1.0",
                "xmlns:text": "urn:oasis:names:tc:opendocument:xmlns:text:1.0",
                "xmlns:draw": "urn:oasis:names:tc:opendocument:xmlns:drawing:1.0",
                "xmlns:fo": "urn:oasis:names:tc:opendocument:xmlns:xsl-fo-compatible:1.0",
                "xmlns:xlink": "http://www.w3.org/1999/xlink",
                "xmlns:dc": "http://purl.org/dc/elements/1.1/",
                "xmlns:meta": "urn:oasis:names:tc:opendocument:xmlns:meta:1.0",
                "xmlns:number": "urn:oasis:names:tc:opendocument:xmlns:datastyle:1.0",
                "xmlns:presentation": "urn:oasis:names:tc:opendocument:xmlns:presentation:1.0",
                "xmlns:svg": "urn:oasis:names:tc:opendocument:xmlns:svg-compatible:1.0",
                "xmlns:chart": "urn:oasis:names:tc:opendocument:xmlns:chart:1.0",
                "xmlns:dr3d": "urn:oasis:names:tc:opendocument:xmlns:dr3d:1.0",
                "xmlns:math": "http://www.w3.org/1998/Math/MathML",
                "xmlns:form": "urn:oasis:names:tc:opendocument:xmlns:form:1.0",
                "xmlns:script": "urn:oasis:names:tc:opendocument:xmlns:script:1.0",
                "xmlns:ooo": "http://openoffice.org/2004/office",
                "xmlns:ooow": "http://openoffice.org/2004/writer",
                "xmlns:oooc": "http://openoffice.org/2004/calc",
                "xmlns:dom": "http://www.w3.org/2001/xml-events",
                "xmlns:xforms": "http://www.w3.org/2002/xforms",
                "xmlns:xsd": "http://www.w3.org/2001/XMLSchema",
                "xmlns:xsi": "http://www.w3.org/2001/XMLSchema-instance",
                "xmlns:sheet": "urn:oasis:names:tc:opendocument:sh33tjs:1.0",
                "xmlns:rpt": "http://openoffice.org/2005/report",
                "xmlns:of": "urn:oasis:names:tc:opendocument:xmlns:of:1.2",
                "xmlns:xhtml": "http://www.w3.org/1999/xhtml",
                "xmlns:grddl": "http://www.w3.org/2003/g/data-view#",
                "xmlns:tableooo": "http://openoffice.org/2009/table",
                "xmlns:drawooo": "http://openoffice.org/2010/draw",
                "xmlns:calcext": "urn:org:documentfoundation:names:experimental:calc:xmlns:calcext:1.0",
                "xmlns:loext": "urn:org:documentfoundation:names:experimental:office:xmlns:loext:1.0",
                "xmlns:field": "urn:openoffice:names:experimental:ooo-ms-interop:xmlns:field:1.0",
                "xmlns:formx": "urn:openoffice:names:experimental:ooxml-odf-interop:xmlns:form:1.0",
                "xmlns:css3t": "http://www.w3.org/TR/css3-text/",
                "office:version": "1.2"
            });
            var fods = wxt_helper({
                "xmlns:config": "urn:oasis:names:tc:opendocument:xmlns:config:1.0",
                "office:mimetype": "application/vnd.oasis.opendocument.spreadsheet"
            });
            if (opts.bookType == "fods") o.push("<office:document" + attr + fods + ">\n"); else o.push("<office:document-content" + attr + ">\n");
            write_automatic_styles_ods(o);
            o.push("  <office:body>\n");
            o.push("    <office:spreadsheet>\n");
            for (var i = 0; i != wb.SheetNames.length; ++i) o.push(write_ws(wb.Sheets[wb.SheetNames[i]], wb, i, opts));
            o.push("    </office:spreadsheet>\n");
            o.push("  </office:body>\n");
            if (opts.bookType == "fods") o.push("</office:document>"); else o.push("</office:document-content>");
            return o.join("");
        };
    }();
    function write_ods(wb, opts) {
        if (opts.bookType == "fods") return write_content_ods(wb, opts);
        var zip = new jszip();
        var f = "";
        var manifest = [];
        var rdf = [];
        f = "mimetype";
        zip.file(f, "application/vnd.oasis.opendocument.spreadsheet");
        f = "content.xml";
        zip.file(f, write_content_ods(wb, opts));
        manifest.push([ f, "text/xml" ]);
        rdf.push([ f, "ContentFile" ]);
        f = "styles.xml";
        zip.file(f, write_styles_ods(wb, opts));
        manifest.push([ f, "text/xml" ]);
        rdf.push([ f, "StylesFile" ]);
        f = "meta.xml";
        zip.file(f, write_meta_ods());
        manifest.push([ f, "text/xml" ]);
        rdf.push([ f, "MetadataFile" ]);
        f = "manifest.rdf";
        zip.file(f, write_rdf(rdf));
        manifest.push([ f, "application/rdf+xml" ]);
        f = "META-INF/manifest.xml";
        zip.file(f, write_manifest(manifest));
        return zip;
    }
    function write_sheet_index(wb, sheet) {
        if (!sheet) return 0;
        var idx = wb.SheetNames.indexOf(sheet);
        if (idx == -1) throw new Error("Sheet not found: " + sheet);
        return idx;
    }
    function write_obj_str(factory) {
        return function write_str(wb, o) {
            var idx = write_sheet_index(wb, o.sheet);
            return factory.from_sheet(wb.Sheets[wb.SheetNames[idx]], o, wb);
        };
    }
    var write_htm_str = write_obj_str(HTML_);
    var write_csv_str = write_obj_str({
        "from_sheet": sheet_to_csv
    });
    var write_slk_str = write_obj_str(SYLK);
    var write_dif_str = write_obj_str(DIF);
    var write_prn_str = write_obj_str(PRN);
    var write_rtf_str = write_obj_str(RTF);
    var write_txt_str = write_obj_str({
        "from_sheet": sheet_to_txt
    });
    var write_dbf_buf = write_obj_str(DBF);
    var write_eth_str = write_obj_str(ETH);
    function fix_opts_func(defaults) {
        return function fix_opts(opts) {
            for (var i = 0; i != defaults.length; ++i) {
                var d = defaults[i];
                if (opts[d[0]] === undefined) opts[d[0]] = d[1];
                if (d[2] === "n") opts[d[0]] = Number(opts[d[0]]);
            }
        };
    }
    var fix_read_opts = fix_opts_func([ [ "cellNF", false ], [ "cellHTML", true ], [ "cellFormula", true ], [ "cellStyles", false ], [ "cellText", true ], [ "cellDates", false ], [ "sheetStubs", false ], [ "sheetRows", 0, "n" ], [ "bookDeps", false ], [ "bookSheets", false ], [ "bookProps", false ], [ "bookFiles", false ], [ "bookVBA", false ], [ "password", "" ], [ "WTF", false ] ]);
    var fix_write_opts = fix_opts_func([ [ "cellDates", false ], [ "bookSST", false ], [ "bookType", "xlsx" ], [ "compression", false ], [ "WTF", false ] ]);
    function get_sheet_type(n) {
        if (RELS.WS.indexOf(n) > -1) return "sheet";
        if (RELS.CS && n == RELS.CS) return "chart";
        if (RELS.DS && n == RELS.DS) return "dialog";
        if (RELS.MS && n == RELS.MS) return "macro";
        return n && n.length ? n : "sheet";
    }
    function safe_parse_wbrels(wbrels, sheets) {
        if (!wbrels) return 0;
        try {
            wbrels = sheets.map(function pwbr(w) {
                if (!w.id) w.id = w.strRelID;
                return [ w.name, wbrels["!id"][w.id].Target, get_sheet_type(wbrels["!id"][w.id].Type) ];
            });
        } catch (e) {
            return null;
        }
        return !wbrels || wbrels.length === 0 ? null : wbrels;
    }
    function safe_parse_sheet(zip, path, relsPath, sheet, idx, sheetRels, sheets, stype, opts, wb, themes, styles) {
        try {
            sheetRels[sheet] = parse_rels(getzipstr(zip, relsPath, true), path);
            var data = getzipdata(zip, path);
            var _ws;
            switch (stype) {
              case "sheet":
                _ws = parse_ws(data, path, idx, opts, sheetRels[sheet], wb, themes, styles);
                break;

              case "chart":
                _ws = parse_cs(data, path, idx, opts, sheetRels[sheet], wb, themes, styles);
                if (!_ws || !_ws["!chart"]) break;
                var dfile = resolve_path(_ws["!chart"].Target, path);
                var drelsp = get_rels_path(dfile);
                var draw = parse_drawing(getzipstr(zip, dfile, true), parse_rels(getzipstr(zip, drelsp, true), dfile));
                var chartp = resolve_path(draw, dfile);
                var crelsp = get_rels_path(chartp);
                _ws = parse_chart(getzipstr(zip, chartp, true), chartp, opts, parse_rels(getzipstr(zip, crelsp, true), chartp), wb, _ws);
                break;

              case "macro":
                _ws = parse_ms(data, path, idx, opts, sheetRels[sheet], wb, themes, styles);
                break;

              case "dialog":
                _ws = parse_ds(data, path, idx, opts, sheetRels[sheet], wb, themes, styles);
                break;
            }
            sheets[sheet] = _ws;
        } catch (e) {
            if (opts.WTF) throw e;
        }
    }
    function strip_front_slash(x) {
        return x.charAt(0) == "/" ? x.slice(1) : x;
    }
    function parse_zip(zip, opts) {
        make_ssf(SSF);
        opts = opts || {};
        fix_read_opts(opts);
        if (safegetzipfile(zip, "META-INF/manifest.xml")) return parse_ods(zip, opts);
        if (safegetzipfile(zip, "objectdata.xml")) return parse_ods(zip, opts);
        if (safegetzipfile(zip, "Index/Document.iwa")) throw new Error("Unsupported NUMBERS file");
        var entries = zipentries(zip);
        var dir = parse_ct(getzipstr(zip, "[Content_Types].xml"));
        var xlsb = false;
        var sheets, binname;
        if (dir.workbooks.length === 0) {
            binname = "xl/workbook.xml";
            if (getzipdata(zip, binname, true)) dir.workbooks.push(binname);
        }
        if (dir.workbooks.length === 0) {
            binname = "xl/workbook.bin";
            if (!getzipdata(zip, binname, true)) throw new Error("Could not find workbook");
            dir.workbooks.push(binname);
            xlsb = true;
        }
        if (dir.workbooks[0].slice(-3) == "bin") xlsb = true;
        var themes = {};
        var styles = {};
        if (!opts.bookSheets && !opts.bookProps) {
            strs = [];
            if (dir.sst) try {
                strs = parse_sst(getzipdata(zip, strip_front_slash(dir.sst)), dir.sst, opts);
            } catch (e) {
                if (opts.WTF) throw e;
            }
            if (opts.cellStyles && dir.themes.length) themes = parse_theme(getzipstr(zip, dir.themes[0].replace(/^\//, ""), true) || "", dir.themes[0], opts);
            if (dir.style) styles = parse_sty(getzipdata(zip, strip_front_slash(dir.style)), dir.style, themes, opts);
        }
        dir.links.map(function(link) {
            return parse_xlink(getzipdata(zip, strip_front_slash(link)), link, opts);
        });
        var wb = parse_wb(getzipdata(zip, strip_front_slash(dir.workbooks[0])), dir.workbooks[0], opts);
        var props = {}, propdata = "";
        if (dir.coreprops.length) {
            propdata = getzipdata(zip, strip_front_slash(dir.coreprops[0]), true);
            if (propdata) props = parse_core_props(propdata);
            if (dir.extprops.length !== 0) {
                propdata = getzipdata(zip, strip_front_slash(dir.extprops[0]), true);
                if (propdata) parse_ext_props(propdata, props, opts);
            }
        }
        var custprops = {};
        if (!opts.bookSheets || opts.bookProps) {
            if (dir.custprops.length !== 0) {
                propdata = getzipstr(zip, strip_front_slash(dir.custprops[0]), true);
                if (propdata) custprops = parse_cust_props(propdata, opts);
            }
        }
        var out = {};
        if (opts.bookSheets || opts.bookProps) {
            if (wb.Sheets) sheets = wb.Sheets.map(function pluck(x) {
                return x.name;
            }); else if (props.Worksheets && props.SheetNames.length > 0) sheets = props.SheetNames;
            if (opts.bookProps) {
                out.Props = props;
                out.Custprops = custprops;
            }
            if (opts.bookSheets && typeof sheets !== "undefined") out.SheetNames = sheets;
            if (opts.bookSheets ? out.SheetNames : opts.bookProps) return out;
        }
        sheets = {};
        var deps = {};
        if (opts.bookDeps && dir.calcchain) deps = parse_cc(getzipdata(zip, strip_front_slash(dir.calcchain)), dir.calcchain, opts);
        var i = 0;
        var sheetRels = {};
        var path, relsPath;
        {
            var wbsheets = wb.Sheets;
            props.Worksheets = wbsheets.length;
            props.SheetNames = [];
            for (var j = 0; j != wbsheets.length; ++j) {
                props.SheetNames[j] = wbsheets[j].name;
            }
        }
        var wbext = xlsb ? "bin" : "xml";
        var wbrelsi = dir.workbooks[0].lastIndexOf("/");
        var wbrelsfile = (dir.workbooks[0].slice(0, wbrelsi + 1) + "_rels/" + dir.workbooks[0].slice(wbrelsi + 1) + ".rels").replace(/^\//, "");
        if (!safegetzipfile(zip, wbrelsfile)) wbrelsfile = "xl/_rels/workbook." + wbext + ".rels";
        var wbrels = parse_rels(getzipstr(zip, wbrelsfile, true), wbrelsfile);
        if (wbrels) wbrels = safe_parse_wbrels(wbrels, wb.Sheets);
        var nmode = getzipdata(zip, "xl/worksheets/sheet.xml", true) ? 1 : 0;
        for (i = 0; i != props.Worksheets; ++i) {
            var stype = "sheet";
            if (wbrels && wbrels[i]) {
                path = "xl/" + wbrels[i][1].replace(/[\/]?xl\//, "");
                if (!safegetzipfile(zip, path)) path = wbrels[i][1];
                if (!safegetzipfile(zip, path)) path = wbrelsfile.replace(/_rels\/.*$/, "") + wbrels[i][1];
                stype = wbrels[i][2];
            } else {
                path = "xl/worksheets/sheet" + (i + 1 - nmode) + "." + wbext;
                path = path.replace(/sheet0\./, "sheet.");
            }
            relsPath = path.replace(/^(.*)(\/)([^\/]*)$/, "$1/_rels/$3.rels");
            safe_parse_sheet(zip, path, relsPath, props.SheetNames[i], i, sheetRels, sheets, stype, opts, wb, themes, styles);
        }
        if (dir.comments) parse_comments(zip, dir.comments, sheets, sheetRels, opts);
        out = {
            "Directory": dir,
            "Workbook": wb,
            "Props": props,
            "Custprops": custprops,
            "Deps": deps,
            "Sheets": sheets,
            "SheetNames": props.SheetNames,
            "Strings": strs,
            "Styles": styles,
            "Themes": themes,
            "SSF": SSF.get_table()
        };
        if (opts.bookFiles) {
            out.keys = entries;
            out.files = zip.files;
        }
        if (opts.bookVBA) {
            if (dir.vba.length > 0) out.vbaraw = getzipdata(zip, strip_front_slash(dir.vba[0]), true); else if (dir.defaults && dir.defaults.bin === CT_VBA) out.vbaraw = getzipdata(zip, "xl/vbaProject.bin", true);
        }
        return out;
    }
    function parse_xlsxcfb(cfb, _opts) {
        var opts = _opts || {};
        var f = "Workbook", data = CFB.find(cfb, f);
        try {
            f = "/!DataSpaces/Version";
            data = CFB.find(cfb, f);
            if (!data || !data.content) throw new Error("ECMA-376 Encrypted file missing " + f);
            parse_DataSpaceVersionInfo(data.content);
            f = "/!DataSpaces/DataSpaceMap";
            data = CFB.find(cfb, f);
            if (!data || !data.content) throw new Error("ECMA-376 Encrypted file missing " + f);
            var dsm = parse_DataSpaceMap(data.content);
            if (dsm.length !== 1 || dsm[0].comps.length !== 1 || dsm[0].comps[0].t !== 0 || dsm[0].name !== "StrongEncryptionDataSpace" || dsm[0].comps[0].v !== "EncryptedPackage") throw new Error("ECMA-376 Encrypted file bad " + f);
            f = "/!DataSpaces/DataSpaceInfo/StrongEncryptionDataSpace";
            data = CFB.find(cfb, f);
            if (!data || !data.content) throw new Error("ECMA-376 Encrypted file missing " + f);
            var seds = parse_DataSpaceDefinition(data.content);
            if (seds.length != 1 || seds[0] != "StrongEncryptionTransform") throw new Error("ECMA-376 Encrypted file bad " + f);
            f = "/!DataSpaces/TransformInfo/StrongEncryptionTransform/!Primary";
            data = CFB.find(cfb, f);
            if (!data || !data.content) throw new Error("ECMA-376 Encrypted file missing " + f);
            parse_Primary(data.content);
        } catch (e) {}
        f = "/EncryptionInfo";
        data = CFB.find(cfb, f);
        if (!data || !data.content) throw new Error("ECMA-376 Encrypted file missing " + f);
        var einfo = parse_EncryptionInfo(data.content);
        f = "/EncryptedPackage";
        data = CFB.find(cfb, f);
        if (!data || !data.content) throw new Error("ECMA-376 Encrypted file missing " + f);
        if (einfo[0] == 4 && typeof decrypt_agile !== "undefined") return decrypt_agile(einfo[1], data.content, opts.password || "", opts);
        if (einfo[0] == 2 && typeof decrypt_std76 !== "undefined") return decrypt_std76(einfo[1], data.content, opts.password || "", opts);
        throw new Error("File is password-protected");
    }
    function write_zip(wb, opts) {
        _shapeid = 1024;
        if (opts.bookType == "ods") return write_ods(wb, opts);
        if (wb && !wb.SSF) {
            wb.SSF = SSF.get_table();
        }
        if (wb && wb.SSF) {
            make_ssf(SSF);
            SSF.load_table(wb.SSF);
            opts.revssf = evert_num(wb.SSF);
            opts.revssf[wb.SSF[65535]] = 0;
            opts.ssf = wb.SSF;
        }
        opts.rels = {};
        opts.wbrels = {};
        opts.Strings = [];
        opts.Strings.Count = 0;
        opts.Strings.Unique = 0;
        if (browser_has_Map) opts.revStrings = new Map(); else {
            opts.revStrings = {};
            opts.revStrings.foo = [];
            delete opts.revStrings.foo;
        }
        var wbext = opts.bookType == "xlsb" ? "bin" : "xml";
        var vbafmt = VBAFMTS.indexOf(opts.bookType) > -1;
        var ct = new_ct();
        fix_write_opts(opts = opts || {});
        var zip = new jszip();
        var f = "", rId = 0;
        opts.cellXfs = [];
        get_cell_style(opts.cellXfs, {}, {
            "revssf": {
                "General": 0
            }
        });
        if (!wb.Props) wb.Props = {};
        f = "docProps/core.xml";
        zip.file(f, write_core_props(wb.Props, opts));
        ct.coreprops.push(f);
        add_rels(opts.rels, 2, f, RELS.CORE_PROPS);
        f = "docProps/app.xml";
        if (wb.Props && wb.Props.SheetNames) {} else if (!wb.Workbook || !wb.Workbook.Sheets) wb.Props.SheetNames = wb.SheetNames; else {
            var _sn = [];
            for (var _i = 0; _i < wb.SheetNames.length; ++_i) if ((wb.Workbook.Sheets[_i] || {}).Hidden != 2) _sn.push(wb.SheetNames[_i]);
            wb.Props.SheetNames = _sn;
        }
        wb.Props.Worksheets = wb.Props.SheetNames.length;
        zip.file(f, write_ext_props(wb.Props, opts));
        ct.extprops.push(f);
        add_rels(opts.rels, 3, f, RELS.EXT_PROPS);
        if (wb.Custprops !== wb.Props && keys(wb.Custprops || {}).length > 0) {
            f = "docProps/custom.xml";
            zip.file(f, write_cust_props(wb.Custprops, opts));
            ct.custprops.push(f);
            add_rels(opts.rels, 4, f, RELS.CUST_PROPS);
        }
        for (rId = 1; rId <= wb.SheetNames.length; ++rId) {
            var wsrels = {
                "!id": {}
            };
            var ws = wb.Sheets[wb.SheetNames[rId - 1]];
            var _type = (ws || {})["!type"] || "sheet";
            switch (_type) {
              case "chart":
              default:
                f = "xl/worksheets/sheet" + rId + "." + wbext;
                zip.file(f, write_ws(rId - 1, f, opts, wb, wsrels));
                ct.sheets.push(f);
                add_rels(opts.wbrels, -1, "worksheets/sheet" + rId + "." + wbext, RELS.WS[0]);
            }
            if (ws) {
                var comments = ws["!comments"];
                if (comments && comments.length > 0) {
                    var cf = "xl/comments" + rId + "." + wbext;
                    zip.file(cf, write_cmnt(comments, cf, opts));
                    ct.comments.push(cf);
                    add_rels(wsrels, -1, "../comments" + rId + "." + wbext, RELS.CMNT);
                }
                if (ws["!legacy"]) {
                    zip.file("xl/drawings/vmlDrawing" + rId + ".vml", write_comments_vml(rId, ws["!comments"]));
                }
                delete ws["!comments"];
                delete ws["!legacy"];
            }
            if (wsrels["!id"].rId1) zip.file(get_rels_path(f), write_rels(wsrels));
        }
        if (opts.Strings != null && opts.Strings.length > 0) {
            f = "xl/sharedStrings." + wbext;
            zip.file(f, write_sst(opts.Strings, f, opts));
            ct.strs.push(f);
            add_rels(opts.wbrels, -1, "sharedStrings." + wbext, RELS.SST);
        }
        f = "xl/workbook." + wbext;
        zip.file(f, write_wb(wb, f, opts));
        ct.workbooks.push(f);
        add_rels(opts.rels, 1, f, RELS.WB);
        f = "xl/theme/theme1.xml";
        zip.file(f, write_theme(wb.Themes, opts));
        ct.themes.push(f);
        add_rels(opts.wbrels, -1, "theme/theme1.xml", RELS.THEME);
        f = "xl/styles." + wbext;
        zip.file(f, write_sty(wb, f, opts));
        ct.styles.push(f);
        add_rels(opts.wbrels, -1, "styles." + wbext, RELS.STY);
        if (wb.vbaraw && vbafmt) {
            f = "xl/vbaProject.bin";
            zip.file(f, wb.vbaraw);
            ct.vba.push(f);
            add_rels(opts.wbrels, -1, "vbaProject.bin", RELS.VBA);
        }
        zip.file("[Content_Types].xml", write_ct(ct, opts));
        zip.file("_rels/.rels", write_rels(opts.rels));
        zip.file("xl/_rels/workbook." + wbext + ".rels", write_rels(opts.wbrels));
        delete opts.revssf;
        delete opts.ssf;
        return zip;
    }
    function firstbyte(f, o) {
        var x = "";
        switch ((o || {}).type || "base64") {
          case "buffer":
            return [ f[0], f[1], f[2], f[3] ];

          case "base64":
            x = Base64.decode(f.slice(0, 24));
            break;

          case "binary":
            x = f;
            break;

          case "array":
            return [ f[0], f[1], f[2], f[3] ];

          default:
            throw new Error("Unrecognized type " + (o && o.type || "undefined"));
        }
        return [ x.charCodeAt(0), x.charCodeAt(1), x.charCodeAt(2), x.charCodeAt(3) ];
    }
    function read_cfb(cfb, opts) {
        if (CFB.find(cfb, "EncryptedPackage")) return parse_xlsxcfb(cfb, opts);
        return parse_xlscfb(cfb, opts);
    }
    function read_zip(data, opts) {
        var zip, d = data;
        var o = opts || {};
        if (!o.type) o.type = has_buf && Buffer.isBuffer(data) ? "buffer" : "base64";
        switch (o.type) {
          case "base64":
            zip = new jszip(d, {
                "base64": true
            });
            break;

          case "binary":
          case "array":
            zip = new jszip(d, {
                "base64": false
            });
            break;

          case "buffer":
            zip = new jszip(d);
            break;

          default:
            throw new Error("Unrecognized type " + o.type);
        }
        return parse_zip(zip, o);
    }
    function read_plaintext(data, o) {
        var i = 0;
        main: while (i < data.length) switch (data.charCodeAt(i)) {
          case 10:
          case 13:
          case 32:
            ++i;
            break;

          case 60:
            return parse_xlml(data.slice(i), o);

          default:
            break main;
        }
        return PRN.to_workbook(data, o);
    }
    function read_plaintext_raw(data, o) {
        var str = "", bytes = firstbyte(data, o);
        switch (o.type) {
          case "base64":
            str = Base64.decode(data);
            break;

          case "binary":
            str = data;
            break;

          case "buffer":
            str = data.toString("binary");
            break;

          case "array":
            str = cc2str(data);
            break;

          default:
            throw new Error("Unrecognized type " + o.type);
        }
        if (bytes[0] == 239 && bytes[1] == 187 && bytes[2] == 191) str = utf8read(str);
        return read_plaintext(str, o);
    }
    function read_utf16(data, o) {
        var d = data;
        if (o.type == "base64") d = Base64.decode(d);
        d = cptable.utils.decode(1200, d.slice(2), "str");
        o.type = "binary";
        return read_plaintext(d, o);
    }
    function bstrify(data) {
        return !data.match(/[^\x00-\x7F]/) ? data : utf8write(data);
    }
    function read_prn(data, d, o, str) {
        if (str) {
            o.type = "string";
            return PRN.to_workbook(data, o);
        }
        return PRN.to_workbook(d, o);
    }
    function readSync(data, opts) {
        reset_cp();
        if (typeof ArrayBuffer !== "undefined" && data instanceof ArrayBuffer) return readSync(new Uint8Array(data), opts);
        var d = data, n = [ 0, 0, 0, 0 ], str = false;
        var o = opts || {};
        _ssfopts = {};
        if (o.dateNF) _ssfopts.dateNF = o.dateNF;
        if (!o.type) o.type = has_buf && Buffer.isBuffer(data) ? "buffer" : "base64";
        if (o.type == "file") {
            o.type = has_buf ? "buffer" : "binary";
            d = read_binary(data);
        }
        if (o.type == "string") {
            str = true;
            o.type = "binary";
            o.codepage = 65001;
            d = bstrify(data);
        }
        if (o.type == "array" && typeof Uint8Array !== "undefined" && data instanceof Uint8Array && typeof ArrayBuffer !== "undefined") {
            var ab = new ArrayBuffer(3), vu = new Uint8Array(ab);
            vu.foo = "bar";
            if (!vu.foo) {
                o = dup(o);
                o.type = "array";
                return readSync(ab2a(d), o);
            }
        }
        switch ((n = firstbyte(d, o))[0]) {
          case 208:
            return read_cfb(CFB.read(d, o), o);

          case 9:
            return parse_xlscfb(d, o);

          case 60:
            return parse_xlml(d, o);

          case 73:
            if (n[1] === 68) return read_wb_ID(d, o);
            break;

          case 84:
            if (n[1] === 65 && n[2] === 66 && n[3] === 76) return DIF.to_workbook(d, o);
            break;

          case 80:
            return n[1] === 75 && n[2] < 9 && n[3] < 9 ? read_zip(d, o) : read_prn(data, d, o, str);

          case 239:
            return n[3] === 60 ? parse_xlml(d, o) : read_prn(data, d, o, str);

          case 255:
            if (n[1] === 254) {
                return read_utf16(d, o);
            }
            break;

          case 0:
            if (n[1] === 0 && n[2] >= 2 && n[3] === 0) return WK_.to_workbook(d, o);
            break;

          case 3:
          case 131:
          case 139:
          case 140:
            return DBF.to_workbook(d, o);

          case 123:
            if (n[1] === 92 && n[2] === 114 && n[3] === 116) return RTF.to_workbook(d, o);
            break;

          case 10:
          case 13:
          case 32:
            return read_plaintext_raw(d, o);
        }
        if (n[2] <= 12 && n[3] <= 31) return DBF.to_workbook(d, o);
        return read_prn(data, d, o, str);
    }
    function readFileSync(filename, opts) {
        var o = opts || {};
        o.type = "file";
        return readSync(filename, o);
    }
    function write_cfb_ctr(cfb, o) {
        switch (o.type) {
          case "base64":
          case "binary":
            break;

          case "buffer":
          case "array":
            o.type = "";
            break;

          case "file":
            return write_dl(o.file, CFB.write(cfb, {
                "type": has_buf ? "buffer" : ""
            }));

          case "string":
            throw new Error("'string' output type invalid for '" + o.bookType + "' files");

          default:
            throw new Error("Unrecognized type " + o.type);
        }
        return CFB.write(cfb, o);
    }
    function write_zip_type(wb, opts) {
        var o = opts || {};
        var z = write_zip(wb, o);
        var oopts = {};
        if (o.compression) oopts.compression = "DEFLATE";
        if (o.password) oopts.type = has_buf ? "nodebuffer" : "string"; else switch (o.type) {
          case "base64":
            oopts.type = "base64";
            break;

          case "binary":
            oopts.type = "string";
            break;

          case "string":
            throw new Error("'string' output type invalid for '" + o.bookType + "' files");

          case "buffer":
          case "file":
            oopts.type = has_buf ? "nodebuffer" : "string";
            break;

          default:
            throw new Error("Unrecognized type " + o.type);
        }
        var out = z.generate(oopts);
        if (o.password && typeof encrypt_agile !== "undefined") return write_cfb_ctr(encrypt_agile(out, o.password), o);
        if (o.type === "file") return write_dl(o.file, out);
        return o.type == "string" ? utf8read(out) : out;
    }
    function write_cfb_type(wb, opts) {
        var o = opts || {};
        var cfb = write_xlscfb(wb, o);
        return write_cfb_ctr(cfb, o);
    }
    function write_string_type(out, opts, bom) {
        if (!bom) bom = "";
        var o = bom + out;
        switch (opts.type) {
          case "base64":
            return Base64.encode(utf8write(o));

          case "binary":
            return utf8write(o);

          case "string":
            return out;

          case "file":
            return write_dl(opts.file, o, "utf8");

          case "buffer":
            {
                if (has_buf) return Buffer_from(o, "utf8"); else return write_string_type(o, {
                    "type": "binary"
                }).split("").map(function(c) {
                    return c.charCodeAt(0);
                });
            }
        }
        throw new Error("Unrecognized type " + opts.type);
    }
    function write_stxt_type(out, opts) {
        switch (opts.type) {
          case "base64":
            return Base64.encode(out);

          case "binary":
            return out;

          case "string":
            return out;

          case "file":
            return write_dl(opts.file, out, "binary");

          case "buffer":
            {
                if (has_buf) return Buffer_from(out, "binary"); else return out.split("").map(function(c) {
                    return c.charCodeAt(0);
                });
            }
        }
        throw new Error("Unrecognized type " + opts.type);
    }
    function write_binary_type(out, opts) {
        switch (opts.type) {
          case "string":
          case "base64":
          case "binary":
            var bstr = "";
            for (var i = 0; i < out.length; ++i) bstr += String.fromCharCode(out[i]);
            return opts.type == "base64" ? Base64.encode(bstr) : opts.type == "string" ? utf8read(bstr) : bstr;

          case "file":
            return write_dl(opts.file, out);

          case "buffer":
            return out;

          default:
            throw new Error("Unrecognized type " + opts.type);
        }
    }
    function writeSync(wb, opts) {
        check_wb(wb);
        var o = opts || {};
        if (o.type == "array") {
            o.type = "binary";
            var out = writeSync(wb, o);
            o.type = "array";
            return s2ab(out);
        }
        switch (o.bookType || "xlsb") {
          case "xml":
          case "xlml":
            return write_string_type(write_xlml(wb, o), o);

          case "slk":
          case "sylk":
            return write_string_type(write_slk_str(wb, o), o);

          case "htm":
          case "html":
            return write_string_type(write_htm_str(wb, o), o);

          case "txt":
            return write_stxt_type(write_txt_str(wb, o), o);

          case "csv":
            return write_string_type(write_csv_str(wb, o), o, "\ufeff");

          case "dif":
            return write_string_type(write_dif_str(wb, o), o);

          case "dbf":
            return write_binary_type(write_dbf_buf(wb, o), o);

          case "prn":
            return write_string_type(write_prn_str(wb, o), o);

          case "rtf":
            return write_string_type(write_rtf_str(wb, o), o);

          case "eth":
            return write_string_type(write_eth_str(wb, o), o);

          case "fods":
            return write_string_type(write_ods(wb, o), o);

          case "biff2":
            if (!o.biff) o.biff = 2;

          case "biff3":
            if (!o.biff) o.biff = 3;

          case "biff4":
            if (!o.biff) o.biff = 4;
            return write_binary_type(write_biff_buf(wb, o), o);

          case "biff5":
            if (!o.biff) o.biff = 5;

          case "biff8":
          case "xla":
          case "xls":
            if (!o.biff) o.biff = 8;
            return write_cfb_type(wb, o);

          case "xlsx":
          case "xlsm":
          case "xlam":
          case "xlsb":
          case "ods":
            return write_zip_type(wb, o);

          default:
            throw new Error("Unrecognized bookType |" + o.bookType + "|");
        }
    }
    function resolve_book_type(o) {
        if (o.bookType) return;
        var _BT = {
            "xls": "biff8",
            "htm": "html",
            "slk": "sylk",
            "socialcalc": "eth",
            "Sh33tJS": "WTF"
        };
        var ext = o.file.slice(o.file.lastIndexOf(".")).toLowerCase();
        if (ext.match(/^\.[a-z]+$/)) o.bookType = ext.slice(1);
        o.bookType = _BT[o.bookType] || o.bookType;
    }
    function writeFileSync(wb, filename, opts) {
        var o = opts || {};
        o.type = "file";
        o.file = filename;
        resolve_book_type(o);
        return writeSync(wb, o);
    }
    function writeFileAsync(filename, wb, opts, cb) {
        var o = opts || {};
        o.type = "file";
        o.file = filename;
        resolve_book_type(o);
        o.type = "buffer";
        var _cb = cb;
        if (!(_cb instanceof Function)) _cb = opts;
        return _fs.writeFile(filename, writeSync(wb, o), _cb);
    }
    function make_json_row(sheet, r, R, cols, header, hdr, dense, o) {
        var rr = encode_row(R);
        var defval = o.defval, raw = o.raw || !o.hasOwnProperty("raw");
        var isempty = true;
        var row = header === 1 ? [] : {};
        if (header !== 1) {
            if (Object.defineProperty) try {
                Object.defineProperty(row, "__rowNum__", {
                    "value": R,
                    "enumerable": false
                });
            } catch (e) {
                row.__rowNum__ = R;
            } else row.__rowNum__ = R;
        }
        if (!dense || sheet[R]) for (var C = r.s.c; C <= r.e.c; ++C) {
            var val = dense ? sheet[R][C] : sheet[cols[C] + rr];
            if (val === undefined || val.t === undefined) {
                if (defval === undefined) continue;
                if (hdr[C] != null) {
                    row[hdr[C]] = defval;
                }
                continue;
            }
            var v = val.v;
            switch (val.t) {
              case "z":
                if (v == null) break;
                continue;

              case "e":
                v = void 0;
                break;

              case "s":
              case "d":
              case "b":
              case "n":
                break;

              default:
                throw new Error("unrecognized type " + val.t);
            }
            if (hdr[C] != null) {
                if (v == null) {
                    if (defval !== undefined) row[hdr[C]] = defval; else if (raw && v === null) row[hdr[C]] = null; else continue;
                } else {
                    row[hdr[C]] = raw ? v : format_cell(val, v, o);
                }
                if (v != null) isempty = false;
            }
        }
        return {
            "row": row,
            "isempty": isempty
        };
    }
    function sheet_to_json(sheet, opts) {
        if (sheet == null || sheet["!ref"] == null) return [];
        var val = {
            "t": "n",
            "v": 0
        }, header = 0, offset = 1, hdr = [], v = 0, vv = "";
        var r = {
            "s": {
                "r": 0,
                "c": 0
            },
            "e": {
                "r": 0,
                "c": 0
            }
        };
        var o = opts || {};
        var range = o.range != null ? o.range : sheet["!ref"];
        if (o.header === 1) header = 1; else if (o.header === "A") header = 2; else if (Array.isArray(o.header)) header = 3;
        switch (typeof range) {
          case "string":
            r = safe_decode_range(range);
            break;

          case "number":
            r = safe_decode_range(sheet["!ref"]);
            r.s.r = range;
            break;

          default:
            r = range;
        }
        if (header > 0) offset = 0;
        var rr = encode_row(r.s.r);
        var cols = [];
        var out = [];
        var outi = 0, counter = 0;
        var dense = Array.isArray(sheet);
        var R = r.s.r, C = 0, CC = 0;
        if (dense && !sheet[R]) sheet[R] = [];
        for (C = r.s.c; C <= r.e.c; ++C) {
            cols[C] = encode_col(C);
            val = dense ? sheet[R][C] : sheet[cols[C] + rr];
            switch (header) {
              case 1:
                hdr[C] = C - r.s.c;
                break;

              case 2:
                hdr[C] = cols[C];
                break;

              case 3:
                hdr[C] = o.header[C - r.s.c];
                break;

              default:
                if (val == null) val = {
                    "w": "__EMPTY",
                    "t": "s"
                };
                vv = v = format_cell(val, null, o);
                counter = 0;
                for (CC = 0; CC < hdr.length; ++CC) if (hdr[CC] == vv) vv = v + "_" + ++counter;
                hdr[C] = vv;
            }
        }
        for (R = r.s.r + offset; R <= r.e.r; ++R) {
            var row = make_json_row(sheet, r, R, cols, header, hdr, dense, o);
            if (row.isempty === false || (header === 1 ? o.blankrows !== false : !!o.blankrows)) out[outi++] = row.row;
        }
        out.length = outi;
        return out;
    }
    var qreg = /"/g;
    function make_csv_row(sheet, r, R, cols, fs, rs, FS, o) {
        var isempty = true;
        var row = [], txt = "", rr = encode_row(R);
        for (var C = r.s.c; C <= r.e.c; ++C) {
            if (!cols[C]) continue;
            var val = o.dense ? (sheet[R] || [])[C] : sheet[cols[C] + rr];
            if (val == null) txt = ""; else if (val.v != null) {
                isempty = false;
                txt = "" + format_cell(val, null, o);
                for (var i = 0, cc = 0; i !== txt.length; ++i) if ((cc = txt.charCodeAt(i)) === fs || cc === rs || cc === 34) {
                    txt = '"' + txt.replace(qreg, '""') + '"';
                    break;
                }
                if (txt == "ID") txt = '"ID"';
            } else if (val.f != null && !val.F) {
                isempty = false;
                txt = "=" + val.f;
                if (txt.indexOf(",") >= 0) txt = '"' + txt.replace(qreg, '""') + '"';
            } else txt = "";
            row.push(txt);
        }
        if (o.blankrows === false && isempty) return null;
        return row.join(FS);
    }
    function sheet_to_csv(sheet, opts) {
        var out = [];
        var o = opts == null ? {} : opts;
        if (sheet == null || sheet["!ref"] == null) return "";
        var r = safe_decode_range(sheet["!ref"]);
        var FS = o.FS !== undefined ? o.FS : ",", fs = FS.charCodeAt(0);
        var RS = o.RS !== undefined ? o.RS : "\n", rs = RS.charCodeAt(0);
        var endregex = new RegExp((FS == "|" ? "\\|" : FS) + "+$");
        var row = "", cols = [];
        o.dense = Array.isArray(sheet);
        var colinfo = o.skipHidden && sheet["!cols"] || [];
        var rowinfo = o.skipHidden && sheet["!rows"] || [];
        for (var C = r.s.c; C <= r.e.c; ++C) if (!(colinfo[C] || {}).hidden) cols[C] = encode_col(C);
        for (var R = r.s.r; R <= r.e.r; ++R) {
            if ((rowinfo[R] || {}).hidden) continue;
            row = make_csv_row(sheet, r, R, cols, fs, rs, FS, o);
            if (row == null) {
                continue;
            }
            if (o.strip) row = row.replace(endregex, "");
            out.push(row + RS);
        }
        delete o.dense;
        return out.join("");
    }
    function sheet_to_txt(sheet, opts) {
        if (!opts) opts = {};
        opts.FS = "\t";
        opts.RS = "\n";
        var s = sheet_to_csv(sheet, opts);
        if (typeof cptable == "undefined" || opts.type == "string") return s;
        var o = cptable.utils.encode(1200, s, "str");
        return String.fromCharCode(255) + String.fromCharCode(254) + o;
    }
    function sheet_to_formulae(sheet) {
        var y = "", x, val = "";
        if (sheet == null || sheet["!ref"] == null) return [];
        var r = safe_decode_range(sheet["!ref"]), rr = "", cols = [], C;
        var cmds = [];
        var dense = Array.isArray(sheet);
        for (C = r.s.c; C <= r.e.c; ++C) cols[C] = encode_col(C);
        for (var R = r.s.r; R <= r.e.r; ++R) {
            rr = encode_row(R);
            for (C = r.s.c; C <= r.e.c; ++C) {
                y = cols[C] + rr;
                x = dense ? (sheet[R] || [])[C] : sheet[y];
                val = "";
                if (x === undefined) continue; else if (x.F != null) {
                    y = x.F;
                    if (!x.f) continue;
                    val = x.f;
                    if (y.indexOf(":") == -1) y = y + ":" + y;
                }
                if (x.f != null) val = x.f; else if (x.t == "z") continue; else if (x.t == "n" && x.v != null) val = "" + x.v; else if (x.t == "b") val = x.v ? "TRUE" : "FALSE"; else if (x.w !== undefined) val = "'" + x.w; else if (x.v === undefined) continue; else if (x.t == "s") val = "'" + x.v; else val = "" + x.v;
                cmds[cmds.length] = y + "=" + val;
            }
        }
        return cmds;
    }
    function sheet_add_json(_ws, js, opts) {
        var o = opts || {};
        var offset = +!o.skipHeader;
        var ws = _ws || {};
        var _R = 0, _C = 0;
        if (ws && o.origin != null) {
            if (typeof o.origin == "number") _R = o.origin; else {
                var _origin = typeof o.origin == "string" ? decode_cell(o.origin) : o.origin;
                _R = _origin.r;
                _C = _origin.c;
            }
        }
        var cell;
        var range = {
            "s": {
                "c": 0,
                "r": 0
            },
            "e": {
                "c": _C,
                "r": _R + js.length - 1 + offset
            }
        };
        if (ws["!ref"]) {
            var _range = safe_decode_range(ws["!ref"]);
            range.e.c = Math.max(range.e.c, _range.e.c);
            range.e.r = Math.max(range.e.r, _range.e.r);
            if (_R == -1) {
                _R = range.e.r + 1;
                range.e.r = _R + js.length - 1 + offset;
            }
        }
        var hdr = o.header || [], C = 0;
        js.forEach(function(JS, R) {
            keys(JS).forEach(function(k) {
                if ((C = hdr.indexOf(k)) == -1) hdr[C = hdr.length] = k;
                var v = JS[k];
                var t = "z";
                var z = "";
                if (v && typeof v === "object" && !(v instanceof Date)) {
                    ws[encode_cell({
                        "c": _C + C,
                        "r": _R + R + offset
                    })] = v;
                } else {
                    if (typeof v == "number") t = "n"; else if (typeof v == "boolean") t = "b"; else if (typeof v == "string") t = "s"; else if (v instanceof Date) {
                        t = "d";
                        if (!o.cellDates) {
                            t = "n";
                            v = datenum(v);
                        }
                        z = o.dateNF || SSF._table[14];
                    }
                    ws[encode_cell({
                        "c": _C + C,
                        "r": _R + R + offset
                    })] = cell = {
                        "t": t,
                        "v": v
                    };
                    if (z) cell.z = z;
                }
            });
        });
        range.e.c = Math.max(range.e.c, _C + hdr.length - 1);
        var __R = encode_row(_R);
        if (offset) for (C = 0; C < hdr.length; ++C) ws[encode_col(C + _C) + __R] = {
            "t": "s",
            "v": hdr[C]
        };
        ws["!ref"] = encode_range(range);
        return ws;
    }
    function json_to_sheet(js, opts) {
        return sheet_add_json(null, js, opts);
    }
    var utils = {
        "encode_col": encode_col,
        "encode_row": encode_row,
        "encode_cell": encode_cell,
        "encode_range": encode_range,
        "decode_col": decode_col,
        "decode_row": decode_row,
        "split_cell": split_cell,
        "decode_cell": decode_cell,
        "decode_range": decode_range,
        "format_cell": format_cell,
        "get_formulae": sheet_to_formulae,
        "make_csv": sheet_to_csv,
        "make_json": sheet_to_json,
        "make_formulae": sheet_to_formulae,
        "sheet_add_aoa": sheet_add_aoa,
        "sheet_add_json": sheet_add_json,
        "aoa_to_sheet": aoa_to_sheet,
        "json_to_sheet": json_to_sheet,
        "table_to_sheet": parse_dom_table,
        "table_to_book": table_to_book,
        "sheet_to_csv": sheet_to_csv,
        "sheet_to_txt": sheet_to_txt,
        "sheet_to_json": sheet_to_json,
        "sheet_to_html": HTML_.from_sheet,
        "sheet_to_dif": DIF.from_sheet,
        "sheet_to_slk": SYLK.from_sheet,
        "sheet_to_eth": ETH.from_sheet,
        "sheet_to_formulae": sheet_to_formulae,
        "sheet_to_row_object_array": sheet_to_json
    };
    (function(utils) {
        utils.consts = utils.consts || {};
        function add_consts(R) {
            R.forEach(function(a) {
                utils.consts[a[0]] = a[1];
            });
        }
        function get_default(x, y, z) {
            return x[y] != null ? x[y] : x[y] = z;
        }
        function ws_get_cell_stub(ws, R, C) {
            if (typeof R == "string") return ws[R] || (ws[R] = {
                "t": "z"
            });
            if (typeof R != "number") return ws_get_cell_stub(ws, encode_cell(R));
            return ws_get_cell_stub(ws, encode_cell({
                "r": R,
                "c": C || 0
            }));
        }
        function wb_sheet_idx(wb, sh) {
            if (typeof sh == "number") {
                if (sh >= 0 && wb.SheetNames.length > sh) return sh;
                throw new Error("Cannot find sheet # " + sh);
            } else if (typeof sh == "string") {
                var idx = wb.SheetNames.indexOf(sh);
                if (idx > -1) return idx;
                throw new Error("Cannot find sheet name |" + sh + "|");
            } else throw new Error("Cannot find sheet |" + sh + "|");
        }
        utils.book_new = function() {
            return {
                "SheetNames": [],
                "Sheets": {}
            };
        };
        utils.book_append_sheet = function(wb, ws, name) {
            if (!name) for (var i = 1; i <= 65535; ++i) if (wb.SheetNames.indexOf(name = "Sheet" + i) == -1) break;
            if (!name) throw new Error("Too many worksheets");
            check_ws_name(name);
            if (wb.SheetNames.indexOf(name) >= 0) throw new Error("Worksheet with name |" + name + "| already exists!");
            wb.SheetNames.push(name);
            wb.Sheets[name] = ws;
        };
        utils.book_set_sheet_visibility = function(wb, sh, vis) {
            get_default(wb, "Workbook", {});
            get_default(wb.Workbook, "Sheets", []);
            var idx = wb_sheet_idx(wb, sh);
            get_default(wb.Workbook.Sheets, idx, {});
            switch (vis) {
              case 0:
              case 1:
              case 2:
                break;

              default:
                throw new Error("Bad sheet visibility setting " + vis);
            }
            wb.Workbook.Sheets[idx].Hidden = vis;
        };
        add_consts([ [ "SHEET_VISIBLE", 0 ], [ "SHEET_HIDDEN", 1 ], [ "SHEET_VERY_HIDDEN", 2 ] ]);
        utils.cell_set_number_format = function(cell, fmt) {
            cell.z = fmt;
            return cell;
        };
        utils.cell_set_hyperlink = function(cell, target, tooltip) {
            if (!target) {
                delete cell.l;
            } else {
                cell.l = {
                    "Target": target
                };
                if (tooltip) cell.l.Tooltip = tooltip;
            }
            return cell;
        };
        utils.cell_set_internal_link = function(cell, range, tooltip) {
            return utils.cell_set_hyperlink(cell, "#" + range, tooltip);
        };
        utils.cell_add_comment = function(cell, text, author) {
            if (!cell.c) cell.c = [];
            cell.c.push({
                "t": text,
                "a": author || "SheetJS"
            });
        };
        utils.sheet_set_array_formula = function(ws, range, formula) {
            var rng = typeof range != "string" ? range : safe_decode_range(range);
            var rngstr = typeof range == "string" ? range : encode_range(range);
            for (var R = rng.s.r; R <= rng.e.r; ++R) for (var C = rng.s.c; C <= rng.e.c; ++C) {
                var cell = ws_get_cell_stub(ws, R, C);
                cell.t = "n";
                cell.F = rngstr;
                delete cell.v;
                if (R == rng.s.r && C == rng.s.c) cell.f = formula;
            }
            return ws;
        };
        return utils;
    })(utils);
    if (has_buf && typeof require != "undefined") (function() {
        var Readable = require("stream").Readable;
        var write_csv_stream = function(sheet, opts) {
            var stream = Readable();
            var o = opts == null ? {} : opts;
            if (sheet == null || sheet["!ref"] == null) {
                stream.push(null);
                return stream;
            }
            var r = safe_decode_range(sheet["!ref"]);
            var FS = o.FS !== undefined ? o.FS : ",", fs = FS.charCodeAt(0);
            var RS = o.RS !== undefined ? o.RS : "\n", rs = RS.charCodeAt(0);
            var endregex = new RegExp((FS == "|" ? "\\|" : FS) + "+$");
            var row = "", cols = [];
            o.dense = Array.isArray(sheet);
            var colinfo = o.skipHidden && sheet["!cols"] || [];
            var rowinfo = o.skipHidden && sheet["!rows"] || [];
            for (var C = r.s.c; C <= r.e.c; ++C) if (!(colinfo[C] || {}).hidden) cols[C] = encode_col(C);
            var R = r.s.r;
            var BOM = false;
            stream._read = function() {
                if (!BOM) {
                    BOM = true;
                    return stream.push("\ufeff");
                }
                if (R > r.e.r) return stream.push(null);
                while (R <= r.e.r) {
                    ++R;
                    if ((rowinfo[R - 1] || {}).hidden) continue;
                    row = make_csv_row(sheet, r, R - 1, cols, fs, rs, FS, o);
                    if (row != null) {
                        if (o.strip) row = row.replace(endregex, "");
                        stream.push(row + RS);
                        break;
                    }
                }
            };
            return stream;
        };
        var write_html_stream = function(ws, opts) {
            var stream = Readable();
            var o = opts || {};
            var header = o.header != null ? o.header : HTML_.BEGIN;
            var footer = o.footer != null ? o.footer : HTML_.END;
            stream.push(header);
            var r = decode_range(ws["!ref"]);
            o.dense = Array.isArray(ws);
            stream.push(HTML_._preamble(ws, r, o));
            var R = r.s.r;
            var end = false;
            stream._read = function() {
                if (R > r.e.r) {
                    if (!end) {
                        end = true;
                        stream.push("</table>" + footer);
                    }
                    return stream.push(null);
                }
                while (R <= r.e.r) {
                    stream.push(HTML_._row(ws, r, R, o));
                    ++R;
                    break;
                }
            };
            return stream;
        };
        var write_json_stream = function(sheet, opts) {
            var stream = Readable({
                "objectMode": true
            });
            if (sheet == null || sheet["!ref"] == null) {
                stream.push(null);
                return stream;
            }
            var val = {
                "t": "n",
                "v": 0
            }, header = 0, offset = 1, hdr = [], v = 0, vv = "";
            var r = {
                "s": {
                    "r": 0,
                    "c": 0
                },
                "e": {
                    "r": 0,
                    "c": 0
                }
            };
            var o = opts || {};
            var range = o.range != null ? o.range : sheet["!ref"];
            if (o.header === 1) header = 1; else if (o.header === "A") header = 2; else if (Array.isArray(o.header)) header = 3;
            switch (typeof range) {
              case "string":
                r = safe_decode_range(range);
                break;

              case "number":
                r = safe_decode_range(sheet["!ref"]);
                r.s.r = range;
                break;

              default:
                r = range;
            }
            if (header > 0) offset = 0;
            var rr = encode_row(r.s.r);
            var cols = [];
            var counter = 0;
            var dense = Array.isArray(sheet);
            var R = r.s.r, C = 0, CC = 0;
            if (dense && !sheet[R]) sheet[R] = [];
            for (C = r.s.c; C <= r.e.c; ++C) {
                cols[C] = encode_col(C);
                val = dense ? sheet[R][C] : sheet[cols[C] + rr];
                switch (header) {
                  case 1:
                    hdr[C] = C - r.s.c;
                    break;

                  case 2:
                    hdr[C] = cols[C];
                    break;

                  case 3:
                    hdr[C] = o.header[C - r.s.c];
                    break;

                  default:
                    if (val == null) val = {
                        "w": "__EMPTY",
                        "t": "s"
                    };
                    vv = v = format_cell(val, null, o);
                    counter = 0;
                    for (CC = 0; CC < hdr.length; ++CC) if (hdr[CC] == vv) vv = v + "_" + ++counter;
                    hdr[C] = vv;
                }
            }
            R = r.s.r + offset;
            stream._read = function() {
                if (R > r.e.r) return stream.push(null);
                while (R <= r.e.r) {
                    ++R;
                    var row = make_json_row(sheet, r, R, cols, header, hdr, dense, o);
                    if (row.isempty === false || (header === 1 ? o.blankrows !== false : !!o.blankrows)) {
                        stream.push(row.row);
                        break;
                    }
                }
            };
            return stream;
        };
        XLSX.stream = {
            "to_json": write_json_stream,
            "to_html": write_html_stream,
            "to_csv": write_csv_stream
        };
    })();
    XLSX.parse_xlscfb = parse_xlscfb;
    XLSX.parse_ods = parse_ods;
    XLSX.parse_fods = parse_fods;
    XLSX.write_ods = write_ods;
    XLSX.parse_zip = parse_zip;
    XLSX.read = readSync;
    XLSX.readFile = readFileSync;
    XLSX.readFileSync = readFileSync;
    XLSX.write = writeSync;
    XLSX.writeFile = writeFileSync;
    XLSX.writeFileSync = writeFileSync;
    XLSX.writeFileAsync = writeFileAsync;
    XLSX.utils = utils;
    XLSX.SSF = SSF;
    XLSX.CFB = CFB;
}

if (typeof exports !== "undefined") make_xlsx_lib(exports); else if (typeof module !== "undefined" && module.exports) make_xlsx_lib(module.exports); else if (typeof define === "function" && define.amd) define("xlsx", function() {
    if (!XLSX.version) make_xlsx_lib(XLSX);
    return XLSX;
}); else make_xlsx_lib(XLSX);

var XLS = XLSX, ODS = XLSX;

importScripts("shim.js");

importScripts("dist/cpexcel.js");

importScripts("jszip.js");

importScripts("xlsx.js");

postMessage({
    "t": "ready"
});

onmessage = function(evt) {
    var v;
    try {
        v = XLSX.read(evt.data.d, {
            "type": evt.data.b
        });
        postMessage({
            "t": "xlsx",
            "d": JSON.stringify(v)
        });
    } catch (e) {
        postMessage({
            "t": "e",
            "d": e.stack || e
        });
    }
};