(function($) {
    $.widget("ui.multiselect", {
        "_init": function() {
            this.element.hide();
            this.id = this.element.attr("id");
            this.container = $('<div class="ui-multiselect ui-helper-clearfix ui-widget"></div>').insertAfter(this.element);
            this.count = 0;
            this.selectedContainer = $('<div class="selected"></div>').appendTo(this.container);
            this.availableContainer = $('<div class="available"></div>').appendTo(this.container);
            this.selectedActions = $('<div class="actions ui-widget-header ui-helper-clearfix"><span class="count">0 ' + $.ui.multiselect.locale.itemsCount + '</span><a href="#" class="remove-all">' + $.ui.multiselect.locale.removeAll + "</a></div>").appendTo(this.selectedContainer);
            this.availableActions = $('<div class="actions ui-widget-header ui-helper-clearfix"><input type="text" class="search empty ui-widget-content ui-corner-all"/><a href="#" class="add-all">' + $.ui.multiselect.locale.addAll + "</a></div>").appendTo(this.availableContainer);
            this.selectedList = $('<ul class="selected connected-list"><li class="ui-helper-hidden-accessible"></li></ul>').bind("selectstart", function() {
                return false;
            }).appendTo(this.selectedContainer);
            this.availableList = $('<ul class="available connected-list"><li class="ui-helper-hidden-accessible"></li></ul>').bind("selectstart", function() {
                return false;
            }).appendTo(this.availableContainer);
            var that = this;
            this.container.width(this.element.width() + 1);
            this.selectedContainer.width(Math.floor(this.element.width() * this.options.dividerLocation));
            this.availableContainer.width(Math.floor(this.element.width() * (1 - this.options.dividerLocation)));
            this.selectedList.height(Math.max(this.element.height() - this.selectedActions.height(), 1));
            this.availableList.height(Math.max(this.element.height() - this.availableActions.height(), 1));
            if (!this.options.animated) {
                this.options.show = "show";
                this.options.hide = "hide";
            }
            this._populateLists(this.element.find("option"));
            if (this.options.sortable) {
                $("ul.selected").sortable({
                    "placeholder": "ui-state-highlight",
                    "axis": "y",
                    "update": function(event, ui) {
                        that.selectedList.find("li").each(function() {
                            if ($(this).data("optionLink")) $(this).data("optionLink").remove().appendTo(that.element);
                        });
                    },
                    "receive": function(event, ui) {
                        ui.item.data("optionLink").attr("selected", true);
                        that.count += 1;
                        that._updateCount();
                        that.selectedList.children(".ui-draggable").each(function() {
                            $(this).removeClass("ui-draggable");
                            $(this).data("optionLink", ui.item.data("optionLink"));
                            $(this).data("idx", ui.item.data("idx"));
                            that._applyItemState($(this), true);
                        });
                        setTimeout(function() {
                            ui.item.remove();
                        }, 1);
                    }
                });
            }
            if (this.options.searchable) {
                this._registerSearchEvents(this.availableContainer.find("input.search"));
            } else {
                $(".search").hide();
            }
            $(".remove-all").click(function() {
                that._populateLists(that.element.find("option").removeAttr("selected"));
                return false;
            });
            $(".add-all").click(function() {
                that._populateLists(that.element.find("option").attr("selected", "selected"));
                return false;
            });
        },
        "destroy": function() {
            this.element.show();
            this.container.remove();
            $.widget.prototype.destroy.apply(this, arguments);
        },
        "_populateLists": function(options) {
            this.selectedList.children(".ui-element").remove();
            this.availableList.children(".ui-element").remove();
            this.count = 0;
            var that = this;
            var items = $(options.map(function(i) {
                var item = that._getOptionNode(this).appendTo(this.selected ? that.selectedList : that.availableList).show();
                if (this.selected) that.count += 1;
                that._applyItemState(item, this.selected);
                item.data("idx", i);
                return item[0];
            }));
            this._updateCount();
        },
        "_updateCount": function() {
            this.selectedContainer.find("span.count").text(this.count + " " + $.ui.multiselect.locale.itemsCount);
        },
        "_getOptionNode": function(option) {
            option = $(option);
            var node = $('<li class="ui-state-default ui-element" title="' + option.text() + '"><span class="ui-icon"/>' + option.text() + '<a href="#" class="action"><span class="ui-corner-all ui-icon"/></a></li>').hide();
            node.data("optionLink", option);
            return node;
        },
        "_cloneWithData": function(clonee) {
            var clone = clonee.clone();
            clone.data("optionLink", clonee.data("optionLink"));
            clone.data("idx", clonee.data("idx"));
            return clone;
        },
        "_setSelected": function(item, selected) {
            item.data("optionLink").attr("selected", selected);
            if (selected) {
                var selectedItem = this._cloneWithData(item);
                item[this.options.hide](this.options.animated, function() {
                    $(this).remove();
                });
                selectedItem.appendTo(this.selectedList).hide()[this.options.show](this.options.animated);
                this._applyItemState(selectedItem, true);
                return selectedItem;
            } else {
                var items = this.availableList.find("li"), comparator = this.options.nodeComparator;
                var succ = null, i = item.data("idx"), direction = comparator(item, $(items[i]));
                if (direction) {
                    while (i >= 0 && i < items.length) {
                        direction > 0 ? i++ : i--;
                        if (direction != comparator(item, $(items[i]))) {
                            succ = items[direction > 0 ? i : i + 1];
                            break;
                        }
                    }
                } else {
                    succ = items[i];
                }
                var availableItem = this._cloneWithData(item);
                succ ? availableItem.insertBefore($(succ)) : availableItem.appendTo(this.availableList);
                item[this.options.hide](this.options.animated, function() {
                    $(this).remove();
                });
                availableItem.hide()[this.options.show](this.options.animated);
                this._applyItemState(availableItem, false);
                return availableItem;
            }
        },
        "_applyItemState": function(item, selected) {
            if (selected) {
                if (this.options.sortable) item.children("span").addClass("ui-icon-arrowthick-2-n-s").removeClass("ui-helper-hidden").addClass("ui-icon"); else item.children("span").removeClass("ui-icon-arrowthick-2-n-s").addClass("ui-helper-hidden").removeClass("ui-icon");
                item.find("a.action span").addClass("ui-icon-minus").removeClass("ui-icon-plus");
                this._registerRemoveEvents(item.find("a.action"));
            } else {
                item.children("span").removeClass("ui-icon-arrowthick-2-n-s").addClass("ui-helper-hidden").removeClass("ui-icon");
                item.find("a.action span").addClass("ui-icon-plus").removeClass("ui-icon-minus");
                this._registerAddEvents(item.find("a.action"));
            }
            this._registerHoverEvents(item);
        },
        "_filter": function(list) {
            var input = $(this);
            var rows = list.children("li"), cache = rows.map(function() {
                return $(this).text().toLowerCase();
            });
            var term = $.trim(input.val().toLowerCase()), scores = [];
            if (!term) {
                rows.show();
            } else {
                rows.hide();
                cache.each(function(i) {
                    if (this.indexOf(term) > -1) {
                        scores.push(i);
                    }
                });
                $.each(scores, function() {
                    $(rows[this]).show();
                });
            }
        },
        "_registerHoverEvents": function(elements) {
            elements.removeClass("ui-state-hover");
            elements.mouseover(function() {
                $(this).addClass("ui-state-hover");
            });
            elements.mouseout(function() {
                $(this).removeClass("ui-state-hover");
            });
        },
        "_registerAddEvents": function(elements) {
            var that = this;
            elements.click(function() {
                var item = that._setSelected($(this).parent(), true);
                that.count += 1;
                that._updateCount();
                return false;
            }).each(function() {
                $(this).parent().draggable({
                    "connectToSortable": "ul.selected",
                    "helper": function() {
                        var selectedItem = that._cloneWithData($(this)).width($(this).width() - 50);
                        selectedItem.width($(this).width());
                        return selectedItem;
                    },
                    "appendTo": ".ui-multiselect",
                    "containment": ".ui-multiselect",
                    "revert": "invalid"
                });
            });
        },
        "_registerRemoveEvents": function(elements) {
            var that = this;
            elements.click(function() {
                that._setSelected($(this).parent(), false);
                that.count -= 1;
                that._updateCount();
                return false;
            });
        },
        "_registerSearchEvents": function(input) {
            var that = this;
            input.focus(function() {
                $(this).addClass("ui-state-active");
            }).blur(function() {
                $(this).removeClass("ui-state-active");
            }).keypress(function(e) {
                if (e.keyCode == 13) return false;
            }).keyup(function() {
                that._filter.apply(this, [ that.availableList ]);
            });
        }
    });
    $.extend($.ui.multiselect, {
        "defaults": {
            "sortable": true,
            "searchable": true,
            "animated": "fast",
            "show": "slideDown",
            "hide": "slideUp",
            "dividerLocation": .6,
            "nodeComparator": function(node1, node2) {
                var text1 = node1.text(), text2 = node2.text();
                return text1 == text2 ? 0 : text1 < text2 ? -1 : 1;
            }
        },
        "locale": {
            "addAll": "Add all",
            "removeAll": "Remove all",
            "itemsCount": "items selected"
        }
    });
})(jQuery);

(function($) {
    $.jgrid = $.jgrid || {};
    $.extend($.jgrid, {
        "defaults": {
            "recordtext": "View {0} - {1} of {2}",
            "emptyrecords": "No records to view",
            "loadtext": "Loading...",
            "pgtext": "Page {0} of {1}"
        },
        "search": {
            "caption": "Search...",
            "Find": "Find",
            "Reset": "Reset",
            "odata": [ "equal", "not equal", "less", "less or equal", "greater", "greater or equal", "begins with", "does not begin with", "is in", "is not in", "ends with", "does not end with", "contains", "does not contain" ],
            "groupOps": [ {
                "op": "AND",
                "text": "all"
            }, {
                "op": "OR",
                "text": "any"
            } ],
            "matchText": " match",
            "rulesText": " rules"
        },
        "edit": {
            "addCaption": "Add Record",
            "editCaption": "Edit Record",
            "bSubmit": "Submit",
            "bCancel": "Cancel",
            "bClose": "Close",
            "saveData": "Data has been changed! Save changes?",
            "bYes": "Yes",
            "bNo": "No",
            "bExit": "Cancel",
            "msg": {
                "required": "Field is required",
                "number": "Please, enter valid number",
                "minValue": "value must be greater than or equal to ",
                "maxValue": "value must be less than or equal to",
                "email": "is not a valid e-mail",
                "integer": "Please, enter valid integer value",
                "date": "Please, enter valid date value",
                "url": "is not a valid URL. Prefix required ('http://' or 'https://')",
                "nodefined": " is not defined!",
                "novalue": " return value is required!",
                "customarray": "Custom function should return array!",
                "customfcheck": "Custom function should be present in case of custom checking!"
            }
        },
        "view": {
            "caption": "View Record",
            "bClose": "Close"
        },
        "del": {
            "caption": "Delete",
            "msg": "Delete selected record(s)?",
            "bSubmit": "Delete",
            "bCancel": "Cancel"
        },
        "nav": {
            "edittext": "",
            "edittitle": "Edit selected row",
            "addtext": "",
            "addtitle": "Add new row",
            "deltext": "",
            "deltitle": "Delete selected row",
            "searchtext": "",
            "searchtitle": "Find records",
            "refreshtext": "",
            "refreshtitle": "Reload Grid",
            "alertcap": "Warning",
            "alerttext": "Please, select row",
            "viewtext": "",
            "viewtitle": "View selected row"
        },
        "col": {
            "caption": "Select columns",
            "bSubmit": "Ok",
            "bCancel": "Cancel"
        },
        "errors": {
            "errcap": "Error",
            "nourl": "No url is set",
            "norecords": "No records to process",
            "model": "Length of colNames <> colModel!"
        },
        "formatter": {
            "integer": {
                "thousandsSeparator": ",",
                "defaultValue": "0"
            },
            "number": {
                "decimalSeparator": ".",
                "thousandsSeparator": ",",
                "decimalPlaces": 2,
                "defaultValue": "0.00"
            },
            "currency": {
                "decimalSeparator": ".",
                "thousandsSeparator": ",",
                "decimalPlaces": 2,
                "prefix": "",
                "suffix": "",
                "defaultValue": "0.00"
            },
            "date": {
                "dayNames": [ "Sun", "Mon", "Tue", "Wed", "Thr", "Fri", "Sat", "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ],
                "monthNames": [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec", "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ],
                "AmPm": [ "am", "pm", "AM", "PM" ],
                "S": function(j) {
                    return j < 11 || j > 13 ? [ "st", "nd", "rd", "th" ][Math.min((j - 1) % 10, 3)] : "th";
                },
                "srcformat": "Y-m-d",
                "newformat": "n/j/Y",
                "masks": {
                    "ISO8601Long": "Y-m-d H:i:s",
                    "ISO8601Short": "Y-m-d",
                    "ShortDate": "n/j/Y",
                    "LongDate": "l, F d, Y",
                    "FullDateTime": "l, F d, Y g:i:s A",
                    "MonthDay": "F d",
                    "ShortTime": "g:i A",
                    "LongTime": "g:i:s A",
                    "SortableDateTime": "Y-m-d\\TH:i:s",
                    "UniversalSortableDateTime": "Y-m-d H:i:sO",
                    "YearMonth": "F, Y"
                },
                "reformatAfterEdit": false
            },
            "baseLinkUrl": "",
            "showAction": "",
            "target": "",
            "checkbox": {
                "disabled": true
            },
            "idName": "id"
        }
    });
})(jQuery);

(function($) {
    "use strict";
    $.jgrid = $.jgrid || {};
    $.extend($.jgrid, {
        "version": "4.4.4",
        "htmlDecode": function(value) {
            if (value && (value == "&nbsp;" || value == "&#160;" || value.length === 1 && value.charCodeAt(0) === 160)) {
                return "";
            }
            return !value ? value : String(value).replace(/&gt;/g, ">").replace(/&lt;/g, "<").replace(/&quot;/g, '"').replace(/&amp;/g, "&");
        },
        "htmlEncode": function(value) {
            return !value ? value : String(value).replace(/&/g, "&amp;").replace(/\"/g, "&quot;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
        },
        "format": function(format) {
            var args = $.makeArray(arguments).slice(1);
            if (format == null) {
                format = "";
            }
            return format.replace(/\{(\d+)\}/g, function(m, i) {
                return args[i];
            });
        },
        "msie": navigator.appName == "Microsoft Internet Explorer",
        "msiever": function() {
            var rv = -1;
            var ua = navigator.userAgent;
            var re = new RegExp("MSIE ([0-9]{1,}[.0-9]{0,})");
            if (re.exec(ua) != null) {
                rv = parseFloat(RegExp.$1);
            }
            return rv;
        },
        "getCellIndex": function(cell) {
            var c = $(cell);
            if (c.is("tr")) {
                return -1;
            }
            c = (!c.is("td") && !c.is("th") ? c.closest("td,th") : c)[0];
            if ($.jgrid.msie) {
                return $.inArray(c, c.parentNode.cells);
            }
            return c.cellIndex;
        },
        "stripHtml": function(v) {
            v = String(v);
            var regexp = /<("[^"]*"|'[^']*'|[^'">])*>/gi;
            if (v) {
                v = v.replace(regexp, "");
                return v && v !== "&nbsp;" && v !== "&#160;" ? v.replace(/\"/g, "'") : "";
            }
            return v;
        },
        "stripPref": function(pref, id) {
            var obj = $.type(pref);
            if (obj == "string" || obj == "number") {
                pref = String(pref);
                id = pref !== "" ? String(id).replace(String(pref), "") : id;
            }
            return id;
        },
        "parse": function(jsonString) {
            var js = jsonString;
            if (js.substr(0, 9) == "while(1);") {
                js = js.substr(9);
            }
            if (js.substr(0, 2) == "/*") {
                js = js.substr(2, js.length - 4);
            }
            if (!js) {
                js = "{}";
            }
            return $.jgrid.useJSON === true && typeof JSON === "object" && typeof JSON.parse === "function" ? JSON.parse(js) : eval("(" + js + ")");
        },
        "parseDate": function(format, date) {
            var tsp = {
                "m": 1,
                "d": 1,
                "y": 1970,
                "h": 0,
                "i": 0,
                "s": 0,
                "u": 0
            }, k, hl, dM, regdate = /[\\\/:_;.,\t\s-]/;
            if (date && date != null) {
                date = $.trim(date);
                date = date.split(regdate);
                if ($.jgrid.formatter.date.masks[format] !== undefined) {
                    format = $.jgrid.formatter.date.masks[format];
                }
                format = format.split(regdate);
                var dfmt = $.jgrid.formatter.date.monthNames;
                var afmt = $.jgrid.formatter.date.AmPm;
                var h12to24 = function(ampm, h) {
                    if (ampm === 0) {
                        if (h === 12) {
                            h = 0;
                        }
                    } else {
                        if (h !== 12) {
                            h += 12;
                        }
                    }
                    return h;
                };
                for (k = 0, hl = format.length; k < hl; k++) {
                    if (format[k] == "M") {
                        dM = $.inArray(date[k], dfmt);
                        if (dM !== -1 && dM < 12) {
                            date[k] = dM + 1;
                            tsp.m = date[k];
                        }
                    }
                    if (format[k] == "F") {
                        dM = $.inArray(date[k], dfmt);
                        if (dM !== -1 && dM > 11) {
                            date[k] = dM + 1 - 12;
                            tsp.m = date[k];
                        }
                    }
                    if (format[k] == "a") {
                        dM = $.inArray(date[k], afmt);
                        if (dM !== -1 && dM < 2 && date[k] == afmt[dM]) {
                            date[k] = dM;
                            tsp.h = h12to24(date[k], tsp.h);
                        }
                    }
                    if (format[k] == "A") {
                        dM = $.inArray(date[k], afmt);
                        if (dM !== -1 && dM > 1 && date[k] == afmt[dM]) {
                            date[k] = dM - 2;
                            tsp.h = h12to24(date[k], tsp.h);
                        }
                    }
                    if (format[k] === "g") {
                        tsp.h = parseInt(date[k], 10);
                    }
                    if (date[k] !== undefined) {
                        tsp[format[k].toLowerCase()] = parseInt(date[k], 10);
                    }
                }
                tsp.m = parseInt(tsp.m, 10) - 1;
                var ty = tsp.y;
                if (ty >= 70 && ty <= 99) {
                    tsp.y = 1900 + tsp.y;
                } else if (ty >= 0 && ty <= 69) {
                    tsp.y = 2e3 + tsp.y;
                }
                if (tsp.j !== undefined) {
                    tsp.d = tsp.j;
                }
                if (tsp.n !== undefined) {
                    tsp.m = parseInt(tsp.n, 10) - 1;
                }
            }
            return new Date(tsp.y, tsp.m, tsp.d, tsp.h, tsp.i, tsp.s, tsp.u);
        },
        "jqID": function(sid) {
            return String(sid).replace(/[!"#$%&'()*+,.\/:; <=>?@\[\\\]\^`{|}~]/g, "\\$&");
        },
        "guid": 1,
        "uidPref": "jqg",
        "randId": function(prefix) {
            return (prefix || $.jgrid.uidPref) + $.jgrid.guid++;
        },
        "getAccessor": function(obj, expr) {
            var ret, p, prm = [], i;
            if (typeof expr === "function") {
                return expr(obj);
            }
            ret = obj[expr];
            if (ret === undefined) {
                try {
                    if (typeof expr === "string") {
                        prm = expr.split(".");
                    }
                    i = prm.length;
                    if (i) {
                        ret = obj;
                        while (ret && i--) {
                            p = prm.shift();
                            ret = ret[p];
                        }
                    }
                } catch (e) {}
            }
            return ret;
        },
        "getXmlData": function(obj, expr, returnObj) {
            var ret, m = typeof expr === "string" ? expr.match(/^(.*)\[(\w+)\]$/) : null;
            if (typeof expr === "function") {
                return expr(obj);
            }
            if (m && m[2]) {
                return m[1] ? $(m[1], obj).attr(m[2]) : $(obj).attr(m[2]);
            }
            ret = $(expr, obj);
            if (returnObj) {
                return ret;
            }
            return ret.length > 0 ? $(ret).text() : undefined;
        },
        "cellWidth": function() {
            var $testDiv = $("<div class='ui-jqgrid' style='left:10000px'><table class='ui-jqgrid-btable' style='width:5px;'><tr class='jqgrow'><td style='width:5px;'></td></tr></table></div>"), testCell = $testDiv.appendTo("body").find("td").width();
            $testDiv.remove();
            return testCell !== 5;
        },
        "cell_width": true,
        "ajaxOptions": {},
        "from": function(source) {
            var QueryObject = function(d, q) {
                if (typeof d === "string") {
                    d = $.data(d);
                }
                var self = this, _data = d, _usecase = true, _trim = false, _query = q, _stripNum = /[\$,%]/g, _lastCommand = null, _lastField = null, _orDepth = 0, _negate = false, _queuedOperator = "", _sorting = [], _useProperties = true;
                if (typeof d === "object" && d.push) {
                    if (d.length > 0) {
                        if (typeof d[0] !== "object") {
                            _useProperties = false;
                        } else {
                            _useProperties = true;
                        }
                    }
                } else {
                    throw "data provides is not an array";
                }
                this._hasData = function() {
                    return _data === null ? false : _data.length === 0 ? false : true;
                };
                this._getStr = function(s) {
                    var phrase = [];
                    if (_trim) {
                        phrase.push("jQuery.trim(");
                    }
                    phrase.push("String(" + s + ")");
                    if (_trim) {
                        phrase.push(")");
                    }
                    if (!_usecase) {
                        phrase.push(".toLowerCase()");
                    }
                    return phrase.join("");
                };
                this._strComp = function(val) {
                    if (typeof val === "string") {
                        return ".toString()";
                    }
                    return "";
                };
                this._group = function(f, u) {
                    return {
                        "field": f.toString(),
                        "unique": u,
                        "items": []
                    };
                };
                this._toStr = function(phrase) {
                    if (_trim) {
                        phrase = $.trim(phrase);
                    }
                    phrase = phrase.toString().replace(/\\/g, "\\\\").replace(/\"/g, '\\"');
                    return _usecase ? phrase : phrase.toLowerCase();
                };
                this._funcLoop = function(func) {
                    var results = [];
                    $.each(_data, function(i, v) {
                        results.push(func(v));
                    });
                    return results;
                };
                this._append = function(s) {
                    var i;
                    if (_query === null) {
                        _query = "";
                    } else {
                        _query += _queuedOperator === "" ? " && " : _queuedOperator;
                    }
                    for (i = 0; i < _orDepth; i++) {
                        _query += "(";
                    }
                    if (_negate) {
                        _query += "!";
                    }
                    _query += "(" + s + ")";
                    _negate = false;
                    _queuedOperator = "";
                    _orDepth = 0;
                };
                this._setCommand = function(f, c) {
                    _lastCommand = f;
                    _lastField = c;
                };
                this._resetNegate = function() {
                    _negate = false;
                };
                this._repeatCommand = function(f, v) {
                    if (_lastCommand === null) {
                        return self;
                    }
                    if (f !== null && v !== null) {
                        return _lastCommand(f, v);
                    }
                    if (_lastField === null) {
                        return _lastCommand(f);
                    }
                    if (!_useProperties) {
                        return _lastCommand(f);
                    }
                    return _lastCommand(_lastField, f);
                };
                this._equals = function(a, b) {
                    return self._compare(a, b, 1) === 0;
                };
                this._compare = function(a, b, d) {
                    var toString = Object.prototype.toString;
                    if (d === undefined) {
                        d = 1;
                    }
                    if (a === undefined) {
                        a = null;
                    }
                    if (b === undefined) {
                        b = null;
                    }
                    if (a === null && b === null) {
                        return 0;
                    }
                    if (a === null && b !== null) {
                        return 1;
                    }
                    if (a !== null && b === null) {
                        return -1;
                    }
                    if (toString.call(a) === "[object Date]" && toString.call(b) === "[object Date]") {
                        if (a < b) {
                            return -d;
                        }
                        if (a > b) {
                            return d;
                        }
                        return 0;
                    }
                    if (!_usecase && typeof a !== "number" && typeof b !== "number") {
                        a = String(a);
                        b = String(b);
                    }
                    if (a < b) {
                        return -d;
                    }
                    if (a > b) {
                        return d;
                    }
                    return 0;
                };
                this._performSort = function() {
                    if (_sorting.length === 0) {
                        return;
                    }
                    _data = self._doSort(_data, 0);
                };
                this._doSort = function(d, q) {
                    var by = _sorting[q].by, dir = _sorting[q].dir, type = _sorting[q].type, dfmt = _sorting[q].datefmt;
                    if (q == _sorting.length - 1) {
                        return self._getOrder(d, by, dir, type, dfmt);
                    }
                    q++;
                    var values = self._getGroup(d, by, dir, type, dfmt), results = [], i, j, sorted;
                    for (i = 0; i < values.length; i++) {
                        sorted = self._doSort(values[i].items, q);
                        for (j = 0; j < sorted.length; j++) {
                            results.push(sorted[j]);
                        }
                    }
                    return results;
                };
                this._getOrder = function(data, by, dir, type, dfmt) {
                    var sortData = [], _sortData = [], newDir = dir == "a" ? 1 : -1, i, ab, j, findSortKey;
                    if (type === undefined) {
                        type = "text";
                    }
                    if (type == "float" || type == "number" || type == "currency" || type == "numeric") {
                        findSortKey = function($cell) {
                            var key = parseFloat(String($cell).replace(_stripNum, ""));
                            return isNaN(key) ? 0 : key;
                        };
                    } else if (type == "int" || type == "integer") {
                        findSortKey = function($cell) {
                            return $cell ? parseFloat(String($cell).replace(_stripNum, "")) : 0;
                        };
                    } else if (type == "date" || type == "datetime") {
                        findSortKey = function($cell) {
                            return $.jgrid.parseDate(dfmt, $cell).getTime();
                        };
                    } else if ($.isFunction(type)) {
                        findSortKey = type;
                    } else {
                        findSortKey = function($cell) {
                            $cell = $cell ? $.trim(String($cell)) : "";
                            return _usecase ? $cell : $cell.toLowerCase();
                        };
                    }
                    $.each(data, function(i, v) {
                        ab = by !== "" ? $.jgrid.getAccessor(v, by) : v;
                        if (ab === undefined) {
                            ab = "";
                        }
                        ab = findSortKey(ab, v);
                        _sortData.push({
                            "vSort": ab,
                            "index": i
                        });
                    });
                    _sortData.sort(function(a, b) {
                        a = a.vSort;
                        b = b.vSort;
                        return self._compare(a, b, newDir);
                    });
                    j = 0;
                    var nrec = data.length;
                    while (j < nrec) {
                        i = _sortData[j].index;
                        sortData.push(data[i]);
                        j++;
                    }
                    return sortData;
                };
                this._getGroup = function(data, by, dir, type, dfmt) {
                    var results = [], group = null, last = null, val;
                    $.each(self._getOrder(data, by, dir, type, dfmt), function(i, v) {
                        val = $.jgrid.getAccessor(v, by);
                        if (val == null) {
                            val = "";
                        }
                        if (!self._equals(last, val)) {
                            last = val;
                            if (group !== null) {
                                results.push(group);
                            }
                            group = self._group(by, val);
                        }
                        group.items.push(v);
                    });
                    if (group !== null) {
                        results.push(group);
                    }
                    return results;
                };
                this.ignoreCase = function() {
                    _usecase = false;
                    return self;
                };
                this.useCase = function() {
                    _usecase = true;
                    return self;
                };
                this.trim = function() {
                    _trim = true;
                    return self;
                };
                this.noTrim = function() {
                    _trim = false;
                    return self;
                };
                this.execute = function() {
                    var match = _query, results = [];
                    if (match === null) {
                        return self;
                    }
                    $.each(_data, function() {
                        if (eval(match)) {
                            results.push(this);
                        }
                    });
                    _data = results;
                    return self;
                };
                this.data = function() {
                    return _data;
                };
                this.select = function(f) {
                    self._performSort();
                    if (!self._hasData()) {
                        return [];
                    }
                    self.execute();
                    if ($.isFunction(f)) {
                        var results = [];
                        $.each(_data, function(i, v) {
                            results.push(f(v));
                        });
                        return results;
                    }
                    return _data;
                };
                this.hasMatch = function() {
                    if (!self._hasData()) {
                        return false;
                    }
                    self.execute();
                    return _data.length > 0;
                };
                this.andNot = function(f, v, x) {
                    _negate = !_negate;
                    return self.and(f, v, x);
                };
                this.orNot = function(f, v, x) {
                    _negate = !_negate;
                    return self.or(f, v, x);
                };
                this.not = function(f, v, x) {
                    return self.andNot(f, v, x);
                };
                this.and = function(f, v, x) {
                    _queuedOperator = " && ";
                    if (f === undefined) {
                        return self;
                    }
                    return self._repeatCommand(f, v, x);
                };
                this.or = function(f, v, x) {
                    _queuedOperator = " || ";
                    if (f === undefined) {
                        return self;
                    }
                    return self._repeatCommand(f, v, x);
                };
                this.orBegin = function() {
                    _orDepth++;
                    return self;
                };
                this.orEnd = function() {
                    if (_query !== null) {
                        _query += ")";
                    }
                    return self;
                };
                this.isNot = function(f) {
                    _negate = !_negate;
                    return self.is(f);
                };
                this.is = function(f) {
                    self._append("this." + f);
                    self._resetNegate();
                    return self;
                };
                this._compareValues = function(func, f, v, how, t) {
                    var fld;
                    if (_useProperties) {
                        fld = "jQuery.jgrid.getAccessor(this,'" + f + "')";
                    } else {
                        fld = "this";
                    }
                    if (v === undefined) {
                        v = null;
                    }
                    var val = v, swst = t.stype === undefined ? "text" : t.stype;
                    if (v !== null) {
                        switch (swst) {
                          case "int":
                          case "integer":
                            val = isNaN(Number(val)) || val === "" ? "0" : val;
                            fld = "parseInt(" + fld + ",10)";
                            val = "parseInt(" + val + ",10)";
                            break;

                          case "float":
                          case "number":
                          case "numeric":
                            val = String(val).replace(_stripNum, "");
                            val = isNaN(Number(val)) || val === "" ? "0" : val;
                            fld = "parseFloat(" + fld + ")";
                            val = "parseFloat(" + val + ")";
                            break;

                          case "date":
                          case "datetime":
                            val = String($.jgrid.parseDate(t.newfmt || "Y-m-d", val).getTime());
                            fld = 'jQuery.jgrid.parseDate("' + t.srcfmt + '",' + fld + ").getTime()";
                            break;

                          default:
                            fld = self._getStr(fld);
                            val = self._getStr('"' + self._toStr(val) + '"');
                        }
                    }
                    self._append(fld + " " + how + " " + val);
                    self._setCommand(func, f);
                    self._resetNegate();
                    return self;
                };
                this.equals = function(f, v, t) {
                    return self._compareValues(self.equals, f, v, "==", t);
                };
                this.notEquals = function(f, v, t) {
                    return self._compareValues(self.equals, f, v, "!==", t);
                };
                this.isNull = function(f, v, t) {
                    return self._compareValues(self.equals, f, null, "===", t);
                };
                this.greater = function(f, v, t) {
                    return self._compareValues(self.greater, f, v, ">", t);
                };
                this.less = function(f, v, t) {
                    return self._compareValues(self.less, f, v, "<", t);
                };
                this.greaterOrEquals = function(f, v, t) {
                    return self._compareValues(self.greaterOrEquals, f, v, ">=", t);
                };
                this.lessOrEquals = function(f, v, t) {
                    return self._compareValues(self.lessOrEquals, f, v, "<=", t);
                };
                this.startsWith = function(f, v) {
                    var val = v == null ? f : v, length = _trim ? $.trim(val.toString()).length : val.toString().length;
                    if (_useProperties) {
                        self._append(self._getStr("jQuery.jgrid.getAccessor(this,'" + f + "')") + ".substr(0," + length + ") == " + self._getStr('"' + self._toStr(v) + '"'));
                    } else {
                        length = _trim ? $.trim(v.toString()).length : v.toString().length;
                        self._append(self._getStr("this") + ".substr(0," + length + ") == " + self._getStr('"' + self._toStr(f) + '"'));
                    }
                    self._setCommand(self.startsWith, f);
                    self._resetNegate();
                    return self;
                };
                this.endsWith = function(f, v) {
                    var val = v == null ? f : v, length = _trim ? $.trim(val.toString()).length : val.toString().length;
                    if (_useProperties) {
                        self._append(self._getStr("jQuery.jgrid.getAccessor(this,'" + f + "')") + ".substr(" + self._getStr("jQuery.jgrid.getAccessor(this,'" + f + "')") + ".length-" + length + "," + length + ') == "' + self._toStr(v) + '"');
                    } else {
                        self._append(self._getStr("this") + ".substr(" + self._getStr("this") + '.length-"' + self._toStr(f) + '".length,"' + self._toStr(f) + '".length) == "' + self._toStr(f) + '"');
                    }
                    self._setCommand(self.endsWith, f);
                    self._resetNegate();
                    return self;
                };
                this.contains = function(f, v) {
                    if (_useProperties) {
                        self._append(self._getStr("jQuery.jgrid.getAccessor(this,'" + f + "')") + '.indexOf("' + self._toStr(v) + '",0) > -1');
                    } else {
                        self._append(self._getStr("this") + '.indexOf("' + self._toStr(f) + '",0) > -1');
                    }
                    self._setCommand(self.contains, f);
                    self._resetNegate();
                    return self;
                };
                this.groupBy = function(by, dir, type, datefmt) {
                    if (!self._hasData()) {
                        return null;
                    }
                    return self._getGroup(_data, by, dir, type, datefmt);
                };
                this.orderBy = function(by, dir, stype, dfmt) {
                    dir = dir == null ? "a" : $.trim(dir.toString().toLowerCase());
                    if (stype == null) {
                        stype = "text";
                    }
                    if (dfmt == null) {
                        dfmt = "Y-m-d";
                    }
                    if (dir == "desc" || dir == "descending") {
                        dir = "d";
                    }
                    if (dir == "asc" || dir == "ascending") {
                        dir = "a";
                    }
                    _sorting.push({
                        "by": by,
                        "dir": dir,
                        "type": stype,
                        "datefmt": dfmt
                    });
                    return self;
                };
                return self;
            };
            return new QueryObject(source, null);
        },
        "getMethod": function(name) {
            return this.getAccessor($.fn.jqGrid, name);
        },
        "extend": function(methods) {
            $.extend($.fn.jqGrid, methods);
            if (!this.no_legacy_api) {
                $.fn.extend(methods);
            }
        }
    });
    $.fn.jqGrid = function(pin) {
        if (typeof pin === "string") {
            var fn = $.jgrid.getMethod(pin);
            if (!fn) {
                throw "jqGrid - No such method: " + pin;
            }
            var args = $.makeArray(arguments).slice(1);
            return fn.apply(this, args);
        }
        return this.each(function() {
            if (this.grid) {
                return;
            }
            var p = $.extend(true, {
                "url": "",
                "height": 150,
                "page": 1,
                "rowNum": 20,
                "rowTotal": null,
                "records": 0,
                "pager": "",
                "pgbuttons": true,
                "pginput": true,
                "colModel": [],
                "rowList": [],
                "colNames": [],
                "sortorder": "asc",
                "sortname": "",
                "datatype": "xml",
                "mtype": "GET",
                "altRows": false,
                "selarrrow": [],
                "savedRow": [],
                "shrinkToFit": true,
                "xmlReader": {},
                "jsonReader": {},
                "subGrid": false,
                "subGridModel": [],
                "reccount": 0,
                "lastpage": 0,
                "lastsort": 0,
                "selrow": null,
                "beforeSelectRow": null,
                "onSelectRow": null,
                "onSortCol": null,
                "ondblClickRow": null,
                "onRightClickRow": null,
                "onPaging": null,
                "onSelectAll": null,
                "onInitGrid": null,
                "loadComplete": null,
                "gridComplete": null,
                "loadError": null,
                "loadBeforeSend": null,
                "afterInsertRow": null,
                "beforeRequest": null,
                "beforeProcessing": null,
                "onHeaderClick": null,
                "viewrecords": false,
                "loadonce": false,
                "multiselect": false,
                "multikey": false,
                "editurl": null,
                "search": false,
                "caption": "",
                "hidegrid": true,
                "hiddengrid": false,
                "postData": {},
                "userData": {},
                "treeGrid": false,
                "treeGridModel": "nested",
                "treeReader": {},
                "treeANode": -1,
                "ExpandColumn": null,
                "tree_root_level": 0,
                "prmNames": {
                    "page": "page",
                    "rows": "rows",
                    "sort": "sidx",
                    "order": "sord",
                    "search": "_search",
                    "nd": "nd",
                    "id": "id",
                    "oper": "oper",
                    "editoper": "edit",
                    "addoper": "add",
                    "deloper": "del",
                    "subgridid": "id",
                    "npage": null,
                    "totalrows": "totalrows"
                },
                "forceFit": false,
                "gridstate": "visible",
                "cellEdit": false,
                "cellsubmit": "remote",
                "nv": 0,
                "loadui": "enable",
                "toolbar": [ false, "" ],
                "scroll": false,
                "multiboxonly": false,
                "deselectAfterSort": true,
                "scrollrows": false,
                "autowidth": false,
                "scrollOffset": 18,
                "cellLayout": 5,
                "subGridWidth": 20,
                "multiselectWidth": 20,
                "gridview": false,
                "rownumWidth": 25,
                "rownumbers": false,
                "pagerpos": "center",
                "recordpos": "right",
                "footerrow": false,
                "userDataOnFooter": false,
                "hoverrows": true,
                "altclass": "ui-priority-secondary",
                "viewsortcols": [ false, "vertical", true ],
                "resizeclass": "",
                "autoencode": false,
                "remapColumns": [],
                "ajaxGridOptions": {},
                "direction": "ltr",
                "toppager": false,
                "headertitles": false,
                "scrollTimeout": 40,
                "data": [],
                "_index": {},
                "grouping": false,
                "groupingView": {
                    "groupField": [],
                    "groupOrder": [],
                    "groupText": [],
                    "groupColumnShow": [],
                    "groupSummary": [],
                    "showSummaryOnHide": false,
                    "sortitems": [],
                    "sortnames": [],
                    "summary": [],
                    "summaryval": [],
                    "plusicon": "ui-icon-circlesmall-plus",
                    "minusicon": "ui-icon-circlesmall-minus",
                    "displayField": []
                },
                "ignoreCase": false,
                "cmTemplate": {},
                "idPrefix": ""
            }, $.jgrid.defaults, pin || {});
            var ts = this, grid = {
                "headers": [],
                "cols": [],
                "footers": [],
                "dragStart": function(i, x, y) {
                    this.resizing = {
                        "idx": i,
                        "startX": x.clientX,
                        "sOL": y[0]
                    };
                    this.hDiv.style.cursor = "col-resize";
                    this.curGbox = $("#rs_m" + $.jgrid.jqID(p.id), "#gbox_" + $.jgrid.jqID(p.id));
                    this.curGbox.css({
                        "display": "block",
                        "left": y[0],
                        "top": y[1],
                        "height": y[2]
                    });
                    $(ts).triggerHandler("jqGridResizeStart", [ x, i ]);
                    if ($.isFunction(p.resizeStart)) {
                        p.resizeStart.call(this, x, i);
                    }
                    document.onselectstart = function() {
                        return false;
                    };
                },
                "dragMove": function(x) {
                    if (this.resizing) {
                        var diff = x.clientX - this.resizing.startX, h = this.headers[this.resizing.idx], newWidth = p.direction === "ltr" ? h.width + diff : h.width - diff, hn, nWn;
                        if (newWidth > 33) {
                            this.curGbox.css({
                                "left": this.resizing.sOL + diff
                            });
                            if (p.forceFit === true) {
                                hn = this.headers[this.resizing.idx + p.nv];
                                nWn = p.direction === "ltr" ? hn.width - diff : hn.width + diff;
                                if (nWn > 33) {
                                    h.newWidth = newWidth;
                                    hn.newWidth = nWn;
                                }
                            } else {
                                this.newWidth = p.direction === "ltr" ? p.tblwidth + diff : p.tblwidth - diff;
                                h.newWidth = newWidth;
                            }
                        }
                    }
                },
                "dragEnd": function() {
                    this.hDiv.style.cursor = "default";
                    if (this.resizing) {
                        var idx = this.resizing.idx, nw = this.headers[idx].newWidth || this.headers[idx].width;
                        nw = parseInt(nw, 10);
                        this.resizing = false;
                        $("#rs_m" + $.jgrid.jqID(p.id)).css("display", "none");
                        p.colModel[idx].width = nw;
                        this.headers[idx].width = nw;
                        this.headers[idx].el.style.width = nw + "px";
                        this.cols[idx].style.width = nw + "px";
                        if (this.footers.length > 0) {
                            this.footers[idx].style.width = nw + "px";
                        }
                        if (p.forceFit === true) {
                            nw = this.headers[idx + p.nv].newWidth || this.headers[idx + p.nv].width;
                            this.headers[idx + p.nv].width = nw;
                            this.headers[idx + p.nv].el.style.width = nw + "px";
                            this.cols[idx + p.nv].style.width = nw + "px";
                            if (this.footers.length > 0) {
                                this.footers[idx + p.nv].style.width = nw + "px";
                            }
                            p.colModel[idx + p.nv].width = nw;
                        } else {
                            p.tblwidth = this.newWidth || p.tblwidth;
                            $("table:first", this.bDiv).css("width", p.tblwidth + "px");
                            $("table:first", this.hDiv).css("width", p.tblwidth + "px");
                            this.hDiv.scrollLeft = this.bDiv.scrollLeft;
                            if (p.footerrow) {
                                $("table:first", this.sDiv).css("width", p.tblwidth + "px");
                                this.sDiv.scrollLeft = this.bDiv.scrollLeft;
                            }
                        }
                        $(ts).triggerHandler("jqGridResizeStop", [ nw, idx ]);
                        if ($.isFunction(p.resizeStop)) {
                            p.resizeStop.call(this, nw, idx);
                        }
                    }
                    this.curGbox = null;
                    document.onselectstart = function() {
                        return true;
                    };
                },
                "populateVisible": function() {
                    if (grid.timer) {
                        clearTimeout(grid.timer);
                    }
                    grid.timer = null;
                    var dh = $(grid.bDiv).height();
                    if (!dh) {
                        return;
                    }
                    var table = $("table:first", grid.bDiv);
                    var rows, rh;
                    if (table[0].rows.length) {
                        try {
                            rows = table[0].rows[1];
                            rh = rows ? $(rows).outerHeight() || grid.prevRowHeight : grid.prevRowHeight;
                        } catch (pv) {
                            rh = grid.prevRowHeight;
                        }
                    }
                    if (!rh) {
                        return;
                    }
                    grid.prevRowHeight = rh;
                    var rn = p.rowNum;
                    var scrollTop = grid.scrollTop = grid.bDiv.scrollTop;
                    var ttop = Math.round(table.position().top) - scrollTop;
                    var tbot = ttop + table.height();
                    var div = rh * rn;
                    var page, npage, empty;
                    if (tbot < dh && ttop <= 0 && (p.lastpage === undefined || parseInt((tbot + scrollTop + div - 1) / div, 10) <= p.lastpage)) {
                        npage = parseInt((dh - tbot + div - 1) / div, 10);
                        if (tbot >= 0 || npage < 2 || p.scroll === true) {
                            page = Math.round((tbot + scrollTop) / div) + 1;
                            ttop = -1;
                        } else {
                            ttop = 1;
                        }
                    }
                    if (ttop > 0) {
                        page = parseInt(scrollTop / div, 10) + 1;
                        npage = parseInt((scrollTop + dh) / div, 10) + 2 - page;
                        empty = true;
                    }
                    if (npage) {
                        if (p.lastpage && (page > p.lastpage || p.lastpage == 1 || page === p.page && page === p.lastpage)) {
                            return;
                        }
                        if (grid.hDiv.loading) {
                            grid.timer = setTimeout(grid.populateVisible, p.scrollTimeout);
                        } else {
                            p.page = page;
                            if (empty) {
                                grid.selectionPreserver(table[0]);
                                grid.emptyRows.call(table[0], false, false);
                            }
                            grid.populate(npage);
                        }
                    }
                },
                "scrollGrid": function(e) {
                    if (p.scroll) {
                        var scrollTop = grid.bDiv.scrollTop;
                        if (grid.scrollTop === undefined) {
                            grid.scrollTop = 0;
                        }
                        if (scrollTop != grid.scrollTop) {
                            grid.scrollTop = scrollTop;
                            if (grid.timer) {
                                clearTimeout(grid.timer);
                            }
                            grid.timer = setTimeout(grid.populateVisible, p.scrollTimeout);
                        }
                    }
                    grid.hDiv.scrollLeft = grid.bDiv.scrollLeft;
                    if (p.footerrow) {
                        grid.sDiv.scrollLeft = grid.bDiv.scrollLeft;
                    }
                    if (e) {
                        e.stopPropagation();
                    }
                },
                "selectionPreserver": function(ts) {
                    var p = ts.p, sr = p.selrow, sra = p.selarrrow ? $.makeArray(p.selarrrow) : null, left = ts.grid.bDiv.scrollLeft, restoreSelection = function() {
                        var i;
                        p.selrow = null;
                        p.selarrrow = [];
                        if (p.multiselect && sra && sra.length > 0) {
                            for (i = 0; i < sra.length; i++) {
                                if (sra[i] != sr) {
                                    $(ts).jqGrid("setSelection", sra[i], false, null);
                                }
                            }
                        }
                        if (sr) {
                            $(ts).jqGrid("setSelection", sr, false, null);
                        }
                        ts.grid.bDiv.scrollLeft = left;
                        $(ts).unbind(".selectionPreserver", restoreSelection);
                    };
                    $(ts).bind("jqGridGridComplete.selectionPreserver", restoreSelection);
                }
            };
            if (this.tagName.toUpperCase() != "TABLE") {
                alert("Element is not a table");
                return;
            }
            if (document.documentMode !== undefined) {
                if (document.documentMode <= 5) {
                    alert("Grid can not be used in this ('quirks') mode!");
                    return;
                }
            }
            $(this).empty().attr("tabindex", "0");
            this.p = p;
            this.p.useProp = !!$.fn.prop;
            var i, dir;
            if (this.p.colNames.length === 0) {
                for (i = 0; i < this.p.colModel.length; i++) {
                    this.p.colNames[i] = this.p.colModel[i].label || this.p.colModel[i].name;
                }
            }
            if (this.p.colNames.length !== this.p.colModel.length) {
                alert($.jgrid.errors.model);
                return;
            }
            var gv = $("<div class='ui-jqgrid-view'></div>"), isMSIE = $.jgrid.msie;
            ts.p.direction = $.trim(ts.p.direction.toLowerCase());
            if ($.inArray(ts.p.direction, [ "ltr", "rtl" ]) == -1) {
                ts.p.direction = "ltr";
            }
            dir = ts.p.direction;
            $(gv).insertBefore(this);
            $(this).removeClass("scroll").appendTo(gv);
            var eg = $("<div class='ui-jqgrid ui-widget ui-widget-content ui-corner-all'></div>");
            $(eg).attr({
                "id": "gbox_" + this.id,
                "dir": dir
            }).insertBefore(gv);
            $(gv).attr("id", "gview_" + this.id).appendTo(eg);
            $("<div class='ui-widget-overlay jqgrid-overlay' id='lui_" + this.id + "'></div>").insertBefore(gv);
            $("<div class='loading ui-state-default ui-state-active' id='load_" + this.id + "'>" + this.p.loadtext + "</div>").insertBefore(gv);
            $(this).attr({
                "cellspacing": "0",
                "cellpadding": "0",
                "border": "0",
                "role": "grid",
                "aria-multiselectable": !!this.p.multiselect,
                "aria-labelledby": "gbox_" + this.id
            });
            var sortkeys = [ "shiftKey", "altKey", "ctrlKey" ], intNum = function(val, defval) {
                val = parseInt(val, 10);
                if (isNaN(val)) {
                    return defval || 0;
                }
                return val;
            }, formatCol = function(pos, rowInd, tv, rawObject, rowId, rdata) {
                var cm = ts.p.colModel[pos], ral = cm.align, result = 'style="', clas = cm.classes, nm = cm.name, celp, acp = [];
                if (ral) {
                    result += "text-align:" + ral + ";";
                }
                if (cm.hidden === true) {
                    result += "display:none;";
                }
                if (rowInd === 0) {
                    result += "width: " + grid.headers[pos].width + "px;";
                } else if (cm.cellattr && $.isFunction(cm.cellattr)) {
                    celp = cm.cellattr.call(ts, rowId, tv, rawObject, cm, rdata);
                    if (celp && typeof celp === "string") {
                        celp = celp.replace(/style/i, "style").replace(/title/i, "title");
                        if (celp.indexOf("title") > -1) {
                            cm.title = false;
                        }
                        if (celp.indexOf("class") > -1) {
                            clas = undefined;
                        }
                        acp = celp.split("style");
                        if (acp.length === 2) {
                            acp[1] = $.trim(acp[1].replace("=", ""));
                            if (acp[1].indexOf("'") === 0 || acp[1].indexOf('"') === 0) {
                                acp[1] = acp[1].substring(1);
                            }
                            result += acp[1].replace(/'/gi, '"');
                        } else {
                            result += '"';
                        }
                    }
                }
                if (!acp.length) {
                    acp[0] = "";
                    result += '"';
                }
                result += (clas !== undefined ? ' class="' + clas + '"' : "") + (cm.title && tv ? ' title="' + $.jgrid.stripHtml(tv) + '"' : "");
                result += ' aria-describedby="' + ts.p.id + "_" + nm + '"';
                return result + acp[0];
            }, cellVal = function(val) {
                return val == null || val === "" ? "&#160;" : ts.p.autoencode ? $.jgrid.htmlEncode(val) : String(val);
            }, formatter = function(rowId, cellval, colpos, rwdat, _act) {
                var cm = ts.p.colModel[colpos], v;
                if (cm.formatter !== undefined) {
                    rowId = String(ts.p.idPrefix) !== "" ? $.jgrid.stripPref(ts.p.idPrefix, rowId) : rowId;
                    var opts = {
                        "rowId": rowId,
                        "colModel": cm,
                        "gid": ts.p.id,
                        "pos": colpos
                    };
                    if ($.isFunction(cm.formatter)) {
                        v = cm.formatter.call(ts, cellval, opts, rwdat, _act);
                    } else if ($.fmatter) {
                        v = $.fn.fmatter.call(ts, cm.formatter, cellval, opts, rwdat, _act);
                    } else {
                        v = cellVal(cellval);
                    }
                } else {
                    v = cellVal(cellval);
                }
                return v;
            }, addCell = function(rowId, cell, pos, irow, srvr, rdata) {
                var v, prp;
                v = formatter(rowId, cell, pos, srvr, "add");
                prp = formatCol(pos, irow, v, srvr, rowId, rdata);
                return '<td role="gridcell" ' + prp + ">" + v + "</td>";
            }, addMulti = function(rowid, pos, irow, checked) {
                var v = '<input role="checkbox" type="checkbox"' + ' id="jqg_' + ts.p.id + "_" + rowid + '" class="cbox" name="jqg_' + ts.p.id + "_" + rowid + '"' + (checked ? 'checked="checked"' : "") + "/>", prp = formatCol(pos, irow, "", null, rowid, true);
                return '<td role="gridcell" ' + prp + ">" + v + "</td>";
            }, addRowNum = function(pos, irow, pG, rN) {
                var v = (parseInt(pG, 10) - 1) * parseInt(rN, 10) + 1 + irow, prp = formatCol(pos, irow, v, null, irow, true);
                return '<td role="gridcell" class="ui-state-default jqgrid-rownum" ' + prp + ">" + v + "</td>";
            }, reader = function(datatype) {
                var field, f = [], j = 0, i;
                for (i = 0; i < ts.p.colModel.length; i++) {
                    field = ts.p.colModel[i];
                    if (field.name !== "cb" && field.name !== "subgrid" && field.name !== "rn") {
                        f[j] = datatype == "local" ? field.name : datatype == "xml" || datatype === "xmlstring" ? field.xmlmap || field.name : field.jsonmap || field.name;
                        j++;
                    }
                }
                return f;
            }, orderedCols = function(offset) {
                var order = ts.p.remapColumns;
                if (!order || !order.length) {
                    order = $.map(ts.p.colModel, function(v, i) {
                        return i;
                    });
                }
                if (offset) {
                    order = $.map(order, function(v) {
                        return v < offset ? null : v - offset;
                    });
                }
                return order;
            }, emptyRows = function(scroll, locdata) {
                var firstrow;
                if (this.p.deepempty) {
                    $(this.rows).slice(1).remove();
                } else {
                    firstrow = this.rows.length > 0 ? this.rows[0] : null;
                    $(this.firstChild).empty().append(firstrow);
                }
                if (scroll && this.p.scroll) {
                    $(this.grid.bDiv.firstChild).css({
                        "height": "auto"
                    });
                    $(this.grid.bDiv.firstChild.firstChild).css({
                        "height": 0,
                        "display": "none"
                    });
                    if (this.grid.bDiv.scrollTop !== 0) {
                        this.grid.bDiv.scrollTop = 0;
                    }
                }
                if (locdata === true && this.p.treeGrid) {
                    this.p.data = [];
                    this.p._index = {};
                }
            }, refreshIndex = function() {
                var datalen = ts.p.data.length, idname, i, val, ni = ts.p.rownumbers === true ? 1 : 0, gi = ts.p.multiselect === true ? 1 : 0, si = ts.p.subGrid === true ? 1 : 0;
                if (ts.p.keyIndex === false || ts.p.loadonce === true) {
                    idname = ts.p.localReader.id;
                } else {
                    idname = ts.p.colModel[ts.p.keyIndex + gi + si + ni].name;
                }
                for (i = 0; i < datalen; i++) {
                    val = $.jgrid.getAccessor(ts.p.data[i], idname);
                    if (val === undefined) {
                        val = String(i + 1);
                    }
                    ts.p._index[val] = i;
                }
            }, constructTr = function(id, hide, altClass, rd, cur, selected) {
                var tabindex = "-1", restAttr = "", attrName, style = hide ? "display:none;" : "", classes = "ui-widget-content jqgrow ui-row-" + ts.p.direction + (altClass ? " " + altClass : "") + (selected ? " ui-state-highlight" : ""), rowAttrObj = $(ts).triggerHandler("jqGridRowAttr", [ rd, cur, id ]);
                if (typeof rowAttrObj !== "object") {
                    rowAttrObj = $.isFunction(ts.p.rowattr) ? ts.p.rowattr.call(ts, rd, cur, id) : {};
                }
                if (!$.isEmptyObject(rowAttrObj)) {
                    if (rowAttrObj.hasOwnProperty("id")) {
                        id = rowAttrObj.id;
                        delete rowAttrObj.id;
                    }
                    if (rowAttrObj.hasOwnProperty("tabindex")) {
                        tabindex = rowAttrObj.tabindex;
                        delete rowAttrObj.tabindex;
                    }
                    if (rowAttrObj.hasOwnProperty("style")) {
                        style += rowAttrObj.style;
                        delete rowAttrObj.style;
                    }
                    if (rowAttrObj.hasOwnProperty("class")) {
                        classes += " " + rowAttrObj["class"];
                        delete rowAttrObj["class"];
                    }
                    try {
                        delete rowAttrObj.role;
                    } catch (ra) {}
                    for (attrName in rowAttrObj) {
                        if (rowAttrObj.hasOwnProperty(attrName)) {
                            restAttr += " " + attrName + "=" + rowAttrObj[attrName];
                        }
                    }
                }
                return '<tr role="row" id="' + id + '" tabindex="' + tabindex + '" class="' + classes + '"' + (style === "" ? "" : ' style="' + style + '"') + restAttr + ">";
            }, addXmlData = function(xml, t, rcnt, more, adjust) {
                var startReq = new Date(), locdata = ts.p.datatype != "local" && ts.p.loadonce || ts.p.datatype == "xmlstring", xmlid = "_id_", xmlRd = ts.p.xmlReader, frd = ts.p.datatype == "local" ? "local" : "xml";
                if (locdata) {
                    ts.p.data = [];
                    ts.p._index = {};
                    ts.p.localReader.id = xmlid;
                }
                ts.p.reccount = 0;
                if ($.isXMLDoc(xml)) {
                    if (ts.p.treeANode === -1 && !ts.p.scroll) {
                        emptyRows.call(ts, false, true);
                        rcnt = 1;
                    } else {
                        rcnt = rcnt > 1 ? rcnt : 1;
                    }
                } else {
                    return;
                }
                var self = $(ts), i, fpos, ir = 0, v, gi = ts.p.multiselect === true ? 1 : 0, si = 0, addSubGridCell, ni = ts.p.rownumbers === true ? 1 : 0, idn, getId, f = [], F, rd = {}, xmlr, rid, rowData = [], cn = ts.p.altRows === true ? ts.p.altclass : "", cn1;
                if (ts.p.subGrid === true) {
                    si = 1;
                    addSubGridCell = $.jgrid.getMethod("addSubGridCell");
                }
                if (!xmlRd.repeatitems) {
                    f = reader(frd);
                }
                if (ts.p.keyIndex === false) {
                    idn = $.isFunction(xmlRd.id) ? xmlRd.id.call(ts, xml) : xmlRd.id;
                } else {
                    idn = ts.p.keyIndex;
                }
                if (f.length > 0 && !isNaN(idn)) {
                    if (ts.p.remapColumns && ts.p.remapColumns.length) {
                        idn = $.inArray(idn, ts.p.remapColumns);
                    }
                    idn = f[idn];
                }
                if (String(idn).indexOf("[") === -1) {
                    if (f.length) {
                        getId = function(trow, k) {
                            return $(idn, trow).text() || k;
                        };
                    } else {
                        getId = function(trow, k) {
                            return $(xmlRd.cell, trow).eq(idn).text() || k;
                        };
                    }
                } else {
                    getId = function(trow, k) {
                        return trow.getAttribute(idn.replace(/[\[\]]/g, "")) || k;
                    };
                }
                ts.p.userData = {};
                ts.p.page = $.jgrid.getXmlData(xml, xmlRd.page) || ts.p.page || 0;
                ts.p.lastpage = $.jgrid.getXmlData(xml, xmlRd.total);
                if (ts.p.lastpage === undefined) {
                    ts.p.lastpage = 1;
                }
                ts.p.records = $.jgrid.getXmlData(xml, xmlRd.records) || 0;
                if ($.isFunction(xmlRd.userdata)) {
                    ts.p.userData = xmlRd.userdata.call(ts, xml) || {};
                } else {
                    $.jgrid.getXmlData(xml, xmlRd.userdata, true).each(function() {
                        ts.p.userData[this.getAttribute("name")] = $(this).text();
                    });
                }
                var gxml = $.jgrid.getXmlData(xml, xmlRd.root, true);
                gxml = $.jgrid.getXmlData(gxml, xmlRd.row, true);
                if (!gxml) {
                    gxml = [];
                }
                var gl = gxml.length, j = 0, grpdata = [], rn = parseInt(ts.p.rowNum, 10), br = ts.p.scroll ? $.jgrid.randId() : 1, altr;
                if (gl > 0 && ts.p.page <= 0) {
                    ts.p.page = 1;
                }
                if (gxml && gl) {
                    if (adjust) {
                        rn *= adjust + 1;
                    }
                    var afterInsRow = $.isFunction(ts.p.afterInsertRow), hiderow = false, groupingPrepare;
                    if (ts.p.grouping) {
                        hiderow = ts.p.groupingView.groupCollapse === true;
                        groupingPrepare = $.jgrid.getMethod("groupingPrepare");
                    }
                    while (j < gl) {
                        xmlr = gxml[j];
                        rid = getId(xmlr, br + j);
                        rid = ts.p.idPrefix + rid;
                        altr = rcnt === 0 ? 0 : rcnt + 1;
                        cn1 = (altr + j) % 2 == 1 ? cn : "";
                        var iStartTrTag = rowData.length;
                        rowData.push("");
                        if (ni) {
                            rowData.push(addRowNum(0, j, ts.p.page, ts.p.rowNum));
                        }
                        if (gi) {
                            rowData.push(addMulti(rid, ni, j, false));
                        }
                        if (si) {
                            rowData.push(addSubGridCell.call(self, gi + ni, j + rcnt));
                        }
                        if (xmlRd.repeatitems) {
                            if (!F) {
                                F = orderedCols(gi + si + ni);
                            }
                            var cells = $.jgrid.getXmlData(xmlr, xmlRd.cell, true);
                            $.each(F, function(k) {
                                var cell = cells[this];
                                if (!cell) {
                                    return false;
                                }
                                v = cell.textContent || cell.text;
                                rd[ts.p.colModel[k + gi + si + ni].name] = v;
                                rowData.push(addCell(rid, v, k + gi + si + ni, j + rcnt, xmlr, rd));
                            });
                        } else {
                            for (i = 0; i < f.length; i++) {
                                v = $.jgrid.getXmlData(xmlr, f[i]);
                                rd[ts.p.colModel[i + gi + si + ni].name] = v;
                                rowData.push(addCell(rid, v, i + gi + si + ni, j + rcnt, xmlr, rd));
                            }
                        }
                        rowData[iStartTrTag] = constructTr(rid, hiderow, cn1, rd, xmlr, false);
                        rowData.push("</tr>");
                        if (ts.p.grouping) {
                            grpdata = groupingPrepare.call(self, rowData, grpdata, rd, j);
                            rowData = [];
                        }
                        if (locdata || ts.p.treeGrid === true) {
                            rd[xmlid] = rid;
                            ts.p.data.push(rd);
                            ts.p._index[rid] = ts.p.data.length - 1;
                        }
                        if (ts.p.gridview === false) {
                            $("tbody:first", t).append(rowData.join(""));
                            self.triggerHandler("jqGridAfterInsertRow", [ rid, rd, xmlr ]);
                            if (afterInsRow) {
                                ts.p.afterInsertRow.call(ts, rid, rd, xmlr);
                            }
                            rowData = [];
                        }
                        rd = {};
                        ir++;
                        j++;
                        if (ir == rn) {
                            break;
                        }
                    }
                }
                if (ts.p.gridview === true) {
                    fpos = ts.p.treeANode > -1 ? ts.p.treeANode : 0;
                    if (ts.p.grouping) {
                        self.jqGrid("groupingRender", grpdata, ts.p.colModel.length);
                        grpdata = null;
                    } else if (ts.p.treeGrid === true && fpos > 0) {
                        $(ts.rows[fpos]).after(rowData.join(""));
                    } else {
                        $("tbody:first", t).append(rowData.join(""));
                    }
                }
                if (ts.p.subGrid === true) {
                    try {
                        self.jqGrid("addSubGrid", gi + ni);
                    } catch (_) {}
                }
                ts.p.totaltime = new Date() - startReq;
                if (ir > 0) {
                    if (ts.p.records === 0) {
                        ts.p.records = gl;
                    }
                }
                rowData = null;
                if (ts.p.treeGrid === true) {
                    try {
                        self.jqGrid("setTreeNode", fpos + 1, ir + fpos + 1);
                    } catch (e) {}
                }
                if (!ts.p.treeGrid && !ts.p.scroll) {
                    ts.grid.bDiv.scrollTop = 0;
                }
                ts.p.reccount = ir;
                ts.p.treeANode = -1;
                if (ts.p.userDataOnFooter) {
                    self.jqGrid("footerData", "set", ts.p.userData, true);
                }
                if (locdata) {
                    ts.p.records = gl;
                    ts.p.lastpage = Math.ceil(gl / rn);
                }
                if (!more) {
                    ts.updatepager(false, true);
                }
                if (locdata) {
                    while (ir < gl) {
                        xmlr = gxml[ir];
                        rid = getId(xmlr, ir + br);
                        rid = ts.p.idPrefix + rid;
                        if (xmlRd.repeatitems) {
                            if (!F) {
                                F = orderedCols(gi + si + ni);
                            }
                            var cells2 = $.jgrid.getXmlData(xmlr, xmlRd.cell, true);
                            $.each(F, function(k) {
                                var cell = cells2[this];
                                if (!cell) {
                                    return false;
                                }
                                v = cell.textContent || cell.text;
                                rd[ts.p.colModel[k + gi + si + ni].name] = v;
                            });
                        } else {
                            for (i = 0; i < f.length; i++) {
                                v = $.jgrid.getXmlData(xmlr, f[i]);
                                rd[ts.p.colModel[i + gi + si + ni].name] = v;
                            }
                        }
                        rd[xmlid] = rid;
                        ts.p.data.push(rd);
                        ts.p._index[rid] = ts.p.data.length - 1;
                        rd = {};
                        ir++;
                    }
                }
            }, addJSONData = function(data, t, rcnt, more, adjust) {
                var startReq = new Date();
                if (data) {
                    if (ts.p.treeANode === -1 && !ts.p.scroll) {
                        emptyRows.call(ts, false, true);
                        rcnt = 1;
                    } else {
                        rcnt = rcnt > 1 ? rcnt : 1;
                    }
                } else {
                    return;
                }
                var dReader, locid = "_id_", frd, locdata = ts.p.datatype !== "local" && ts.p.loadonce || ts.p.datatype === "jsonstring";
                if (locdata) {
                    ts.p.data = [];
                    ts.p._index = {};
                    ts.p.localReader.id = locid;
                }
                ts.p.reccount = 0;
                if (ts.p.datatype === "local") {
                    dReader = ts.p.localReader;
                    frd = "local";
                } else {
                    dReader = ts.p.jsonReader;
                    frd = "json";
                }
                var self = $(ts), ir = 0, v, i, j, f = [], cur, gi = ts.p.multiselect ? 1 : 0, si = ts.p.subGrid === true ? 1 : 0, addSubGridCell, ni = ts.p.rownumbers === true ? 1 : 0, arrayReader = orderedCols(gi + si + ni), objectReader = reader(frd), rowReader, len, drows, idn, rd = {}, fpos, idr, rowData = [], cn = ts.p.altRows === true ? ts.p.altclass : "", cn1, lp;
                ts.p.page = $.jgrid.getAccessor(data, dReader.page) || ts.p.page || 0;
                lp = $.jgrid.getAccessor(data, dReader.total);
                if (si) {
                    addSubGridCell = $.jgrid.getMethod("addSubGridCell");
                }
                ts.p.lastpage = lp === undefined ? 1 : lp;
                ts.p.records = $.jgrid.getAccessor(data, dReader.records) || 0;
                ts.p.userData = $.jgrid.getAccessor(data, dReader.userdata) || {};
                if (ts.p.keyIndex === false) {
                    idn = $.isFunction(dReader.id) ? dReader.id.call(ts, data) : dReader.id;
                } else {
                    idn = ts.p.keyIndex;
                }
                if (!dReader.repeatitems) {
                    f = objectReader;
                    if (f.length > 0 && !isNaN(idn)) {
                        if (ts.p.remapColumns && ts.p.remapColumns.length) {
                            idn = $.inArray(idn, ts.p.remapColumns);
                        }
                        idn = f[idn];
                    }
                }
                drows = $.jgrid.getAccessor(data, dReader.root);
                if (drows == null && $.isArray(data)) {
                    drows = data;
                }
                if (!drows) {
                    drows = [];
                }
                len = drows.length;
                i = 0;
                if (len > 0 && ts.p.page <= 0) {
                    ts.p.page = 1;
                }
                var rn = parseInt(ts.p.rowNum, 10), br = ts.p.scroll ? $.jgrid.randId() : 1, altr, selected = false, selr;
                if (adjust) {
                    rn *= adjust + 1;
                }
                if (ts.p.datatype === "local" && !ts.p.deselectAfterSort) {
                    selected = true;
                }
                var afterInsRow = $.isFunction(ts.p.afterInsertRow), grpdata = [], hiderow = false, groupingPrepare;
                if (ts.p.grouping) {
                    hiderow = ts.p.groupingView.groupCollapse === true;
                    groupingPrepare = $.jgrid.getMethod("groupingPrepare");
                }
                while (i < len) {
                    cur = drows[i];
                    idr = $.jgrid.getAccessor(cur, idn);
                    if (idr === undefined) {
                        if (typeof idn === "number" && ts.p.colModel[idn + gi + si + ni] != null) {
                            idr = $.jgrid.getAccessor(cur, ts.p.colModel[idn + gi + si + ni].name);
                        }
                        if (idr === undefined) {
                            idr = br + i;
                            if (f.length === 0) {
                                if (dReader.cell) {
                                    var ccur = $.jgrid.getAccessor(cur, dReader.cell) || cur;
                                    idr = ccur != null && ccur[idn] !== undefined ? ccur[idn] : idr;
                                    ccur = null;
                                }
                            }
                        }
                    }
                    idr = ts.p.idPrefix + idr;
                    altr = rcnt === 1 ? 0 : rcnt;
                    cn1 = (altr + i) % 2 === 1 ? cn : "";
                    if (selected) {
                        if (ts.p.multiselect) {
                            selr = $.inArray(idr, ts.p.selarrrow) !== -1;
                        } else {
                            selr = idr === ts.p.selrow;
                        }
                    }
                    var iStartTrTag = rowData.length;
                    rowData.push("");
                    if (ni) {
                        rowData.push(addRowNum(0, i, ts.p.page, ts.p.rowNum));
                    }
                    if (gi) {
                        rowData.push(addMulti(idr, ni, i, selr));
                    }
                    if (si) {
                        rowData.push(addSubGridCell.call(self, gi + ni, i + rcnt));
                    }
                    rowReader = objectReader;
                    if (dReader.repeatitems) {
                        if (dReader.cell) {
                            cur = $.jgrid.getAccessor(cur, dReader.cell) || cur;
                        }
                        if ($.isArray(cur)) {
                            rowReader = arrayReader;
                        }
                    }
                    for (j = 0; j < rowReader.length; j++) {
                        v = $.jgrid.getAccessor(cur, rowReader[j]);
                        rd[ts.p.colModel[j + gi + si + ni].name] = v;
                        rowData.push(addCell(idr, v, j + gi + si + ni, i + rcnt, cur, rd));
                    }
                    rowData[iStartTrTag] = constructTr(idr, hiderow, cn1, rd, cur, selr);
                    rowData.push("</tr>");
                    if (ts.p.grouping) {
                        grpdata = groupingPrepare.call(self, rowData, grpdata, rd, i);
                        rowData = [];
                    }
                    if (locdata || ts.p.treeGrid === true) {
                        rd[locid] = idr;
                        ts.p.data.push(rd);
                        ts.p._index[idr] = ts.p.data.length - 1;
                    }
                    if (ts.p.gridview === false) {
                        $("#" + $.jgrid.jqID(ts.p.id) + " tbody:first").append(rowData.join(""));
                        self.triggerHandler("jqGridAfterInsertRow", [ idr, rd, cur ]);
                        if (afterInsRow) {
                            ts.p.afterInsertRow.call(ts, idr, rd, cur);
                        }
                        rowData = [];
                    }
                    rd = {};
                    ir++;
                    i++;
                    if (ir === rn) {
                        break;
                    }
                }
                if (ts.p.gridview === true) {
                    fpos = ts.p.treeANode > -1 ? ts.p.treeANode : 0;
                    if (ts.p.grouping) {
                        self.jqGrid("groupingRender", grpdata, ts.p.colModel.length);
                        grpdata = null;
                    } else if (ts.p.treeGrid === true && fpos > 0) {
                        $(ts.rows[fpos]).after(rowData.join(""));
                    } else {
                        $("#" + $.jgrid.jqID(ts.p.id) + " tbody:first").append(rowData.join(""));
                    }
                }
                if (ts.p.subGrid === true) {
                    try {
                        self.jqGrid("addSubGrid", gi + ni);
                    } catch (_) {}
                }
                ts.p.totaltime = new Date() - startReq;
                if (ir > 0) {
                    if (ts.p.records === 0) {
                        ts.p.records = len;
                    }
                }
                rowData = null;
                if (ts.p.treeGrid === true) {
                    try {
                        self.jqGrid("setTreeNode", fpos + 1, ir + fpos + 1);
                    } catch (e) {}
                }
                if (!ts.p.treeGrid && !ts.p.scroll) {
                    ts.grid.bDiv.scrollTop = 0;
                }
                ts.p.reccount = ir;
                ts.p.treeANode = -1;
                if (ts.p.userDataOnFooter) {
                    self.jqGrid("footerData", "set", ts.p.userData, true);
                }
                if (locdata) {
                    ts.p.records = len;
                    ts.p.lastpage = Math.ceil(len / rn);
                }
                if (!more) {
                    ts.updatepager(false, true);
                }
                if (locdata) {
                    while (ir < len && drows[ir]) {
                        cur = drows[ir];
                        idr = $.jgrid.getAccessor(cur, idn);
                        if (idr === undefined) {
                            if (typeof idn === "number" && ts.p.colModel[idn + gi + si + ni] != null) {
                                idr = $.jgrid.getAccessor(cur, ts.p.colModel[idn + gi + si + ni].name);
                            }
                            if (idr === undefined) {
                                idr = br + ir;
                                if (f.length === 0) {
                                    if (dReader.cell) {
                                        var ccur2 = $.jgrid.getAccessor(cur, dReader.cell) || cur;
                                        idr = ccur2 != null && ccur2[idn] !== undefined ? ccur2[idn] : idr;
                                        ccur2 = null;
                                    }
                                }
                            }
                        }
                        if (cur) {
                            idr = ts.p.idPrefix + idr;
                            rowReader = objectReader;
                            if (dReader.repeatitems) {
                                if (dReader.cell) {
                                    cur = $.jgrid.getAccessor(cur, dReader.cell);
                                }
                                if ($.isArray(cur)) {
                                    rowReader = arrayReader;
                                }
                            }
                            for (j = 0; j < rowReader.length; j++) {
                                rd[ts.p.colModel[j + gi + si + ni].name] = $.jgrid.getAccessor(cur, rowReader[j]);
                            }
                            rd[locid] = idr;
                            ts.p.data.push(rd);
                            ts.p._index[idr] = ts.p.data.length - 1;
                            rd = {};
                        }
                        ir++;
                    }
                }
            }, addLocalData = function() {
                var st, fndsort = false, cmtypes = {}, grtypes = [], grindexes = [], srcformat, sorttype, newformat;
                if (!$.isArray(ts.p.data)) {
                    return;
                }
                var grpview = ts.p.grouping ? ts.p.groupingView : false, lengrp, gin;
                $.each(ts.p.colModel, function() {
                    sorttype = this.sorttype || "text";
                    if (sorttype == "date" || sorttype == "datetime") {
                        if (this.formatter && typeof this.formatter === "string" && this.formatter == "date") {
                            if (this.formatoptions && this.formatoptions.srcformat) {
                                srcformat = this.formatoptions.srcformat;
                            } else {
                                srcformat = $.jgrid.formatter.date.srcformat;
                            }
                            if (this.formatoptions && this.formatoptions.newformat) {
                                newformat = this.formatoptions.newformat;
                            } else {
                                newformat = $.jgrid.formatter.date.newformat;
                            }
                        } else {
                            srcformat = newformat = this.datefmt || "Y-m-d";
                        }
                        cmtypes[this.name] = {
                            "stype": sorttype,
                            "srcfmt": srcformat,
                            "newfmt": newformat
                        };
                    } else {
                        cmtypes[this.name] = {
                            "stype": sorttype,
                            "srcfmt": "",
                            "newfmt": ""
                        };
                    }
                    if (ts.p.grouping) {
                        for (gin = 0, lengrp = grpview.groupField.length; gin < lengrp; gin++) {
                            if (this.name == grpview.groupField[gin]) {
                                var grindex = this.name;
                                if (this.index) {
                                    grindex = this.index;
                                }
                                grtypes[gin] = cmtypes[grindex];
                                grindexes[gin] = grindex;
                            }
                        }
                    }
                    if (!fndsort && (this.index == ts.p.sortname || this.name == ts.p.sortname)) {
                        st = this.name;
                        fndsort = true;
                    }
                });
                if (ts.p.treeGrid) {
                    $(ts).jqGrid("SortTree", st, ts.p.sortorder, cmtypes[st].stype, cmtypes[st].srcfmt);
                    return;
                }
                var compareFnMap = {
                    "eq": function(queryObj) {
                        return queryObj.equals;
                    },
                    "ne": function(queryObj) {
                        return queryObj.notEquals;
                    },
                    "lt": function(queryObj) {
                        return queryObj.less;
                    },
                    "le": function(queryObj) {
                        return queryObj.lessOrEquals;
                    },
                    "gt": function(queryObj) {
                        return queryObj.greater;
                    },
                    "ge": function(queryObj) {
                        return queryObj.greaterOrEquals;
                    },
                    "cn": function(queryObj) {
                        return queryObj.contains;
                    },
                    "nc": function(queryObj, op) {
                        return op === "OR" ? queryObj.orNot().contains : queryObj.andNot().contains;
                    },
                    "bw": function(queryObj) {
                        return queryObj.startsWith;
                    },
                    "bn": function(queryObj, op) {
                        return op === "OR" ? queryObj.orNot().startsWith : queryObj.andNot().startsWith;
                    },
                    "en": function(queryObj, op) {
                        return op === "OR" ? queryObj.orNot().endsWith : queryObj.andNot().endsWith;
                    },
                    "ew": function(queryObj) {
                        return queryObj.endsWith;
                    },
                    "ni": function(queryObj, op) {
                        return op === "OR" ? queryObj.orNot().equals : queryObj.andNot().equals;
                    },
                    "in": function(queryObj) {
                        return queryObj.equals;
                    },
                    "nu": function(queryObj) {
                        return queryObj.isNull;
                    },
                    "nn": function(queryObj, op) {
                        return op === "OR" ? queryObj.orNot().isNull : queryObj.andNot().isNull;
                    }
                }, query = $.jgrid.from(ts.p.data);
                if (ts.p.ignoreCase) {
                    query = query.ignoreCase();
                }
                function tojLinq(group) {
                    var s = 0, index, gor, ror, opr, rule;
                    if (group.groups != null) {
                        gor = group.groups.length && group.groupOp.toString().toUpperCase() === "OR";
                        if (gor) {
                            query.orBegin();
                        }
                        for (index = 0; index < group.groups.length; index++) {
                            if (s > 0 && gor) {
                                query.or();
                            }
                            try {
                                tojLinq(group.groups[index]);
                            } catch (e) {
                                alert(e);
                            }
                            s++;
                        }
                        if (gor) {
                            query.orEnd();
                        }
                    }
                    if (group.rules != null) {
                        try {
                            ror = group.rules.length && group.groupOp.toString().toUpperCase() === "OR";
                            if (ror) {
                                query.orBegin();
                            }
                            for (index = 0; index < group.rules.length; index++) {
                                rule = group.rules[index];
                                opr = group.groupOp.toString().toUpperCase();
                                if (compareFnMap[rule.op] && rule.field) {
                                    if (s > 0 && opr && opr === "OR") {
                                        query = query.or();
                                    }
                                    query = compareFnMap[rule.op](query, opr)(rule.field, rule.data, cmtypes[rule.field]);
                                }
                                s++;
                            }
                            if (ror) {
                                query.orEnd();
                            }
                        } catch (g) {
                            alert(g);
                        }
                    }
                }
                if (ts.p.search === true) {
                    var srules = ts.p.postData.filters;
                    if (srules) {
                        if (typeof srules === "string") {
                            srules = $.jgrid.parse(srules);
                        }
                        tojLinq(srules);
                    } else {
                        try {
                            query = compareFnMap[ts.p.postData.searchOper](query)(ts.p.postData.searchField, ts.p.postData.searchString, cmtypes[ts.p.postData.searchField]);
                        } catch (se) {}
                    }
                }
                if (ts.p.grouping) {
                    for (gin = 0; gin < lengrp; gin++) {
                        query.orderBy(grindexes[gin], grpview.groupOrder[gin], grtypes[gin].stype, grtypes[gin].srcfmt);
                    }
                }
                if (st && ts.p.sortorder && fndsort) {
                    if (ts.p.sortorder.toUpperCase() == "DESC") {
                        query.orderBy(ts.p.sortname, "d", cmtypes[st].stype, cmtypes[st].srcfmt);
                    } else {
                        query.orderBy(ts.p.sortname, "a", cmtypes[st].stype, cmtypes[st].srcfmt);
                    }
                }
                var queryResults = query.select(), recordsperpage = parseInt(ts.p.rowNum, 10), total = queryResults.length, page = parseInt(ts.p.page, 10), totalpages = Math.ceil(total / recordsperpage), retresult = {};
                queryResults = queryResults.slice((page - 1) * recordsperpage, page * recordsperpage);
                query = null;
                cmtypes = null;
                retresult[ts.p.localReader.total] = totalpages;
                retresult[ts.p.localReader.page] = page;
                retresult[ts.p.localReader.records] = total;
                retresult[ts.p.localReader.root] = queryResults;
                retresult[ts.p.localReader.userdata] = ts.p.userData;
                queryResults = null;
                return retresult;
            }, updatepager = function(rn, dnd) {
                var cp, last, base, from, to, tot, fmt, pgboxes = "", sppg, tspg = ts.p.pager ? "_" + $.jgrid.jqID(ts.p.pager.substr(1)) : "", tspg_t = ts.p.toppager ? "_" + ts.p.toppager.substr(1) : "";
                base = parseInt(ts.p.page, 10) - 1;
                if (base < 0) {
                    base = 0;
                }
                base = base * parseInt(ts.p.rowNum, 10);
                to = base + ts.p.reccount;
                if (ts.p.scroll) {
                    var rows = $("tbody:first > tr:gt(0)", ts.grid.bDiv);
                    base = to - rows.length;
                    ts.p.reccount = rows.length;
                    var rh = rows.outerHeight() || ts.grid.prevRowHeight;
                    if (rh) {
                        var top = base * rh;
                        var height = parseInt(ts.p.records, 10) * rh;
                        $(">div:first", ts.grid.bDiv).css({
                            "height": height
                        }).children("div:first").css({
                            "height": top,
                            "display": top ? "" : "none"
                        });
                    }
                    ts.grid.bDiv.scrollLeft = ts.grid.hDiv.scrollLeft;
                }
                pgboxes = ts.p.pager || "";
                pgboxes += ts.p.toppager ? pgboxes ? "," + ts.p.toppager : ts.p.toppager : "";
                if (pgboxes) {
                    fmt = $.jgrid.formatter.integer || {};
                    cp = intNum(ts.p.page);
                    last = intNum(ts.p.lastpage);
                    $(".selbox", pgboxes)[this.p.useProp ? "prop" : "attr"]("disabled", false);
                    if (ts.p.pginput === true) {
                        $(".ui-pg-input", pgboxes).val(ts.p.page);
                        sppg = ts.p.toppager ? "#sp_1" + tspg + ",#sp_1" + tspg_t : "#sp_1" + tspg;
                        $(sppg).html($.fmatter ? $.fmatter.util.NumberFormat(ts.p.lastpage, fmt) : ts.p.lastpage);
                    }
                    if (ts.p.viewrecords) {
                        if (ts.p.reccount === 0) {
                            $(".ui-paging-info", pgboxes).html(ts.p.emptyrecords);
                        } else {
                            from = base + 1;
                            tot = ts.p.records;
                            if ($.fmatter) {
                                from = $.fmatter.util.NumberFormat(from, fmt);
                                to = $.fmatter.util.NumberFormat(to, fmt);
                                tot = $.fmatter.util.NumberFormat(tot, fmt);
                            }
                            $(".ui-paging-info", pgboxes).html($.jgrid.format(ts.p.recordtext, from, to, tot));
                        }
                    }
                    if (ts.p.pgbuttons === true) {
                        if (cp <= 0) {
                            cp = last = 0;
                        }
                        if (cp == 1 || cp === 0) {
                            $("#first" + tspg + ", #prev" + tspg).addClass("ui-state-disabled").removeClass("ui-state-hover");
                            if (ts.p.toppager) {
                                $("#first_t" + tspg_t + ", #prev_t" + tspg_t).addClass("ui-state-disabled").removeClass("ui-state-hover");
                            }
                        } else {
                            $("#first" + tspg + ", #prev" + tspg).removeClass("ui-state-disabled");
                            if (ts.p.toppager) {
                                $("#first_t" + tspg_t + ", #prev_t" + tspg_t).removeClass("ui-state-disabled");
                            }
                        }
                        if (cp == last || cp === 0) {
                            $("#next" + tspg + ", #last" + tspg).addClass("ui-state-disabled").removeClass("ui-state-hover");
                            if (ts.p.toppager) {
                                $("#next_t" + tspg_t + ", #last_t" + tspg_t).addClass("ui-state-disabled").removeClass("ui-state-hover");
                            }
                        } else {
                            $("#next" + tspg + ", #last" + tspg).removeClass("ui-state-disabled");
                            if (ts.p.toppager) {
                                $("#next_t" + tspg_t + ", #last_t" + tspg_t).removeClass("ui-state-disabled");
                            }
                        }
                    }
                }
                if (rn === true && ts.p.rownumbers === true) {
                    $("td.jqgrid-rownum", ts.rows).each(function(i) {
                        $(this).html(base + 1 + i);
                    });
                }
                if (dnd && ts.p.jqgdnd) {
                    $(ts).jqGrid("gridDnD", "updateDnD");
                }
                $(ts).triggerHandler("jqGridGridComplete");
                if ($.isFunction(ts.p.gridComplete)) {
                    ts.p.gridComplete.call(ts);
                }
                $(ts).triggerHandler("jqGridAfterGridComplete");
            }, beginReq = function() {
                ts.grid.hDiv.loading = true;
                if (ts.p.hiddengrid) {
                    return;
                }
                switch (ts.p.loadui) {
                  case "disable":
                    break;

                  case "enable":
                    $("#load_" + $.jgrid.jqID(ts.p.id)).show();
                    break;

                  case "block":
                    $("#lui_" + $.jgrid.jqID(ts.p.id)).show();
                    $("#load_" + $.jgrid.jqID(ts.p.id)).show();
                    break;
                }
            }, endReq = function() {
                ts.grid.hDiv.loading = false;
                switch (ts.p.loadui) {
                  case "disable":
                    break;

                  case "enable":
                    $("#load_" + $.jgrid.jqID(ts.p.id)).hide();
                    break;

                  case "block":
                    $("#lui_" + $.jgrid.jqID(ts.p.id)).hide();
                    $("#load_" + $.jgrid.jqID(ts.p.id)).hide();
                    break;
                }
            }, populate = function(npage) {
                if (!ts.grid.hDiv.loading) {
                    var pvis = ts.p.scroll && npage === false, prm = {}, dt, dstr, pN = ts.p.prmNames;
                    if (ts.p.page <= 0) {
                        ts.p.page = 1;
                    }
                    if (pN.search !== null) {
                        prm[pN.search] = ts.p.search;
                    }
                    if (pN.nd !== null) {
                        prm[pN.nd] = new Date().getTime();
                    }
                    if (pN.rows !== null) {
                        prm[pN.rows] = ts.p.rowNum;
                    }
                    if (pN.page !== null) {
                        prm[pN.page] = ts.p.page;
                    }
                    if (pN.sort !== null) {
                        prm[pN.sort] = ts.p.sortname;
                    }
                    if (pN.order !== null) {
                        prm[pN.order] = ts.p.sortorder;
                    }
                    if (ts.p.rowTotal !== null && pN.totalrows !== null) {
                        prm[pN.totalrows] = ts.p.rowTotal;
                    }
                    var lcf = $.isFunction(ts.p.loadComplete), lc = lcf ? ts.p.loadComplete : null;
                    var adjust = 0;
                    npage = npage || 1;
                    if (npage > 1) {
                        if (pN.npage !== null) {
                            prm[pN.npage] = npage;
                            adjust = npage - 1;
                            npage = 1;
                        } else {
                            lc = function(req) {
                                ts.p.page++;
                                ts.grid.hDiv.loading = false;
                                if (lcf) {
                                    ts.p.loadComplete.call(ts, req);
                                }
                                populate(npage - 1);
                            };
                        }
                    } else if (pN.npage !== null) {
                        delete ts.p.postData[pN.npage];
                    }
                    if (ts.p.grouping) {
                        $(ts).jqGrid("groupingSetup");
                        var grp = ts.p.groupingView, gi, gs = "";
                        for (gi = 0; gi < grp.groupField.length; gi++) {
                            var index = grp.groupField[gi];
                            $.each(ts.p.colModel, function(cmIndex, cmValue) {
                                if (cmValue.name == index && cmValue.index) {
                                    index = cmValue.index;
                                }
                            });
                            gs += index + " " + grp.groupOrder[gi] + ", ";
                        }
                        prm[pN.sort] = gs + prm[pN.sort];
                    }
                    $.extend(ts.p.postData, prm);
                    var rcnt = !ts.p.scroll ? 1 : ts.rows.length - 1;
                    var bfr = $(ts).triggerHandler("jqGridBeforeRequest");
                    if (bfr === false || bfr === "stop") {
                        return;
                    }
                    if ($.isFunction(ts.p.datatype)) {
                        ts.p.datatype.call(ts, ts.p.postData, "load_" + ts.p.id);
                        return;
                    }
                    if ($.isFunction(ts.p.beforeRequest)) {
                        bfr = ts.p.beforeRequest.call(ts);
                        if (bfr === undefined) {
                            bfr = true;
                        }
                        if (bfr === false) {
                            return;
                        }
                    }
                    dt = ts.p.datatype.toLowerCase();
                    switch (dt) {
                      case "json":
                      case "jsonp":
                      case "xml":
                      case "script":
                        $.ajax($.extend({
                            "url": ts.p.url,
                            "type": ts.p.mtype,
                            "dataType": dt,
                            "data": $.isFunction(ts.p.serializeGridData) ? ts.p.serializeGridData.call(ts, ts.p.postData) : ts.p.postData,
                            "success": function(data, st, xhr) {
                                if ($.isFunction(ts.p.beforeProcessing)) {
                                    if (ts.p.beforeProcessing.call(ts, data, st, xhr) === false) {
                                        endReq();
                                        return;
                                    }
                                }
                                if (dt === "xml") {
                                    addXmlData(data, ts.grid.bDiv, rcnt, npage > 1, adjust);
                                } else {
                                    addJSONData(data, ts.grid.bDiv, rcnt, npage > 1, adjust);
                                }
                                $(ts).triggerHandler("jqGridLoadComplete", [ data ]);
                                if (lc) {
                                    lc.call(ts, data);
                                }
                                $(ts).triggerHandler("jqGridAfterLoadComplete", [ data ]);
                                if (pvis) {
                                    ts.grid.populateVisible();
                                }
                                if (ts.p.loadonce || ts.p.treeGrid) {
                                    ts.p.datatype = "local";
                                }
                                data = null;
                                if (npage === 1) {
                                    endReq();
                                }
                            },
                            "error": function(xhr, st, err) {
                                if ($.isFunction(ts.p.loadError)) {
                                    ts.p.loadError.call(ts, xhr, st, err);
                                }
                                if (npage === 1) {
                                    endReq();
                                }
                                xhr = null;
                            },
                            "beforeSend": function(xhr, settings) {
                                var gotoreq = true;
                                if ($.isFunction(ts.p.loadBeforeSend)) {
                                    gotoreq = ts.p.loadBeforeSend.call(ts, xhr, settings);
                                }
                                if (gotoreq === undefined) {
                                    gotoreq = true;
                                }
                                if (gotoreq === false) {
                                    return false;
                                }
                                beginReq();
                            }
                        }, $.jgrid.ajaxOptions, ts.p.ajaxGridOptions));
                        break;

                      case "xmlstring":
                        beginReq();
                        dstr = typeof ts.p.datastr !== "string" ? ts.p.datastr : $.parseXML(ts.p.datastr);
                        ;
                        addXmlData(dstr, ts.grid.bDiv);
                        $(ts).triggerHandler("jqGridLoadComplete", [ dstr ]);
                        if (lcf) {
                            ts.p.loadComplete.call(ts, dstr);
                        }
                        $(ts).triggerHandler("jqGridAfterLoadComplete", [ dstr ]);
                        ts.p.datatype = "local";
                        ts.p.datastr = null;
                        endReq();
                        break;

                      case "jsonstring":
                        beginReq();
                        if (typeof ts.p.datastr === "string") {
                            dstr = $.jgrid.parse(ts.p.datastr);
                        } else {
                            dstr = ts.p.datastr;
                        }
                        addJSONData(dstr, ts.grid.bDiv);
                        $(ts).triggerHandler("jqGridLoadComplete", [ dstr ]);
                        if (lcf) {
                            ts.p.loadComplete.call(ts, dstr);
                        }
                        $(ts).triggerHandler("jqGridAfterLoadComplete", [ dstr ]);
                        ts.p.datatype = "local";
                        ts.p.datastr = null;
                        endReq();
                        break;

                      case "local":
                      case "clientside":
                        beginReq();
                        ts.p.datatype = "local";
                        var req = addLocalData();
                        addJSONData(req, ts.grid.bDiv, rcnt, npage > 1, adjust);
                        $(ts).triggerHandler("jqGridLoadComplete", [ req ]);
                        if (lc) {
                            lc.call(ts, req);
                        }
                        $(ts).triggerHandler("jqGridAfterLoadComplete", [ req ]);
                        if (pvis) {
                            ts.grid.populateVisible();
                        }
                        endReq();
                        break;
                    }
                }
            }, setHeadCheckBox = function(checked) {
                $("#cb_" + $.jgrid.jqID(ts.p.id), ts.grid.hDiv)[ts.p.useProp ? "prop" : "attr"]("checked", checked);
                var fid = ts.p.frozenColumns ? ts.p.id + "_frozen" : "";
                if (fid) {
                    $("#cb_" + $.jgrid.jqID(ts.p.id), ts.grid.fhDiv)[ts.p.useProp ? "prop" : "attr"]("checked", checked);
                }
            }, setPager = function(pgid, tp) {
                var sep = "<td class='ui-pg-button ui-state-disabled' style='width:4px;'><span class='ui-separator'></span></td>", pginp = "", pgl = "<table cellspacing='0' cellpadding='0' border='0' style='table-layout:auto;' class='ui-pg-table'><tbody><tr>", str = "", pgcnt, lft, cent, rgt, twd, tdw, i, clearVals = function(onpaging) {
                    var ret;
                    if ($.isFunction(ts.p.onPaging)) {
                        ret = ts.p.onPaging.call(ts, onpaging);
                    }
                    ts.p.selrow = null;
                    if (ts.p.multiselect) {
                        ts.p.selarrrow = [];
                        setHeadCheckBox(false);
                    }
                    ts.p.savedRow = [];
                    if (ret == "stop") {
                        return false;
                    }
                    return true;
                };
                pgid = pgid.substr(1);
                tp += "_" + pgid;
                pgcnt = "pg_" + pgid;
                lft = pgid + "_left";
                cent = pgid + "_center";
                rgt = pgid + "_right";
                $("#" + $.jgrid.jqID(pgid)).append("<div id='" + pgcnt + "' class='ui-pager-control' role='group'><table cellspacing='0' cellpadding='0' border='0' class='ui-pg-table' style='width:100%;table-layout:fixed;height:100%;' role='row'><tbody><tr><td id='" + lft + "' align='left'></td><td id='" + cent + "' align='center' style='white-space:pre;'></td><td id='" + rgt + "' align='right'></td></tr></tbody></table></div>").attr("dir", "ltr");
                if (ts.p.rowList.length > 0) {
                    str = "<td dir='" + dir + "'>";
                    str += "<select class='ui-pg-selbox' role='listbox'>";
                    for (i = 0; i < ts.p.rowList.length; i++) {
                        str += '<option role="option" value="' + ts.p.rowList[i] + '"' + (ts.p.rowNum == ts.p.rowList[i] ? ' selected="selected"' : "") + ">" + ts.p.rowList[i] + "</option>";
                    }
                    str += "</select></td>";
                }
                if (dir == "rtl") {
                    pgl += str;
                }
                if (ts.p.pginput === true) {
                    pginp = "<td dir='" + dir + "'>" + $.jgrid.format(ts.p.pgtext || "", "<input class='ui-pg-input' type='text' size='2' maxlength='7' value='0' role='textbox'/>", "<span id='sp_1_" + $.jgrid.jqID(pgid) + "'></span>") + "</td>";
                }
                if (ts.p.pgbuttons === true) {
                    var po = [ "first" + tp, "prev" + tp, "next" + tp, "last" + tp ];
                    if (dir == "rtl") {
                        po.reverse();
                    }
                    pgl += "<td id='" + po[0] + "' class='ui-pg-button ui-corner-all'><span class='ui-icon ui-icon-seek-first'></span></td>";
                    pgl += "<td id='" + po[1] + "' class='ui-pg-button ui-corner-all'><span class='ui-icon ui-icon-seek-prev'></span></td>";
                    pgl += pginp !== "" ? sep + pginp + sep : "";
                    pgl += "<td id='" + po[2] + "' class='ui-pg-button ui-corner-all'><span class='ui-icon ui-icon-seek-next'></span></td>";
                    pgl += "<td id='" + po[3] + "' class='ui-pg-button ui-corner-all'><span class='ui-icon ui-icon-seek-end'></span></td>";
                } else if (pginp !== "") {
                    pgl += pginp;
                }
                if (dir == "ltr") {
                    pgl += str;
                }
                pgl += "</tr></tbody></table>";
                if (ts.p.viewrecords === true) {
                    $("td#" + pgid + "_" + ts.p.recordpos, "#" + pgcnt).append("<div dir='" + dir + "' style='text-align:" + ts.p.recordpos + "' class='ui-paging-info'></div>");
                }
                $("td#" + pgid + "_" + ts.p.pagerpos, "#" + pgcnt).append(pgl);
                tdw = $(".ui-jqgrid").css("font-size") || "11px";
                $(document.body).append("<div id='testpg' class='ui-jqgrid ui-widget ui-widget-content' style='font-size:" + tdw + ";visibility:hidden;' ></div>");
                twd = $(pgl).clone().appendTo("#testpg").width();
                $("#testpg").remove();
                if (twd > 0) {
                    if (pginp !== "") {
                        twd += 50;
                    }
                    $("td#" + pgid + "_" + ts.p.pagerpos, "#" + pgcnt).width(twd);
                }
                ts.p._nvtd = [];
                ts.p._nvtd[0] = twd ? Math.floor((ts.p.width - twd) / 2) : Math.floor(ts.p.width / 3);
                ts.p._nvtd[1] = 0;
                pgl = null;
                $(".ui-pg-selbox", "#" + pgcnt).bind("change", function() {
                    if (!clearVals("records")) {
                        return false;
                    }
                    ts.p.page = Math.round(ts.p.rowNum * (ts.p.page - 1) / this.value - .5) + 1;
                    ts.p.rowNum = this.value;
                    if (ts.p.pager) {
                        $(".ui-pg-selbox", ts.p.pager).val(this.value);
                    }
                    if (ts.p.toppager) {
                        $(".ui-pg-selbox", ts.p.toppager).val(this.value);
                    }
                    populate();
                    return false;
                });
                if (ts.p.pgbuttons === true) {
                    $(".ui-pg-button", "#" + pgcnt).hover(function() {
                        if ($(this).hasClass("ui-state-disabled")) {
                            this.style.cursor = "default";
                        } else {
                            $(this).addClass("ui-state-hover");
                            this.style.cursor = "pointer";
                        }
                    }, function() {
                        if (!$(this).hasClass("ui-state-disabled")) {
                            $(this).removeClass("ui-state-hover");
                            this.style.cursor = "default";
                        }
                    });
                    $("#first" + $.jgrid.jqID(tp) + ", #prev" + $.jgrid.jqID(tp) + ", #next" + $.jgrid.jqID(tp) + ", #last" + $.jgrid.jqID(tp)).click(function() {
                        var cp = intNum(ts.p.page, 1), last = intNum(ts.p.lastpage, 1), selclick = false, fp = true, pp = true, np = true, lp = true;
                        if (last === 0 || last === 1) {
                            fp = false;
                            pp = false;
                            np = false;
                            lp = false;
                        } else if (last > 1 && cp >= 1) {
                            if (cp === 1) {
                                fp = false;
                                pp = false;
                            } else if (cp === last) {
                                np = false;
                                lp = false;
                            }
                        } else if (last > 1 && cp === 0) {
                            np = false;
                            lp = false;
                            cp = last - 1;
                        }
                        if (!clearVals(this.id)) {
                            return false;
                        }
                        if (this.id === "first" + tp && fp) {
                            ts.p.page = 1;
                            selclick = true;
                        }
                        if (this.id === "prev" + tp && pp) {
                            ts.p.page = cp - 1;
                            selclick = true;
                        }
                        if (this.id === "next" + tp && np) {
                            ts.p.page = cp + 1;
                            selclick = true;
                        }
                        if (this.id === "last" + tp && lp) {
                            ts.p.page = last;
                            selclick = true;
                        }
                        if (selclick) {
                            populate();
                        }
                        return false;
                    });
                }
                if (ts.p.pginput === true) {
                    $("input.ui-pg-input", "#" + pgcnt).keypress(function(e) {
                        var key = e.charCode || e.keyCode || 0;
                        if (key == 13) {
                            if (!clearVals("user")) {
                                return false;
                            }
                            $(this).val(intNum($(this).val(), 1));
                            ts.p.page = $(this).val() > 0 ? $(this).val() : ts.p.page;
                            populate();
                            return false;
                        }
                        return this;
                    });
                }
            }, sortData = function(index, idxcol, reload, sor) {
                if (!ts.p.colModel[idxcol].sortable) {
                    return;
                }
                var so;
                if (ts.p.savedRow.length > 0) {
                    return;
                }
                if (!reload) {
                    if (ts.p.lastsort == idxcol) {
                        if (ts.p.sortorder == "asc") {
                            ts.p.sortorder = "desc";
                        } else if (ts.p.sortorder == "desc") {
                            ts.p.sortorder = "asc";
                        }
                    } else {
                        ts.p.sortorder = ts.p.colModel[idxcol].firstsortorder || "asc";
                    }
                    ts.p.page = 1;
                }
                if (sor) {
                    if (ts.p.lastsort == idxcol && ts.p.sortorder == sor && !reload) {
                        return;
                    }
                    ts.p.sortorder = sor;
                }
                var previousSelectedTh = ts.grid.headers[ts.p.lastsort].el, newSelectedTh = ts.grid.headers[idxcol].el;
                $("span.ui-grid-ico-sort", previousSelectedTh).addClass("ui-state-disabled");
                $(previousSelectedTh).attr("aria-selected", "false");
                $("span.ui-icon-" + ts.p.sortorder, newSelectedTh).removeClass("ui-state-disabled");
                $(newSelectedTh).attr("aria-selected", "true");
                if (!ts.p.viewsortcols[0]) {
                    if (ts.p.lastsort != idxcol) {
                        $("span.s-ico", previousSelectedTh).hide();
                        $("span.s-ico", newSelectedTh).show();
                    }
                }
                index = index.substring(5 + ts.p.id.length + 1);
                ts.p.sortname = ts.p.colModel[idxcol].index || index;
                so = ts.p.sortorder;
                if ($(ts).triggerHandler("jqGridSortCol", [ index, idxcol, so ]) === "stop") {
                    ts.p.lastsort = idxcol;
                    return;
                }
                if ($.isFunction(ts.p.onSortCol)) {
                    if (ts.p.onSortCol.call(ts, index, idxcol, so) == "stop") {
                        ts.p.lastsort = idxcol;
                        return;
                    }
                }
                if (ts.p.datatype == "local") {
                    if (ts.p.deselectAfterSort) {
                        $(ts).jqGrid("resetSelection");
                    }
                } else {
                    ts.p.selrow = null;
                    if (ts.p.multiselect) {
                        setHeadCheckBox(false);
                    }
                    ts.p.selarrrow = [];
                    ts.p.savedRow = [];
                }
                if (ts.p.scroll) {
                    var sscroll = ts.grid.bDiv.scrollLeft;
                    emptyRows.call(ts, true, false);
                    ts.grid.hDiv.scrollLeft = sscroll;
                }
                if (ts.p.subGrid && ts.p.datatype == "local") {
                    $("td.sgexpanded", "#" + $.jgrid.jqID(ts.p.id)).each(function() {
                        $(this).trigger("click");
                    });
                }
                populate();
                ts.p.lastsort = idxcol;
                if (ts.p.sortname != index && idxcol) {
                    ts.p.lastsort = idxcol;
                }
            }, setColWidth = function() {
                var initwidth = 0, brd = $.jgrid.cell_width ? 0 : intNum(ts.p.cellLayout, 0), vc = 0, lvc, scw = intNum(ts.p.scrollOffset, 0), cw, hs = false, aw, gw = 0, cl = 0, cr;
                $.each(ts.p.colModel, function() {
                    if (this.hidden === undefined) {
                        this.hidden = false;
                    }
                    if (ts.p.grouping && ts.p.autowidth) {
                        var ind = $.inArray(this.name, ts.p.groupingView.groupField);
                        if (ind >= 0 && ts.p.groupingView.groupColumnShow.length > ind) {
                            this.hidden = !ts.p.groupingView.groupColumnShow[ind];
                        }
                    }
                    this.widthOrg = cw = intNum(this.width, 0);
                    if (this.hidden === false) {
                        initwidth += cw + brd;
                        if (this.fixed) {
                            gw += cw + brd;
                        } else {
                            vc++;
                        }
                        cl++;
                    }
                });
                if (isNaN(ts.p.width)) {
                    ts.p.width = initwidth + (ts.p.shrinkToFit === false && !isNaN(ts.p.height) ? scw : 0);
                }
                grid.width = ts.p.width;
                ts.p.tblwidth = initwidth;
                if (ts.p.shrinkToFit === false && ts.p.forceFit === true) {
                    ts.p.forceFit = false;
                }
                if (ts.p.shrinkToFit === true && vc > 0) {
                    aw = grid.width - brd * vc - gw;
                    if (!isNaN(ts.p.height)) {
                        aw -= scw;
                        hs = true;
                    }
                    initwidth = 0;
                    $.each(ts.p.colModel, function(i) {
                        if (this.hidden === false && !this.fixed) {
                            cw = Math.round(aw * this.width / (ts.p.tblwidth - brd * vc - gw));
                            this.width = cw;
                            initwidth += cw;
                            lvc = i;
                        }
                    });
                    cr = 0;
                    if (hs) {
                        if (grid.width - gw - (initwidth + brd * vc) !== scw) {
                            cr = grid.width - gw - (initwidth + brd * vc) - scw;
                        }
                    } else if (!hs && Math.abs(grid.width - gw - (initwidth + brd * vc)) !== 1) {
                        cr = grid.width - gw - (initwidth + brd * vc);
                    }
                    ts.p.colModel[lvc].width += cr;
                    ts.p.tblwidth = initwidth + cr + brd * vc + gw;
                    if (ts.p.tblwidth > ts.p.width) {
                        ts.p.colModel[lvc].width -= ts.p.tblwidth - parseInt(ts.p.width, 10);
                        ts.p.tblwidth = ts.p.width;
                    }
                }
            }, nextVisible = function(iCol) {
                var ret = iCol, j = iCol, i;
                for (i = iCol + 1; i < ts.p.colModel.length; i++) {
                    if (ts.p.colModel[i].hidden !== true) {
                        j = i;
                        break;
                    }
                }
                return j - ret;
            }, getOffset = function(iCol) {
                var $th = $(ts.grid.headers[iCol].el), ret = [ $th.position().left + $th.outerWidth() ];
                if (ts.p.direction == "rtl") {
                    ret[0] = ts.p.width - ret[0];
                }
                ret[0] -= ts.grid.bDiv.scrollLeft;
                ret.push($(ts.grid.hDiv).position().top);
                ret.push($(ts.grid.bDiv).offset().top - $(ts.grid.hDiv).offset().top + $(ts.grid.bDiv).height());
                return ret;
            }, getColumnHeaderIndex = function(th) {
                var i, headers = ts.grid.headers, ci = $.jgrid.getCellIndex(th);
                for (i = 0; i < headers.length; i++) {
                    if (th === headers[i].el) {
                        ci = i;
                        break;
                    }
                }
                return ci;
            };
            this.p.id = this.id;
            if ($.inArray(ts.p.multikey, sortkeys) == -1) {
                ts.p.multikey = false;
            }
            ts.p.keyIndex = false;
            for (i = 0; i < ts.p.colModel.length; i++) {
                ts.p.colModel[i] = $.extend(true, {}, ts.p.cmTemplate, ts.p.colModel[i].template || {}, ts.p.colModel[i]);
                if (ts.p.keyIndex === false && ts.p.colModel[i].key === true) {
                    ts.p.keyIndex = i;
                }
            }
            ts.p.sortorder = ts.p.sortorder.toLowerCase();
            $.jgrid.cell_width = $.jgrid.cellWidth();
            if (ts.p.grouping === true) {
                ts.p.scroll = false;
                ts.p.rownumbers = false;
                ts.p.treeGrid = false;
                ts.p.gridview = true;
            }
            if (this.p.treeGrid === true) {
                try {
                    $(this).jqGrid("setTreeGrid");
                } catch (_) {}
                if (ts.p.datatype != "local") {
                    ts.p.localReader = {
                        "id": "_id_"
                    };
                }
            }
            if (this.p.subGrid) {
                try {
                    $(ts).jqGrid("setSubGrid");
                } catch (s) {}
            }
            if (this.p.multiselect) {
                this.p.colNames.unshift("<input role='checkbox' id='cb_" + this.p.id + "' class='cbox' type='checkbox'/>");
                this.p.colModel.unshift({
                    "name": "cb",
                    "width": $.jgrid.cell_width ? ts.p.multiselectWidth + ts.p.cellLayout : ts.p.multiselectWidth,
                    "sortable": false,
                    "resizable": false,
                    "hidedlg": true,
                    "search": false,
                    "align": "center",
                    "fixed": true
                });
            }
            if (this.p.rownumbers) {
                this.p.colNames.unshift("");
                this.p.colModel.unshift({
                    "name": "rn",
                    "width": ts.p.rownumWidth,
                    "sortable": false,
                    "resizable": false,
                    "hidedlg": true,
                    "search": false,
                    "align": "center",
                    "fixed": true
                });
            }
            ts.p.xmlReader = $.extend(true, {
                "root": "rows",
                "row": "row",
                "page": "rows>page",
                "total": "rows>total",
                "records": "rows>records",
                "repeatitems": true,
                "cell": "cell",
                "id": "[id]",
                "userdata": "userdata",
                "subgrid": {
                    "root": "rows",
                    "row": "row",
                    "repeatitems": true,
                    "cell": "cell"
                }
            }, ts.p.xmlReader);
            ts.p.jsonReader = $.extend(true, {
                "root": "rows",
                "page": "page",
                "total": "total",
                "records": "records",
                "repeatitems": true,
                "cell": "cell",
                "id": "id",
                "userdata": "userdata",
                "subgrid": {
                    "root": "rows",
                    "repeatitems": true,
                    "cell": "cell"
                }
            }, ts.p.jsonReader);
            ts.p.localReader = $.extend(true, {
                "root": "rows",
                "page": "page",
                "total": "total",
                "records": "records",
                "repeatitems": false,
                "cell": "cell",
                "id": "id",
                "userdata": "userdata",
                "subgrid": {
                    "root": "rows",
                    "repeatitems": true,
                    "cell": "cell"
                }
            }, ts.p.localReader);
            if (ts.p.scroll) {
                ts.p.pgbuttons = false;
                ts.p.pginput = false;
                ts.p.rowList = [];
            }
            if (ts.p.data.length) {
                refreshIndex();
            }
            var thead = "<thead><tr class='ui-jqgrid-labels' role='rowheader'>", tdc, idn, w, res, sort, td, ptr, tbody, imgs, iac = "", idc = "";
            if (ts.p.shrinkToFit === true && ts.p.forceFit === true) {
                for (i = ts.p.colModel.length - 1; i >= 0; i--) {
                    if (!ts.p.colModel[i].hidden) {
                        ts.p.colModel[i].resizable = false;
                        break;
                    }
                }
            }
            if (ts.p.viewsortcols[1] == "horizontal") {
                iac = " ui-i-asc";
                idc = " ui-i-desc";
            }
            tdc = isMSIE ? "class='ui-th-div-ie'" : "";
            imgs = "<span class='s-ico' style='display:none'><span sort='asc' class='ui-grid-ico-sort ui-icon-asc" + iac + " ui-state-disabled ui-icon ui-icon-triangle-1-n ui-sort-" + dir + "'></span>";
            imgs += "<span sort='desc' class='ui-grid-ico-sort ui-icon-desc" + idc + " ui-state-disabled ui-icon ui-icon-triangle-1-s ui-sort-" + dir + "'></span></span>";
            for (i = 0; i < this.p.colNames.length; i++) {
                var tooltip = ts.p.headertitles ? ' title="' + $.jgrid.stripHtml(ts.p.colNames[i]) + '"' : "";
                thead += "<th id='" + ts.p.id + "_" + ts.p.colModel[i].name + "' role='columnheader' class='ui-state-default ui-th-column ui-th-" + dir + "'" + tooltip + ">";
                idn = ts.p.colModel[i].index || ts.p.colModel[i].name;
                thead += "<div id='jqgh_" + ts.p.id + "_" + ts.p.colModel[i].name + "' " + tdc + ">" + ts.p.colNames[i];
                if (!ts.p.colModel[i].width) {
                    ts.p.colModel[i].width = 150;
                } else {
                    ts.p.colModel[i].width = parseInt(ts.p.colModel[i].width, 10);
                }
                if (typeof ts.p.colModel[i].title !== "boolean") {
                    ts.p.colModel[i].title = true;
                }
                if (idn == ts.p.sortname) {
                    ts.p.lastsort = i;
                }
                thead += imgs + "</div></th>";
            }
            thead += "</tr></thead>";
            imgs = null;
            $(this).append(thead);
            $("thead tr:first th", this).hover(function() {
                $(this).addClass("ui-state-hover");
            }, function() {
                $(this).removeClass("ui-state-hover");
            });
            if (this.p.multiselect) {
                var emp = [], chk;
                $("#cb_" + $.jgrid.jqID(ts.p.id), this).bind("click", function() {
                    ts.p.selarrrow = [];
                    var froz = ts.p.frozenColumns === true ? ts.p.id + "_frozen" : "";
                    if (this.checked) {
                        $(ts.rows).each(function(i) {
                            if (i > 0) {
                                if (!$(this).hasClass("ui-subgrid") && !$(this).hasClass("jqgroup") && !$(this).hasClass("ui-state-disabled")) {
                                    $("#jqg_" + $.jgrid.jqID(ts.p.id) + "_" + $.jgrid.jqID(this.id))[ts.p.useProp ? "prop" : "attr"]("checked", true);
                                    $(this).addClass("ui-state-highlight").attr("aria-selected", "true");
                                    ts.p.selarrrow.push(this.id);
                                    ts.p.selrow = this.id;
                                    if (froz) {
                                        $("#jqg_" + $.jgrid.jqID(ts.p.id) + "_" + $.jgrid.jqID(this.id), ts.grid.fbDiv)[ts.p.useProp ? "prop" : "attr"]("checked", true);
                                        $("#" + $.jgrid.jqID(this.id), ts.grid.fbDiv).addClass("ui-state-highlight");
                                    }
                                }
                            }
                        });
                        chk = true;
                        emp = [];
                    } else {
                        $(ts.rows).each(function(i) {
                            if (i > 0) {
                                if (!$(this).hasClass("ui-subgrid") && !$(this).hasClass("ui-state-disabled")) {
                                    $("#jqg_" + $.jgrid.jqID(ts.p.id) + "_" + $.jgrid.jqID(this.id))[ts.p.useProp ? "prop" : "attr"]("checked", false);
                                    $(this).removeClass("ui-state-highlight").attr("aria-selected", "false");
                                    emp.push(this.id);
                                    if (froz) {
                                        $("#jqg_" + $.jgrid.jqID(ts.p.id) + "_" + $.jgrid.jqID(this.id), ts.grid.fbDiv)[ts.p.useProp ? "prop" : "attr"]("checked", false);
                                        $("#" + $.jgrid.jqID(this.id), ts.grid.fbDiv).removeClass("ui-state-highlight");
                                    }
                                }
                            }
                        });
                        ts.p.selrow = null;
                        chk = false;
                    }
                    $(ts).triggerHandler("jqGridSelectAll", [ chk ? ts.p.selarrrow : emp, chk ]);
                    if ($.isFunction(ts.p.onSelectAll)) {
                        ts.p.onSelectAll.call(ts, chk ? ts.p.selarrrow : emp, chk);
                    }
                });
            }
            if (ts.p.autowidth === true) {
                var pw = $(eg).innerWidth();
                ts.p.width = pw > 0 ? pw : "nw";
            }
            setColWidth();
            $(eg).css("width", grid.width + "px").append("<div class='ui-jqgrid-resize-mark' id='rs_m" + ts.p.id + "'>&#160;</div>");
            $(gv).css("width", grid.width + "px");
            thead = $("thead:first", ts).get(0);
            var tfoot = "";
            if (ts.p.footerrow) {
                tfoot += "<table role='grid' style='width:" + ts.p.tblwidth + "px' class='ui-jqgrid-ftable' cellspacing='0' cellpadding='0' border='0'><tbody><tr role='row' class='ui-widget-content footrow footrow-" + dir + "'>";
            }
            var thr = $("tr:first", thead), firstr = "<tr class='jqgfirstrow' role='row' style='height:auto'>";
            ts.p.disableClick = false;
            $("th", thr).each(function(j) {
                w = ts.p.colModel[j].width;
                if (ts.p.colModel[j].resizable === undefined) {
                    ts.p.colModel[j].resizable = true;
                }
                if (ts.p.colModel[j].resizable) {
                    res = document.createElement("span");
                    $(res).html("&#160;").addClass("ui-jqgrid-resize ui-jqgrid-resize-" + dir).css("cursor", "col-resize");
                    $(this).addClass(ts.p.resizeclass);
                } else {
                    res = "";
                }
                $(this).css("width", w + "px").prepend(res);
                var hdcol = "";
                if (ts.p.colModel[j].hidden) {
                    $(this).css("display", "none");
                    hdcol = "display:none;";
                }
                firstr += "<td role='gridcell' style='height:0px;width:" + w + "px;" + hdcol + "'></td>";
                grid.headers[j] = {
                    "width": w,
                    "el": this
                };
                sort = ts.p.colModel[j].sortable;
                if (typeof sort !== "boolean") {
                    ts.p.colModel[j].sortable = true;
                    sort = true;
                }
                var nm = ts.p.colModel[j].name;
                if (!(nm == "cb" || nm == "subgrid" || nm == "rn")) {
                    if (ts.p.viewsortcols[2]) {
                        $(">div", this).addClass("ui-jqgrid-sortable");
                    }
                }
                if (sort) {
                    if (ts.p.viewsortcols[0]) {
                        $("div span.s-ico", this).show();
                        if (j == ts.p.lastsort) {
                            $("div span.ui-icon-" + ts.p.sortorder, this).removeClass("ui-state-disabled");
                        }
                    } else if (j == ts.p.lastsort) {
                        $("div span.s-ico", this).show();
                        $("div span.ui-icon-" + ts.p.sortorder, this).removeClass("ui-state-disabled");
                    }
                }
                if (ts.p.footerrow) {
                    tfoot += "<td role='gridcell' " + formatCol(j, 0, "", null, "", false) + ">&#160;</td>";
                }
            }).mousedown(function(e) {
                if ($(e.target).closest("th>span.ui-jqgrid-resize").length != 1) {
                    return;
                }
                var ci = getColumnHeaderIndex(this);
                if (ts.p.forceFit === true) {
                    ts.p.nv = nextVisible(ci);
                }
                grid.dragStart(ci, e, getOffset(ci));
                return false;
            }).click(function(e) {
                if (ts.p.disableClick) {
                    ts.p.disableClick = false;
                    return false;
                }
                var s = "th>div.ui-jqgrid-sortable", r, d;
                if (!ts.p.viewsortcols[2]) {
                    s = "th>div>span>span.ui-grid-ico-sort";
                }
                var t = $(e.target).closest(s);
                if (t.length != 1) {
                    return;
                }
                var ci = getColumnHeaderIndex(this);
                if (!ts.p.viewsortcols[2]) {
                    r = true;
                    d = t.attr("sort");
                }
                sortData($("div", this)[0].id, ci, r, d);
                return false;
            });
            if (ts.p.sortable && $.fn.sortable) {
                try {
                    $(ts).jqGrid("sortableColumns", thr);
                } catch (e) {}
            }
            if (ts.p.footerrow) {
                tfoot += "</tr></tbody></table>";
            }
            firstr += "</tr>";
            tbody = document.createElement("tbody");
            this.appendChild(tbody);
            $(this).addClass("ui-jqgrid-btable").append(firstr);
            firstr = null;
            var hTable = $("<table class='ui-jqgrid-htable' style='width:" + ts.p.tblwidth + "px' role='grid' aria-labelledby='gbox_" + this.id + "' cellspacing='0' cellpadding='0' border='0'></table>").append(thead), hg = ts.p.caption && ts.p.hiddengrid === true ? true : false, hb = $("<div class='ui-jqgrid-hbox" + (dir == "rtl" ? "-rtl" : "") + "'></div>");
            thead = null;
            grid.hDiv = document.createElement("div");
            $(grid.hDiv).css({
                "width": grid.width + "px"
            }).addClass("ui-state-default ui-jqgrid-hdiv").append(hb);
            $(hb).append(hTable);
            hTable = null;
            if (hg) {
                $(grid.hDiv).hide();
            }
            if (ts.p.pager) {
                if (typeof ts.p.pager === "string") {
                    if (ts.p.pager.substr(0, 1) != "#") {
                        ts.p.pager = "#" + ts.p.pager;
                    }
                } else {
                    ts.p.pager = "#" + $(ts.p.pager).attr("id");
                }
                $(ts.p.pager).css({
                    "width": grid.width + "px"
                }).addClass("ui-state-default ui-jqgrid-pager ui-corner-bottom").appendTo(eg);
                if (hg) {
                    $(ts.p.pager).hide();
                }
                setPager(ts.p.pager, "");
            }
            if (ts.p.cellEdit === false && ts.p.hoverrows === true) {
                $(ts).bind("mouseover", function(e) {
                    ptr = $(e.target).closest("tr.jqgrow");
                    if ($(ptr).attr("class") !== "ui-subgrid") {
                        $(ptr).addClass("ui-state-hover");
                    }
                }).bind("mouseout", function(e) {
                    ptr = $(e.target).closest("tr.jqgrow");
                    $(ptr).removeClass("ui-state-hover");
                });
            }
            var ri, ci, tdHtml;
            $(ts).before(grid.hDiv).click(function(e) {
                td = e.target;
                ptr = $(td, ts.rows).closest("tr.jqgrow");
                if ($(ptr).length === 0 || ptr[0].className.indexOf("ui-state-disabled") > -1 || ($(td, ts).closest("table.ui-jqgrid-btable").attr("id") || "").replace("_frozen", "") !== ts.id) {
                    return this;
                }
                var scb = $(td).hasClass("cbox"), cSel = $(ts).triggerHandler("jqGridBeforeSelectRow", [ ptr[0].id, e ]);
                cSel = cSel === false || cSel === "stop" ? false : true;
                if (cSel && $.isFunction(ts.p.beforeSelectRow)) {
                    cSel = ts.p.beforeSelectRow.call(ts, ptr[0].id, e);
                }
                if (td.tagName == "A" || (td.tagName == "INPUT" || td.tagName == "TEXTAREA" || td.tagName == "OPTION" || td.tagName == "SELECT") && !scb) {
                    return;
                }
                if (cSel === true) {
                    ri = ptr[0].id;
                    ci = $.jgrid.getCellIndex(td);
                    tdHtml = $(td).closest("td,th").html();
                    $(ts).triggerHandler("jqGridCellSelect", [ ri, ci, tdHtml, e ]);
                    if ($.isFunction(ts.p.onCellSelect)) {
                        ts.p.onCellSelect.call(ts, ri, ci, tdHtml, e);
                    }
                    if (ts.p.cellEdit === true) {
                        if (ts.p.multiselect && scb) {
                            $(ts).jqGrid("setSelection", ri, true, e);
                        } else {
                            ri = ptr[0].rowIndex;
                            try {
                                $(ts).jqGrid("editCell", ri, ci, true);
                            } catch (_) {}
                        }
                    } else if (!ts.p.multikey) {
                        if (ts.p.multiselect && ts.p.multiboxonly) {
                            if (scb) {
                                $(ts).jqGrid("setSelection", ri, true, e);
                            } else {
                                var frz = ts.p.frozenColumns ? ts.p.id + "_frozen" : "";
                                $(ts.p.selarrrow).each(function(i, n) {
                                    var ind = ts.rows.namedItem(n);
                                    $(ind).removeClass("ui-state-highlight");
                                    $("#jqg_" + $.jgrid.jqID(ts.p.id) + "_" + $.jgrid.jqID(n))[ts.p.useProp ? "prop" : "attr"]("checked", false);
                                    if (frz) {
                                        $("#" + $.jgrid.jqID(n), "#" + $.jgrid.jqID(frz)).removeClass("ui-state-highlight");
                                        $("#jqg_" + $.jgrid.jqID(ts.p.id) + "_" + $.jgrid.jqID(n), "#" + $.jgrid.jqID(frz))[ts.p.useProp ? "prop" : "attr"]("checked", false);
                                    }
                                });
                                ts.p.selarrrow = [];
                                $(ts).jqGrid("setSelection", ri, true, e);
                            }
                        } else {
                            $(ts).jqGrid("setSelection", ri, true, e);
                        }
                    } else {
                        if (e[ts.p.multikey]) {
                            $(ts).jqGrid("setSelection", ri, true, e);
                        } else if (ts.p.multiselect && scb) {
                            scb = $("#jqg_" + $.jgrid.jqID(ts.p.id) + "_" + ri).is(":checked");
                            $("#jqg_" + $.jgrid.jqID(ts.p.id) + "_" + ri)[ts.p.useProp ? "prop" : "attr"]("checked", scb);
                        }
                    }
                }
            }).bind("reloadGrid", function(e, opts) {
                if (ts.p.treeGrid === true) {
                    ts.p.datatype = ts.p.treedatatype;
                }
                if (opts && opts.current) {
                    ts.grid.selectionPreserver(ts);
                }
                if (ts.p.datatype == "local") {
                    $(ts).jqGrid("resetSelection");
                    if (ts.p.data.length) {
                        refreshIndex();
                    }
                } else if (!ts.p.treeGrid) {
                    ts.p.selrow = null;
                    if (ts.p.multiselect) {
                        ts.p.selarrrow = [];
                        setHeadCheckBox(false);
                    }
                    ts.p.savedRow = [];
                }
                if (ts.p.scroll) {
                    emptyRows.call(ts, true, false);
                }
                if (opts && opts.page) {
                    var page = opts.page;
                    if (page > ts.p.lastpage) {
                        page = ts.p.lastpage;
                    }
                    if (page < 1) {
                        page = 1;
                    }
                    ts.p.page = page;
                    if (ts.grid.prevRowHeight) {
                        ts.grid.bDiv.scrollTop = (page - 1) * ts.grid.prevRowHeight * ts.p.rowNum;
                    } else {
                        ts.grid.bDiv.scrollTop = 0;
                    }
                }
                if (ts.grid.prevRowHeight && ts.p.scroll) {
                    delete ts.p.lastpage;
                    ts.grid.populateVisible();
                } else {
                    ts.grid.populate();
                }
                if (ts.p._inlinenav === true) {
                    $(ts).jqGrid("showAddEditButtons");
                }
                return false;
            }).dblclick(function(e) {
                td = e.target;
                ptr = $(td, ts.rows).closest("tr.jqgrow");
                if ($(ptr).length === 0) {
                    return;
                }
                ri = ptr[0].rowIndex;
                ci = $.jgrid.getCellIndex(td);
                $(ts).triggerHandler("jqGridDblClickRow", [ $(ptr).attr("id"), ri, ci, e ]);
                if ($.isFunction(this.p.ondblClickRow)) {
                    ts.p.ondblClickRow.call(ts, $(ptr).attr("id"), ri, ci, e);
                }
            }).bind("contextmenu", function(e) {
                td = e.target;
                ptr = $(td, ts.rows).closest("tr.jqgrow");
                if ($(ptr).length === 0) {
                    return;
                }
                if (!ts.p.multiselect) {
                    $(ts).jqGrid("setSelection", ptr[0].id, true, e);
                }
                ri = ptr[0].rowIndex;
                ci = $.jgrid.getCellIndex(td);
                $(ts).triggerHandler("jqGridRightClickRow", [ $(ptr).attr("id"), ri, ci, e ]);
                if ($.isFunction(this.p.onRightClickRow)) {
                    ts.p.onRightClickRow.call(ts, $(ptr).attr("id"), ri, ci, e);
                }
            });
            grid.bDiv = document.createElement("div");
            if (isMSIE) {
                if (String(ts.p.height).toLowerCase() === "auto") {
                    ts.p.height = "100%";
                }
            }
            $(grid.bDiv).append($('<div style="position:relative;' + (isMSIE && $.jgrid.msiever() < 8 ? "height:0.01%;" : "") + '"></div>').append("<div></div>").append(this)).addClass("ui-jqgrid-bdiv").css({
                "height": ts.p.height + (isNaN(ts.p.height) ? "" : "px"),
                "width": grid.width + "px"
            }).scroll(grid.scrollGrid);
            $("table:first", grid.bDiv).css({
                "width": ts.p.tblwidth + "px"
            });
            if (!$.support.tbody) {
                if ($("tbody", this).length == 2) {
                    $("tbody:gt(0)", this).remove();
                }
            }
            if (ts.p.multikey) {
                if ($.jgrid.msie) {
                    $(grid.bDiv).bind("selectstart", function() {
                        return false;
                    });
                } else {
                    $(grid.bDiv).bind("mousedown", function() {
                        return false;
                    });
                }
            }
            if (hg) {
                $(grid.bDiv).hide();
            }
            grid.cDiv = document.createElement("div");
            var arf = ts.p.hidegrid === true ? $("<a role='link' href='javascript:void(0)'/>").addClass("ui-jqgrid-titlebar-close HeaderButton").hover(function() {
                arf.addClass("ui-state-hover");
            }, function() {
                arf.removeClass("ui-state-hover");
            }).append("<span class='ui-icon ui-icon-circle-triangle-n'></span>").css(dir == "rtl" ? "left" : "right", "0px") : "";
            $(grid.cDiv).append(arf).append("<span class='ui-jqgrid-title" + (dir == "rtl" ? "-rtl" : "") + "'>" + ts.p.caption + "</span>").addClass("ui-jqgrid-titlebar ui-widget-header ui-corner-top ui-helper-clearfix");
            $(grid.cDiv).insertBefore(grid.hDiv);
            if (ts.p.toolbar[0]) {
                grid.uDiv = document.createElement("div");
                if (ts.p.toolbar[1] == "top") {
                    $(grid.uDiv).insertBefore(grid.hDiv);
                } else if (ts.p.toolbar[1] == "bottom") {
                    $(grid.uDiv).insertAfter(grid.hDiv);
                }
                if (ts.p.toolbar[1] == "both") {
                    grid.ubDiv = document.createElement("div");
                    $(grid.uDiv).addClass("ui-userdata ui-state-default").attr("id", "t_" + this.id).insertBefore(grid.hDiv);
                    $(grid.ubDiv).addClass("ui-userdata ui-state-default").attr("id", "tb_" + this.id).insertAfter(grid.hDiv);
                    if (hg) {
                        $(grid.ubDiv).hide();
                    }
                } else {
                    $(grid.uDiv).width(grid.width).addClass("ui-userdata ui-state-default").attr("id", "t_" + this.id);
                }
                if (hg) {
                    $(grid.uDiv).hide();
                }
            }
            if (ts.p.toppager) {
                ts.p.toppager = $.jgrid.jqID(ts.p.id) + "_toppager";
                grid.topDiv = $("<div id='" + ts.p.toppager + "'></div>")[0];
                ts.p.toppager = "#" + ts.p.toppager;
                $(grid.topDiv).addClass("ui-state-default ui-jqgrid-toppager").width(grid.width).insertBefore(grid.hDiv);
                setPager(ts.p.toppager, "_t");
            }
            if (ts.p.footerrow) {
                grid.sDiv = $("<div class='ui-jqgrid-sdiv'></div>")[0];
                hb = $("<div class='ui-jqgrid-hbox" + (dir == "rtl" ? "-rtl" : "") + "'></div>");
                $(grid.sDiv).append(hb).width(grid.width).insertAfter(grid.hDiv);
                $(hb).append(tfoot);
                grid.footers = $(".ui-jqgrid-ftable", grid.sDiv)[0].rows[0].cells;
                if (ts.p.rownumbers) {
                    grid.footers[0].className = "ui-state-default jqgrid-rownum";
                }
                if (hg) {
                    $(grid.sDiv).hide();
                }
            }
            hb = null;
            if (ts.p.caption) {
                var tdt = ts.p.datatype;
                if (ts.p.hidegrid === true) {
                    $(".ui-jqgrid-titlebar-close", grid.cDiv).click(function(e) {
                        var onHdCl = $.isFunction(ts.p.onHeaderClick), elems = ".ui-jqgrid-bdiv, .ui-jqgrid-hdiv, .ui-jqgrid-pager, .ui-jqgrid-sdiv", counter, self = this;
                        if (ts.p.toolbar[0] === true) {
                            if (ts.p.toolbar[1] == "both") {
                                elems += ", #" + $(grid.ubDiv).attr("id");
                            }
                            elems += ", #" + $(grid.uDiv).attr("id");
                        }
                        counter = $(elems, "#gview_" + $.jgrid.jqID(ts.p.id)).length;
                        if (ts.p.gridstate == "visible") {
                            $(elems, "#gbox_" + $.jgrid.jqID(ts.p.id)).slideUp("fast", function() {
                                counter--;
                                if (counter === 0) {
                                    $("span", self).removeClass("ui-icon-circle-triangle-n").addClass("ui-icon-circle-triangle-s");
                                    ts.p.gridstate = "hidden";
                                    if ($("#gbox_" + $.jgrid.jqID(ts.p.id)).hasClass("ui-resizable")) {
                                        $(".ui-resizable-handle", "#gbox_" + $.jgrid.jqID(ts.p.id)).hide();
                                    }
                                    $(ts).triggerHandler("jqGridHeaderClick", [ ts.p.gridstate, e ]);
                                    if (onHdCl) {
                                        if (!hg) {
                                            ts.p.onHeaderClick.call(ts, ts.p.gridstate, e);
                                        }
                                    }
                                }
                            });
                        } else if (ts.p.gridstate == "hidden") {
                            $(elems, "#gbox_" + $.jgrid.jqID(ts.p.id)).slideDown("fast", function() {
                                counter--;
                                if (counter === 0) {
                                    $("span", self).removeClass("ui-icon-circle-triangle-s").addClass("ui-icon-circle-triangle-n");
                                    if (hg) {
                                        ts.p.datatype = tdt;
                                        populate();
                                        hg = false;
                                    }
                                    ts.p.gridstate = "visible";
                                    if ($("#gbox_" + $.jgrid.jqID(ts.p.id)).hasClass("ui-resizable")) {
                                        $(".ui-resizable-handle", "#gbox_" + $.jgrid.jqID(ts.p.id)).show();
                                    }
                                    $(ts).triggerHandler("jqGridHeaderClick", [ ts.p.gridstate, e ]);
                                    if (onHdCl) {
                                        if (!hg) {
                                            ts.p.onHeaderClick.call(ts, ts.p.gridstate, e);
                                        }
                                    }
                                }
                            });
                        }
                        return false;
                    });
                    if (hg) {
                        ts.p.datatype = "local";
                        $(".ui-jqgrid-titlebar-close", grid.cDiv).trigger("click");
                    }
                }
            } else {
                $(grid.cDiv).hide();
            }
            $(grid.hDiv).after(grid.bDiv).mousemove(function(e) {
                if (grid.resizing) {
                    grid.dragMove(e);
                    return false;
                }
            });
            $(".ui-jqgrid-labels", grid.hDiv).bind("selectstart", function() {
                return false;
            });
            $(document).mouseup(function() {
                if (grid.resizing) {
                    grid.dragEnd();
                    return false;
                }
                return true;
            });
            ts.formatCol = formatCol;
            ts.sortData = sortData;
            ts.updatepager = updatepager;
            ts.refreshIndex = refreshIndex;
            ts.setHeadCheckBox = setHeadCheckBox;
            ts.constructTr = constructTr;
            ts.formatter = function(rowId, cellval, colpos, rwdat, act) {
                return formatter(rowId, cellval, colpos, rwdat, act);
            };
            $.extend(grid, {
                "populate": populate,
                "emptyRows": emptyRows
            });
            this.grid = grid;
            ts.addXmlData = function(d) {
                addXmlData(d, ts.grid.bDiv);
            };
            ts.addJSONData = function(d) {
                addJSONData(d, ts.grid.bDiv);
            };
            this.grid.cols = this.rows[0].cells;
            $(ts).triggerHandler("jqGridInitGrid");
            if ($.isFunction(ts.p.onInitGrid)) {
                ts.p.onInitGrid.call(ts);
            }
            populate();
            ts.p.hiddengrid = false;
        });
    };
    $.jgrid.extend({
        "getGridParam": function(pName) {
            var $t = this[0];
            if (!$t || !$t.grid) {
                return;
            }
            if (!pName) {
                return $t.p;
            }
            return $t.p[pName] !== undefined ? $t.p[pName] : null;
        },
        "setGridParam": function(newParams) {
            return this.each(function() {
                if (this.grid && typeof newParams === "object") {
                    $.extend(true, this.p, newParams);
                }
            });
        },
        "getDataIDs": function() {
            var ids = [], i = 0, len, j = 0;
            this.each(function() {
                len = this.rows.length;
                if (len && len > 0) {
                    while (i < len) {
                        if ($(this.rows[i]).hasClass("jqgrow")) {
                            ids[j] = this.rows[i].id;
                            j++;
                        }
                        i++;
                    }
                }
            });
            return ids;
        },
        "setSelection": function(selection, onsr, e) {
            return this.each(function() {
                var $t = this, stat, pt, ner, ia, tpsr, fid;
                if (selection === undefined) {
                    return;
                }
                onsr = onsr === false ? false : true;
                pt = $t.rows.namedItem(String(selection));
                if (!pt || !pt.className || pt.className.indexOf("ui-state-disabled") > -1) {
                    return;
                }
                function scrGrid(iR) {
                    var ch = $($t.grid.bDiv)[0].clientHeight, st = $($t.grid.bDiv)[0].scrollTop, rpos = $($t.rows[iR]).position().top, rh = $t.rows[iR].clientHeight;
                    if (rpos + rh >= ch + st) {
                        $($t.grid.bDiv)[0].scrollTop = rpos - (ch + st) + rh + st;
                    } else if (rpos < ch + st) {
                        if (rpos < st) {
                            $($t.grid.bDiv)[0].scrollTop = rpos;
                        }
                    }
                }
                if ($t.p.scrollrows === true) {
                    ner = $t.rows.namedItem(selection).rowIndex;
                    if (ner >= 0) {
                        scrGrid(ner);
                    }
                }
                if ($t.p.frozenColumns === true) {
                    fid = $t.p.id + "_frozen";
                }
                if (!$t.p.multiselect) {
                    if (pt.className !== "ui-subgrid") {
                        if ($t.p.selrow != pt.id) {
                            $($t.rows.namedItem($t.p.selrow)).removeClass("ui-state-highlight").attr({
                                "aria-selected": "false",
                                "tabindex": "-1"
                            });
                            $(pt).addClass("ui-state-highlight").attr({
                                "aria-selected": "true",
                                "tabindex": "0"
                            });
                            if (fid) {
                                $("#" + $.jgrid.jqID($t.p.selrow), "#" + $.jgrid.jqID(fid)).removeClass("ui-state-highlight");
                                $("#" + $.jgrid.jqID(selection), "#" + $.jgrid.jqID(fid)).addClass("ui-state-highlight");
                            }
                            stat = true;
                        } else {
                            stat = false;
                        }
                        $t.p.selrow = pt.id;
                        $($t).triggerHandler("jqGridSelectRow", [ pt.id, stat, e ]);
                        if ($t.p.onSelectRow && onsr) {
                            $t.p.onSelectRow.call($t, pt.id, stat, e);
                        }
                    }
                } else {
                    $t.setHeadCheckBox(false);
                    $t.p.selrow = pt.id;
                    ia = $.inArray($t.p.selrow, $t.p.selarrrow);
                    if (ia === -1) {
                        if (pt.className !== "ui-subgrid") {
                            $(pt).addClass("ui-state-highlight").attr("aria-selected", "true");
                        }
                        stat = true;
                        $t.p.selarrrow.push($t.p.selrow);
                    } else {
                        if (pt.className !== "ui-subgrid") {
                            $(pt).removeClass("ui-state-highlight").attr("aria-selected", "false");
                        }
                        stat = false;
                        $t.p.selarrrow.splice(ia, 1);
                        tpsr = $t.p.selarrrow[0];
                        $t.p.selrow = tpsr === undefined ? null : tpsr;
                    }
                    $("#jqg_" + $.jgrid.jqID($t.p.id) + "_" + $.jgrid.jqID(pt.id))[$t.p.useProp ? "prop" : "attr"]("checked", stat);
                    if (fid) {
                        if (ia === -1) {
                            $("#" + $.jgrid.jqID(selection), "#" + $.jgrid.jqID(fid)).addClass("ui-state-highlight");
                        } else {
                            $("#" + $.jgrid.jqID(selection), "#" + $.jgrid.jqID(fid)).removeClass("ui-state-highlight");
                        }
                        $("#jqg_" + $.jgrid.jqID($t.p.id) + "_" + $.jgrid.jqID(selection), "#" + $.jgrid.jqID(fid))[$t.p.useProp ? "prop" : "attr"]("checked", stat);
                    }
                    $($t).triggerHandler("jqGridSelectRow", [ pt.id, stat, e ]);
                    if ($t.p.onSelectRow && onsr) {
                        $t.p.onSelectRow.call($t, pt.id, stat, e);
                    }
                }
            });
        },
        "resetSelection": function(rowid) {
            return this.each(function() {
                var t = this, ind, sr, fid;
                if (t.p.frozenColumns === true) {
                    fid = t.p.id + "_frozen";
                }
                if (rowid !== undefined) {
                    sr = rowid === t.p.selrow ? t.p.selrow : rowid;
                    $("#" + $.jgrid.jqID(t.p.id) + " tbody:first tr#" + $.jgrid.jqID(sr)).removeClass("ui-state-highlight").attr("aria-selected", "false");
                    if (fid) {
                        $("#" + $.jgrid.jqID(sr), "#" + $.jgrid.jqID(fid)).removeClass("ui-state-highlight");
                    }
                    if (t.p.multiselect) {
                        $("#jqg_" + $.jgrid.jqID(t.p.id) + "_" + $.jgrid.jqID(sr), "#" + $.jgrid.jqID(t.p.id))[t.p.useProp ? "prop" : "attr"]("checked", false);
                        if (fid) {
                            $("#jqg_" + $.jgrid.jqID(t.p.id) + "_" + $.jgrid.jqID(sr), "#" + $.jgrid.jqID(fid))[t.p.useProp ? "prop" : "attr"]("checked", false);
                        }
                        t.setHeadCheckBox(false);
                    }
                    sr = null;
                } else if (!t.p.multiselect) {
                    if (t.p.selrow) {
                        $("#" + $.jgrid.jqID(t.p.id) + " tbody:first tr#" + $.jgrid.jqID(t.p.selrow)).removeClass("ui-state-highlight").attr("aria-selected", "false");
                        if (fid) {
                            $("#" + $.jgrid.jqID(t.p.selrow), "#" + $.jgrid.jqID(fid)).removeClass("ui-state-highlight");
                        }
                        t.p.selrow = null;
                    }
                } else {
                    $(t.p.selarrrow).each(function(i, n) {
                        ind = t.rows.namedItem(n);
                        $(ind).removeClass("ui-state-highlight").attr("aria-selected", "false");
                        $("#jqg_" + $.jgrid.jqID(t.p.id) + "_" + $.jgrid.jqID(n))[t.p.useProp ? "prop" : "attr"]("checked", false);
                        if (fid) {
                            $("#" + $.jgrid.jqID(n), "#" + $.jgrid.jqID(fid)).removeClass("ui-state-highlight");
                            $("#jqg_" + $.jgrid.jqID(t.p.id) + "_" + $.jgrid.jqID(n), "#" + $.jgrid.jqID(fid))[t.p.useProp ? "prop" : "attr"]("checked", false);
                        }
                    });
                    t.setHeadCheckBox(false);
                    t.p.selarrrow = [];
                }
                if (t.p.cellEdit === true) {
                    if (parseInt(t.p.iCol, 10) >= 0 && parseInt(t.p.iRow, 10) >= 0) {
                        $("td:eq(" + t.p.iCol + ")", t.rows[t.p.iRow]).removeClass("edit-cell ui-state-highlight");
                        $(t.rows[t.p.iRow]).removeClass("selected-row ui-state-hover");
                    }
                }
                t.p.savedRow = [];
            });
        },
        "getRowData": function(rowid) {
            var res = {}, resall, getall = false, len, j = 0;
            this.each(function() {
                var $t = this, nm, ind;
                if (rowid === undefined) {
                    getall = true;
                    resall = [];
                    len = $t.rows.length;
                } else {
                    ind = $t.rows.namedItem(rowid);
                    if (!ind) {
                        return res;
                    }
                    len = 2;
                }
                while (j < len) {
                    if (getall) {
                        ind = $t.rows[j];
                    }
                    if ($(ind).hasClass("jqgrow")) {
                        $('td[role="gridcell"]', ind).each(function(i) {
                            nm = $t.p.colModel[i].name;
                            if (nm !== "cb" && nm !== "subgrid" && nm !== "rn") {
                                if ($t.p.treeGrid === true && nm == $t.p.ExpandColumn) {
                                    res[nm] = $.jgrid.htmlDecode($("span:first", this).html());
                                } else {
                                    try {
                                        res[nm] = $.unformat.call($t, this, {
                                            "rowId": ind.id,
                                            "colModel": $t.p.colModel[i]
                                        }, i);
                                    } catch (e) {
                                        res[nm] = $.jgrid.htmlDecode($(this).html());
                                    }
                                }
                            }
                        });
                        if (getall) {
                            resall.push(res);
                            res = {};
                        }
                    }
                    j++;
                }
            });
            return resall || res;
        },
        "delRowData": function(rowid) {
            var success = false, rowInd, ia, ri;
            this.each(function() {
                var $t = this;
                rowInd = $t.rows.namedItem(rowid);
                if (!rowInd) {
                    return false;
                }
                ri = rowInd.rowIndex;
                $(rowInd).remove();
                $t.p.records--;
                $t.p.reccount--;
                $t.updatepager(true, false);
                success = true;
                if ($t.p.multiselect) {
                    ia = $.inArray(rowid, $t.p.selarrrow);
                    if (ia != -1) {
                        $t.p.selarrrow.splice(ia, 1);
                    }
                }
                if ($t.p.multiselect && $t.p.selarrrow.length > 0) {
                    $t.p.selrow = $t.p.selarrrow[$t.p.selarrrow.length - 1];
                } else {
                    $t.p.selrow = null;
                }
                if ($t.p.datatype == "local") {
                    var id = $.jgrid.stripPref($t.p.idPrefix, rowid), pos = $t.p._index[id];
                    if (pos !== undefined) {
                        $t.p.data.splice(pos, 1);
                        $t.refreshIndex();
                    }
                }
                if ($t.p.altRows === true && success) {
                    var cn = $t.p.altclass;
                    $($t.rows).each(function(i) {
                        if (i % 2 == 1) {
                            $(this).addClass(cn);
                        } else {
                            $(this).removeClass(cn);
                        }
                    });
                }
            });
            return success;
        },
        "setRowData": function(rowid, data, cssp) {
            var nm, success = true, title;
            this.each(function() {
                if (!this.grid) {
                    return false;
                }
                var t = this, vl, ind, cp = typeof cssp, lcdata = {};
                ind = t.rows.namedItem(rowid);
                if (!ind) {
                    return false;
                }
                if (data) {
                    try {
                        $(this.p.colModel).each(function(i) {
                            nm = this.name;
                            var dval = $.jgrid.getAccessor(data, nm);
                            if (dval !== undefined) {
                                lcdata[nm] = this.formatter && typeof this.formatter === "string" && this.formatter == "date" ? $.unformat.date.call(t, dval, this) : dval;
                                vl = t.formatter(rowid, dval, i, data, "edit");
                                title = this.title ? {
                                    "title": $.jgrid.stripHtml(vl)
                                } : {};
                                if (t.p.treeGrid === true && nm == t.p.ExpandColumn) {
                                    $("td[role='gridcell']:eq(" + i + ") > span:first", ind).html(vl).attr(title);
                                } else {
                                    $("td[role='gridcell']:eq(" + i + ")", ind).html(vl).attr(title);
                                }
                            }
                        });
                        if (t.p.datatype == "local") {
                            var id = $.jgrid.stripPref(t.p.idPrefix, rowid), pos = t.p._index[id], key;
                            if (t.p.treeGrid) {
                                for (key in t.p.treeReader) {
                                    if (t.p.treeReader.hasOwnProperty(key)) {
                                        delete lcdata[t.p.treeReader[key]];
                                    }
                                }
                            }
                            if (pos !== undefined) {
                                t.p.data[pos] = $.extend(true, t.p.data[pos], lcdata);
                            }
                            lcdata = null;
                        }
                    } catch (e) {
                        success = false;
                    }
                }
                if (success) {
                    if (cp === "string") {
                        $(ind).addClass(cssp);
                    } else if (cp === "object") {
                        $(ind).css(cssp);
                    }
                    $(t).triggerHandler("jqGridAfterGridComplete");
                }
            });
            return success;
        },
        "addRowData": function(rowid, rdata, pos, src) {
            if (!pos) {
                pos = "last";
            }
            var success = false, nm, row, gi, si, ni, sind, i, v, prp = "", aradd, cnm, cn, data, cm, id;
            if (rdata) {
                if ($.isArray(rdata)) {
                    aradd = true;
                    pos = "last";
                    cnm = rowid;
                } else {
                    rdata = [ rdata ];
                    aradd = false;
                }
                this.each(function() {
                    var t = this, datalen = rdata.length;
                    ni = t.p.rownumbers === true ? 1 : 0;
                    gi = t.p.multiselect === true ? 1 : 0;
                    si = t.p.subGrid === true ? 1 : 0;
                    if (!aradd) {
                        if (rowid !== undefined) {
                            rowid = String(rowid);
                        } else {
                            rowid = $.jgrid.randId();
                            if (t.p.keyIndex !== false) {
                                cnm = t.p.colModel[t.p.keyIndex + gi + si + ni].name;
                                if (rdata[0][cnm] !== undefined) {
                                    rowid = rdata[0][cnm];
                                }
                            }
                        }
                    }
                    cn = t.p.altclass;
                    var k = 0, cna = "", lcdata = {}, air = $.isFunction(t.p.afterInsertRow) ? true : false;
                    while (k < datalen) {
                        data = rdata[k];
                        row = [];
                        if (aradd) {
                            try {
                                rowid = data[cnm];
                                if (rowid === undefined) {
                                    rowid = $.jgrid.randId();
                                }
                            } catch (e) {
                                rowid = $.jgrid.randId();
                            }
                            cna = t.p.altRows === true ? (t.rows.length - 1) % 2 === 0 ? cn : "" : "";
                        }
                        id = rowid;
                        rowid = t.p.idPrefix + rowid;
                        if (ni) {
                            prp = t.formatCol(0, 1, "", null, rowid, true);
                            row[row.length] = '<td role="gridcell" class="ui-state-default jqgrid-rownum" ' + prp + ">0</td>";
                        }
                        if (gi) {
                            v = '<input role="checkbox" type="checkbox"' + ' id="jqg_' + t.p.id + "_" + rowid + '" class="cbox"/>';
                            prp = t.formatCol(ni, 1, "", null, rowid, true);
                            row[row.length] = '<td role="gridcell" ' + prp + ">" + v + "</td>";
                        }
                        if (si) {
                            row[row.length] = $(t).jqGrid("addSubGridCell", gi + ni, 1);
                        }
                        for (i = gi + si + ni; i < t.p.colModel.length; i++) {
                            cm = t.p.colModel[i];
                            nm = cm.name;
                            lcdata[nm] = data[nm];
                            v = t.formatter(rowid, $.jgrid.getAccessor(data, nm), i, data);
                            prp = t.formatCol(i, 1, v, data, rowid, lcdata);
                            row[row.length] = '<td role="gridcell" ' + prp + ">" + v + "</td>";
                        }
                        row.unshift(t.constructTr(rowid, false, cna, lcdata, data, false));
                        row[row.length] = "</tr>";
                        if (t.rows.length === 0) {
                            $("table:first", t.grid.bDiv).append(row.join(""));
                        } else {
                            switch (pos) {
                              case "last":
                                $(t.rows[t.rows.length - 1]).after(row.join(""));
                                sind = t.rows.length - 1;
                                break;

                              case "first":
                                $(t.rows[0]).after(row.join(""));
                                sind = 1;
                                break;

                              case "after":
                                sind = t.rows.namedItem(src);
                                if (sind) {
                                    if ($(t.rows[sind.rowIndex + 1]).hasClass("ui-subgrid")) {
                                        $(t.rows[sind.rowIndex + 1]).after(row);
                                    } else {
                                        $(sind).after(row.join(""));
                                    }
                                }
                                sind++;
                                break;

                              case "before":
                                sind = t.rows.namedItem(src);
                                if (sind) {
                                    $(sind).before(row.join(""));
                                    sind = sind.rowIndex;
                                }
                                sind--;
                                break;
                            }
                        }
                        if (t.p.subGrid === true) {
                            $(t).jqGrid("addSubGrid", gi + ni, sind);
                        }
                        t.p.records++;
                        t.p.reccount++;
                        $(t).triggerHandler("jqGridAfterInsertRow", [ rowid, data, data ]);
                        if (air) {
                            t.p.afterInsertRow.call(t, rowid, data, data);
                        }
                        k++;
                        if (t.p.datatype == "local") {
                            lcdata[t.p.localReader.id] = id;
                            t.p._index[id] = t.p.data.length;
                            t.p.data.push(lcdata);
                            lcdata = {};
                        }
                    }
                    if (t.p.altRows === true && !aradd) {
                        if (pos == "last") {
                            if ((t.rows.length - 1) % 2 == 1) {
                                $(t.rows[t.rows.length - 1]).addClass(cn);
                            }
                        } else {
                            $(t.rows).each(function(i) {
                                if (i % 2 == 1) {
                                    $(this).addClass(cn);
                                } else {
                                    $(this).removeClass(cn);
                                }
                            });
                        }
                    }
                    t.updatepager(true, true);
                    success = true;
                });
            }
            return success;
        },
        "footerData": function(action, data, format) {
            var nm, success = false, res = {}, title;
            function isEmpty(obj) {
                var i;
                for (i in obj) {
                    if (obj.hasOwnProperty(i)) {
                        return false;
                    }
                }
                return true;
            }
            if (action === undefined) {
                action = "get";
            }
            if (typeof format !== "boolean") {
                format = true;
            }
            action = action.toLowerCase();
            this.each(function() {
                var t = this, vl;
                if (!t.grid || !t.p.footerrow) {
                    return false;
                }
                if (action == "set") {
                    if (isEmpty(data)) {
                        return false;
                    }
                }
                success = true;
                $(this.p.colModel).each(function(i) {
                    nm = this.name;
                    if (action == "set") {
                        if (data[nm] !== undefined) {
                            vl = format ? t.formatter("", data[nm], i, data, "edit") : data[nm];
                            title = this.title ? {
                                "title": $.jgrid.stripHtml(vl)
                            } : {};
                            $("tr.footrow td:eq(" + i + ")", t.grid.sDiv).html(vl).attr(title);
                            success = true;
                        }
                    } else if (action == "get") {
                        res[nm] = $("tr.footrow td:eq(" + i + ")", t.grid.sDiv).html();
                    }
                });
            });
            return action == "get" ? res : success;
        },
        "showHideCol": function(colname, show) {
            return this.each(function() {
                var $t = this, fndh = false, brd = $.jgrid.cell_width ? 0 : $t.p.cellLayout, cw;
                if (!$t.grid) {
                    return;
                }
                if (typeof colname === "string") {
                    colname = [ colname ];
                }
                show = show != "none" ? "" : "none";
                var sw = show === "" ? true : false, gh = $t.p.groupHeader && (typeof $t.p.groupHeader === "object" || $.isFunction($t.p.groupHeader));
                if (gh) {
                    $($t).jqGrid("destroyGroupHeader", false);
                }
                $(this.p.colModel).each(function(i) {
                    if ($.inArray(this.name, colname) !== -1 && this.hidden === sw) {
                        if ($t.p.frozenColumns === true && this.frozen === true) {
                            return true;
                        }
                        $("tr", $t.grid.hDiv).each(function() {
                            $(this.cells[i]).css("display", show);
                        });
                        $($t.rows).each(function() {
                            if (!$(this).hasClass("jqgroup")) {
                                $(this.cells[i]).css("display", show);
                            }
                        });
                        if ($t.p.footerrow) {
                            $("tr.footrow td:eq(" + i + ")", $t.grid.sDiv).css("display", show);
                        }
                        cw = parseInt(this.width, 10);
                        if (show === "none") {
                            $t.p.tblwidth -= cw + brd;
                        } else {
                            $t.p.tblwidth += cw + brd;
                        }
                        this.hidden = !sw;
                        fndh = true;
                        $($t).triggerHandler("jqGridShowHideCol", [ sw, this.name, i ]);
                    }
                });
                if (fndh === true) {
                    if ($t.p.shrinkToFit === true && !isNaN($t.p.height)) {
                        $t.p.tblwidth += parseInt($t.p.scrollOffset, 10);
                    }
                    $($t).jqGrid("setGridWidth", $t.p.shrinkToFit === true ? $t.p.tblwidth : $t.p.width);
                }
                if (gh) {
                    $($t).jqGrid("setGroupHeaders", $t.p.groupHeader);
                }
            });
        },
        "hideCol": function(colname) {
            return this.each(function() {
                $(this).jqGrid("showHideCol", colname, "none");
            });
        },
        "showCol": function(colname) {
            return this.each(function() {
                $(this).jqGrid("showHideCol", colname, "");
            });
        },
        "remapColumns": function(permutation, updateCells, keepHeader) {
            function resortArray(a) {
                var ac;
                if (a.length) {
                    ac = $.makeArray(a);
                } else {
                    ac = $.extend({}, a);
                }
                $.each(permutation, function(i) {
                    a[i] = ac[this];
                });
            }
            var ts = this.get(0);
            function resortRows(parent, clobj) {
                $(">tr" + (clobj || ""), parent).each(function() {
                    var row = this;
                    var elems = $.makeArray(row.cells);
                    $.each(permutation, function() {
                        var e = elems[this];
                        if (e) {
                            row.appendChild(e);
                        }
                    });
                });
            }
            resortArray(ts.p.colModel);
            resortArray(ts.p.colNames);
            resortArray(ts.grid.headers);
            resortRows($("thead:first", ts.grid.hDiv), keepHeader && ":not(.ui-jqgrid-labels)");
            if (updateCells) {
                resortRows($("#" + $.jgrid.jqID(ts.p.id) + " tbody:first"), ".jqgfirstrow, tr.jqgrow, tr.jqfoot");
            }
            if (ts.p.footerrow) {
                resortRows($("tbody:first", ts.grid.sDiv));
            }
            if (ts.p.remapColumns) {
                if (!ts.p.remapColumns.length) {
                    ts.p.remapColumns = $.makeArray(permutation);
                } else {
                    resortArray(ts.p.remapColumns);
                }
            }
            ts.p.lastsort = $.inArray(ts.p.lastsort, permutation);
            if (ts.p.treeGrid) {
                ts.p.expColInd = $.inArray(ts.p.expColInd, permutation);
            }
            $(ts).triggerHandler("jqGridRemapColumns", [ permutation, updateCells, keepHeader ]);
        },
        "setGridWidth": function(nwidth, shrink) {
            return this.each(function() {
                if (!this.grid) {
                    return;
                }
                var $t = this, cw, initwidth = 0, brd = $.jgrid.cell_width ? 0 : $t.p.cellLayout, lvc, vc = 0, hs = false, scw = $t.p.scrollOffset, aw, gw = 0, cl = 0, cr;
                if (typeof shrink !== "boolean") {
                    shrink = $t.p.shrinkToFit;
                }
                if (isNaN(nwidth)) {
                    return;
                }
                nwidth = parseInt(nwidth, 10);
                $t.grid.width = $t.p.width = nwidth;
                $("#gbox_" + $.jgrid.jqID($t.p.id)).css("width", nwidth + "px");
                $("#gview_" + $.jgrid.jqID($t.p.id)).css("width", nwidth + "px");
                $($t.grid.bDiv).css("width", nwidth + "px");
                $($t.grid.hDiv).css("width", nwidth + "px");
                if ($t.p.pager) {
                    $($t.p.pager).css("width", nwidth + "px");
                }
                if ($t.p.toppager) {
                    $($t.p.toppager).css("width", nwidth + "px");
                }
                if ($t.p.toolbar[0] === true) {
                    $($t.grid.uDiv).css("width", nwidth + "px");
                    if ($t.p.toolbar[1] == "both") {
                        $($t.grid.ubDiv).css("width", nwidth + "px");
                    }
                }
                if ($t.p.footerrow) {
                    $($t.grid.sDiv).css("width", nwidth + "px");
                }
                if (shrink === false && $t.p.forceFit === true) {
                    $t.p.forceFit = false;
                }
                if (shrink === true) {
                    $.each($t.p.colModel, function() {
                        if (this.hidden === false) {
                            cw = this.widthOrg;
                            initwidth += cw + brd;
                            if (this.fixed) {
                                gw += cw + brd;
                            } else {
                                vc++;
                            }
                            cl++;
                        }
                    });
                    if (vc === 0) {
                        return;
                    }
                    $t.p.tblwidth = initwidth;
                    aw = nwidth - brd * vc - gw;
                    if (!isNaN($t.p.height)) {
                        if ($($t.grid.bDiv)[0].clientHeight < $($t.grid.bDiv)[0].scrollHeight || $t.rows.length === 1) {
                            hs = true;
                            aw -= scw;
                        }
                    }
                    initwidth = 0;
                    var cle = $t.grid.cols.length > 0;
                    $.each($t.p.colModel, function(i) {
                        if (this.hidden === false && !this.fixed) {
                            cw = this.widthOrg;
                            cw = Math.round(aw * cw / ($t.p.tblwidth - brd * vc - gw));
                            if (cw < 0) {
                                return;
                            }
                            this.width = cw;
                            initwidth += cw;
                            $t.grid.headers[i].width = cw;
                            $t.grid.headers[i].el.style.width = cw + "px";
                            if ($t.p.footerrow) {
                                $t.grid.footers[i].style.width = cw + "px";
                            }
                            if (cle) {
                                $t.grid.cols[i].style.width = cw + "px";
                            }
                            lvc = i;
                        }
                    });
                    if (!lvc) {
                        return;
                    }
                    cr = 0;
                    if (hs) {
                        if (nwidth - gw - (initwidth + brd * vc) !== scw) {
                            cr = nwidth - gw - (initwidth + brd * vc) - scw;
                        }
                    } else if (Math.abs(nwidth - gw - (initwidth + brd * vc)) !== 1) {
                        cr = nwidth - gw - (initwidth + brd * vc);
                    }
                    $t.p.colModel[lvc].width += cr;
                    $t.p.tblwidth = initwidth + cr + brd * vc + gw;
                    if ($t.p.tblwidth > nwidth) {
                        var delta = $t.p.tblwidth - parseInt(nwidth, 10);
                        $t.p.tblwidth = nwidth;
                        cw = $t.p.colModel[lvc].width = $t.p.colModel[lvc].width - delta;
                    } else {
                        cw = $t.p.colModel[lvc].width;
                    }
                    $t.grid.headers[lvc].width = cw;
                    $t.grid.headers[lvc].el.style.width = cw + "px";
                    if (cle) {
                        $t.grid.cols[lvc].style.width = cw + "px";
                    }
                    if ($t.p.footerrow) {
                        $t.grid.footers[lvc].style.width = cw + "px";
                    }
                }
                if ($t.p.tblwidth) {
                    $("table:first", $t.grid.bDiv).css("width", $t.p.tblwidth + "px");
                    $("table:first", $t.grid.hDiv).css("width", $t.p.tblwidth + "px");
                    $t.grid.hDiv.scrollLeft = $t.grid.bDiv.scrollLeft;
                    if ($t.p.footerrow) {
                        $("table:first", $t.grid.sDiv).css("width", $t.p.tblwidth + "px");
                    }
                }
            });
        },
        "setGridHeight": function(nh) {
            return this.each(function() {
                var $t = this;
                if (!$t.grid) {
                    return;
                }
                var bDiv = $($t.grid.bDiv);
                bDiv.css({
                    "height": nh + (isNaN(nh) ? "" : "px")
                });
                if ($t.p.frozenColumns === true) {
                    $("#" + $.jgrid.jqID($t.p.id) + "_frozen").parent().height(bDiv.height() - 16);
                }
                $t.p.height = nh;
                if ($t.p.scroll) {
                    $t.grid.populateVisible();
                }
            });
        },
        "setCaption": function(newcap) {
            return this.each(function() {
                this.p.caption = newcap;
                $("span.ui-jqgrid-title, span.ui-jqgrid-title-rtl", this.grid.cDiv).html(newcap);
                $(this.grid.cDiv).show();
            });
        },
        "setLabel": function(colname, nData, prop, attrp) {
            return this.each(function() {
                var $t = this, pos = -1;
                if (!$t.grid) {
                    return;
                }
                if (colname !== undefined) {
                    $($t.p.colModel).each(function(i) {
                        if (this.name == colname) {
                            pos = i;
                            return false;
                        }
                    });
                } else {
                    return;
                }
                if (pos >= 0) {
                    var thecol = $("tr.ui-jqgrid-labels th:eq(" + pos + ")", $t.grid.hDiv);
                    if (nData) {
                        var ico = $(".s-ico", thecol);
                        $("[id^=jqgh_]", thecol).empty().html(nData).append(ico);
                        $t.p.colNames[pos] = nData;
                    }
                    if (prop) {
                        if (typeof prop === "string") {
                            $(thecol).addClass(prop);
                        } else {
                            $(thecol).css(prop);
                        }
                    }
                    if (typeof attrp === "object") {
                        $(thecol).attr(attrp);
                    }
                }
            });
        },
        "setCell": function(rowid, colname, nData, cssp, attrp, forceupd) {
            return this.each(function() {
                var $t = this, pos = -1, v, title;
                if (!$t.grid) {
                    return;
                }
                if (isNaN(colname)) {
                    $($t.p.colModel).each(function(i) {
                        if (this.name == colname) {
                            pos = i;
                            return false;
                        }
                    });
                } else {
                    pos = parseInt(colname, 10);
                }
                if (pos >= 0) {
                    var ind = $t.rows.namedItem(rowid);
                    if (ind) {
                        var tcell = $("td:eq(" + pos + ")", ind);
                        if (nData !== "" || forceupd === true) {
                            v = $t.formatter(rowid, nData, pos, ind, "edit");
                            title = $t.p.colModel[pos].title ? {
                                "title": $.jgrid.stripHtml(v)
                            } : {};
                            if ($t.p.treeGrid && $(".tree-wrap", $(tcell)).length > 0) {
                                $("span", $(tcell)).html(v).attr(title);
                            } else {
                                $(tcell).html(v).attr(title);
                            }
                            if ($t.p.datatype == "local") {
                                var cm = $t.p.colModel[pos], index;
                                nData = cm.formatter && typeof cm.formatter === "string" && cm.formatter == "date" ? $.unformat.date.call($t, nData, cm) : nData;
                                index = $t.p._index[rowid];
                                if (index !== undefined) {
                                    $t.p.data[index][cm.name] = nData;
                                }
                            }
                        }
                        if (typeof cssp === "string") {
                            $(tcell).addClass(cssp);
                        } else if (cssp) {
                            $(tcell).css(cssp);
                        }
                        if (typeof attrp === "object") {
                            $(tcell).attr(attrp);
                        }
                    }
                }
            });
        },
        "getCell": function(rowid, col) {
            var ret = false;
            this.each(function() {
                var $t = this, pos = -1;
                if (!$t.grid) {
                    return;
                }
                if (isNaN(col)) {
                    $($t.p.colModel).each(function(i) {
                        if (this.name === col) {
                            pos = i;
                            return false;
                        }
                    });
                } else {
                    pos = parseInt(col, 10);
                }
                if (pos >= 0) {
                    var ind = $t.rows.namedItem(rowid);
                    if (ind) {
                        try {
                            ret = $.unformat.call($t, $("td:eq(" + pos + ")", ind), {
                                "rowId": ind.id,
                                "colModel": $t.p.colModel[pos]
                            }, pos);
                        } catch (e) {
                            ret = $.jgrid.htmlDecode($("td:eq(" + pos + ")", ind).html());
                        }
                    }
                }
            });
            return ret;
        },
        "getCol": function(col, obj, mathopr) {
            var ret = [], val, sum = 0, min, max, v;
            obj = typeof obj !== "boolean" ? false : obj;
            if (mathopr === undefined) {
                mathopr = false;
            }
            this.each(function() {
                var $t = this, pos = -1;
                if (!$t.grid) {
                    return;
                }
                if (isNaN(col)) {
                    $($t.p.colModel).each(function(i) {
                        if (this.name === col) {
                            pos = i;
                            return false;
                        }
                    });
                } else {
                    pos = parseInt(col, 10);
                }
                if (pos >= 0) {
                    var ln = $t.rows.length, i = 0;
                    if (ln && ln > 0) {
                        while (i < ln) {
                            if ($($t.rows[i]).hasClass("jqgrow")) {
                                try {
                                    val = $.unformat.call($t, $($t.rows[i].cells[pos]), {
                                        "rowId": $t.rows[i].id,
                                        "colModel": $t.p.colModel[pos]
                                    }, pos);
                                } catch (e) {
                                    val = $.jgrid.htmlDecode($t.rows[i].cells[pos].innerHTML);
                                }
                                if (mathopr) {
                                    v = parseFloat(val);
                                    sum += v;
                                    if (max === undefined) {
                                        max = min = v;
                                    }
                                    min = Math.min(min, v);
                                    max = Math.max(max, v);
                                } else if (obj) {
                                    ret.push({
                                        "id": $t.rows[i].id,
                                        "value": val
                                    });
                                } else {
                                    ret.push(val);
                                }
                            }
                            i++;
                        }
                        if (mathopr) {
                            switch (mathopr.toLowerCase()) {
                              case "sum":
                                ret = sum;
                                break;

                              case "avg":
                                ret = sum / ln;
                                break;

                              case "count":
                                ret = ln;
                                break;

                              case "min":
                                ret = min;
                                break;

                              case "max":
                                ret = max;
                                break;
                            }
                        }
                    }
                }
            });
            return ret;
        },
        "clearGridData": function(clearfooter) {
            return this.each(function() {
                var $t = this;
                if (!$t.grid) {
                    return;
                }
                if (typeof clearfooter !== "boolean") {
                    clearfooter = false;
                }
                if ($t.p.deepempty) {
                    $("#" + $.jgrid.jqID($t.p.id) + " tbody:first tr:gt(0)").remove();
                } else {
                    var trf = $("#" + $.jgrid.jqID($t.p.id) + " tbody:first tr:first")[0];
                    $("#" + $.jgrid.jqID($t.p.id) + " tbody:first").empty().append(trf);
                }
                if ($t.p.footerrow && clearfooter) {
                    $(".ui-jqgrid-ftable td", $t.grid.sDiv).html("&#160;");
                }
                $t.p.selrow = null;
                $t.p.selarrrow = [];
                $t.p.savedRow = [];
                $t.p.records = 0;
                $t.p.page = 1;
                $t.p.lastpage = 0;
                $t.p.reccount = 0;
                $t.p.data = [];
                $t.p._index = {};
                $t.updatepager(true, false);
            });
        },
        "getInd": function(rowid, rc) {
            var ret = false, rw;
            this.each(function() {
                rw = this.rows.namedItem(rowid);
                if (rw) {
                    ret = rc === true ? rw : rw.rowIndex;
                }
            });
            return ret;
        },
        "bindKeys": function(settings) {
            var o = $.extend({
                "onEnter": null,
                "onSpace": null,
                "onLeftKey": null,
                "onRightKey": null,
                "scrollingRows": true
            }, settings || {});
            return this.each(function() {
                var $t = this;
                if (!$("body").is("[role]")) {
                    $("body").attr("role", "application");
                }
                $t.p.scrollrows = o.scrollingRows;
                $($t).keydown(function(event) {
                    var target = $($t).find("tr[tabindex=0]")[0], id, r, mind, expanded = $t.p.treeReader.expanded_field;
                    if (target) {
                        mind = $t.p._index[target.id];
                        if (event.keyCode === 37 || event.keyCode === 38 || event.keyCode === 39 || event.keyCode === 40) {
                            if (event.keyCode === 38) {
                                r = target.previousSibling;
                                id = "";
                                if (r) {
                                    if ($(r).is(":hidden")) {
                                        while (r) {
                                            r = r.previousSibling;
                                            if (!$(r).is(":hidden") && $(r).hasClass("jqgrow")) {
                                                id = r.id;
                                                break;
                                            }
                                        }
                                    } else {
                                        id = r.id;
                                    }
                                }
                                $($t).jqGrid("setSelection", id, true, event);
                                event.preventDefault();
                            }
                            if (event.keyCode === 40) {
                                r = target.nextSibling;
                                id = "";
                                if (r) {
                                    if ($(r).is(":hidden")) {
                                        while (r) {
                                            r = r.nextSibling;
                                            if (!$(r).is(":hidden") && $(r).hasClass("jqgrow")) {
                                                id = r.id;
                                                break;
                                            }
                                        }
                                    } else {
                                        id = r.id;
                                    }
                                }
                                $($t).jqGrid("setSelection", id, true, event);
                                event.preventDefault();
                            }
                            if (event.keyCode === 37) {
                                if ($t.p.treeGrid && $t.p.data[mind][expanded]) {
                                    $(target).find("div.treeclick").trigger("click");
                                }
                                $($t).triggerHandler("jqGridKeyLeft", [ $t.p.selrow ]);
                                if ($.isFunction(o.onLeftKey)) {
                                    o.onLeftKey.call($t, $t.p.selrow);
                                }
                            }
                            if (event.keyCode === 39) {
                                if ($t.p.treeGrid && !$t.p.data[mind][expanded]) {
                                    $(target).find("div.treeclick").trigger("click");
                                }
                                $($t).triggerHandler("jqGridKeyRight", [ $t.p.selrow ]);
                                if ($.isFunction(o.onRightKey)) {
                                    o.onRightKey.call($t, $t.p.selrow);
                                }
                            }
                        } else if (event.keyCode === 13) {
                            $($t).triggerHandler("jqGridKeyEnter", [ $t.p.selrow ]);
                            if ($.isFunction(o.onEnter)) {
                                o.onEnter.call($t, $t.p.selrow);
                            }
                        } else if (event.keyCode === 32) {
                            $($t).triggerHandler("jqGridKeySpace", [ $t.p.selrow ]);
                            if ($.isFunction(o.onSpace)) {
                                o.onSpace.call($t, $t.p.selrow);
                            }
                        }
                    }
                });
            });
        },
        "unbindKeys": function() {
            return this.each(function() {
                $(this).unbind("keydown");
            });
        },
        "getLocalRow": function(rowid) {
            var ret = false, ind;
            this.each(function() {
                if (rowid !== undefined) {
                    ind = this.p._index[rowid];
                    if (ind >= 0) {
                        ret = this.p.data[ind];
                    }
                }
            });
            return ret;
        }
    });
})(jQuery);

(function($) {
    "use strict";
    $.jgrid.extend({
        "getColProp": function(colname) {
            var ret = {}, $t = this[0];
            if (!$t.grid) {
                return false;
            }
            var cM = $t.p.colModel, i;
            for (i = 0; i < cM.length; i++) {
                if (cM[i].name == colname) {
                    ret = cM[i];
                    break;
                }
            }
            return ret;
        },
        "setColProp": function(colname, obj) {
            return this.each(function() {
                if (this.grid) {
                    if (obj) {
                        var cM = this.p.colModel, i;
                        for (i = 0; i < cM.length; i++) {
                            if (cM[i].name == colname) {
                                $.extend(true, this.p.colModel[i], obj);
                                break;
                            }
                        }
                    }
                }
            });
        },
        "sortGrid": function(colname, reload, sor) {
            return this.each(function() {
                var $t = this, idx = -1, i;
                if (!$t.grid) {
                    return;
                }
                if (!colname) {
                    colname = $t.p.sortname;
                }
                for (i = 0; i < $t.p.colModel.length; i++) {
                    if ($t.p.colModel[i].index == colname || $t.p.colModel[i].name == colname) {
                        idx = i;
                        break;
                    }
                }
                if (idx != -1) {
                    var sort = $t.p.colModel[idx].sortable;
                    if (typeof sort !== "boolean") {
                        sort = true;
                    }
                    if (typeof reload !== "boolean") {
                        reload = false;
                    }
                    if (sort) {
                        $t.sortData("jqgh_" + $t.p.id + "_" + colname, idx, reload, sor);
                    }
                }
            });
        },
        "clearBeforeUnload": function() {
            return this.each(function() {
                var grid = this.grid;
                grid.emptyRows.call(this, true, true);
                $(grid.hDiv).unbind("mousemove");
                $(this).unbind();
                grid.dragEnd = null;
                grid.dragMove = null;
                grid.dragStart = null;
                grid.emptyRows = null;
                grid.populate = null;
                grid.populateVisible = null;
                grid.scrollGrid = null;
                grid.selectionPreserver = null;
                grid.bDiv = null;
                grid.cDiv = null;
                grid.hDiv = null;
                grid.cols = null;
                var i, l = grid.headers.length;
                for (i = 0; i < l; i++) {
                    grid.headers[i].el = null;
                }
                this.formatCol = null;
                this.sortData = null;
                this.updatepager = null;
                this.refreshIndex = null;
                this.setHeadCheckBox = null;
                this.constructTr = null;
                this.formatter = null;
                this.addXmlData = null;
                this.addJSONData = null;
            });
        },
        "GridDestroy": function() {
            return this.each(function() {
                if (this.grid) {
                    if (this.p.pager) {
                        $(this.p.pager).remove();
                    }
                    try {
                        $(this).jqGrid("clearBeforeUnload");
                        $("#gbox_" + $.jgrid.jqID(this.id)).remove();
                    } catch (_) {}
                }
            });
        },
        "GridUnload": function() {
            return this.each(function() {
                if (!this.grid) {
                    return;
                }
                var defgrid = {
                    "id": $(this).attr("id"),
                    "cl": $(this).attr("class")
                };
                if (this.p.pager) {
                    $(this.p.pager).empty().removeClass("ui-state-default ui-jqgrid-pager corner-bottom");
                }
                var newtable = document.createElement("table");
                $(newtable).attr({
                    "id": defgrid.id
                });
                newtable.className = defgrid.cl;
                var gid = $.jgrid.jqID(this.id);
                $(newtable).removeClass("ui-jqgrid-btable");
                if ($(this.p.pager).parents("#gbox_" + gid).length === 1) {
                    $(newtable).insertBefore("#gbox_" + gid).show();
                    $(this.p.pager).insertBefore("#gbox_" + gid);
                } else {
                    $(newtable).insertBefore("#gbox_" + gid).show();
                }
                $(this).jqGrid("clearBeforeUnload");
                $("#gbox_" + gid).remove();
            });
        },
        "setGridState": function(state) {
            return this.each(function() {
                if (!this.grid) {
                    return;
                }
                var $t = this;
                if (state == "hidden") {
                    $(".ui-jqgrid-bdiv, .ui-jqgrid-hdiv", "#gview_" + $.jgrid.jqID($t.p.id)).slideUp("fast");
                    if ($t.p.pager) {
                        $($t.p.pager).slideUp("fast");
                    }
                    if ($t.p.toppager) {
                        $($t.p.toppager).slideUp("fast");
                    }
                    if ($t.p.toolbar[0] === true) {
                        if ($t.p.toolbar[1] == "both") {
                            $($t.grid.ubDiv).slideUp("fast");
                        }
                        $($t.grid.uDiv).slideUp("fast");
                    }
                    if ($t.p.footerrow) {
                        $(".ui-jqgrid-sdiv", "#gbox_" + $.jgrid.jqID($t.p.id)).slideUp("fast");
                    }
                    $(".ui-jqgrid-titlebar-close span", $t.grid.cDiv).removeClass("ui-icon-circle-triangle-n").addClass("ui-icon-circle-triangle-s");
                    $t.p.gridstate = "hidden";
                } else if (state == "visible") {
                    $(".ui-jqgrid-hdiv, .ui-jqgrid-bdiv", "#gview_" + $.jgrid.jqID($t.p.id)).slideDown("fast");
                    if ($t.p.pager) {
                        $($t.p.pager).slideDown("fast");
                    }
                    if ($t.p.toppager) {
                        $($t.p.toppager).slideDown("fast");
                    }
                    if ($t.p.toolbar[0] === true) {
                        if ($t.p.toolbar[1] == "both") {
                            $($t.grid.ubDiv).slideDown("fast");
                        }
                        $($t.grid.uDiv).slideDown("fast");
                    }
                    if ($t.p.footerrow) {
                        $(".ui-jqgrid-sdiv", "#gbox_" + $.jgrid.jqID($t.p.id)).slideDown("fast");
                    }
                    $(".ui-jqgrid-titlebar-close span", $t.grid.cDiv).removeClass("ui-icon-circle-triangle-s").addClass("ui-icon-circle-triangle-n");
                    $t.p.gridstate = "visible";
                }
            });
        },
        "filterToolbar": function(p) {
            p = $.extend({
                "autosearch": true,
                "searchOnEnter": true,
                "beforeSearch": null,
                "afterSearch": null,
                "beforeClear": null,
                "afterClear": null,
                "searchurl": "",
                "stringResult": false,
                "groupOp": "AND",
                "defaultSearch": "bw"
            }, p || {});
            return this.each(function() {
                var $t = this;
                if (this.ftoolbar) {
                    return;
                }
                var triggerToolbar = function() {
                    var sdata = {}, j = 0, v, nm, sopt = {}, so;
                    $.each($t.p.colModel, function() {
                        nm = this.index || this.name;
                        so = this.searchoptions && this.searchoptions.sopt ? this.searchoptions.sopt[0] : this.stype == "select" ? "eq" : p.defaultSearch;
                        v = $("#gs_" + $.jgrid.jqID(this.name), this.frozen === true && $t.p.frozenColumns === true ? $t.grid.fhDiv : $t.grid.hDiv).val();
                        if (v) {
                            sdata[nm] = v;
                            sopt[nm] = so;
                            j++;
                        } else {
                            try {
                                delete $t.p.postData[nm];
                            } catch (z) {}
                        }
                    });
                    var sd = j > 0 ? true : false;
                    if (p.stringResult === true || $t.p.datatype == "local") {
                        var ruleGroup = '{"groupOp":"' + p.groupOp + '","rules":[';
                        var gi = 0;
                        $.each(sdata, function(i, n) {
                            if (gi > 0) {
                                ruleGroup += ",";
                            }
                            ruleGroup += '{"field":"' + i + '",';
                            ruleGroup += '"op":"' + sopt[i] + '",';
                            n += "";
                            ruleGroup += '"data":"' + n.replace(/\\/g, "\\\\").replace(/\"/g, '\\"') + '"}';
                            gi++;
                        });
                        ruleGroup += "]}";
                        $.extend($t.p.postData, {
                            "filters": ruleGroup
                        });
                        $.each([ "searchField", "searchString", "searchOper" ], function(i, n) {
                            if ($t.p.postData.hasOwnProperty(n)) {
                                delete $t.p.postData[n];
                            }
                        });
                    } else {
                        $.extend($t.p.postData, sdata);
                    }
                    var saveurl;
                    if ($t.p.searchurl) {
                        saveurl = $t.p.url;
                        $($t).jqGrid("setGridParam", {
                            "url": $t.p.searchurl
                        });
                    }
                    var bsr = $($t).triggerHandler("jqGridToolbarBeforeSearch") === "stop" ? true : false;
                    if (!bsr && $.isFunction(p.beforeSearch)) {
                        bsr = p.beforeSearch.call($t);
                    }
                    if (!bsr) {
                        $($t).jqGrid("setGridParam", {
                            "search": sd
                        }).trigger("reloadGrid", [ {
                            "page": 1
                        } ]);
                    }
                    if (saveurl) {
                        $($t).jqGrid("setGridParam", {
                            "url": saveurl
                        });
                    }
                    $($t).triggerHandler("jqGridToolbarAfterSearch");
                    if ($.isFunction(p.afterSearch)) {
                        p.afterSearch.call($t);
                    }
                };
                var clearToolbar = function(trigger) {
                    var sdata = {}, j = 0, nm;
                    trigger = typeof trigger !== "boolean" ? true : trigger;
                    $.each($t.p.colModel, function() {
                        var v;
                        if (this.searchoptions && this.searchoptions.defaultValue !== undefined) {
                            v = this.searchoptions.defaultValue;
                        }
                        nm = this.index || this.name;
                        switch (this.stype) {
                          case "select":
                            $("#gs_" + $.jgrid.jqID(this.name) + " option", this.frozen === true && $t.p.frozenColumns === true ? $t.grid.fhDiv : $t.grid.hDiv).each(function(i) {
                                if (i === 0) {
                                    this.selected = true;
                                }
                                if ($(this).val() == v) {
                                    this.selected = true;
                                    return false;
                                }
                            });
                            if (v !== undefined) {
                                sdata[nm] = v;
                                j++;
                            } else {
                                try {
                                    delete $t.p.postData[nm];
                                } catch (e) {}
                            }
                            break;

                          case "text":
                            $("#gs_" + $.jgrid.jqID(this.name), this.frozen === true && $t.p.frozenColumns === true ? $t.grid.fhDiv : $t.grid.hDiv).val(v);
                            if (v !== undefined) {
                                sdata[nm] = v;
                                j++;
                            } else {
                                try {
                                    delete $t.p.postData[nm];
                                } catch (y) {}
                            }
                            break;
                        }
                    });
                    var sd = j > 0 ? true : false;
                    if (p.stringResult === true || $t.p.datatype == "local") {
                        var ruleGroup = '{"groupOp":"' + p.groupOp + '","rules":[';
                        var gi = 0;
                        $.each(sdata, function(i, n) {
                            if (gi > 0) {
                                ruleGroup += ",";
                            }
                            ruleGroup += '{"field":"' + i + '",';
                            ruleGroup += '"op":"' + "eq" + '",';
                            n += "";
                            ruleGroup += '"data":"' + n.replace(/\\/g, "\\\\").replace(/\"/g, '\\"') + '"}';
                            gi++;
                        });
                        ruleGroup += "]}";
                        $.extend($t.p.postData, {
                            "filters": ruleGroup
                        });
                        $.each([ "searchField", "searchString", "searchOper" ], function(i, n) {
                            if ($t.p.postData.hasOwnProperty(n)) {
                                delete $t.p.postData[n];
                            }
                        });
                    } else {
                        $.extend($t.p.postData, sdata);
                    }
                    var saveurl;
                    if ($t.p.searchurl) {
                        saveurl = $t.p.url;
                        $($t).jqGrid("setGridParam", {
                            "url": $t.p.searchurl
                        });
                    }
                    var bcv = $($t).triggerHandler("jqGridToolbarBeforeClear") === "stop" ? true : false;
                    if (!bcv && $.isFunction(p.beforeClear)) {
                        bcv = p.beforeClear.call($t);
                    }
                    if (!bcv) {
                        if (trigger) {
                            $($t).jqGrid("setGridParam", {
                                "search": sd
                            }).trigger("reloadGrid", [ {
                                "page": 1
                            } ]);
                        }
                    }
                    if (saveurl) {
                        $($t).jqGrid("setGridParam", {
                            "url": saveurl
                        });
                    }
                    $($t).triggerHandler("jqGridToolbarAfterClear");
                    if ($.isFunction(p.afterClear)) {
                        p.afterClear();
                    }
                };
                var toggleToolbar = function() {
                    var trow = $("tr.ui-search-toolbar", $t.grid.hDiv), trow2 = $t.p.frozenColumns === true ? $("tr.ui-search-toolbar", $t.grid.fhDiv) : false;
                    if (trow.css("display") == "none") {
                        trow.show();
                        if (trow2) {
                            trow2.show();
                        }
                    } else {
                        trow.hide();
                        if (trow2) {
                            trow2.hide();
                        }
                    }
                };
                var tr = $("<tr class='ui-search-toolbar' role='rowheader'></tr>");
                var timeoutHnd;
                $.each($t.p.colModel, function() {
                    var cm = this, thd, th, soptions, surl, self;
                    th = $("<th role='columnheader' class='ui-state-default ui-th-column ui-th-" + $t.p.direction + "'></th>");
                    thd = $("<div style='position:relative;height:100%;padding-right:0.3em;'></div>");
                    if (this.hidden === true) {
                        $(th).css("display", "none");
                    }
                    this.search = this.search === false ? false : true;
                    if (this.stype === undefined) {
                        this.stype = "text";
                    }
                    soptions = $.extend({}, this.searchoptions || {});
                    if (this.search) {
                        switch (this.stype) {
                          case "select":
                            surl = this.surl || soptions.dataUrl;
                            if (surl) {
                                self = thd;
                                $.ajax($.extend({
                                    "url": surl,
                                    "dataType": "html",
                                    "success": function(res) {
                                        if (soptions.buildSelect !== undefined) {
                                            var d = soptions.buildSelect(res);
                                            if (d) {
                                                $(self).append(d);
                                            }
                                        } else {
                                            $(self).append(res);
                                        }
                                        if (soptions.defaultValue !== undefined) {
                                            $("select", self).val(soptions.defaultValue);
                                        }
                                        $("select", self).attr({
                                            "name": cm.index || cm.name,
                                            "id": "gs_" + cm.name
                                        });
                                        if (soptions.attr) {
                                            $("select", self).attr(soptions.attr);
                                        }
                                        $("select", self).css({
                                            "width": "100%"
                                        });
                                        $.jgrid.bindEv($("select", self)[0], soptions, $t);
                                        if (p.autosearch === true) {
                                            $("select", self).change(function() {
                                                triggerToolbar();
                                                return false;
                                            });
                                        }
                                        res = null;
                                    }
                                }, $.jgrid.ajaxOptions, $t.p.ajaxSelectOptions || {}));
                            } else {
                                var oSv, sep, delim;
                                if (cm.searchoptions) {
                                    oSv = cm.searchoptions.value === undefined ? "" : cm.searchoptions.value;
                                    sep = cm.searchoptions.separator === undefined ? ":" : cm.searchoptions.separator;
                                    delim = cm.searchoptions.delimiter === undefined ? ";" : cm.searchoptions.delimiter;
                                } else if (cm.editoptions) {
                                    oSv = cm.editoptions.value === undefined ? "" : cm.editoptions.value;
                                    sep = cm.editoptions.separator === undefined ? ":" : cm.editoptions.separator;
                                    delim = cm.editoptions.delimiter === undefined ? ";" : cm.editoptions.delimiter;
                                }
                                if (oSv) {
                                    var elem = document.createElement("select");
                                    elem.style.width = "100%";
                                    $(elem).attr({
                                        "name": cm.index || cm.name,
                                        "id": "gs_" + cm.name
                                    });
                                    var so, sv, ov, key, k;
                                    if (typeof oSv === "string") {
                                        so = oSv.split(delim);
                                        for (k = 0; k < so.length; k++) {
                                            sv = so[k].split(sep);
                                            ov = document.createElement("option");
                                            ov.value = sv[0];
                                            ov.innerHTML = sv[1];
                                            elem.appendChild(ov);
                                        }
                                    } else if (typeof oSv === "object") {
                                        for (key in oSv) {
                                            if (oSv.hasOwnProperty(key)) {
                                                ov = document.createElement("option");
                                                ov.value = key;
                                                ov.innerHTML = oSv[key];
                                                elem.appendChild(ov);
                                            }
                                        }
                                    }
                                    if (soptions.defaultValue !== undefined) {
                                        $(elem).val(soptions.defaultValue);
                                    }
                                    if (soptions.attr) {
                                        $(elem).attr(soptions.attr);
                                    }
                                    $.jgrid.bindEv(elem, soptions, $t);
                                    $(thd).append(elem);
                                    if (p.autosearch === true) {
                                        $(elem).change(function() {
                                            triggerToolbar();
                                            return false;
                                        });
                                    }
                                }
                            }
                            break;

                          case "text":
                            var df = soptions.defaultValue !== undefined ? soptions.defaultValue : "";
                            $(thd).append("<input type='text' style='width:95%;padding:0px;' name='" + (cm.index || cm.name) + "' id='gs_" + cm.name + "' value='" + df + "'/>");
                            if (soptions.attr) {
                                $("input", thd).attr(soptions.attr);
                            }
                            $.jgrid.bindEv($("input", thd)[0], soptions, $t);
                            if (p.autosearch === true) {
                                if (p.searchOnEnter) {
                                    $("input", thd).keypress(function(e) {
                                        var key = e.charCode || e.keyCode || 0;
                                        if (key == 13) {
                                            triggerToolbar();
                                            return false;
                                        }
                                        return this;
                                    });
                                } else {
                                    $("input", thd).keydown(function(e) {
                                        var key = e.which;
                                        switch (key) {
                                          case 13:
                                            return false;

                                          case 9:
                                          case 16:
                                          case 37:
                                          case 38:
                                          case 39:
                                          case 40:
                                          case 27:
                                            break;

                                          default:
                                            if (timeoutHnd) {
                                                clearTimeout(timeoutHnd);
                                            }
                                            timeoutHnd = setTimeout(function() {
                                                triggerToolbar();
                                            }, 500);
                                        }
                                    });
                                }
                            }
                            break;
                        }
                    }
                    $(th).append(thd);
                    $(tr).append(th);
                });
                $("table thead", $t.grid.hDiv).append(tr);
                this.ftoolbar = true;
                this.triggerToolbar = triggerToolbar;
                this.clearToolbar = clearToolbar;
                this.toggleToolbar = toggleToolbar;
            });
        },
        "destroyFilterToolbar": function() {
            return this.each(function() {
                if (!this.ftoolbar) {
                    return;
                }
                this.triggerToolbar = null;
                this.clearToolbar = null;
                this.toggleToolbar = null;
                this.ftoolbar = false;
                $(this.grid.hDiv).find("table thead tr.ui-search-toolbar").remove();
            });
        },
        "destroyGroupHeader": function(nullHeader) {
            if (nullHeader === undefined) {
                nullHeader = true;
            }
            return this.each(function() {
                var $t = this, $tr, i, l, headers, $th, $resizing, grid = $t.grid, thead = $("table.ui-jqgrid-htable thead", grid.hDiv), cm = $t.p.colModel, hc;
                if (!grid) {
                    return;
                }
                $(this).unbind(".setGroupHeaders");
                $tr = $("<tr>", {
                    "role": "rowheader"
                }).addClass("ui-jqgrid-labels");
                headers = grid.headers;
                for (i = 0, l = headers.length; i < l; i++) {
                    hc = cm[i].hidden ? "none" : "";
                    $th = $(headers[i].el).width(headers[i].width).css("display", hc);
                    try {
                        $th.removeAttr("rowSpan");
                    } catch (rs) {
                        $th.attr("rowSpan", 1);
                    }
                    $tr.append($th);
                    $resizing = $th.children("span.ui-jqgrid-resize");
                    if ($resizing.length > 0) {
                        $resizing[0].style.height = "";
                    }
                    $th.children("div")[0].style.top = "";
                }
                $(thead).children("tr.ui-jqgrid-labels").remove();
                $(thead).prepend($tr);
                if (nullHeader === true) {
                    $($t).jqGrid("setGridParam", {
                        "groupHeader": null
                    });
                }
            });
        },
        "setGroupHeaders": function(o) {
            o = $.extend({
                "useColSpanStyle": false,
                "groupHeaders": []
            }, o || {});
            return this.each(function() {
                this.p.groupHeader = o;
                var ts = this, i, cmi, skip = 0, $tr, $colHeader, th, $th, thStyle, iCol, cghi, numberOfColumns, titleText, cVisibleColumns, colModel = ts.p.colModel, cml = colModel.length, ths = ts.grid.headers, $htable = $("table.ui-jqgrid-htable", ts.grid.hDiv), $trLabels = $htable.children("thead").children("tr.ui-jqgrid-labels:last").addClass("jqg-second-row-header"), $thead = $htable.children("thead"), $theadInTable, $firstHeaderRow = $htable.find(".jqg-first-row-header");
                if ($firstHeaderRow[0] === undefined) {
                    $firstHeaderRow = $("<tr>", {
                        "role": "row",
                        "aria-hidden": "true"
                    }).addClass("jqg-first-row-header").css("height", "auto");
                } else {
                    $firstHeaderRow.empty();
                }
                var $firstRow, inColumnHeader = function(text, columnHeaders) {
                    var length = columnHeaders.length, i;
                    for (i = 0; i < length; i++) {
                        if (columnHeaders[i].startColumnName === text) {
                            return i;
                        }
                    }
                    return -1;
                };
                $(ts).prepend($thead);
                $tr = $("<tr>", {
                    "role": "rowheader"
                }).addClass("ui-jqgrid-labels jqg-third-row-header");
                for (i = 0; i < cml; i++) {
                    th = ths[i].el;
                    $th = $(th);
                    cmi = colModel[i];
                    thStyle = {
                        "height": "0px",
                        "width": ths[i].width + "px",
                        "display": cmi.hidden ? "none" : ""
                    };
                    $("<th>", {
                        "role": "gridcell"
                    }).css(thStyle).addClass("ui-first-th-" + ts.p.direction).appendTo($firstHeaderRow);
                    th.style.width = "";
                    iCol = inColumnHeader(cmi.name, o.groupHeaders);
                    if (iCol >= 0) {
                        cghi = o.groupHeaders[iCol];
                        numberOfColumns = cghi.numberOfColumns;
                        titleText = cghi.titleText;
                        for (cVisibleColumns = 0, iCol = 0; iCol < numberOfColumns && i + iCol < cml; iCol++) {
                            if (!colModel[i + iCol].hidden) {
                                cVisibleColumns++;
                            }
                        }
                        $colHeader = $("<th>").attr({
                            "role": "columnheader"
                        }).addClass("ui-state-default ui-th-column-header ui-th-" + ts.p.direction).css({
                            "height": "22px",
                            "border-top": "0px none"
                        }).html(titleText);
                        if (cVisibleColumns > 0) {
                            $colHeader.attr("colspan", String(cVisibleColumns));
                        }
                        if (ts.p.headertitles) {
                            $colHeader.attr("title", $colHeader.text());
                        }
                        if (cVisibleColumns === 0) {
                            $colHeader.hide();
                        }
                        $th.before($colHeader);
                        $tr.append(th);
                        skip = numberOfColumns - 1;
                    } else {
                        if (skip === 0) {
                            if (o.useColSpanStyle) {
                                $th.attr("rowspan", "2");
                            } else {
                                $("<th>", {
                                    "role": "columnheader"
                                }).addClass("ui-state-default ui-th-column-header ui-th-" + ts.p.direction).css({
                                    "display": cmi.hidden ? "none" : "",
                                    "border-top": "0px none"
                                }).insertBefore($th);
                                $tr.append(th);
                            }
                        } else {
                            $tr.append(th);
                            skip--;
                        }
                    }
                }
                $theadInTable = $(ts).children("thead");
                $theadInTable.prepend($firstHeaderRow);
                $tr.insertAfter($trLabels);
                $htable.append($theadInTable);
                if (o.useColSpanStyle) {
                    $htable.find("span.ui-jqgrid-resize").each(function() {
                        var $parent = $(this).parent();
                        if ($parent.is(":visible")) {
                            this.style.cssText = "height: " + $parent.height() + "px !important; cursor: col-resize;";
                        }
                    });
                    $htable.find("div.ui-jqgrid-sortable").each(function() {
                        var $ts = $(this), $parent = $ts.parent();
                        if ($parent.is(":visible") && $parent.is(":has(span.ui-jqgrid-resize)")) {
                            $ts.css("top", ($parent.height() - $ts.outerHeight()) / 2 + "px");
                        }
                    });
                }
                $firstRow = $theadInTable.find("tr.jqg-first-row-header");
                $(ts).bind("jqGridResizeStop.setGroupHeaders", function(e, nw, idx) {
                    $firstRow.find("th").eq(idx).width(nw);
                });
            });
        },
        "setFrozenColumns": function() {
            return this.each(function() {
                if (!this.grid) {
                    return;
                }
                var $t = this, cm = $t.p.colModel, i = 0, len = cm.length, maxfrozen = -1, frozen = false;
                if ($t.p.subGrid === true || $t.p.treeGrid === true || $t.p.cellEdit === true || $t.p.sortable || $t.p.scroll || $t.p.grouping) {
                    return;
                }
                if ($t.p.rownumbers) {
                    i++;
                }
                if ($t.p.multiselect) {
                    i++;
                }
                while (i < len) {
                    if (cm[i].frozen === true) {
                        frozen = true;
                        maxfrozen = i;
                    } else {
                        break;
                    }
                    i++;
                }
                if (maxfrozen >= 0 && frozen) {
                    var top = $t.p.caption ? $($t.grid.cDiv).outerHeight() : 0, hth = $(".ui-jqgrid-htable", "#gview_" + $.jgrid.jqID($t.p.id)).height();
                    if ($t.p.toppager) {
                        top = top + $($t.grid.topDiv).outerHeight();
                    }
                    if ($t.p.toolbar[0] === true) {
                        if ($t.p.toolbar[1] != "bottom") {
                            top = top + $($t.grid.uDiv).outerHeight();
                        }
                    }
                    $t.grid.fhDiv = $('<div style="position:absolute;left:0px;top:' + top + "px;height:" + hth + 'px;" class="frozen-div ui-state-default ui-jqgrid-hdiv"></div>');
                    $t.grid.fbDiv = $('<div style="position:absolute;left:0px;top:' + (parseInt(top, 10) + parseInt(hth, 10) + 1) + 'px;overflow-y:hidden" class="frozen-bdiv ui-jqgrid-bdiv"></div>');
                    $("#gview_" + $.jgrid.jqID($t.p.id)).append($t.grid.fhDiv);
                    var htbl = $(".ui-jqgrid-htable", "#gview_" + $.jgrid.jqID($t.p.id)).clone(true);
                    if ($t.p.groupHeader) {
                        $("tr.jqg-first-row-header, tr.jqg-third-row-header", htbl).each(function() {
                            $("th:gt(" + maxfrozen + ")", this).remove();
                        });
                        var swapfroz = -1, fdel = -1;
                        $("tr.jqg-second-row-header th", htbl).each(function() {
                            var cs = parseInt($(this).attr("colspan"), 10);
                            if (cs) {
                                swapfroz = swapfroz + cs;
                                fdel++;
                            }
                            if (swapfroz === maxfrozen) {
                                return false;
                            }
                        });
                        if (swapfroz !== maxfrozen) {
                            fdel = maxfrozen;
                        }
                        $("tr.jqg-second-row-header", htbl).each(function() {
                            $("th:gt(" + fdel + ")", this).remove();
                        });
                    } else {
                        $("tr", htbl).each(function() {
                            $("th:gt(" + maxfrozen + ")", this).remove();
                        });
                    }
                    $(htbl).width(1);
                    $($t.grid.fhDiv).append(htbl).mousemove(function(e) {
                        if ($t.grid.resizing) {
                            $t.grid.dragMove(e);
                            return false;
                        }
                    });
                    $($t).bind("jqGridResizeStop.setFrozenColumns", function(e, w, index) {
                        var rhth = $(".ui-jqgrid-htable", $t.grid.fhDiv);
                        $("th:eq(" + index + ")", rhth).width(w);
                        var btd = $(".ui-jqgrid-btable", $t.grid.fbDiv);
                        $("tr:first td:eq(" + index + ")", btd).width(w);
                    });
                    $($t).bind("jqGridOnSortCol.setFrozenColumns", function(index, idxcol) {
                        var previousSelectedTh = $("tr.ui-jqgrid-labels:last th:eq(" + $t.p.lastsort + ")", $t.grid.fhDiv), newSelectedTh = $("tr.ui-jqgrid-labels:last th:eq(" + idxcol + ")", $t.grid.fhDiv);
                        $("span.ui-grid-ico-sort", previousSelectedTh).addClass("ui-state-disabled");
                        $(previousSelectedTh).attr("aria-selected", "false");
                        $("span.ui-icon-" + $t.p.sortorder, newSelectedTh).removeClass("ui-state-disabled");
                        $(newSelectedTh).attr("aria-selected", "true");
                        if (!$t.p.viewsortcols[0]) {
                            if ($t.p.lastsort != idxcol) {
                                $("span.s-ico", previousSelectedTh).hide();
                                $("span.s-ico", newSelectedTh).show();
                            }
                        }
                    });
                    $("#gview_" + $.jgrid.jqID($t.p.id)).append($t.grid.fbDiv);
                    $($t.grid.bDiv).scroll(function() {
                        $($t.grid.fbDiv).scrollTop($(this).scrollTop());
                    });
                    if ($t.p.hoverrows === true) {
                        $("#" + $.jgrid.jqID($t.p.id)).unbind("mouseover").unbind("mouseout");
                    }
                    $($t).bind("jqGridAfterGridComplete.setFrozenColumns", function() {
                        $("#" + $.jgrid.jqID($t.p.id) + "_frozen").remove();
                        $($t.grid.fbDiv).height($($t.grid.bDiv).height() - 16);
                        var btbl = $("#" + $.jgrid.jqID($t.p.id)).clone(true);
                        $("tr", btbl).each(function() {
                            $("td:gt(" + maxfrozen + ")", this).remove();
                        });
                        $(btbl).width(1).attr("id", $t.p.id + "_frozen");
                        $($t.grid.fbDiv).append(btbl);
                        if ($t.p.hoverrows === true) {
                            $("tr.jqgrow", btbl).hover(function() {
                                $(this).addClass("ui-state-hover");
                                $("#" + $.jgrid.jqID(this.id), "#" + $.jgrid.jqID($t.p.id)).addClass("ui-state-hover");
                            }, function() {
                                $(this).removeClass("ui-state-hover");
                                $("#" + $.jgrid.jqID(this.id), "#" + $.jgrid.jqID($t.p.id)).removeClass("ui-state-hover");
                            });
                            $("tr.jqgrow", "#" + $.jgrid.jqID($t.p.id)).hover(function() {
                                $(this).addClass("ui-state-hover");
                                $("#" + $.jgrid.jqID(this.id), "#" + $.jgrid.jqID($t.p.id) + "_frozen").addClass("ui-state-hover");
                            }, function() {
                                $(this).removeClass("ui-state-hover");
                                $("#" + $.jgrid.jqID(this.id), "#" + $.jgrid.jqID($t.p.id) + "_frozen").removeClass("ui-state-hover");
                            });
                        }
                        btbl = null;
                    });
                    $t.p.frozenColumns = true;
                }
            });
        },
        "destroyFrozenColumns": function() {
            return this.each(function() {
                if (!this.grid) {
                    return;
                }
                if (this.p.frozenColumns === true) {
                    var $t = this;
                    $($t.grid.fhDiv).remove();
                    $($t.grid.fbDiv).remove();
                    $t.grid.fhDiv = null;
                    $t.grid.fbDiv = null;
                    $(this).unbind(".setFrozenColumns");
                    if ($t.p.hoverrows === true) {
                        var ptr;
                        $("#" + $.jgrid.jqID($t.p.id)).bind("mouseover", function(e) {
                            ptr = $(e.target).closest("tr.jqgrow");
                            if ($(ptr).attr("class") !== "ui-subgrid") {
                                $(ptr).addClass("ui-state-hover");
                            }
                        }).bind("mouseout", function(e) {
                            ptr = $(e.target).closest("tr.jqgrow");
                            $(ptr).removeClass("ui-state-hover");
                        });
                    }
                    this.p.frozenColumns = false;
                }
            });
        }
    });
})(jQuery);

(function($) {
    "use strict";
    $.extend($.jgrid, {
        "template": function(format) {
            var args = $.makeArray(arguments).slice(1), j, al = args.length;
            if (format == null) {
                format = "";
            }
            return format.replace(/\{([\w\-]+)(?:\:([\w\.]*)(?:\((.*?)?\))?)?\}/g, function(m, i) {
                if (!isNaN(parseInt(i, 10))) {
                    return args[parseInt(i, 10)];
                }
                for (j = 0; j < al; j++) {
                    if ($.isArray(args[j])) {
                        var nmarr = args[j], k = nmarr.length;
                        while (k--) {
                            if (i === nmarr[k].nm) {
                                return nmarr[k].v;
                            }
                        }
                    }
                }
            });
        }
    });
    $.jgrid.extend({
        "groupingSetup": function() {
            return this.each(function() {
                var $t = this, i, j, cml, cm = $t.p.colModel, grp = $t.p.groupingView;
                if (grp !== null && (typeof grp === "object" || $.isFunction(grp))) {
                    if (!grp.groupField.length) {
                        $t.p.grouping = false;
                    } else {
                        if (grp.visibiltyOnNextGrouping === undefined) {
                            grp.visibiltyOnNextGrouping = [];
                        }
                        grp.lastvalues = [];
                        grp.groups = [];
                        grp.counters = [];
                        for (i = 0; i < grp.groupField.length; i++) {
                            if (!grp.groupOrder[i]) {
                                grp.groupOrder[i] = "asc";
                            }
                            if (!grp.groupText[i]) {
                                grp.groupText[i] = "{0}";
                            }
                            if (typeof grp.groupColumnShow[i] !== "boolean") {
                                grp.groupColumnShow[i] = true;
                            }
                            if (typeof grp.groupSummary[i] !== "boolean") {
                                grp.groupSummary[i] = false;
                            }
                            if (grp.groupColumnShow[i] === true) {
                                grp.visibiltyOnNextGrouping[i] = true;
                                $($t).jqGrid("showCol", grp.groupField[i]);
                            } else {
                                grp.visibiltyOnNextGrouping[i] = $("#" + $.jgrid.jqID($t.p.id + "_" + grp.groupField[i])).is(":visible");
                                $($t).jqGrid("hideCol", grp.groupField[i]);
                            }
                        }
                        grp.summary = [];
                        for (j = 0, cml = cm.length; j < cml; j++) {
                            if (cm[j].summaryType) {
                                grp.summary.push({
                                    "nm": cm[j].name,
                                    "st": cm[j].summaryType,
                                    "v": "",
                                    "sr": cm[j].summaryRound,
                                    "srt": cm[j].summaryRoundType || "round"
                                });
                            }
                        }
                    }
                } else {
                    $t.p.grouping = false;
                }
            });
        },
        "groupingPrepare": function(rData, gdata, record, irow) {
            this.each(function() {
                var grp = this.p.groupingView, $t = this, i, grlen = grp.groupField.length, fieldName, v, displayName, displayValue, changed = 0;
                for (i = 0; i < grlen; i++) {
                    fieldName = grp.groupField[i];
                    displayName = grp.displayField[i];
                    v = record[fieldName];
                    displayValue = displayName == null ? null : record[displayName];
                    if (displayValue == null) {
                        displayValue = v;
                    }
                    if (v !== undefined) {
                        if (irow === 0) {
                            grp.groups.push({
                                "idx": i,
                                "dataIndex": fieldName,
                                "value": v,
                                "displayValue": displayValue,
                                "startRow": irow,
                                "cnt": 1,
                                "summary": []
                            });
                            grp.lastvalues[i] = v;
                            grp.counters[i] = {
                                "cnt": 1,
                                "pos": grp.groups.length - 1,
                                "summary": $.extend(true, [], grp.summary)
                            };
                            $.each(grp.counters[i].summary, function() {
                                if ($.isFunction(this.st)) {
                                    this.v = this.st.call($t, this.v, this.nm, record);
                                } else {
                                    this.v = $($t).jqGrid("groupingCalculations.handler", this.st, this.v, this.nm, this.sr, this.srt, record);
                                }
                            });
                            grp.groups[grp.counters[i].pos].summary = grp.counters[i].summary;
                        } else {
                            if (typeof v !== "object" && grp.lastvalues[i] !== v) {
                                grp.groups.push({
                                    "idx": i,
                                    "dataIndex": fieldName,
                                    "value": v,
                                    "displayValue": displayValue,
                                    "startRow": irow,
                                    "cnt": 1,
                                    "summary": []
                                });
                                grp.lastvalues[i] = v;
                                changed = 1;
                                grp.counters[i] = {
                                    "cnt": 1,
                                    "pos": grp.groups.length - 1,
                                    "summary": $.extend(true, [], grp.summary)
                                };
                                $.each(grp.counters[i].summary, function() {
                                    if ($.isFunction(this.st)) {
                                        this.v = this.st.call($t, this.v, this.nm, record);
                                    } else {
                                        this.v = $($t).jqGrid("groupingCalculations.handler", this.st, this.v, this.nm, this.sr, this.srt, record);
                                    }
                                });
                                grp.groups[grp.counters[i].pos].summary = grp.counters[i].summary;
                            } else {
                                if (changed === 1) {
                                    grp.groups.push({
                                        "idx": i,
                                        "dataIndex": fieldName,
                                        "value": v,
                                        "displayValue": displayValue,
                                        "startRow": irow,
                                        "cnt": 1,
                                        "summary": []
                                    });
                                    grp.lastvalues[i] = v;
                                    grp.counters[i] = {
                                        "cnt": 1,
                                        "pos": grp.groups.length - 1,
                                        "summary": $.extend(true, [], grp.summary)
                                    };
                                    $.each(grp.counters[i].summary, function() {
                                        if ($.isFunction(this.st)) {
                                            this.v = this.st.call($t, this.v, this.nm, record);
                                        } else {
                                            this.v = $($t).jqGrid("groupingCalculations.handler", this.st, this.v, this.nm, this.sr, this.srt, record);
                                        }
                                    });
                                    grp.groups[grp.counters[i].pos].summary = grp.counters[i].summary;
                                } else {
                                    grp.counters[i].cnt += 1;
                                    grp.groups[grp.counters[i].pos].cnt = grp.counters[i].cnt;
                                    $.each(grp.counters[i].summary, function() {
                                        if ($.isFunction(this.st)) {
                                            this.v = this.st.call($t, this.v, this.nm, record);
                                        } else {
                                            this.v = $($t).jqGrid("groupingCalculations.handler", this.st, this.v, this.nm, this.sr, this.srt, record);
                                        }
                                    });
                                    grp.groups[grp.counters[i].pos].summary = grp.counters[i].summary;
                                }
                            }
                        }
                    }
                }
                gdata.push(rData);
            });
            return gdata;
        },
        "groupingToggle": function(hid) {
            this.each(function() {
                var $t = this, grp = $t.p.groupingView, strpos = hid.split("_"), num = parseInt(strpos[strpos.length - 2], 10);
                strpos.splice(strpos.length - 2, 2);
                var uid = strpos.join("_"), minus = grp.minusicon, plus = grp.plusicon, tar = $("#" + $.jgrid.jqID(hid)), r = tar.length ? tar[0].nextSibling : null, tarspan = $("#" + $.jgrid.jqID(hid) + " span." + "tree-wrap-" + $t.p.direction), collapsed = false, tspan;
                if (tarspan.hasClass(minus)) {
                    if (grp.showSummaryOnHide) {
                        if (r) {
                            while (r) {
                                if ($(r).hasClass("jqfoot")) {
                                    var lv = parseInt($(r).attr("jqfootlevel"), 10);
                                    if (lv <= num) {
                                        break;
                                    }
                                }
                                $(r).hide();
                                r = r.nextSibling;
                            }
                        }
                    } else {
                        if (r) {
                            while (r) {
                                if ($(r).hasClass(uid + "_" + String(num)) || $(r).hasClass(uid + "_" + String(num - 1))) {
                                    break;
                                }
                                $(r).hide();
                                r = r.nextSibling;
                            }
                        }
                    }
                    tarspan.removeClass(minus).addClass(plus);
                    collapsed = true;
                } else {
                    if (r) {
                        while (r) {
                            if ($(r).hasClass(uid + "_" + String(num)) || $(r).hasClass(uid + "_" + String(num - 1))) {
                                break;
                            }
                            $(r).show();
                            tspan = $(r).find("span." + "tree-wrap-" + $t.p.direction);
                            if (tspan && $(tspan).hasClass(plus)) {
                                $(tspan).removeClass(plus).addClass(minus);
                            }
                            r = r.nextSibling;
                        }
                    }
                    tarspan.removeClass(plus).addClass(minus);
                }
                $($t).triggerHandler("jqGridGroupingClickGroup", [ hid, collapsed ]);
                if ($.isFunction($t.p.onClickGroup)) {
                    $t.p.onClickGroup.call($t, hid, collapsed);
                }
            });
            return false;
        },
        "groupingRender": function(grdata, colspans) {
            return this.each(function() {
                var $t = this, grp = $t.p.groupingView, str = "", icon = "", hid, clid, pmrtl = grp.groupCollapse ? grp.plusicon : grp.minusicon, gv, cp = [], len = grp.groupField.length;
                pmrtl += " tree-wrap-" + $t.p.direction;
                $.each($t.p.colModel, function(i, n) {
                    var ii;
                    for (ii = 0; ii < len; ii++) {
                        if (grp.groupField[ii] === n.name) {
                            cp[ii] = i;
                            break;
                        }
                    }
                });
                var toEnd = 0;
                function findGroupIdx(ind, offset, grp) {
                    var ret = false, i;
                    if (offset === 0) {
                        ret = grp[ind];
                    } else {
                        var id = grp[ind].idx;
                        if (id === 0) {
                            ret = grp[ind];
                        } else {
                            for (i = ind; i >= 0; i--) {
                                if (grp[i].idx === id - offset) {
                                    ret = grp[i];
                                    break;
                                }
                            }
                        }
                    }
                    return ret;
                }
                var sumreverse = $.makeArray(grp.groupSummary);
                sumreverse.reverse();
                $.each(grp.groups, function(i, n) {
                    toEnd++;
                    clid = $t.p.id + "ghead_" + n.idx;
                    hid = clid + "_" + i;
                    icon = "<span style='cursor:pointer;' class='ui-icon " + pmrtl + "' onclick=\"jQuery('#" + $.jgrid.jqID($t.p.id) + "').jqGrid('groupingToggle','" + hid + "');return false;\"></span>";
                    try {
                        gv = $t.formatter(hid, n.displayValue, cp[n.idx], n.value);
                    } catch (egv) {
                        gv = n.displayValue;
                    }
                    str += '<tr id="' + hid + '" role="row" class= "ui-widget-content jqgroup ui-row-' + $t.p.direction + " " + clid + '"><td style="padding-left:' + n.idx * 12 + "px;" + '" colspan="' + colspans + '">' + icon + $.jgrid.template(grp.groupText[n.idx], gv, n.cnt, n.summary) + "</td></tr>";
                    var leaf = len - 1 === n.idx;
                    if (leaf) {
                        var gg = grp.groups[i + 1], k, kk, ik;
                        var end = gg !== undefined ? grp.groups[i + 1].startRow : grdata.length;
                        for (kk = n.startRow; kk < end; kk++) {
                            str += grdata[kk].join("");
                        }
                        var jj;
                        if (gg !== undefined) {
                            for (jj = 0; jj < grp.groupField.length; jj++) {
                                if (gg.dataIndex === grp.groupField[jj]) {
                                    break;
                                }
                            }
                            toEnd = grp.groupField.length - jj;
                        }
                        for (ik = 0; ik < toEnd; ik++) {
                            if (!sumreverse[ik]) {
                                continue;
                            }
                            var hhdr = "";
                            if (grp.groupCollapse && !grp.showSummaryOnHide) {
                                hhdr = ' style="display:none;"';
                            }
                            str += "<tr" + hhdr + ' jqfootlevel="' + (n.idx - ik) + '" role="row" class="ui-widget-content jqfoot ui-row-' + $t.p.direction + '">';
                            var fdata = findGroupIdx(i, ik, grp.groups), cm = $t.p.colModel, vv, grlen = fdata.cnt;
                            for (k = 0; k < colspans; k++) {
                                var tmpdata = "<td " + $t.formatCol(k, 1, "") + ">&#160;</td>", tplfld = "{0}";
                                $.each(fdata.summary, function() {
                                    if (this.nm === cm[k].name) {
                                        if (cm[k].summaryTpl) {
                                            tplfld = cm[k].summaryTpl;
                                        }
                                        if (typeof this.st === "string" && this.st.toLowerCase() === "avg") {
                                            if (this.v && grlen > 0) {
                                                this.v = this.v / grlen;
                                            }
                                        }
                                        try {
                                            vv = $t.formatter("", this.v, k, this);
                                        } catch (ef) {
                                            vv = this.v;
                                        }
                                        tmpdata = "<td " + $t.formatCol(k, 1, "") + ">" + $.jgrid.format(tplfld, vv) + "</td>";
                                        return false;
                                    }
                                });
                                str += tmpdata;
                            }
                            str += "</tr>";
                        }
                        toEnd = jj;
                    }
                });
                $("#" + $.jgrid.jqID($t.p.id) + " tbody:first").append(str);
                str = null;
            });
        },
        "groupingGroupBy": function(name, options) {
            return this.each(function() {
                var $t = this;
                if (typeof name === "string") {
                    name = [ name ];
                }
                var grp = $t.p.groupingView;
                $t.p.grouping = true;
                if (grp.visibiltyOnNextGrouping === undefined) {
                    grp.visibiltyOnNextGrouping = [];
                }
                var i;
                for (i = 0; i < grp.groupField.length; i++) {
                    if (!grp.groupColumnShow[i] && grp.visibiltyOnNextGrouping[i]) {
                        $($t).jqGrid("showCol", grp.groupField[i]);
                    }
                }
                for (i = 0; i < name.length; i++) {
                    grp.visibiltyOnNextGrouping[i] = $("#" + $.jgrid.jqID($t.p.id) + "_" + $.jgrid.jqID(name[i])).is(":visible");
                }
                $t.p.groupingView = $.extend($t.p.groupingView, options || {});
                grp.groupField = name;
                $($t).trigger("reloadGrid");
            });
        },
        "groupingRemove": function(current) {
            return this.each(function() {
                var $t = this;
                if (current === undefined) {
                    current = true;
                }
                $t.p.grouping = false;
                if (current === true) {
                    var grp = $t.p.groupingView, i;
                    for (i = 0; i < grp.groupField.length; i++) {
                        if (!grp.groupColumnShow[i] && grp.visibiltyOnNextGrouping[i]) {
                            $($t).jqGrid("showCol", grp.groupField);
                        }
                    }
                    $("tr.jqgroup, tr.jqfoot", "#" + $.jgrid.jqID($t.p.id) + " tbody:first").remove();
                    $("tr.jqgrow:hidden", "#" + $.jgrid.jqID($t.p.id) + " tbody:first").show();
                } else {
                    $($t).trigger("reloadGrid");
                }
            });
        },
        "groupingCalculations": {
            "handler": function(fn, v, field, round, roundType, rc) {
                var funcs = {
                    "sum": function() {
                        return parseFloat(v || 0) + parseFloat(rc[field] || 0);
                    },
                    "min": function() {
                        if (v === "") {
                            return parseFloat(rc[field] || 0);
                        }
                        return Math.min(parseFloat(v), parseFloat(rc[field] || 0));
                    },
                    "max": function() {
                        if (v === "") {
                            return parseFloat(rc[field] || 0);
                        }
                        return Math.max(parseFloat(v), parseFloat(rc[field] || 0));
                    },
                    "count": function() {
                        if (v === "") {
                            v = 0;
                        }
                        if (rc.hasOwnProperty(field)) {
                            return v + 1;
                        }
                        return 0;
                    },
                    "avg": function() {
                        return funcs.sum();
                    }
                };
                if (!funcs[fn]) {
                    throw "jqGrid Grouping No such method: " + fn;
                }
                var res = funcs[fn]();
                if (round != null) {
                    if (roundType == "fixed") {
                        res = res.toFixed(round);
                    } else {
                        var mul = Math.pow(10, round);
                        res = Math.round(res * mul) / mul;
                    }
                }
                return res;
            }
        }
    });
})(jQuery);

(function($) {
    "use strict";
    $.fmatter = {};
    $.extend($.fmatter, {
        "isBoolean": function(o) {
            return typeof o === "boolean";
        },
        "isObject": function(o) {
            return o && (typeof o === "object" || $.isFunction(o)) || false;
        },
        "isString": function(o) {
            return typeof o === "string";
        },
        "isNumber": function(o) {
            return typeof o === "number" && isFinite(o);
        },
        "isValue": function(o) {
            return this.isObject(o) || this.isString(o) || this.isNumber(o) || this.isBoolean(o);
        },
        "isEmpty": function(o) {
            if (!this.isString(o) && this.isValue(o)) {
                return false;
            }
            if (!this.isValue(o)) {
                return true;
            }
            o = $.trim(o).replace(/\&nbsp\;/gi, "").replace(/\&#160\;/gi, "");
            return o === "";
        }
    });
    $.fn.fmatter = function(formatType, cellval, opts, rwd, act) {
        var v = cellval;
        opts = $.extend({}, $.jgrid.formatter, opts);
        try {
            v = $.fn.fmatter[formatType].call(this, cellval, opts, rwd, act);
        } catch (fe) {}
        return v;
    };
    $.fmatter.util = {
        "NumberFormat": function(nData, opts) {
            if (!$.fmatter.isNumber(nData)) {
                nData *= 1;
            }
            if ($.fmatter.isNumber(nData)) {
                var bNegative = nData < 0;
                var sOutput = String(nData);
                var sDecimalSeparator = opts.decimalSeparator || ".";
                var nDotIndex;
                if ($.fmatter.isNumber(opts.decimalPlaces)) {
                    var nDecimalPlaces = opts.decimalPlaces;
                    var nDecimal = Math.pow(10, nDecimalPlaces);
                    sOutput = String(Math.round(nData * nDecimal) / nDecimal);
                    nDotIndex = sOutput.lastIndexOf(".");
                    if (nDecimalPlaces > 0) {
                        if (nDotIndex < 0) {
                            sOutput += sDecimalSeparator;
                            nDotIndex = sOutput.length - 1;
                        } else if (sDecimalSeparator !== ".") {
                            sOutput = sOutput.replace(".", sDecimalSeparator);
                        }
                        while (sOutput.length - 1 - nDotIndex < nDecimalPlaces) {
                            sOutput += "0";
                        }
                    }
                }
                if (opts.thousandsSeparator) {
                    var sThousandsSeparator = opts.thousandsSeparator;
                    nDotIndex = sOutput.lastIndexOf(sDecimalSeparator);
                    nDotIndex = nDotIndex > -1 ? nDotIndex : sOutput.length;
                    var sNewOutput = sOutput.substring(nDotIndex);
                    var nCount = -1, i;
                    for (i = nDotIndex; i > 0; i--) {
                        nCount++;
                        if (nCount % 3 === 0 && i !== nDotIndex && (!bNegative || i > 1)) {
                            sNewOutput = sThousandsSeparator + sNewOutput;
                        }
                        sNewOutput = sOutput.charAt(i - 1) + sNewOutput;
                    }
                    sOutput = sNewOutput;
                }
                sOutput = opts.prefix ? opts.prefix + sOutput : sOutput;
                sOutput = opts.suffix ? sOutput + opts.suffix : sOutput;
                return sOutput;
            }
            return nData;
        },
        "DateFormat": function(format, date, newformat, opts) {
            var token = /\\.|[dDjlNSwzWFmMntLoYyaABgGhHisueIOPTZcrU]/g, timezone = /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g, timezoneClip = /[^-+\dA-Z]/g, msDateRegExp = new RegExp("^/Date\\((([-+])?[0-9]+)(([-+])([0-9]{2})([0-9]{2}))?\\)/$"), msMatch = typeof date === "string" ? date.match(msDateRegExp) : null, pad = function(value, length) {
                value = String(value);
                length = parseInt(length, 10) || 2;
                while (value.length < length) {
                    value = "0" + value;
                }
                return value;
            }, ts = {
                "m": 1,
                "d": 1,
                "y": 1970,
                "h": 0,
                "i": 0,
                "s": 0,
                "u": 0
            }, timestamp = 0, dM, k, hl, dateFormat = [ "i18n" ];
            dateFormat.i18n = {
                "dayNames": opts.dayNames,
                "monthNames": opts.monthNames
            };
            if (opts.masks.hasOwnProperty(format)) {
                format = opts.masks[format];
            }
            if (!isNaN(date - 0) && String(format).toLowerCase() === "u") {
                timestamp = new Date(parseFloat(date) * 1e3);
            } else if (date.constructor === Date) {
                timestamp = date;
            } else if (msMatch !== null) {
                timestamp = new Date(parseInt(msMatch[1], 10));
                if (msMatch[3]) {
                    var offset = Number(msMatch[5]) * 60 + Number(msMatch[6]);
                    offset *= msMatch[4] === "-" ? 1 : -1;
                    offset -= timestamp.getTimezoneOffset();
                    timestamp.setTime(Number(Number(timestamp) + offset * 60 * 1e3));
                }
            } else {
                date = String(date).split(/[\\\/:_;.,\t\s-]/);
                format = format.split(/[\\\/:_;.,\t\s-]/);
                for (k = 0, hl = format.length; k < hl; k++) {
                    if (format[k] === "M") {
                        dM = $.inArray(date[k], dateFormat.i18n.monthNames);
                        if (dM !== -1 && dM < 12) {
                            date[k] = dM + 1;
                        }
                    }
                    if (format[k] === "F") {
                        dM = $.inArray(date[k], dateFormat.i18n.monthNames);
                        if (dM !== -1 && dM > 11) {
                            date[k] = dM + 1 - 12;
                        }
                    }
                    if (date[k]) {
                        ts[format[k].toLowerCase()] = parseInt(date[k], 10);
                    }
                }
                if (ts.f) {
                    ts.m = ts.f;
                }
                if (ts.m === 0 && ts.y === 0 && ts.d === 0) {
                    return "&#160;";
                }
                ts.m = parseInt(ts.m, 10) - 1;
                var ty = ts.y;
                if (ty >= 70 && ty <= 99) {
                    ts.y = 1900 + ts.y;
                } else if (ty >= 0 && ty <= 69) {
                    ts.y = 2e3 + ts.y;
                }
                timestamp = new Date(ts.y, ts.m, ts.d, ts.h, ts.i, ts.s, ts.u);
            }
            if (opts.masks.hasOwnProperty(newformat)) {
                newformat = opts.masks[newformat];
            } else if (!newformat) {
                newformat = "Y-m-d";
            }
            var G = timestamp.getHours(), i = timestamp.getMinutes(), j = timestamp.getDate(), n = timestamp.getMonth() + 1, o = timestamp.getTimezoneOffset(), s = timestamp.getSeconds(), u = timestamp.getMilliseconds(), w = timestamp.getDay(), Y = timestamp.getFullYear(), N = (w + 6) % 7 + 1, z = (new Date(Y, n - 1, j) - new Date(Y, 0, 1)) / 864e5, flags = {
                "d": pad(j),
                "D": dateFormat.i18n.dayNames[w],
                "j": j,
                "l": dateFormat.i18n.dayNames[w + 7],
                "N": N,
                "S": opts.S(j),
                "w": w,
                "z": z,
                "W": N < 5 ? Math.floor((z + N - 1) / 7) + 1 : Math.floor((z + N - 1) / 7) || ((new Date(Y - 1, 0, 1).getDay() + 6) % 7 < 4 ? 53 : 52),
                "F": dateFormat.i18n.monthNames[n - 1 + 12],
                "m": pad(n),
                "M": dateFormat.i18n.monthNames[n - 1],
                "n": n,
                "t": "?",
                "L": "?",
                "o": "?",
                "Y": Y,
                "y": String(Y).substring(2),
                "a": G < 12 ? opts.AmPm[0] : opts.AmPm[1],
                "A": G < 12 ? opts.AmPm[2] : opts.AmPm[3],
                "B": "?",
                "g": G % 12 || 12,
                "G": G,
                "h": pad(G % 12 || 12),
                "H": pad(G),
                "i": pad(i),
                "s": pad(s),
                "u": u,
                "e": "?",
                "I": "?",
                "O": (o > 0 ? "-" : "+") + pad(Math.floor(Math.abs(o) / 60) * 100 + Math.abs(o) % 60, 4),
                "P": "?",
                "T": (String(timestamp).match(timezone) || [ "" ]).pop().replace(timezoneClip, ""),
                "Z": "?",
                "c": "?",
                "r": "?",
                "U": Math.floor(timestamp / 1e3)
            };
            return newformat.replace(token, function($0) {
                return flags.hasOwnProperty($0) ? flags[$0] : $0.substring(1);
            });
        }
    };
    $.fn.fmatter.defaultFormat = function(cellval, opts) {
        return $.fmatter.isValue(cellval) && cellval !== "" ? cellval : opts.defaultValue || "&#160;";
    };
    $.fn.fmatter.email = function(cellval, opts) {
        if (!$.fmatter.isEmpty(cellval)) {
            return '<a href="mailto:' + cellval + '">' + cellval + "</a>";
        }
        return $.fn.fmatter.defaultFormat(cellval, opts);
    };
    $.fn.fmatter.checkbox = function(cval, opts) {
        var op = $.extend({}, opts.checkbox), ds;
        if (opts.colModel !== undefined && opts.colModel.formatoptions !== undefined) {
            op = $.extend({}, op, opts.colModel.formatoptions);
        }
        if (op.disabled === true) {
            ds = 'disabled="disabled"';
        } else {
            ds = "";
        }
        if ($.fmatter.isEmpty(cval) || cval === undefined) {
            cval = $.fn.fmatter.defaultFormat(cval, op);
        }
        cval = String(cval);
        cval = cval.toLowerCase();
        var bchk = cval.search(/(false|f|0|no|n|off|undefined)/i) < 0 ? " checked='checked' " : "";
        return '<input type="checkbox" ' + bchk + ' value="' + cval + '" offval="no" ' + ds + "/>";
    };
    $.fn.fmatter.link = function(cellval, opts) {
        var op = {
            "target": opts.target
        };
        var target = "";
        if (opts.colModel !== undefined && opts.colModel.formatoptions !== undefined) {
            op = $.extend({}, op, opts.colModel.formatoptions);
        }
        if (op.target) {
            target = "target=" + op.target;
        }
        if (!$.fmatter.isEmpty(cellval)) {
            return "<a " + target + ' href="' + cellval + '">' + cellval + "</a>";
        }
        return $.fn.fmatter.defaultFormat(cellval, opts);
    };
    $.fn.fmatter.showlink = function(cellval, opts) {
        var op = {
            "baseLinkUrl": opts.baseLinkUrl,
            "showAction": opts.showAction,
            "addParam": opts.addParam || "",
            "target": opts.target,
            "idName": opts.idName
        }, target = "", idUrl;
        if (opts.colModel !== undefined && opts.colModel.formatoptions !== undefined) {
            op = $.extend({}, op, opts.colModel.formatoptions);
        }
        if (op.target) {
            target = "target=" + op.target;
        }
        idUrl = op.baseLinkUrl + op.showAction + "?" + op.idName + "=" + opts.rowId + op.addParam;
        if ($.fmatter.isString(cellval) || $.fmatter.isNumber(cellval)) {
            return "<a " + target + ' href="' + idUrl + '">' + cellval + "</a>";
        }
        return $.fn.fmatter.defaultFormat(cellval, opts);
    };
    $.fn.fmatter.integer = function(cellval, opts) {
        var op = $.extend({}, opts.integer);
        if (opts.colModel !== undefined && opts.colModel.formatoptions !== undefined) {
            op = $.extend({}, op, opts.colModel.formatoptions);
        }
        if ($.fmatter.isEmpty(cellval)) {
            return op.defaultValue;
        }
        return $.fmatter.util.NumberFormat(cellval, op);
    };
    $.fn.fmatter.number = function(cellval, opts) {
        var op = $.extend({}, opts.number);
        if (opts.colModel !== undefined && opts.colModel.formatoptions !== undefined) {
            op = $.extend({}, op, opts.colModel.formatoptions);
        }
        if ($.fmatter.isEmpty(cellval)) {
            return op.defaultValue;
        }
        return $.fmatter.util.NumberFormat(cellval, op);
    };
    $.fn.fmatter.currency = function(cellval, opts) {
        var op = $.extend({}, opts.currency);
        if (opts.colModel !== undefined && opts.colModel.formatoptions !== undefined) {
            op = $.extend({}, op, opts.colModel.formatoptions);
        }
        if ($.fmatter.isEmpty(cellval)) {
            return op.defaultValue;
        }
        return $.fmatter.util.NumberFormat(cellval, op);
    };
    $.fn.fmatter.date = function(cellval, opts, rwd, act) {
        var op = $.extend({}, opts.date);
        if (opts.colModel !== undefined && opts.colModel.formatoptions !== undefined) {
            op = $.extend({}, op, opts.colModel.formatoptions);
        }
        if (!op.reformatAfterEdit && act === "edit") {
            return $.fn.fmatter.defaultFormat(cellval, opts);
        }
        if (!$.fmatter.isEmpty(cellval)) {
            return $.fmatter.util.DateFormat(op.srcformat, cellval, op.newformat, op);
        }
        return $.fn.fmatter.defaultFormat(cellval, opts);
    };
    $.fn.fmatter.select = function(cellval, opts) {
        cellval = String(cellval);
        var oSelect = false, ret = [], sep, delim;
        if (opts.colModel.formatoptions !== undefined) {
            oSelect = opts.colModel.formatoptions.value;
            sep = opts.colModel.formatoptions.separator === undefined ? ":" : opts.colModel.formatoptions.separator;
            delim = opts.colModel.formatoptions.delimiter === undefined ? ";" : opts.colModel.formatoptions.delimiter;
        } else if (opts.colModel.editoptions !== undefined) {
            oSelect = opts.colModel.editoptions.value;
            sep = opts.colModel.editoptions.separator === undefined ? ":" : opts.colModel.editoptions.separator;
            delim = opts.colModel.editoptions.delimiter === undefined ? ";" : opts.colModel.editoptions.delimiter;
        }
        if (oSelect) {
            var msl = opts.colModel.editoptions.multiple === true ? true : false, scell = [], sv;
            if (msl) {
                scell = cellval.split(",");
                scell = $.map(scell, function(n) {
                    return $.trim(n);
                });
            }
            if ($.fmatter.isString(oSelect)) {
                var so = oSelect.split(delim), j = 0, i;
                for (i = 0; i < so.length; i++) {
                    sv = so[i].split(sep);
                    if (sv.length > 2) {
                        sv[1] = $.map(sv, function(n, i) {
                            if (i > 0) {
                                return n;
                            }
                        }).join(sep);
                    }
                    if (msl) {
                        if ($.inArray(sv[0], scell) > -1) {
                            ret[j] = sv[1];
                            j++;
                        }
                    } else if ($.trim(sv[0]) === $.trim(cellval)) {
                        ret[0] = sv[1];
                        break;
                    }
                }
            } else if ($.fmatter.isObject(oSelect)) {
                if (msl) {
                    ret = $.map(scell, function(n) {
                        return oSelect[n];
                    });
                } else {
                    ret[0] = oSelect[cellval] || "";
                }
            }
        }
        cellval = ret.join(", ");
        return cellval === "" ? $.fn.fmatter.defaultFormat(cellval, opts) : cellval;
    };
    $.fn.fmatter.rowactions = function(act) {
        var $tr = $(this).closest("tr.jqgrow"), $actionsDiv = $(this).parent(), rid = $tr.attr("id"), $grid = $(this).closest("table.ui-jqgrid-btable"), $t = $grid[0], p = $t.p, cm = p.colModel[$.jgrid.getCellIndex(this)], op = {
            "keys": false,
            "onEdit": null,
            "onSuccess": null,
            "afterSave": null,
            "onError": null,
            "afterRestore": null,
            "extraparam": {},
            "url": null,
            "restoreAfterError": true,
            "mtype": "POST",
            "delOptions": {},
            "editOptions": {}
        }, saverow = function(rowid, res) {
            if ($.isFunction(op.afterSave)) {
                op.afterSave.call($t, rowid, res);
            }
            $actionsDiv.find("div.ui-inline-edit,div.ui-inline-del").show();
            $actionsDiv.find("div.ui-inline-save,div.ui-inline-cancel").hide();
        }, restorerow = function(rowid) {
            if ($.isFunction(op.afterRestore)) {
                op.afterRestore.call($t, rowid);
            }
            $actionsDiv.find("div.ui-inline-edit,div.ui-inline-del").show();
            $actionsDiv.find("div.ui-inline-save,div.ui-inline-cancel").hide();
        };
        if (cm.formatoptions !== undefined) {
            op = $.extend(op, cm.formatoptions);
        }
        if (p.editOptions !== undefined) {
            op.editOptions = p.editOptions;
        }
        if (p.delOptions !== undefined) {
            op.delOptions = p.delOptions;
        }
        if ($tr.hasClass("jqgrid-new-row")) {
            op.extraparam[p.prmNames.oper] = p.prmNames.addoper;
        }
        var actop = {
            "keys": op.keys,
            "oneditfunc": op.onEdit,
            "successfunc": op.onSuccess,
            "url": op.url,
            "extraparam": op.extraparam,
            "aftersavefunc": saverow,
            "errorfunc": op.onError,
            "afterrestorefunc": restorerow,
            "restoreAfterError": op.restoreAfterError,
            "mtype": op.mtype
        };
        switch (act) {
          case "edit":
            $grid.jqGrid("editRow", rid, actop);
            $actionsDiv.find("div.ui-inline-edit,div.ui-inline-del").hide();
            $actionsDiv.find("div.ui-inline-save,div.ui-inline-cancel").show();
            $grid.triggerHandler("jqGridAfterGridComplete");
            break;

          case "save":
            if ($grid.jqGrid("saveRow", rid, actop)) {
                $actionsDiv.find("div.ui-inline-edit,div.ui-inline-del").show();
                $actionsDiv.find("div.ui-inline-save,div.ui-inline-cancel").hide();
                $grid.triggerHandler("jqGridAfterGridComplete");
            }
            break;

          case "cancel":
            $grid.jqGrid("restoreRow", rid, restorerow);
            $actionsDiv.find("div.ui-inline-edit,div.ui-inline-del").show();
            $actionsDiv.find("div.ui-inline-save,div.ui-inline-cancel").hide();
            $grid.triggerHandler("jqGridAfterGridComplete");
            break;

          case "del":
            $grid.jqGrid("delGridRow", rid, op.delOptions);
            break;

          case "formedit":
            $grid.jqGrid("setSelection", rid);
            $grid.jqGrid("editGridRow", rid, op.editOptions);
            break;
        }
    };
    $.fn.fmatter.actions = function(cellval, opts) {
        var op = {
            "keys": false,
            "editbutton": true,
            "delbutton": true,
            "editformbutton": false
        }, rowid = opts.rowId, str = "", ocl;
        if (opts.colModel.formatoptions !== undefined) {
            op = $.extend(op, opts.colModel.formatoptions);
        }
        if (rowid === undefined || $.fmatter.isEmpty(rowid)) {
            return "";
        }
        if (op.editformbutton) {
            ocl = "id='jEditButton_" + rowid + "' onclick=jQuery.fn.fmatter.rowactions.call(this,'formedit'); onmouseover=jQuery(this).addClass('ui-state-hover'); onmouseout=jQuery(this).removeClass('ui-state-hover'); ";
            str += "<div title='" + $.jgrid.nav.edittitle + "' style='float:left;cursor:pointer;' class='ui-pg-div ui-inline-edit' " + ocl + "><span class='ui-icon ui-icon-pencil'></span></div>";
        } else if (op.editbutton) {
            ocl = "id='jEditButton_" + rowid + "' onclick=jQuery.fn.fmatter.rowactions.call(this,'edit'); onmouseover=jQuery(this).addClass('ui-state-hover'); onmouseout=jQuery(this).removeClass('ui-state-hover') ";
            str += "<div title='" + $.jgrid.nav.edittitle + "' style='float:left;cursor:pointer;' class='ui-pg-div ui-inline-edit' " + ocl + "><span class='ui-icon ui-icon-pencil'></span></div>";
        }
        if (op.delbutton) {
            ocl = "id='jDeleteButton_" + rowid + "' onclick=jQuery.fn.fmatter.rowactions.call(this,'del'); onmouseover=jQuery(this).addClass('ui-state-hover'); onmouseout=jQuery(this).removeClass('ui-state-hover'); ";
            str += "<div title='" + $.jgrid.nav.deltitle + "' style='float:left;margin-left:5px;' class='ui-pg-div ui-inline-del' " + ocl + "><span class='ui-icon ui-icon-trash'></span></div>";
        }
        ocl = "id='jSaveButton_" + rowid + "' onclick=jQuery.fn.fmatter.rowactions.call(this,'save'); onmouseover=jQuery(this).addClass('ui-state-hover'); onmouseout=jQuery(this).removeClass('ui-state-hover'); ";
        str += "<div title='" + $.jgrid.edit.bSubmit + "' style='float:left;display:none' class='ui-pg-div ui-inline-save' " + ocl + "><span class='ui-icon ui-icon-disk'></span></div>";
        ocl = "id='jCancelButton_" + rowid + "' onclick=jQuery.fn.fmatter.rowactions.call(this,'cancel'); onmouseover=jQuery(this).addClass('ui-state-hover'); onmouseout=jQuery(this).removeClass('ui-state-hover'); ";
        str += "<div title='" + $.jgrid.edit.bCancel + "' style='float:left;display:none;margin-left:5px;' class='ui-pg-div ui-inline-cancel' " + ocl + "><span class='ui-icon ui-icon-cancel'></span></div>";
        return "<div style='margin-left:8px;'>" + str + "</div>";
    };
    $.unformat = function(cellval, options, pos, cnt) {
        var ret, formatType = options.colModel.formatter, op = options.colModel.formatoptions || {}, sep, re = /([\.\*\_\'\(\)\{\}\+\?\\])/g, unformatFunc = options.colModel.unformat || $.fn.fmatter[formatType] && $.fn.fmatter[formatType].unformat;
        if (unformatFunc !== undefined && $.isFunction(unformatFunc)) {
            ret = unformatFunc.call(this, $(cellval).text(), options, cellval);
        } else if (formatType !== undefined && $.fmatter.isString(formatType)) {
            var opts = $.jgrid.formatter || {}, stripTag;
            switch (formatType) {
              case "integer":
                op = $.extend({}, opts.integer, op);
                sep = op.thousandsSeparator.replace(re, "\\$1");
                stripTag = new RegExp(sep, "g");
                ret = $(cellval).text().replace(stripTag, "");
                break;

              case "number":
                op = $.extend({}, opts.number, op);
                sep = op.thousandsSeparator.replace(re, "\\$1");
                stripTag = new RegExp(sep, "g");
                ret = $(cellval).text().replace(stripTag, "").replace(op.decimalSeparator, ".");
                break;

              case "currency":
                op = $.extend({}, opts.currency, op);
                sep = op.thousandsSeparator.replace(re, "\\$1");
                stripTag = new RegExp(sep, "g");
                ret = $(cellval).text();
                if (op.prefix && op.prefix.length) {
                    ret = ret.substr(op.prefix.length);
                }
                if (op.suffix && op.suffix.length) {
                    ret = ret.substr(0, ret.length - op.suffix.length);
                }
                ret = ret.replace(stripTag, "").replace(op.decimalSeparator, ".");
                break;

              case "checkbox":
                var cbv = options.colModel.editoptions ? options.colModel.editoptions.value.split(":") : [ "Yes", "No" ];
                ret = $("input", cellval).is(":checked") ? cbv[0] : cbv[1];
                break;

              case "select":
                ret = $.unformat.select(cellval, options, pos, cnt);
                break;

              case "actions":
                return "";

              default:
                ret = $(cellval).text();
            }
        }
        return ret !== undefined ? ret : cnt === true ? $(cellval).text() : $.jgrid.htmlDecode($(cellval).html());
    };
    $.unformat.select = function(cellval, options, pos, cnt) {
        var ret = [];
        var cell = $(cellval).text();
        if (cnt === true) {
            return cell;
        }
        var op = $.extend({}, options.colModel.formatoptions !== undefined ? options.colModel.formatoptions : options.colModel.editoptions), sep = op.separator === undefined ? ":" : op.separator, delim = op.delimiter === undefined ? ";" : op.delimiter;
        if (op.value) {
            var oSelect = op.value, msl = op.multiple === true ? true : false, scell = [], sv;
            if (msl) {
                scell = cell.split(",");
                scell = $.map(scell, function(n) {
                    return $.trim(n);
                });
            }
            if ($.fmatter.isString(oSelect)) {
                var so = oSelect.split(delim), j = 0, i;
                for (i = 0; i < so.length; i++) {
                    sv = so[i].split(sep);
                    if (sv.length > 2) {
                        sv[1] = $.map(sv, function(n, i) {
                            if (i > 0) {
                                return n;
                            }
                        }).join(sep);
                    }
                    if (msl) {
                        if ($.inArray(sv[1], scell) > -1) {
                            ret[j] = sv[0];
                            j++;
                        }
                    } else if ($.trim(sv[1]) === $.trim(cell)) {
                        ret[0] = sv[0];
                        break;
                    }
                }
            } else if ($.fmatter.isObject(oSelect) || $.isArray(oSelect)) {
                if (!msl) {
                    scell[0] = cell;
                }
                ret = $.map(scell, function(n) {
                    var rv;
                    $.each(oSelect, function(i, val) {
                        if (val === n) {
                            rv = i;
                            return false;
                        }
                    });
                    if (rv !== undefined) {
                        return rv;
                    }
                });
            }
            return ret.join(", ");
        }
        return cell || "";
    };
    $.unformat.date = function(cellval, opts) {
        var op = $.jgrid.formatter.date || {};
        if (opts.formatoptions !== undefined) {
            op = $.extend({}, op, opts.formatoptions);
        }
        if (!$.fmatter.isEmpty(cellval)) {
            return $.fmatter.util.DateFormat(op.newformat, cellval, op.srcformat, op);
        }
        return $.fn.fmatter.defaultFormat(cellval, opts);
    };
})(jQuery);

(function() {
    var gridz;
    gridz = angular.module("angleGrinder.gridz", [ "ngSanitize", "angleGrinder.common", "ui.select2", "angleGrinder.resources" ]);
    gridz.run([ "$window", "agDateFilter", "agCurrencyFilter", function($window, agDateFilter, agCurrencyFilter) {
        $window.agDateFilter = agDateFilter;
        return $window.agCurrencyFilter = agCurrencyFilter;
    } ]);
}).call(this);

(function() {
    "use strict";
    angular.module("ui.grid.i18n", []);
    angular.module("ui.grid", [ "ui.grid.i18n" ]);
})();

(function() {
    "use strict";
    angular.module("ui.grid").constant("uiGridConstants", {
        "LOG_DEBUG_MESSAGES": true,
        "LOG_WARN_MESSAGES": true,
        "LOG_ERROR_MESSAGES": true,
        "CUSTOM_FILTERS": /CUSTOM_FILTERS/g,
        "COL_FIELD": /COL_FIELD/g,
        "MODEL_COL_FIELD": /MODEL_COL_FIELD/g,
        "TOOLTIP": /title=\"TOOLTIP\"/g,
        "DISPLAY_CELL_TEMPLATE": /DISPLAY_CELL_TEMPLATE/g,
        "TEMPLATE_REGEXP": /<.+>/,
        "FUNC_REGEXP": /(\([^)]*\))?$/,
        "DOT_REGEXP": /\./g,
        "APOS_REGEXP": /'/g,
        "BRACKET_REGEXP": /^(.*)((?:\s*\[\s*\d+\s*\]\s*)|(?:\s*\[\s*"(?:[^"\\]|\\.)*"\s*\]\s*)|(?:\s*\[\s*'(?:[^'\\]|\\.)*'\s*\]\s*))(.*)$/,
        "COL_CLASS_PREFIX": "ui-grid-col",
        "events": {
            "GRID_SCROLL": "uiGridScroll",
            "COLUMN_MENU_SHOWN": "uiGridColMenuShown",
            "ITEM_DRAGGING": "uiGridItemDragStart",
            "COLUMN_HEADER_CLICK": "uiGridColumnHeaderClick"
        },
        "keymap": {
            "TAB": 9,
            "STRG": 17,
            "CAPSLOCK": 20,
            "CTRL": 17,
            "CTRLRIGHT": 18,
            "CTRLR": 18,
            "SHIFT": 16,
            "RETURN": 13,
            "ENTER": 13,
            "BACKSPACE": 8,
            "BCKSP": 8,
            "ALT": 18,
            "ALTR": 17,
            "ALTRIGHT": 17,
            "SPACE": 32,
            "WIN": 91,
            "MAC": 91,
            "FN": null,
            "PG_UP": 33,
            "PG_DOWN": 34,
            "UP": 38,
            "DOWN": 40,
            "LEFT": 37,
            "RIGHT": 39,
            "ESC": 27,
            "DEL": 46,
            "F1": 112,
            "F2": 113,
            "F3": 114,
            "F4": 115,
            "F5": 116,
            "F6": 117,
            "F7": 118,
            "F8": 119,
            "F9": 120,
            "F10": 121,
            "F11": 122,
            "F12": 123
        },
        "ASC": "asc",
        "DESC": "desc",
        "filter": {
            "STARTS_WITH": 2,
            "ENDS_WITH": 4,
            "EXACT": 8,
            "CONTAINS": 16,
            "GREATER_THAN": 32,
            "GREATER_THAN_OR_EQUAL": 64,
            "LESS_THAN": 128,
            "LESS_THAN_OR_EQUAL": 256,
            "NOT_EQUAL": 512,
            "SELECT": "select",
            "INPUT": "input"
        },
        "aggregationTypes": {
            "sum": 2,
            "count": 4,
            "avg": 8,
            "min": 16,
            "max": 32
        },
        "CURRENCY_SYMBOLS": [ "\u0192", "$", "\xa3", "$", "\xa4", "\xa5", "\u17db", "\u20a9", "\u20b1", "\u0e3f", "\u20ab" ],
        "scrollDirection": {
            "UP": "up",
            "DOWN": "down",
            "LEFT": "left",
            "RIGHT": "right",
            "NONE": "none"
        },
        "dataChange": {
            "ALL": "all",
            "EDIT": "edit",
            "ROW": "row",
            "COLUMN": "column",
            "OPTIONS": "options"
        },
        "scrollbars": {
            "NEVER": 0,
            "ALWAYS": 1
        }
    });
})();

angular.module("ui.grid").directive("uiGridCell", [ "$compile", "$parse", "gridUtil", "uiGridConstants", function($compile, $parse, gridUtil, uiGridConstants) {
    var uiGridCell = {
        "priority": 0,
        "scope": false,
        "require": "?^uiGrid",
        "compile": function() {
            return {
                "pre": function($scope, $elm, $attrs, uiGridCtrl) {
                    function compileTemplate() {
                        var compiledElementFn = $scope.col.compiledElementFn;
                        compiledElementFn($scope, function(clonedElement, scope) {
                            $elm.append(clonedElement);
                        });
                    }
                    if (uiGridCtrl && $scope.col.compiledElementFn) {
                        compileTemplate();
                    } else {
                        if (uiGridCtrl && !$scope.col.compiledElementFn) {
                            $scope.col.getCompiledElementFn().then(function(compiledElementFn) {
                                compiledElementFn($scope, function(clonedElement, scope) {
                                    $elm.append(clonedElement);
                                });
                            });
                        } else {
                            var html = $scope.col.cellTemplate.replace(uiGridConstants.MODEL_COL_FIELD, "row.entity." + gridUtil.preEval($scope.col.field)).replace(uiGridConstants.COL_FIELD, "grid.getCellValue(row, col)");
                            var cellElement = $compile(html)($scope);
                            $elm.append(cellElement);
                        }
                    }
                },
                "post": function($scope, $elm, $attrs, uiGridCtrl) {
                    var initColClass = $scope.col.getColClass(false);
                    $elm.addClass(initColClass);
                    var classAdded;
                    var updateClass = function(grid) {
                        var contents = $elm;
                        if (classAdded) {
                            contents.removeClass(classAdded);
                            classAdded = null;
                        }
                        if (angular.isFunction($scope.col.cellClass)) {
                            classAdded = $scope.col.cellClass($scope.grid, $scope.row, $scope.col, $scope.rowRenderIndex, $scope.colRenderIndex);
                        } else {
                            classAdded = $scope.col.cellClass;
                        }
                        contents.addClass(classAdded);
                    };
                    if ($scope.col.cellClass) {
                        updateClass();
                    }
                    var dataChangeDereg = $scope.grid.registerDataChangeCallback(updateClass, [ uiGridConstants.dataChange.COLUMN, uiGridConstants.dataChange.EDIT ]);
                    var cellChangeFunction = function(n, o) {
                        if (n !== o) {
                            if (classAdded || $scope.col.cellClass) {
                                updateClass();
                            }
                            var newColClass = $scope.col.getColClass(false);
                            if (newColClass !== initColClass) {
                                $elm.removeClass(initColClass);
                                $elm.addClass(newColClass);
                                initColClass = newColClass;
                            }
                        }
                    };
                    var rowWatchDereg = $scope.$watch("row", cellChangeFunction);
                    var deregisterFunction = function() {
                        dataChangeDereg();
                        rowWatchDereg();
                    };
                    $scope.$on("$destroy", deregisterFunction);
                    $elm.on("$destroy", deregisterFunction);
                }
            };
        }
    };
    return uiGridCell;
} ]);

(function() {
    angular.module("ui.grid").service("uiGridColumnMenuService", [ "i18nService", "uiGridConstants", "gridUtil", function(i18nService, uiGridConstants, gridUtil) {
        var service = {
            "initialize": function($scope, uiGridCtrl) {
                $scope.grid = uiGridCtrl.grid;
                uiGridCtrl.columnMenuScope = $scope;
                $scope.menuShown = false;
            },
            "setColMenuItemWatch": function($scope) {
                var deregFunction = $scope.$watch("col.menuItems", function(n) {
                    if (typeof n !== "undefined" && n && angular.isArray(n)) {
                        n.forEach(function(item) {
                            if (typeof item.context === "undefined" || !item.context) {
                                item.context = {};
                            }
                            item.context.col = $scope.col;
                        });
                        $scope.menuItems = $scope.defaultMenuItems.concat(n);
                    } else {
                        $scope.menuItems = $scope.defaultMenuItems;
                    }
                });
                $scope.$on("$destroy", deregFunction);
            },
            "sortable": function($scope) {
                if ($scope.grid.options.enableSorting && typeof $scope.col !== "undefined" && $scope.col && $scope.col.enableSorting) {
                    return true;
                } else {
                    return false;
                }
            },
            "isActiveSort": function($scope, direction) {
                return typeof $scope.col !== "undefined" && typeof $scope.col.sort !== "undefined" && typeof $scope.col.sort.direction !== "undefined" && $scope.col.sort.direction === direction;
            },
            "suppressRemoveSort": function($scope) {
                if ($scope.col && $scope.col.suppressRemoveSort) {
                    return true;
                } else {
                    return false;
                }
            },
            "hideable": function($scope) {
                if (typeof $scope.col !== "undefined" && $scope.col && $scope.col.colDef && $scope.col.colDef.enableHiding === false) {
                    return false;
                } else {
                    return true;
                }
            },
            "getDefaultMenuItems": function($scope) {
                return [ {
                    "title": i18nService.getSafeText("sort.ascending"),
                    "icon": "ui-grid-icon-sort-alt-up",
                    "action": function($event) {
                        $event.stopPropagation();
                        $scope.sortColumn($event, uiGridConstants.ASC);
                    },
                    "shown": function() {
                        return service.sortable($scope);
                    },
                    "active": function() {
                        return service.isActiveSort($scope, uiGridConstants.ASC);
                    }
                }, {
                    "title": i18nService.getSafeText("sort.descending"),
                    "icon": "ui-grid-icon-sort-alt-down",
                    "action": function($event) {
                        $event.stopPropagation();
                        $scope.sortColumn($event, uiGridConstants.DESC);
                    },
                    "shown": function() {
                        return service.sortable($scope);
                    },
                    "active": function() {
                        return service.isActiveSort($scope, uiGridConstants.DESC);
                    }
                }, {
                    "title": i18nService.getSafeText("sort.remove"),
                    "icon": "ui-grid-icon-cancel",
                    "action": function($event) {
                        $event.stopPropagation();
                        $scope.unsortColumn();
                    },
                    "shown": function() {
                        return service.sortable($scope) && typeof $scope.col !== "undefined" && (typeof $scope.col.sort !== "undefined" && typeof $scope.col.sort.direction !== "undefined") && $scope.col.sort.direction !== null && !service.suppressRemoveSort($scope);
                    }
                }, {
                    "title": i18nService.getSafeText("column.hide"),
                    "icon": "ui-grid-icon-cancel",
                    "shown": function() {
                        return service.hideable($scope);
                    },
                    "action": function($event) {
                        $event.stopPropagation();
                        $scope.hideColumn();
                    }
                } ];
            },
            "getColumnElementPosition": function($scope, column, $columnElement) {
                var positionData = {};
                positionData.left = $columnElement[0].offsetLeft;
                positionData.top = $columnElement[0].offsetTop;
                positionData.parentLeft = $columnElement[0].offsetParent.offsetLeft;
                positionData.offset = 0;
                if (column.grid.options.offsetLeft) {
                    positionData.offset = column.grid.options.offsetLeft;
                }
                positionData.height = gridUtil.elementHeight($columnElement, true);
                positionData.width = gridUtil.elementWidth($columnElement, true);
                return positionData;
            },
            "repositionMenu": function($scope, column, positionData, $elm, $columnElement) {
                var menu = $elm[0].querySelectorAll(".ui-grid-menu");
                var renderContainerElm = gridUtil.closestElm($columnElement, ".ui-grid-render-container");
                var renderContainerOffset = renderContainerElm.getBoundingClientRect().left - $scope.grid.element[0].getBoundingClientRect().left;
                var containerScrollLeft = renderContainerElm.querySelectorAll(".ui-grid-viewport")[0].scrollLeft;
                var myWidth = column.lastMenuWidth ? column.lastMenuWidth : $scope.lastMenuWidth ? $scope.lastMenuWidth : 170;
                var paddingRight = column.lastMenuPaddingRight ? column.lastMenuPaddingRight : $scope.lastMenuPaddingRight ? $scope.lastMenuPaddingRight : 10;
                if (menu.length !== 0) {
                    var mid = menu[0].querySelectorAll(".ui-grid-menu-mid");
                    if (mid.length !== 0 && !angular.element(mid).hasClass("ng-hide")) {
                        myWidth = gridUtil.elementWidth(menu, true);
                        $scope.lastMenuWidth = myWidth;
                        column.lastMenuWidth = myWidth;
                        paddingRight = parseInt(gridUtil.getStyles(angular.element(menu)[0])["paddingRight"], 10);
                        $scope.lastMenuPaddingRight = paddingRight;
                        column.lastMenuPaddingRight = paddingRight;
                    }
                }
                var left = positionData.left + renderContainerOffset - containerScrollLeft + positionData.parentLeft + positionData.width - myWidth + paddingRight;
                if (left < positionData.offset) {
                    left = positionData.offset;
                }
                $elm.css("left", left + "px");
                $elm.css("top", positionData.top + positionData.height + "px");
            }
        };
        return service;
    } ]).directive("uiGridColumnMenu", [ "$timeout", "gridUtil", "uiGridConstants", "uiGridColumnMenuService", "$document", function($timeout, gridUtil, uiGridConstants, uiGridColumnMenuService, $document) {
        var uiGridColumnMenu = {
            "priority": 0,
            "scope": true,
            "require": "^uiGrid",
            "templateUrl": "ui-grid/uiGridColumnMenu",
            "replace": true,
            "link": function($scope, $elm, $attrs, uiGridCtrl) {
                uiGridColumnMenuService.initialize($scope, uiGridCtrl);
                $scope.defaultMenuItems = uiGridColumnMenuService.getDefaultMenuItems($scope);
                $scope.menuItems = $scope.defaultMenuItems;
                uiGridColumnMenuService.setColMenuItemWatch($scope);
                $scope.showMenu = function(column, $columnElement, event) {
                    $scope.col = column;
                    var colElementPosition = uiGridColumnMenuService.getColumnElementPosition($scope, column, $columnElement);
                    if ($scope.menuShown) {
                        $scope.colElement = $columnElement;
                        $scope.colElementPosition = colElementPosition;
                        $scope.hideThenShow = true;
                        $scope.$broadcast("hide-menu", {
                            "originalEvent": event
                        });
                    } else {
                        $scope.menuShown = true;
                        uiGridColumnMenuService.repositionMenu($scope, column, colElementPosition, $elm, $columnElement);
                        $scope.colElement = $columnElement;
                        $scope.colElementPosition = colElementPosition;
                        $scope.$broadcast("show-menu", {
                            "originalEvent": event
                        });
                    }
                };
                $scope.hideMenu = function(broadcastTrigger) {
                    $scope.menuShown = false;
                    if (!broadcastTrigger) {
                        $scope.$broadcast("hide-menu");
                    }
                };
                $scope.$on("menu-hidden", function() {
                    if ($scope.hideThenShow) {
                        delete $scope.hideThenShow;
                        uiGridColumnMenuService.repositionMenu($scope, $scope.col, $scope.colElementPosition, $elm, $scope.colElement);
                        $scope.$broadcast("show-menu");
                        $scope.menuShown = true;
                    } else {
                        $scope.hideMenu(true);
                        if ($scope.col) {
                            gridUtil.focus.bySelector($document, ".ui-grid-header-cell." + $scope.col.getColClass() + " .ui-grid-column-menu-button", $scope.col.grid, false);
                        }
                    }
                });
                $scope.$on("menu-shown", function() {
                    $timeout(function() {
                        uiGridColumnMenuService.repositionMenu($scope, $scope.col, $scope.colElementPosition, $elm, $scope.colElement);
                        gridUtil.focus.bySelector($document, ".ui-grid-menu-items .ui-grid-menu-item", true);
                        delete $scope.colElementPosition;
                        delete $scope.columnElement;
                    }, 200);
                });
                $scope.sortColumn = function(event, dir) {
                    event.stopPropagation();
                    $scope.grid.sortColumn($scope.col, dir, true).then(function() {
                        $scope.grid.refresh();
                        $scope.hideMenu();
                    });
                };
                $scope.unsortColumn = function() {
                    $scope.col.unsort();
                    $scope.grid.refresh();
                    $scope.hideMenu();
                };
                var setFocusOnHideColumn = function() {
                    $timeout(function() {
                        var focusToGridMenu = function() {
                            return gridUtil.focus.byId("grid-menu", $scope.grid);
                        };
                        var thisIndex;
                        $scope.grid.columns.some(function(element, index) {
                            if (angular.equals(element, $scope.col)) {
                                thisIndex = index;
                                return true;
                            }
                        });
                        var previousVisibleCol;
                        $scope.grid.columns.some(function(element, index) {
                            if (!element.visible) {
                                return false;
                            } else if (index < thisIndex) {
                                previousVisibleCol = element;
                            } else if (index > thisIndex && !previousVisibleCol) {
                                previousVisibleCol = element;
                                return true;
                            } else if (index > thisIndex && previousVisibleCol) {
                                return true;
                            }
                        });
                        if (previousVisibleCol) {
                            var colClass = previousVisibleCol.getColClass();
                            gridUtil.focus.bySelector($document, ".ui-grid-header-cell." + colClass + " .ui-grid-header-cell-primary-focus", true).then(angular.noop, function(reason) {
                                if (reason !== "canceled") {
                                    return focusToGridMenu();
                                }
                            });
                        } else {
                            focusToGridMenu();
                        }
                    });
                };
                $scope.hideColumn = function() {
                    $scope.col.colDef.visible = false;
                    $scope.col.visible = false;
                    $scope.grid.queueGridRefresh();
                    $scope.hideMenu();
                    $scope.grid.api.core.notifyDataChange(uiGridConstants.dataChange.COLUMN);
                    $scope.grid.api.core.raise.columnVisibilityChanged($scope.col);
                    setFocusOnHideColumn();
                };
            },
            "controller": [ "$scope", function($scope) {
                var self = this;
                $scope.$watch("menuItems", function(n) {
                    self.menuItems = n;
                });
            } ]
        };
        return uiGridColumnMenu;
    } ]);
})();

(function() {
    "use strict";
    angular.module("ui.grid").directive("uiGridFilter", [ "$compile", "$templateCache", "i18nService", "gridUtil", function($compile, $templateCache, i18nService, gridUtil) {
        return {
            "compile": function() {
                return {
                    "pre": function($scope, $elm, $attrs, controllers) {
                        $scope.col.updateFilters = function(filterable) {
                            $elm.children().remove();
                            if (filterable) {
                                var template = $scope.col.filterHeaderTemplate;
                                $elm.append($compile(template)($scope));
                            }
                        };
                        $scope.$on("$destroy", function() {
                            delete $scope.col.updateFilters;
                        });
                    },
                    "post": function($scope, $elm, $attrs, controllers) {
                        $scope.aria = i18nService.getSafeText("headerCell.aria");
                        $scope.removeFilter = function(colFilter, index) {
                            colFilter.term = null;
                            gridUtil.focus.bySelector($elm, ".ui-grid-filter-input-" + index);
                        };
                    }
                };
            }
        };
    } ]);
})();

(function() {
    "use strict";
    angular.module("ui.grid").directive("uiGridFooterCell", [ "$timeout", "gridUtil", "uiGridConstants", "$compile", function($timeout, gridUtil, uiGridConstants, $compile) {
        var uiGridFooterCell = {
            "priority": 0,
            "scope": {
                "col": "=",
                "row": "=",
                "renderIndex": "="
            },
            "replace": true,
            "require": "^uiGrid",
            "compile": function compile(tElement, tAttrs, transclude) {
                return {
                    "pre": function($scope, $elm, $attrs, uiGridCtrl) {
                        var cellFooter = $compile($scope.col.footerCellTemplate)($scope);
                        $elm.append(cellFooter);
                    },
                    "post": function($scope, $elm, $attrs, uiGridCtrl) {
                        $scope.grid = uiGridCtrl.grid;
                        var initColClass = $scope.col.getColClass(false);
                        $elm.addClass(initColClass);
                        var classAdded;
                        var updateClass = function(grid) {
                            var contents = $elm;
                            if (classAdded) {
                                contents.removeClass(classAdded);
                                classAdded = null;
                            }
                            if (angular.isFunction($scope.col.footerCellClass)) {
                                classAdded = $scope.col.footerCellClass($scope.grid, $scope.row, $scope.col, $scope.rowRenderIndex, $scope.colRenderIndex);
                            } else {
                                classAdded = $scope.col.footerCellClass;
                            }
                            contents.addClass(classAdded);
                        };
                        if ($scope.col.footerCellClass) {
                            updateClass();
                        }
                        $scope.col.updateAggregationValue();
                        var dataChangeDereg = $scope.grid.registerDataChangeCallback(updateClass, [ uiGridConstants.dataChange.COLUMN ]);
                        $scope.grid.api.core.on.rowsRendered($scope, $scope.col.updateAggregationValue);
                        $scope.grid.api.core.on.rowsRendered($scope, updateClass);
                        $scope.$on("$destroy", dataChangeDereg);
                    }
                };
            }
        };
        return uiGridFooterCell;
    } ]);
})();

(function() {
    "use strict";
    angular.module("ui.grid").directive("uiGridFooter", [ "$templateCache", "$compile", "uiGridConstants", "gridUtil", "$timeout", function($templateCache, $compile, uiGridConstants, gridUtil, $timeout) {
        return {
            "restrict": "EA",
            "replace": true,
            "require": [ "^uiGrid", "^uiGridRenderContainer" ],
            "scope": true,
            "compile": function($elm, $attrs) {
                return {
                    "pre": function($scope, $elm, $attrs, controllers) {
                        var uiGridCtrl = controllers[0];
                        var containerCtrl = controllers[1];
                        $scope.grid = uiGridCtrl.grid;
                        $scope.colContainer = containerCtrl.colContainer;
                        containerCtrl.footer = $elm;
                        var footerTemplate = $scope.grid.options.footerTemplate;
                        gridUtil.getTemplate(footerTemplate).then(function(contents) {
                            var template = angular.element(contents);
                            var newElm = $compile(template)($scope);
                            $elm.append(newElm);
                            if (containerCtrl) {
                                var footerViewport = $elm[0].getElementsByClassName("ui-grid-footer-viewport")[0];
                                if (footerViewport) {
                                    containerCtrl.footerViewport = footerViewport;
                                }
                            }
                        });
                    },
                    "post": function($scope, $elm, $attrs, controllers) {
                        var uiGridCtrl = controllers[0];
                        var containerCtrl = controllers[1];
                        var grid = uiGridCtrl.grid;
                        gridUtil.disableAnimations($elm);
                        containerCtrl.footer = $elm;
                        var footerViewport = $elm[0].getElementsByClassName("ui-grid-footer-viewport")[0];
                        if (footerViewport) {
                            containerCtrl.footerViewport = footerViewport;
                        }
                    }
                };
            }
        };
    } ]);
})();

(function() {
    "use strict";
    angular.module("ui.grid").directive("uiGridGridFooter", [ "$templateCache", "$compile", "uiGridConstants", "gridUtil", "$timeout", function($templateCache, $compile, uiGridConstants, gridUtil, $timeout) {
        return {
            "restrict": "EA",
            "replace": true,
            "require": "^uiGrid",
            "scope": true,
            "compile": function($elm, $attrs) {
                return {
                    "pre": function($scope, $elm, $attrs, uiGridCtrl) {
                        $scope.grid = uiGridCtrl.grid;
                        var footerTemplate = $scope.grid.options.gridFooterTemplate;
                        gridUtil.getTemplate(footerTemplate).then(function(contents) {
                            var template = angular.element(contents);
                            var newElm = $compile(template)($scope);
                            $elm.append(newElm);
                        });
                    },
                    "post": function($scope, $elm, $attrs, controllers) {}
                };
            }
        };
    } ]);
})();

(function() {
    "use strict";
    angular.module("ui.grid").directive("uiGridGroupPanel", [ "$compile", "uiGridConstants", "gridUtil", function($compile, uiGridConstants, gridUtil) {
        var defaultTemplate = "ui-grid/ui-grid-group-panel";
        return {
            "restrict": "EA",
            "replace": true,
            "require": "?^uiGrid",
            "scope": false,
            "compile": function($elm, $attrs) {
                return {
                    "pre": function($scope, $elm, $attrs, uiGridCtrl) {
                        var groupPanelTemplate = $scope.grid.options.groupPanelTemplate || defaultTemplate;
                        gridUtil.getTemplate(groupPanelTemplate).then(function(contents) {
                            var template = angular.element(contents);
                            var newElm = $compile(template)($scope);
                            $elm.append(newElm);
                        });
                    },
                    "post": function($scope, $elm, $attrs, uiGridCtrl) {
                        $elm.bind("$destroy", function() {});
                    }
                };
            }
        };
    } ]);
})();

(function() {
    "use strict";
    angular.module("ui.grid").directive("uiGridHeaderCell", [ "$compile", "$timeout", "$window", "$document", "gridUtil", "uiGridConstants", "ScrollEvent", "i18nService", function($compile, $timeout, $window, $document, gridUtil, uiGridConstants, ScrollEvent, i18nService) {
        var mousedownTimeout = 500;
        var changeModeTimeout = 500;
        var uiGridHeaderCell = {
            "priority": 0,
            "scope": {
                "col": "=",
                "row": "=",
                "renderIndex": "="
            },
            "require": [ "^uiGrid", "^uiGridRenderContainer" ],
            "replace": true,
            "compile": function() {
                return {
                    "pre": function($scope, $elm, $attrs) {
                        var cellHeader = $compile($scope.col.headerCellTemplate)($scope);
                        $elm.append(cellHeader);
                    },
                    "post": function($scope, $elm, $attrs, controllers) {
                        var uiGridCtrl = controllers[0];
                        var renderContainerCtrl = controllers[1];
                        $scope.i18n = {
                            "headerCell": i18nService.getSafeText("headerCell"),
                            "sort": i18nService.getSafeText("sort")
                        };
                        $scope.isSortPriorityVisible = function() {
                            return angular.isNumber($scope.col.sort.priority) && $scope.grid.columns.some(function(element, index) {
                                return angular.isNumber(element.sort.priority) && element !== $scope.col;
                            });
                        };
                        $scope.getSortDirectionAriaLabel = function() {
                            var col = $scope.col;
                            var sortDirectionText = col.sort.direction === uiGridConstants.ASC ? $scope.i18n.sort.ascending : col.sort.direction === uiGridConstants.DESC ? $scope.i18n.sort.descending : $scope.i18n.sort.none;
                            var label = sortDirectionText;
                            if ($scope.isSortPriorityVisible()) {
                                label = label + ". " + $scope.i18n.headerCell.priority + " " + col.sort.priority;
                            }
                            return label;
                        };
                        $scope.grid = uiGridCtrl.grid;
                        $scope.renderContainer = uiGridCtrl.grid.renderContainers[renderContainerCtrl.containerId];
                        var initColClass = $scope.col.getColClass(false);
                        $elm.addClass(initColClass);
                        $scope.menuShown = false;
                        $scope.asc = uiGridConstants.ASC;
                        $scope.desc = uiGridConstants.DESC;
                        var $colMenu = angular.element($elm[0].querySelectorAll(".ui-grid-header-cell-menu"));
                        var $contentsElm = angular.element($elm[0].querySelectorAll(".ui-grid-cell-contents"));
                        var classAdded;
                        var previousMouseX;
                        var filterDeregisters = [];
                        $scope.downFn = function(event) {
                            event.stopPropagation();
                            if (typeof event.originalEvent !== "undefined" && event.originalEvent !== undefined) {
                                event = event.originalEvent;
                            }
                            if (event.button && event.button !== 0) {
                                return;
                            }
                            previousMouseX = event.pageX;
                            $scope.mousedownStartTime = new Date().getTime();
                            $scope.mousedownTimeout = $timeout(function() {}, mousedownTimeout);
                            $scope.mousedownTimeout.then(function() {
                                if ($scope.colMenu) {
                                    uiGridCtrl.columnMenuScope.showMenu($scope.col, $elm, event);
                                }
                            });
                            uiGridCtrl.fireEvent(uiGridConstants.events.COLUMN_HEADER_CLICK, {
                                "event": event,
                                "columnName": $scope.col.colDef.name
                            });
                            $scope.offAllEvents();
                            if (event.type === "touchstart") {
                                $document.on("touchend", $scope.upFn);
                                $document.on("touchmove", $scope.moveFn);
                            } else if (event.type === "mousedown") {
                                $document.on("mouseup", $scope.upFn);
                                $document.on("mousemove", $scope.moveFn);
                            }
                        };
                        $scope.upFn = function(event) {
                            event.stopPropagation();
                            $timeout.cancel($scope.mousedownTimeout);
                            $scope.offAllEvents();
                            $scope.onDownEvents(event.type);
                            var mousedownEndTime = new Date().getTime();
                            var mousedownTime = mousedownEndTime - $scope.mousedownStartTime;
                            if (mousedownTime > mousedownTimeout) {} else {
                                if ($scope.sortable) {
                                    $scope.handleClick(event);
                                }
                            }
                        };
                        $scope.moveFn = function(event) {
                            var changeValue = event.pageX - previousMouseX;
                            if (changeValue === 0) {
                                return;
                            }
                            $timeout.cancel($scope.mousedownTimeout);
                            $scope.offAllEvents();
                            $scope.onDownEvents(event.type);
                        };
                        $scope.clickFn = function(event) {
                            event.stopPropagation();
                            $contentsElm.off("click", $scope.clickFn);
                        };
                        $scope.offAllEvents = function() {
                            $contentsElm.off("touchstart", $scope.downFn);
                            $contentsElm.off("mousedown", $scope.downFn);
                            $document.off("touchend", $scope.upFn);
                            $document.off("mouseup", $scope.upFn);
                            $document.off("touchmove", $scope.moveFn);
                            $document.off("mousemove", $scope.moveFn);
                            $contentsElm.off("click", $scope.clickFn);
                        };
                        $scope.onDownEvents = function(type) {
                            switch (type) {
                              case "touchmove":
                              case "touchend":
                                $contentsElm.on("click", $scope.clickFn);
                                $contentsElm.on("touchstart", $scope.downFn);
                                $timeout(function() {
                                    $contentsElm.on("mousedown", $scope.downFn);
                                }, changeModeTimeout);
                                break;

                              case "mousemove":
                              case "mouseup":
                                $contentsElm.on("click", $scope.clickFn);
                                $contentsElm.on("mousedown", $scope.downFn);
                                $timeout(function() {
                                    $contentsElm.on("touchstart", $scope.downFn);
                                }, changeModeTimeout);
                                break;

                              default:
                                $contentsElm.on("click", $scope.clickFn);
                                $contentsElm.on("touchstart", $scope.downFn);
                                $contentsElm.on("mousedown", $scope.downFn);
                            }
                        };
                        var updateHeaderOptions = function(grid) {
                            var contents = $elm;
                            if (classAdded) {
                                contents.removeClass(classAdded);
                                classAdded = null;
                            }
                            if (angular.isFunction($scope.col.headerCellClass)) {
                                classAdded = $scope.col.headerCellClass($scope.grid, $scope.row, $scope.col, $scope.rowRenderIndex, $scope.colRenderIndex);
                            } else {
                                classAdded = $scope.col.headerCellClass;
                            }
                            contents.addClass(classAdded);
                            $timeout(function() {
                                var rightMostContainer = $scope.grid.renderContainers["right"] ? $scope.grid.renderContainers["right"] : $scope.grid.renderContainers["body"];
                                $scope.isLastCol = $scope.col === rightMostContainer.visibleColumnCache[rightMostContainer.visibleColumnCache.length - 1];
                            });
                            if (uiGridCtrl.grid.options.enableSorting && $scope.col.enableSorting) {
                                $scope.sortable = true;
                            } else {
                                $scope.sortable = false;
                            }
                            var oldFilterable = $scope.filterable;
                            if (uiGridCtrl.grid.options.enableFiltering && $scope.col.enableFiltering) {
                                $scope.filterable = true;
                            } else {
                                $scope.filterable = false;
                            }
                            if (oldFilterable !== $scope.filterable) {
                                if (typeof $scope.col.updateFilters !== "undefined") {
                                    $scope.col.updateFilters($scope.filterable);
                                }
                                if ($scope.filterable) {
                                    $scope.col.filters.forEach(function(filter, i) {
                                        filterDeregisters.push($scope.$watch("col.filters[" + i + "].term", function(n, o) {
                                            if (n !== o) {
                                                uiGridCtrl.grid.api.core.raise.filterChanged();
                                                uiGridCtrl.grid.api.core.notifyDataChange(uiGridConstants.dataChange.COLUMN);
                                                uiGridCtrl.grid.queueGridRefresh();
                                            }
                                        }));
                                    });
                                    $scope.$on("$destroy", function() {
                                        filterDeregisters.forEach(function(filterDeregister) {
                                            filterDeregister();
                                        });
                                    });
                                } else {
                                    filterDeregisters.forEach(function(filterDeregister) {
                                        filterDeregister();
                                    });
                                }
                            }
                            if ($scope.col.grid.options && $scope.col.grid.options.enableColumnMenus !== false && $scope.col.colDef && $scope.col.colDef.enableColumnMenu !== false) {
                                $scope.colMenu = true;
                            } else {
                                $scope.colMenu = false;
                            }
                            $scope.offAllEvents();
                            if ($scope.sortable || $scope.colMenu) {
                                $scope.onDownEvents();
                                $scope.$on("$destroy", function() {
                                    $scope.offAllEvents();
                                });
                            }
                        };
                        updateHeaderOptions();
                        var dataChangeDereg = $scope.grid.registerDataChangeCallback(updateHeaderOptions, [ uiGridConstants.dataChange.COLUMN ]);
                        $scope.$on("$destroy", dataChangeDereg);
                        $scope.handleClick = function(event) {
                            var add = false;
                            if (event.shiftKey) {
                                add = true;
                            }
                            uiGridCtrl.grid.sortColumn($scope.col, add).then(function() {
                                if (uiGridCtrl.columnMenuScope) {
                                    uiGridCtrl.columnMenuScope.hideMenu();
                                }
                                uiGridCtrl.grid.refresh();
                            });
                        };
                        $scope.toggleMenu = function(event) {
                            event.stopPropagation();
                            if (uiGridCtrl.columnMenuScope.menuShown) {
                                if (uiGridCtrl.columnMenuScope.col === $scope.col) {
                                    uiGridCtrl.columnMenuScope.hideMenu();
                                } else {
                                    uiGridCtrl.columnMenuScope.showMenu($scope.col, $elm);
                                }
                            } else {
                                uiGridCtrl.columnMenuScope.showMenu($scope.col, $elm);
                            }
                        };
                    }
                };
            }
        };
        return uiGridHeaderCell;
    } ]);
})();

(function() {
    "use strict";
    angular.module("ui.grid").directive("uiGridHeader", [ "$templateCache", "$compile", "uiGridConstants", "gridUtil", "$timeout", "ScrollEvent", function($templateCache, $compile, uiGridConstants, gridUtil, $timeout, ScrollEvent) {
        var defaultTemplate = "ui-grid/ui-grid-header";
        var emptyTemplate = "ui-grid/ui-grid-no-header";
        return {
            "restrict": "EA",
            "replace": true,
            "require": [ "^uiGrid", "^uiGridRenderContainer" ],
            "scope": true,
            "compile": function($elm, $attrs) {
                return {
                    "pre": function($scope, $elm, $attrs, controllers) {
                        var uiGridCtrl = controllers[0];
                        var containerCtrl = controllers[1];
                        $scope.grid = uiGridCtrl.grid;
                        $scope.colContainer = containerCtrl.colContainer;
                        updateHeaderReferences();
                        var headerTemplate;
                        if (!$scope.grid.options.showHeader) {
                            headerTemplate = emptyTemplate;
                        } else {
                            headerTemplate = $scope.grid.options.headerTemplate ? $scope.grid.options.headerTemplate : defaultTemplate;
                        }
                        gridUtil.getTemplate(headerTemplate).then(function(contents) {
                            var template = angular.element(contents);
                            var newElm = $compile(template)($scope);
                            $elm.replaceWith(newElm);
                            $elm = newElm;
                            updateHeaderReferences();
                            if (containerCtrl) {
                                var headerViewport = $elm[0].getElementsByClassName("ui-grid-header-viewport")[0];
                                if (headerViewport) {
                                    containerCtrl.headerViewport = headerViewport;
                                    angular.element(headerViewport).on("scroll", scrollHandler);
                                    $scope.$on("$destroy", function() {
                                        angular.element(headerViewport).off("scroll", scrollHandler);
                                    });
                                }
                            }
                            $scope.grid.queueRefresh();
                        });
                        function updateHeaderReferences() {
                            containerCtrl.header = containerCtrl.colContainer.header = $elm;
                            var headerCanvases = $elm[0].getElementsByClassName("ui-grid-header-canvas");
                            if (headerCanvases.length > 0) {
                                containerCtrl.headerCanvas = containerCtrl.colContainer.headerCanvas = headerCanvases[0];
                            } else {
                                containerCtrl.headerCanvas = null;
                            }
                        }
                        function scrollHandler(evt) {
                            if (uiGridCtrl.grid.isScrollingHorizontally) {
                                return;
                            }
                            var newScrollLeft = gridUtil.normalizeScrollLeft(containerCtrl.headerViewport, uiGridCtrl.grid);
                            var horizScrollPercentage = containerCtrl.colContainer.scrollHorizontal(newScrollLeft);
                            var scrollEvent = new ScrollEvent(uiGridCtrl.grid, null, containerCtrl.colContainer, ScrollEvent.Sources.ViewPortScroll);
                            scrollEvent.newScrollLeft = newScrollLeft;
                            if (horizScrollPercentage > -1) {
                                scrollEvent.x = {
                                    "percentage": horizScrollPercentage
                                };
                            }
                            uiGridCtrl.grid.scrollContainers(null, scrollEvent);
                        }
                    },
                    "post": function($scope, $elm, $attrs, controllers) {
                        var uiGridCtrl = controllers[0];
                        var containerCtrl = controllers[1];
                        var grid = uiGridCtrl.grid;
                        gridUtil.disableAnimations($elm);
                        function updateColumnWidths() {
                            var columnCache = containerCtrl.colContainer.visibleColumnCache;
                            var ret = "";
                            var canvasWidth = 0;
                            columnCache.forEach(function(column) {
                                ret = ret + column.getColClassDefinition();
                                canvasWidth += column.drawnWidth;
                            });
                            containerCtrl.colContainer.canvasWidth = canvasWidth;
                            return ret;
                        }
                        containerCtrl.header = $elm;
                        var headerViewport = $elm[0].getElementsByClassName("ui-grid-header-viewport")[0];
                        if (headerViewport) {
                            containerCtrl.headerViewport = headerViewport;
                        }
                        if (uiGridCtrl) {
                            uiGridCtrl.grid.registerStyleComputation({
                                "priority": 15,
                                "func": updateColumnWidths
                            });
                        }
                    }
                };
            }
        };
    } ]);
})();

(function() {
    angular.module("ui.grid").service("uiGridGridMenuService", [ "gridUtil", "i18nService", "uiGridConstants", function(gridUtil, i18nService, uiGridConstants) {
        var service = {
            "initialize": function($scope, grid) {
                grid.gridMenuScope = $scope;
                $scope.grid = grid;
                $scope.registeredMenuItems = [];
                $scope.$on("$destroy", function() {
                    if ($scope.grid && $scope.grid.gridMenuScope) {
                        $scope.grid.gridMenuScope = null;
                    }
                    if ($scope.grid) {
                        $scope.grid = null;
                    }
                    if ($scope.registeredMenuItems) {
                        $scope.registeredMenuItems = null;
                    }
                });
                $scope.registeredMenuItems = [];
                grid.api.registerMethod("core", "addToGridMenu", service.addToGridMenu);
                grid.api.registerMethod("core", "removeFromGridMenu", service.removeFromGridMenu);
            },
            "addToGridMenu": function(grid, menuItems) {
                if (!angular.isArray(menuItems)) {
                    gridUtil.logError("addToGridMenu: menuItems must be an array, and is not, not adding any items");
                } else {
                    if (grid.gridMenuScope) {
                        grid.gridMenuScope.registeredMenuItems = grid.gridMenuScope.registeredMenuItems ? grid.gridMenuScope.registeredMenuItems : [];
                        grid.gridMenuScope.registeredMenuItems = grid.gridMenuScope.registeredMenuItems.concat(menuItems);
                    } else {
                        gridUtil.logError("Asked to addToGridMenu, but gridMenuScope not present.  Timing issue?  Please log issue with ui-grid");
                    }
                }
            },
            "removeFromGridMenu": function(grid, id) {
                var foundIndex = -1;
                if (grid && grid.gridMenuScope) {
                    grid.gridMenuScope.registeredMenuItems.forEach(function(value, index) {
                        if (value.id === id) {
                            if (foundIndex > -1) {
                                gridUtil.logError("removeFromGridMenu: found multiple items with the same id, removing only the last");
                            } else {
                                foundIndex = index;
                            }
                        }
                    });
                }
                if (foundIndex > -1) {
                    grid.gridMenuScope.registeredMenuItems.splice(foundIndex, 1);
                }
            },
            "getMenuItems": function($scope) {
                var menuItems = [];
                if ($scope.grid.options.gridMenuCustomItems) {
                    if (!angular.isArray($scope.grid.options.gridMenuCustomItems)) {
                        gridUtil.logError("gridOptions.gridMenuCustomItems must be an array, and is not");
                    } else {
                        menuItems = menuItems.concat($scope.grid.options.gridMenuCustomItems);
                    }
                }
                var clearFilters = [ {
                    "title": i18nService.getSafeText("gridMenu.clearAllFilters"),
                    "action": function($event) {
                        $scope.grid.clearAllFilters(undefined, true, undefined);
                    },
                    "shown": function() {
                        return $scope.grid.options.enableFiltering;
                    },
                    "order": 100
                } ];
                menuItems = menuItems.concat(clearFilters);
                menuItems = menuItems.concat($scope.registeredMenuItems);
                if ($scope.grid.options.gridMenuShowHideColumns !== false) {
                    menuItems = menuItems.concat(service.showHideColumns($scope));
                }
                menuItems.sort(function(a, b) {
                    return a.order - b.order;
                });
                return menuItems;
            },
            "showHideColumns": function($scope) {
                var showHideColumns = [];
                if (!$scope.grid.options.columnDefs || $scope.grid.options.columnDefs.length === 0 || $scope.grid.columns.length === 0) {
                    return showHideColumns;
                }
                showHideColumns.push({
                    "title": i18nService.getSafeText("gridMenu.columns"),
                    "order": 300
                });
                $scope.grid.options.gridMenuTitleFilter = $scope.grid.options.gridMenuTitleFilter ? $scope.grid.options.gridMenuTitleFilter : function(title) {
                    return title;
                };
                $scope.grid.options.columnDefs.forEach(function(colDef, index) {
                    if (colDef.enableHiding !== false) {
                        var menuItem = {
                            "icon": "ui-grid-icon-ok",
                            "action": function($event) {
                                $event.stopPropagation();
                                service.toggleColumnVisibility(this.context.gridCol);
                            },
                            "shown": function() {
                                return this.context.gridCol.colDef.visible === true || this.context.gridCol.colDef.visible === undefined;
                            },
                            "context": {
                                "gridCol": $scope.grid.getColumn(colDef.name || colDef.field)
                            },
                            "leaveOpen": true,
                            "order": 301 + index * 2
                        };
                        service.setMenuItemTitle(menuItem, colDef, $scope.grid);
                        showHideColumns.push(menuItem);
                        menuItem = {
                            "icon": "ui-grid-icon-cancel",
                            "action": function($event) {
                                $event.stopPropagation();
                                service.toggleColumnVisibility(this.context.gridCol);
                            },
                            "shown": function() {
                                return !(this.context.gridCol.colDef.visible === true || this.context.gridCol.colDef.visible === undefined);
                            },
                            "context": {
                                "gridCol": $scope.grid.getColumn(colDef.name || colDef.field)
                            },
                            "leaveOpen": true,
                            "order": 301 + index * 2 + 1
                        };
                        service.setMenuItemTitle(menuItem, colDef, $scope.grid);
                        showHideColumns.push(menuItem);
                    }
                });
                return showHideColumns;
            },
            "setMenuItemTitle": function(menuItem, colDef, grid) {
                var title = grid.options.gridMenuTitleFilter(colDef.displayName || gridUtil.readableColumnName(colDef.name) || colDef.field);
                if (typeof title === "string") {
                    menuItem.title = title;
                } else if (title.then) {
                    menuItem.title = "";
                    title.then(function(successValue) {
                        menuItem.title = successValue;
                    }, function(errorValue) {
                        menuItem.title = errorValue;
                    });
                } else {
                    gridUtil.logError("Expected gridMenuTitleFilter to return a string or a promise, it has returned neither, bad config");
                    menuItem.title = "badconfig";
                }
            },
            "toggleColumnVisibility": function(gridCol) {
                gridCol.colDef.visible = !(gridCol.colDef.visible === true || gridCol.colDef.visible === undefined);
                gridCol.grid.refresh();
                gridCol.grid.api.core.notifyDataChange(uiGridConstants.dataChange.COLUMN);
                gridCol.grid.api.core.raise.columnVisibilityChanged(gridCol);
            }
        };
        return service;
    } ]).directive("uiGridMenuButton", [ "gridUtil", "uiGridConstants", "uiGridGridMenuService", "i18nService", function(gridUtil, uiGridConstants, uiGridGridMenuService, i18nService) {
        return {
            "priority": 0,
            "scope": true,
            "require": [ "^uiGrid" ],
            "templateUrl": "ui-grid/ui-grid-menu-button",
            "replace": true,
            "link": function($scope, $elm, $attrs, controllers) {
                var uiGridCtrl = controllers[0];
                $scope.i18n = {
                    "aria": i18nService.getSafeText("gridMenu.aria")
                };
                uiGridGridMenuService.initialize($scope, uiGridCtrl.grid);
                $scope.shown = false;
                $scope.toggleMenu = function() {
                    if ($scope.shown) {
                        $scope.$broadcast("hide-menu");
                        $scope.shown = false;
                    } else {
                        $scope.menuItems = uiGridGridMenuService.getMenuItems($scope);
                        $scope.$broadcast("show-menu");
                        $scope.shown = true;
                    }
                };
                $scope.$on("menu-hidden", function() {
                    $scope.shown = false;
                    gridUtil.focus.bySelector($elm, ".ui-grid-icon-container");
                });
            }
        };
    } ]);
})();

(function() {
    angular.module("ui.grid").directive("uiGridMenu", [ "$compile", "$timeout", "$window", "$document", "gridUtil", "uiGridConstants", "i18nService", function($compile, $timeout, $window, $document, gridUtil, uiGridConstants, i18nService) {
        var uiGridMenu = {
            "priority": 0,
            "scope": {
                "menuItems": "=",
                "autoHide": "=?"
            },
            "require": "?^uiGrid",
            "templateUrl": "ui-grid/uiGridMenu",
            "replace": false,
            "link": function($scope, $elm, $attrs, uiGridCtrl) {
                var gridMenuMaxHeight;
                $scope.dynamicStyles = "";
                if (uiGridCtrl) {
                    gridMenuMaxHeight = uiGridCtrl.grid.gridHeight - 30;
                    $scope.dynamicStyles = [ ".grid" + uiGridCtrl.grid.id + " .ui-grid-menu-mid {", "max-height: " + gridMenuMaxHeight + "px;", "}" ].join(" ");
                }
                $scope.i18n = {
                    "close": i18nService.getSafeText("columnMenu.close")
                };
                $scope.showMenu = function(event, args) {
                    if (!$scope.shown) {
                        $scope.shown = true;
                        $timeout(function() {
                            $scope.shownMid = true;
                            $scope.$emit("menu-shown");
                        });
                    } else if (!$scope.shownMid) {
                        $scope.shownMid = true;
                        $scope.$emit("menu-shown");
                    }
                    var docEventType = "click";
                    if (args && args.originalEvent && args.originalEvent.type && args.originalEvent.type === "touchstart") {
                        docEventType = args.originalEvent.type;
                    }
                    angular.element(document).off("click touchstart", applyHideMenu);
                    $elm.off("keyup", checkKeyUp);
                    $elm.off("keydown", checkKeyDown);
                    $timeout(function() {
                        angular.element(document).on(docEventType, applyHideMenu);
                        $elm.on("keyup", checkKeyUp);
                        $elm.on("keydown", checkKeyDown);
                    });
                    gridUtil.focus.bySelector($elm, "button[type=button]", true);
                };
                $scope.hideMenu = function(event) {
                    if ($scope.shown) {
                        $scope.shownMid = false;
                        $timeout(function() {
                            if (!$scope.shownMid) {
                                $scope.shown = false;
                                $scope.$emit("menu-hidden");
                            }
                        }, 200);
                    }
                    angular.element(document).off("click touchstart", applyHideMenu);
                    $elm.off("keyup", checkKeyUp);
                    $elm.off("keydown", checkKeyDown);
                };
                $scope.$on("hide-menu", function(event, args) {
                    $scope.hideMenu(event, args);
                });
                $scope.$on("show-menu", function(event, args) {
                    $scope.showMenu(event, args);
                });
                var applyHideMenu = function() {
                    if ($scope.shown) {
                        $scope.$apply(function() {
                            $scope.hideMenu();
                        });
                    }
                };
                var checkKeyUp = function(event) {
                    if (event.keyCode === 27) {
                        $scope.hideMenu();
                    }
                };
                var checkKeyDown = function(event) {
                    var setFocus = function(elm) {
                        elm.focus();
                        event.preventDefault();
                        return false;
                    };
                    if (event.keyCode === 9) {
                        var firstMenuItem, lastMenuItem;
                        var menuItemButtons = $elm[0].querySelectorAll("button:not(.ng-hide)");
                        if (menuItemButtons.length > 0) {
                            firstMenuItem = menuItemButtons[0];
                            lastMenuItem = menuItemButtons[menuItemButtons.length - 1];
                            if (event.target === lastMenuItem && !event.shiftKey) {
                                setFocus(firstMenuItem);
                            } else if (event.target === firstMenuItem && event.shiftKey) {
                                setFocus(lastMenuItem);
                            }
                        }
                    }
                };
                if (typeof $scope.autoHide === "undefined" || $scope.autoHide === undefined) {
                    $scope.autoHide = true;
                }
                if ($scope.autoHide) {
                    angular.element($window).on("resize", applyHideMenu);
                }
                $scope.$on("$destroy", function() {
                    angular.element(document).off("click touchstart", applyHideMenu);
                });
                $scope.$on("$destroy", function() {
                    angular.element($window).off("resize", applyHideMenu);
                });
                if (uiGridCtrl) {
                    $scope.$on("$destroy", uiGridCtrl.grid.api.core.on.scrollBegin($scope, applyHideMenu));
                }
                $scope.$on("$destroy", $scope.$on(uiGridConstants.events.ITEM_DRAGGING, applyHideMenu));
            }
        };
        return uiGridMenu;
    } ]).directive("uiGridMenuItem", [ "gridUtil", "$compile", "i18nService", function(gridUtil, $compile, i18nService) {
        var uiGridMenuItem = {
            "priority": 0,
            "scope": {
                "name": "=",
                "active": "=",
                "action": "=",
                "icon": "=",
                "shown": "=",
                "context": "=",
                "templateUrl": "=",
                "leaveOpen": "=",
                "screenReaderOnly": "="
            },
            "require": [ "?^uiGrid" ],
            "templateUrl": "ui-grid/uiGridMenuItem",
            "replace": false,
            "compile": function() {
                return {
                    "pre": function($scope, $elm) {
                        if ($scope.templateUrl) {
                            gridUtil.getTemplate($scope.templateUrl).then(function(contents) {
                                var template = angular.element(contents);
                                var newElm = $compile(template)($scope);
                                $elm.replaceWith(newElm);
                            });
                        }
                    },
                    "post": function($scope, $elm, $attrs, controllers) {
                        var uiGridCtrl = controllers[0];
                        if (typeof $scope.shown === "undefined" || $scope.shown === null) {
                            $scope.shown = function() {
                                return true;
                            };
                        }
                        $scope.itemShown = function() {
                            var context = {};
                            if ($scope.context) {
                                context.context = $scope.context;
                            }
                            if (typeof uiGridCtrl !== "undefined" && uiGridCtrl) {
                                context.grid = uiGridCtrl.grid;
                            }
                            return $scope.shown.call(context);
                        };
                        $scope.itemAction = function($event, title) {
                            gridUtil.logDebug("itemAction");
                            $event.stopPropagation();
                            if (typeof $scope.action === "function") {
                                var context = {};
                                if ($scope.context) {
                                    context.context = $scope.context;
                                }
                                if (typeof uiGridCtrl !== "undefined" && uiGridCtrl) {
                                    context.grid = uiGridCtrl.grid;
                                }
                                $scope.action.call(context, $event, title);
                                if (!$scope.leaveOpen) {
                                    $scope.$emit("hide-menu");
                                } else {
                                    gridUtil.focus.bySelector(angular.element(gridUtil.closestElm($elm, ".ui-grid-menu-items")), "button[type=button]", true);
                                }
                            }
                        };
                        $scope.i18n = i18nService.get();
                    }
                };
            }
        };
        return uiGridMenuItem;
    } ]);
})();

(function() {
    "use strict";
    var oneBinders = angular.module("ui.grid");
    angular.forEach([ {
        "tag": "Src",
        "method": "attr"
    }, {
        "tag": "Text",
        "method": "text"
    }, {
        "tag": "Href",
        "method": "attr"
    }, {
        "tag": "Class",
        "method": "addClass"
    }, {
        "tag": "Html",
        "method": "html"
    }, {
        "tag": "Alt",
        "method": "attr"
    }, {
        "tag": "Style",
        "method": "css"
    }, {
        "tag": "Value",
        "method": "attr"
    }, {
        "tag": "Id",
        "method": "attr"
    }, {
        "tag": "Id",
        "directiveName": "IdGrid",
        "method": "attr",
        "appendGridId": true
    }, {
        "tag": "Title",
        "method": "attr"
    }, {
        "tag": "Label",
        "method": "attr",
        "aria": true
    }, {
        "tag": "Labelledby",
        "method": "attr",
        "aria": true
    }, {
        "tag": "Labelledby",
        "directiveName": "LabelledbyGrid",
        "appendGridId": true,
        "method": "attr",
        "aria": true
    }, {
        "tag": "Describedby",
        "method": "attr",
        "aria": true
    }, {
        "tag": "Describedby",
        "directiveName": "DescribedbyGrid",
        "appendGridId": true,
        "method": "attr",
        "aria": true
    } ], function(v) {
        var baseDirectiveName = "uiGridOneBind";
        var directiveName = (v.aria ? baseDirectiveName + "Aria" : baseDirectiveName) + (v.directiveName ? v.directiveName : v.tag);
        oneBinders.directive(directiveName, [ "gridUtil", function(gridUtil) {
            return {
                "restrict": "A",
                "require": [ "?uiGrid", "?^uiGrid" ],
                "link": function(scope, iElement, iAttrs, controllers) {
                    var appendGridId = function(val) {
                        var grid;
                        if (scope.grid) {
                            grid = scope.grid;
                        } else if (scope.col && scope.col.grid) {
                            grid = scope.col.grid;
                        } else if (!controllers.some(function(controller) {
                            if (controller && controller.grid) {
                                grid = controller.grid;
                                return true;
                            }
                        })) {
                            gridUtil.logError("[" + directiveName + "] A valid grid could not be found to bind id. Are you using this directive " + "within the correct scope? Trying to generate id: [gridID]-" + val);
                            throw new Error("No valid grid could be found");
                        }
                        if (grid) {
                            var idRegex = new RegExp(grid.id.toString());
                            if (!idRegex.test(val)) {
                                val = grid.id.toString() + "-" + val;
                            }
                        }
                        return val;
                    };
                    var rmWatcher = scope.$watch(iAttrs[directiveName], function(newV) {
                        if (newV) {
                            if (v.appendGridId) {
                                var newIdString = null;
                                angular.forEach(newV.split(" "), function(s) {
                                    newIdString = (newIdString ? newIdString + " " : "") + appendGridId(s);
                                });
                                newV = newIdString;
                            }
                            switch (v.method) {
                              case "attr":
                                if (v.aria) {
                                    iElement[v.method]("aria-" + v.tag.toLowerCase(), newV);
                                } else {
                                    iElement[v.method](v.tag.toLowerCase(), newV);
                                }
                                break;

                              case "addClass":
                                if (angular.isObject(newV) && !angular.isArray(newV)) {
                                    var results = [];
                                    var nonNullFound = false;
                                    angular.forEach(newV, function(value, index) {
                                        if (value !== null && typeof value !== "undefined") {
                                            nonNullFound = true;
                                            if (value) {
                                                results.push(index);
                                            }
                                        }
                                    });
                                    if (!nonNullFound) {
                                        return;
                                    }
                                    newV = results;
                                }
                                if (newV) {
                                    iElement.addClass(angular.isArray(newV) ? newV.join(" ") : newV);
                                } else {
                                    return;
                                }
                                break;

                              default:
                                iElement[v.method](newV);
                                break;
                            }
                            rmWatcher();
                        }
                    }, true);
                }
            };
        } ]);
    });
})();

(function() {
    "use strict";
    var module = angular.module("ui.grid");
    module.directive("uiGridRenderContainer", [ "$timeout", "$document", "uiGridConstants", "gridUtil", "ScrollEvent", function($timeout, $document, uiGridConstants, gridUtil, ScrollEvent) {
        return {
            "replace": true,
            "transclude": true,
            "templateUrl": "ui-grid/uiGridRenderContainer",
            "require": [ "^uiGrid", "uiGridRenderContainer" ],
            "scope": {
                "containerId": "=",
                "rowContainerName": "=",
                "colContainerName": "=",
                "bindScrollHorizontal": "=",
                "bindScrollVertical": "=",
                "enableVerticalScrollbar": "=",
                "enableHorizontalScrollbar": "="
            },
            "controller": "uiGridRenderContainer as RenderContainer",
            "compile": function() {
                return {
                    "pre": function prelink($scope, $elm, $attrs, controllers) {
                        var uiGridCtrl = controllers[0];
                        var containerCtrl = controllers[1];
                        var grid = $scope.grid = uiGridCtrl.grid;
                        if (!$scope.rowContainerName) {
                            throw "No row render container name specified";
                        }
                        if (!$scope.colContainerName) {
                            throw "No column render container name specified";
                        }
                        if (!grid.renderContainers[$scope.rowContainerName]) {
                            throw "Row render container '" + $scope.rowContainerName + "' is not registered.";
                        }
                        if (!grid.renderContainers[$scope.colContainerName]) {
                            throw "Column render container '" + $scope.colContainerName + "' is not registered.";
                        }
                        var rowContainer = $scope.rowContainer = grid.renderContainers[$scope.rowContainerName];
                        var colContainer = $scope.colContainer = grid.renderContainers[$scope.colContainerName];
                        containerCtrl.containerId = $scope.containerId;
                        containerCtrl.rowContainer = rowContainer;
                        containerCtrl.colContainer = colContainer;
                    },
                    "post": function postlink($scope, $elm, $attrs, controllers) {
                        var uiGridCtrl = controllers[0];
                        var containerCtrl = controllers[1];
                        var grid = uiGridCtrl.grid;
                        var rowContainer = containerCtrl.rowContainer;
                        var colContainer = containerCtrl.colContainer;
                        var scrollTop = null;
                        var scrollLeft = null;
                        var renderContainer = grid.renderContainers[$scope.containerId];
                        $elm.addClass("ui-grid-render-container-" + $scope.containerId);
                        gridUtil.on.mousewheel($elm, function(event) {
                            var scrollEvent = new ScrollEvent(grid, rowContainer, colContainer, ScrollEvent.Sources.RenderContainerMouseWheel);
                            if (event.deltaY !== 0) {
                                var scrollYAmount = event.deltaY * -1 * event.deltaFactor;
                                scrollTop = containerCtrl.viewport[0].scrollTop;
                                scrollEvent.verticalScrollLength = rowContainer.getVerticalScrollLength();
                                var scrollYPercentage = (scrollTop + scrollYAmount) / scrollEvent.verticalScrollLength;
                                if (scrollYPercentage >= 1 && scrollTop < scrollEvent.verticalScrollLength) {
                                    containerCtrl.viewport[0].scrollTop = scrollEvent.verticalScrollLength;
                                }
                                if (scrollYPercentage < 0) {
                                    scrollYPercentage = 0;
                                } else if (scrollYPercentage > 1) {
                                    scrollYPercentage = 1;
                                }
                                scrollEvent.y = {
                                    "percentage": scrollYPercentage,
                                    "pixels": scrollYAmount
                                };
                            }
                            if (event.deltaX !== 0) {
                                var scrollXAmount = event.deltaX * event.deltaFactor;
                                scrollLeft = gridUtil.normalizeScrollLeft(containerCtrl.viewport, grid);
                                scrollEvent.horizontalScrollLength = colContainer.getCanvasWidth() - colContainer.getViewportWidth();
                                var scrollXPercentage = (scrollLeft + scrollXAmount) / scrollEvent.horizontalScrollLength;
                                if (scrollXPercentage < 0) {
                                    scrollXPercentage = 0;
                                } else if (scrollXPercentage > 1) {
                                    scrollXPercentage = 1;
                                }
                                scrollEvent.x = {
                                    "percentage": scrollXPercentage,
                                    "pixels": scrollXAmount
                                };
                            }
                            if (event.deltaY !== 0 && (scrollEvent.atTop(scrollTop) || scrollEvent.atBottom(scrollTop)) || event.deltaX !== 0 && (scrollEvent.atLeft(scrollLeft) || scrollEvent.atRight(scrollLeft))) {} else {
                                event.preventDefault();
                                event.stopPropagation();
                                scrollEvent.fireThrottledScrollingEvent("", scrollEvent);
                            }
                        });
                        $elm.bind("$destroy", function() {
                            $elm.unbind("keydown");
                            [ "touchstart", "touchmove", "touchend", "keydown", "wheel", "mousewheel", "DomMouseScroll", "MozMousePixelScroll" ].forEach(function(eventName) {
                                $elm.unbind(eventName);
                            });
                        });
                        function update() {
                            var ret = "";
                            var canvasWidth = colContainer.canvasWidth;
                            var viewportWidth = colContainer.getViewportWidth();
                            var canvasHeight = rowContainer.getCanvasHeight();
                            var viewportHeight = rowContainer.getViewportHeight();
                            if (colContainer.needsHScrollbarPlaceholder()) {
                                viewportHeight -= grid.scrollbarHeight;
                            }
                            var headerViewportWidth, footerViewportWidth;
                            headerViewportWidth = footerViewportWidth = colContainer.getHeaderViewportWidth();
                            ret += "\n .grid" + uiGridCtrl.grid.id + " .ui-grid-render-container-" + $scope.containerId + " .ui-grid-canvas { width: " + canvasWidth + "px; height: " + canvasHeight + "px; }";
                            ret += "\n .grid" + uiGridCtrl.grid.id + " .ui-grid-render-container-" + $scope.containerId + " .ui-grid-header-canvas { width: " + (canvasWidth + grid.scrollbarWidth) + "px; }";
                            if (renderContainer.explicitHeaderCanvasHeight) {
                                ret += "\n .grid" + uiGridCtrl.grid.id + " .ui-grid-render-container-" + $scope.containerId + " .ui-grid-header-canvas { height: " + renderContainer.explicitHeaderCanvasHeight + "px; }";
                            } else {
                                ret += "\n .grid" + uiGridCtrl.grid.id + " .ui-grid-render-container-" + $scope.containerId + " .ui-grid-header-canvas { height: inherit; }";
                            }
                            ret += "\n .grid" + uiGridCtrl.grid.id + " .ui-grid-render-container-" + $scope.containerId + " .ui-grid-viewport { width: " + viewportWidth + "px; height: " + viewportHeight + "px; }";
                            ret += "\n .grid" + uiGridCtrl.grid.id + " .ui-grid-render-container-" + $scope.containerId + " .ui-grid-header-viewport { width: " + headerViewportWidth + "px; }";
                            ret += "\n .grid" + uiGridCtrl.grid.id + " .ui-grid-render-container-" + $scope.containerId + " .ui-grid-footer-canvas { width: " + (canvasWidth + grid.scrollbarWidth) + "px; }";
                            ret += "\n .grid" + uiGridCtrl.grid.id + " .ui-grid-render-container-" + $scope.containerId + " .ui-grid-footer-viewport { width: " + footerViewportWidth + "px; }";
                            return ret;
                        }
                        uiGridCtrl.grid.registerStyleComputation({
                            "priority": 6,
                            "func": update
                        });
                    }
                };
            }
        };
    } ]);
    module.controller("uiGridRenderContainer", [ "$scope", "gridUtil", function($scope, gridUtil) {} ]);
})();

(function() {
    "use strict";
    angular.module("ui.grid").directive("uiGridRow", [ "gridUtil", function(gridUtil) {
        return {
            "replace": true,
            "require": [ "^uiGrid", "^uiGridRenderContainer" ],
            "scope": {
                "row": "=uiGridRow",
                "rowRenderIndex": "="
            },
            "compile": function() {
                return {
                    "pre": function($scope, $elm, $attrs, controllers) {
                        var uiGridCtrl = controllers[0];
                        var containerCtrl = controllers[1];
                        var grid = uiGridCtrl.grid;
                        $scope.grid = uiGridCtrl.grid;
                        $scope.colContainer = containerCtrl.colContainer;
                        var clonedElement, cloneScope;
                        function compileTemplate() {
                            $scope.row.getRowTemplateFn.then(function(compiledElementFn) {
                                var newScope = $scope.$new();
                                compiledElementFn(newScope, function(newElm, scope) {
                                    if (clonedElement) {
                                        clonedElement.remove();
                                        cloneScope.$destroy();
                                    }
                                    $elm.empty().append(newElm);
                                    clonedElement = newElm;
                                    cloneScope = newScope;
                                });
                            });
                        }
                        compileTemplate();
                        $scope.$watch("row.getRowTemplateFn", function(newFunc, oldFunc) {
                            if (newFunc !== oldFunc) {
                                compileTemplate();
                            }
                        });
                    },
                    "post": function($scope, $elm, $attrs, controllers) {}
                };
            }
        };
    } ]);
})();

(function() {
    angular.module("ui.grid").directive("uiGridStyle", [ "gridUtil", "$interpolate", function(gridUtil, $interpolate) {
        return {
            "link": function($scope, $elm, $attrs, uiGridCtrl) {
                var interpolateFn = $interpolate($elm.text(), true);
                if (interpolateFn) {
                    $scope.$watch(interpolateFn, function(value) {
                        $elm.text(value);
                    });
                }
            }
        };
    } ]);
})();

(function() {
    "use strict";
    angular.module("ui.grid").directive("uiGridViewport", [ "gridUtil", "ScrollEvent", "uiGridConstants", "$log", function(gridUtil, ScrollEvent, uiGridConstants, $log) {
        return {
            "replace": true,
            "scope": {},
            "controllerAs": "Viewport",
            "templateUrl": "ui-grid/uiGridViewport",
            "require": [ "^uiGrid", "^uiGridRenderContainer" ],
            "link": function($scope, $elm, $attrs, controllers) {
                var uiGridCtrl = controllers[0];
                var containerCtrl = controllers[1];
                $scope.containerCtrl = containerCtrl;
                var rowContainer = containerCtrl.rowContainer;
                var colContainer = containerCtrl.colContainer;
                var grid = uiGridCtrl.grid;
                $scope.grid = uiGridCtrl.grid;
                $scope.rowContainer = containerCtrl.rowContainer;
                $scope.colContainer = containerCtrl.colContainer;
                containerCtrl.viewport = $elm;
                $elm.on("scroll", scrollHandler);
                var ignoreScroll = false;
                function scrollHandler(evt) {
                    var newScrollTop = $elm[0].scrollTop;
                    var newScrollLeft = gridUtil.normalizeScrollLeft($elm, grid);
                    var vertScrollPercentage = rowContainer.scrollVertical(newScrollTop);
                    var horizScrollPercentage = colContainer.scrollHorizontal(newScrollLeft);
                    var scrollEvent = new ScrollEvent(grid, rowContainer, colContainer, ScrollEvent.Sources.ViewPortScroll);
                    scrollEvent.newScrollLeft = newScrollLeft;
                    scrollEvent.newScrollTop = newScrollTop;
                    if (horizScrollPercentage > -1) {
                        scrollEvent.x = {
                            "percentage": horizScrollPercentage
                        };
                    }
                    if (vertScrollPercentage > -1) {
                        scrollEvent.y = {
                            "percentage": vertScrollPercentage
                        };
                    }
                    grid.scrollContainers($scope.$parent.containerId, scrollEvent);
                }
                if ($scope.$parent.bindScrollVertical) {
                    grid.addVerticalScrollSync($scope.$parent.containerId, syncVerticalScroll);
                }
                if ($scope.$parent.bindScrollHorizontal) {
                    grid.addHorizontalScrollSync($scope.$parent.containerId, syncHorizontalScroll);
                    grid.addHorizontalScrollSync($scope.$parent.containerId + "header", syncHorizontalHeader);
                    grid.addHorizontalScrollSync($scope.$parent.containerId + "footer", syncHorizontalFooter);
                }
                function syncVerticalScroll(scrollEvent) {
                    containerCtrl.prevScrollArgs = scrollEvent;
                    var newScrollTop = scrollEvent.getNewScrollTop(rowContainer, containerCtrl.viewport);
                    $elm[0].scrollTop = newScrollTop;
                }
                function syncHorizontalScroll(scrollEvent) {
                    containerCtrl.prevScrollArgs = scrollEvent;
                    var newScrollLeft = scrollEvent.getNewScrollLeft(colContainer, containerCtrl.viewport);
                    $elm[0].scrollLeft = gridUtil.denormalizeScrollLeft(containerCtrl.viewport, newScrollLeft, grid);
                }
                function syncHorizontalHeader(scrollEvent) {
                    var newScrollLeft = scrollEvent.getNewScrollLeft(colContainer, containerCtrl.viewport);
                    if (containerCtrl.headerViewport) {
                        containerCtrl.headerViewport.scrollLeft = gridUtil.denormalizeScrollLeft(containerCtrl.viewport, newScrollLeft, grid);
                    }
                }
                function syncHorizontalFooter(scrollEvent) {
                    var newScrollLeft = scrollEvent.getNewScrollLeft(colContainer, containerCtrl.viewport);
                    if (containerCtrl.footerViewport) {
                        containerCtrl.footerViewport.scrollLeft = gridUtil.denormalizeScrollLeft(containerCtrl.viewport, newScrollLeft, grid);
                    }
                }
            },
            "controller": [ "$scope", function($scope) {
                this.rowStyle = function(index) {
                    var rowContainer = $scope.rowContainer;
                    var colContainer = $scope.colContainer;
                    var styles = {};
                    if (index === 0 && rowContainer.currentTopRow !== 0) {
                        var hiddenRowWidth = rowContainer.currentTopRow * rowContainer.grid.options.rowHeight;
                        styles["margin-top"] = hiddenRowWidth + "px";
                    }
                    if (colContainer.currentFirstColumn !== 0) {
                        if (colContainer.grid.isRTL()) {
                            styles["margin-right"] = colContainer.columnOffset + "px";
                        } else {
                            styles["margin-left"] = colContainer.columnOffset + "px";
                        }
                    }
                    return styles;
                };
            } ]
        };
    } ]);
})();

(function() {
    angular.module("ui.grid").directive("uiGridVisible", function uiGridVisibleAction() {
        return function($scope, $elm, $attr) {
            $scope.$watch($attr.uiGridVisible, function(visible) {
                $elm[visible ? "removeClass" : "addClass"]("ui-grid-invisible");
            });
        };
    });
})();

(function() {
    "use strict";
    angular.module("ui.grid").controller("uiGridController", [ "$scope", "$element", "$attrs", "gridUtil", "$q", "uiGridConstants", "$templateCache", "gridClassFactory", "$timeout", "$parse", "$compile", function($scope, $elm, $attrs, gridUtil, $q, uiGridConstants, $templateCache, gridClassFactory, $timeout, $parse, $compile) {
        var self = this;
        self.grid = gridClassFactory.createGrid($scope.uiGrid);
        self.grid.appScope = self.grid.appScope || $scope.$parent;
        $elm.addClass("grid" + self.grid.id);
        self.grid.rtl = gridUtil.getStyles($elm[0])["direction"] === "rtl";
        $scope.grid = self.grid;
        if ($attrs.uiGridColumns) {
            $attrs.$observe("uiGridColumns", function(value) {
                self.grid.options.columnDefs = value;
                self.grid.buildColumns().then(function() {
                    self.grid.preCompileCellTemplates();
                    self.grid.refreshCanvas(true);
                });
            });
        }
        var deregFunctions = [];
        if (self.grid.options.fastWatch) {
            self.uiGrid = $scope.uiGrid;
            if (angular.isString($scope.uiGrid.data)) {
                deregFunctions.push($scope.$parent.$watch($scope.uiGrid.data, dataWatchFunction));
                deregFunctions.push($scope.$parent.$watch(function() {
                    if (self.grid.appScope[$scope.uiGrid.data]) {
                        return self.grid.appScope[$scope.uiGrid.data].length;
                    } else {
                        return undefined;
                    }
                }, dataWatchFunction));
            } else {
                deregFunctions.push($scope.$parent.$watch(function() {
                    return $scope.uiGrid.data;
                }, dataWatchFunction));
                deregFunctions.push($scope.$parent.$watch(function() {
                    return $scope.uiGrid.data.length;
                }, function() {
                    dataWatchFunction($scope.uiGrid.data);
                }));
            }
            deregFunctions.push($scope.$parent.$watch(function() {
                return $scope.uiGrid.columnDefs;
            }, columnDefsWatchFunction));
            deregFunctions.push($scope.$parent.$watch(function() {
                return $scope.uiGrid.columnDefs.length;
            }, function() {
                columnDefsWatchFunction($scope.uiGrid.columnDefs);
            }));
        } else {
            if (angular.isString($scope.uiGrid.data)) {
                deregFunctions.push($scope.$parent.$watchCollection($scope.uiGrid.data, dataWatchFunction));
            } else {
                deregFunctions.push($scope.$parent.$watchCollection(function() {
                    return $scope.uiGrid.data;
                }, dataWatchFunction));
            }
            deregFunctions.push($scope.$parent.$watchCollection(function() {
                return $scope.uiGrid.columnDefs;
            }, columnDefsWatchFunction));
        }
        function columnDefsWatchFunction(n, o) {
            if (n && n !== o) {
                self.grid.options.columnDefs = $scope.uiGrid.columnDefs;
                self.grid.buildColumns({
                    "orderByColumnDefs": true
                }).then(function() {
                    self.grid.preCompileCellTemplates();
                    self.grid.callDataChangeCallbacks(uiGridConstants.dataChange.COLUMN);
                });
            }
        }
        var mostRecentData;
        function dataWatchFunction(newData) {
            var promises = [];
            if (self.grid.options.fastWatch) {
                if (angular.isString($scope.uiGrid.data)) {
                    newData = self.grid.appScope[$scope.uiGrid.data];
                } else {
                    newData = $scope.uiGrid.data;
                }
            }
            mostRecentData = newData;
            if (newData) {
                var hasColumns = self.grid.columns.length > (self.grid.rowHeaderColumns ? self.grid.rowHeaderColumns.length : 0);
                if (!hasColumns && !$attrs.uiGridColumns && self.grid.options.columnDefs.length === 0 && newData.length > 0) {
                    self.grid.buildColumnDefsFromData(newData);
                }
                if (!hasColumns && (self.grid.options.columnDefs.length > 0 || newData.length > 0)) {
                    promises.push(self.grid.buildColumns().then(function() {
                        self.grid.preCompileCellTemplates();
                    }));
                }
                $q.all(promises).then(function() {
                    self.grid.modifyRows(mostRecentData).then(function() {
                        self.grid.redrawInPlace(true);
                        $scope.$evalAsync(function() {
                            self.grid.refreshCanvas(true);
                            self.grid.callDataChangeCallbacks(uiGridConstants.dataChange.ROW);
                        });
                    });
                });
            }
        }
        var styleWatchDereg = $scope.$watch(function() {
            return self.grid.styleComputations;
        }, function() {
            self.grid.refreshCanvas(true);
        });
        $scope.$on("$destroy", function() {
            deregFunctions.forEach(function(deregFn) {
                deregFn();
            });
            styleWatchDereg();
        });
        self.fireEvent = function(eventName, args) {
            if (typeof args === "undefined" || args === undefined) {
                args = {};
            }
            if (typeof args.grid === "undefined" || args.grid === undefined) {
                args.grid = self.grid;
            }
            $scope.$broadcast(eventName, args);
        };
        self.innerCompile = function innerCompile(elm) {
            $compile(elm)($scope);
        };
    } ]);
    angular.module("ui.grid").directive("uiGrid", uiGridDirective);
    uiGridDirective.$inject = [ "$compile", "$templateCache", "$timeout", "$window", "gridUtil", "uiGridConstants" ];
    function uiGridDirective($compile, $templateCache, $timeout, $window, gridUtil, uiGridConstants) {
        return {
            "templateUrl": "ui-grid/ui-grid",
            "scope": {
                "uiGrid": "="
            },
            "replace": true,
            "transclude": true,
            "controller": "uiGridController",
            "compile": function() {
                return {
                    "post": function($scope, $elm, $attrs, uiGridCtrl) {
                        var grid = uiGridCtrl.grid;
                        uiGridCtrl.scrollbars = [];
                        grid.element = $elm;
                        var sizeCheckInterval = 100;
                        var maxSizeChecks = 20;
                        var sizeChecks = 0;
                        setup();
                        init();
                        grid.renderingComplete();
                        checkSize();
                        function checkSize() {
                            if ($elm[0].offsetWidth <= 0 && sizeChecks < maxSizeChecks) {
                                setTimeout(checkSize, sizeCheckInterval);
                                sizeChecks++;
                            } else {
                                $timeout(init);
                            }
                        }
                        function setup() {
                            angular.element($window).on("resize", gridResize);
                            $elm.on("$destroy", function() {
                                angular.element($window).off("resize", gridResize);
                            });
                            $scope.$watch(function() {
                                return grid.hasLeftContainer();
                            }, function(newValue, oldValue) {
                                if (newValue === oldValue) {
                                    return;
                                }
                                grid.refreshCanvas(true);
                            });
                            $scope.$watch(function() {
                                return grid.hasRightContainer();
                            }, function(newValue, oldValue) {
                                if (newValue === oldValue) {
                                    return;
                                }
                                grid.refreshCanvas(true);
                            });
                        }
                        function init() {
                            grid.gridWidth = $scope.gridWidth = gridUtil.elementWidth($elm);
                            grid.canvasWidth = uiGridCtrl.grid.gridWidth;
                            grid.gridHeight = $scope.gridHeight = gridUtil.elementHeight($elm);
                            if (grid.gridHeight <= grid.options.rowHeight && grid.options.enableMinHeightCheck) {
                                autoAdjustHeight();
                            }
                            grid.refreshCanvas(true);
                        }
                        function autoAdjustHeight() {
                            var contentHeight = grid.options.minRowsToShow * grid.options.rowHeight;
                            var headerHeight = grid.options.showHeader ? grid.options.headerRowHeight : 0;
                            var footerHeight = grid.calcFooterHeight();
                            var scrollbarHeight = 0;
                            if (grid.options.enableHorizontalScrollbar === uiGridConstants.scrollbars.ALWAYS) {
                                scrollbarHeight = gridUtil.getScrollbarWidth();
                            }
                            var maxNumberOfFilters = 0;
                            angular.forEach(grid.options.columnDefs, function(col) {
                                if (col.hasOwnProperty("filter")) {
                                    if (maxNumberOfFilters < 1) {
                                        maxNumberOfFilters = 1;
                                    }
                                } else if (col.hasOwnProperty("filters")) {
                                    if (maxNumberOfFilters < col.filters.length) {
                                        maxNumberOfFilters = col.filters.length;
                                    }
                                }
                            });
                            if (grid.options.enableFiltering && !maxNumberOfFilters) {
                                var allColumnsHaveFilteringTurnedOff = grid.options.columnDefs.length && grid.options.columnDefs.every(function(col) {
                                    return col.enableFiltering === false;
                                });
                                if (!allColumnsHaveFilteringTurnedOff) {
                                    maxNumberOfFilters = 1;
                                }
                            }
                            var filterHeight = maxNumberOfFilters * headerHeight;
                            var newHeight = headerHeight + contentHeight + footerHeight + scrollbarHeight + filterHeight;
                            $elm.css("height", newHeight + "px");
                            grid.gridHeight = $scope.gridHeight = gridUtil.elementHeight($elm);
                        }
                        function gridResize($event) {
                            grid.gridWidth = $scope.gridWidth = gridUtil.elementWidth($elm);
                            grid.gridHeight = $scope.gridHeight = gridUtil.elementHeight($elm);
                            grid.refreshCanvas(true);
                        }
                    }
                };
            }
        };
    }
})();

(function() {
    "use strict";
    angular.module("ui.grid").directive("uiGridPinnedContainer", [ "gridUtil", function(gridUtil) {
        return {
            "restrict": "EA",
            "replace": true,
            "template": '<div class="ui-grid-pinned-container"><div ui-grid-render-container container-id="side" row-container-name="\'body\'" col-container-name="side" bind-scroll-vertical="true" class="{{ side }} ui-grid-render-container-{{ side }}"></div></div>',
            "scope": {
                "side": "=uiGridPinnedContainer"
            },
            "require": "^uiGrid",
            "compile": function compile() {
                return {
                    "post": function($scope, $elm, $attrs, uiGridCtrl) {
                        var grid = uiGridCtrl.grid;
                        var myWidth = 0;
                        $elm.addClass("ui-grid-pinned-container-" + $scope.side);
                        if ($scope.side === "left" || $scope.side === "right") {
                            grid.renderContainers[$scope.side].getViewportWidth = monkeyPatchedGetViewportWidth;
                        }
                        function monkeyPatchedGetViewportWidth() {
                            var self = this;
                            var viewportWidth = 0;
                            self.visibleColumnCache.forEach(function(column) {
                                viewportWidth += column.drawnWidth;
                            });
                            var adjustment = self.getViewportAdjustment();
                            viewportWidth = viewportWidth + adjustment.width;
                            return viewportWidth;
                        }
                        function updateContainerWidth() {
                            if ($scope.side === "left" || $scope.side === "right") {
                                var cols = grid.renderContainers[$scope.side].visibleColumnCache;
                                var width = 0;
                                for (var i = 0; i < cols.length; i++) {
                                    var col = cols[i];
                                    width += col.drawnWidth || col.width || 0;
                                }
                                return width;
                            }
                        }
                        function updateContainerDimensions() {
                            var ret = "";
                            if ($scope.side === "left" || $scope.side === "right") {
                                myWidth = updateContainerWidth();
                                $elm.attr("style", null);
                                ret += ".grid" + grid.id + " .ui-grid-pinned-container-" + $scope.side + ", .grid" + grid.id + " .ui-grid-pinned-container-" + $scope.side + " .ui-grid-render-container-" + $scope.side + " .ui-grid-viewport { width: " + myWidth + "px; } ";
                            }
                            return ret;
                        }
                        grid.renderContainers.body.registerViewportAdjuster(function(adjustment) {
                            myWidth = updateContainerWidth();
                            adjustment.width -= myWidth;
                            adjustment.side = $scope.side;
                            return adjustment;
                        });
                        grid.registerStyleComputation({
                            "priority": 15,
                            "func": updateContainerDimensions
                        });
                    }
                };
            }
        };
    } ]);
})();

(function() {
    angular.module("ui.grid").factory("Grid", [ "$q", "$compile", "$parse", "gridUtil", "uiGridConstants", "GridOptions", "GridColumn", "GridRow", "GridApi", "rowSorter", "rowSearcher", "GridRenderContainer", "$timeout", "ScrollEvent", function($q, $compile, $parse, gridUtil, uiGridConstants, GridOptions, GridColumn, GridRow, GridApi, rowSorter, rowSearcher, GridRenderContainer, $timeout, ScrollEvent) {
        var Grid = function Grid(options) {
            var self = this;
            if (options !== undefined && typeof options.id !== "undefined" && options.id) {
                if (!/^[_a-zA-Z0-9-]+$/.test(options.id)) {
                    throw new Error("Grid id '" + options.id + '" is invalid. It must follow CSS selector syntax rules.');
                }
            } else {
                throw new Error("No ID provided. An ID must be given when creating a grid.");
            }
            self.id = options.id;
            delete options.id;
            self.options = GridOptions.initialize(options);
            self.appScope = self.options.appScopeProvider;
            self.headerHeight = self.options.headerRowHeight;
            self.footerHeight = self.calcFooterHeight();
            self.columnFooterHeight = self.calcColumnFooterHeight();
            self.rtl = false;
            self.gridHeight = 0;
            self.gridWidth = 0;
            self.columnBuilders = [];
            self.rowBuilders = [];
            self.rowsProcessors = [];
            self.columnsProcessors = [];
            self.styleComputations = [];
            self.viewportAdjusters = [];
            self.rowHeaderColumns = [];
            self.dataChangeCallbacks = {};
            self.verticalScrollSyncCallBackFns = {};
            self.horizontalScrollSyncCallBackFns = {};
            self.renderContainers = {};
            self.renderContainers.body = new GridRenderContainer("body", self);
            self.cellValueGetterCache = {};
            self.getRowTemplateFn = null;
            self.rows = [];
            self.columns = [];
            self.isScrollingVertically = false;
            self.isScrollingHorizontally = false;
            self.scrollDirection = uiGridConstants.scrollDirection.NONE;
            self.disableScrolling = false;
            function vertical(scrollEvent) {
                self.isScrollingVertically = false;
                self.api.core.raise.scrollEnd(scrollEvent);
                self.scrollDirection = uiGridConstants.scrollDirection.NONE;
            }
            var debouncedVertical = gridUtil.debounce(vertical, self.options.scrollDebounce);
            var debouncedVerticalMinDelay = gridUtil.debounce(vertical, 0);
            function horizontal(scrollEvent) {
                self.isScrollingHorizontally = false;
                self.api.core.raise.scrollEnd(scrollEvent);
                self.scrollDirection = uiGridConstants.scrollDirection.NONE;
            }
            var debouncedHorizontal = gridUtil.debounce(horizontal, self.options.scrollDebounce);
            var debouncedHorizontalMinDelay = gridUtil.debounce(horizontal, 0);
            self.flagScrollingVertically = function(scrollEvent) {
                if (!self.isScrollingVertically && !self.isScrollingHorizontally) {
                    self.api.core.raise.scrollBegin(scrollEvent);
                }
                self.isScrollingVertically = true;
                if (self.options.scrollDebounce === 0 || !scrollEvent.withDelay) {
                    debouncedVerticalMinDelay(scrollEvent);
                } else {
                    debouncedVertical(scrollEvent);
                }
            };
            self.flagScrollingHorizontally = function(scrollEvent) {
                if (!self.isScrollingVertically && !self.isScrollingHorizontally) {
                    self.api.core.raise.scrollBegin(scrollEvent);
                }
                self.isScrollingHorizontally = true;
                if (self.options.scrollDebounce === 0 || !scrollEvent.withDelay) {
                    debouncedHorizontalMinDelay(scrollEvent);
                } else {
                    debouncedHorizontal(scrollEvent);
                }
            };
            self.scrollbarHeight = 0;
            self.scrollbarWidth = 0;
            if (self.options.enableHorizontalScrollbar === uiGridConstants.scrollbars.ALWAYS) {
                self.scrollbarHeight = gridUtil.getScrollbarWidth();
            }
            if (self.options.enableVerticalScrollbar === uiGridConstants.scrollbars.ALWAYS) {
                self.scrollbarWidth = gridUtil.getScrollbarWidth();
            }
            self.api = new GridApi(self);
            self.api.registerMethod("core", "refresh", this.refresh);
            self.api.registerMethod("core", "queueGridRefresh", this.queueGridRefresh);
            self.api.registerMethod("core", "refreshRows", this.refreshRows);
            self.api.registerMethod("core", "queueRefresh", this.queueRefresh);
            self.api.registerMethod("core", "handleWindowResize", this.handleWindowResize);
            self.api.registerMethod("core", "addRowHeaderColumn", this.addRowHeaderColumn);
            self.api.registerMethod("core", "scrollToIfNecessary", function(gridRow, gridCol) {
                return self.scrollToIfNecessary(gridRow, gridCol);
            });
            self.api.registerMethod("core", "scrollTo", function(rowEntity, colDef) {
                return self.scrollTo(rowEntity, colDef);
            });
            self.api.registerMethod("core", "registerRowsProcessor", this.registerRowsProcessor);
            self.api.registerMethod("core", "registerColumnsProcessor", this.registerColumnsProcessor);
            self.api.registerMethod("core", "sortHandleNulls", rowSorter.handleNulls);
            self.api.registerEvent("core", "sortChanged");
            self.api.registerEvent("core", "columnVisibilityChanged");
            self.api.registerMethod("core", "notifyDataChange", this.notifyDataChange);
            self.api.registerMethod("core", "clearAllFilters", this.clearAllFilters);
            self.registerDataChangeCallback(self.columnRefreshCallback, [ uiGridConstants.dataChange.COLUMN ]);
            self.registerDataChangeCallback(self.processRowsCallback, [ uiGridConstants.dataChange.EDIT ]);
            self.registerDataChangeCallback(self.updateFooterHeightCallback, [ uiGridConstants.dataChange.OPTIONS ]);
            self.registerStyleComputation({
                "priority": 10,
                "func": self.getFooterStyles
            });
        };
        Grid.prototype.calcFooterHeight = function() {
            if (!this.hasFooter()) {
                return 0;
            }
            var height = 0;
            if (this.options.showGridFooter) {
                height += this.options.gridFooterHeight;
            }
            height += this.calcColumnFooterHeight();
            return height;
        };
        Grid.prototype.calcColumnFooterHeight = function() {
            var height = 0;
            if (this.options.showColumnFooter) {
                height += this.options.columnFooterHeight;
            }
            return height;
        };
        Grid.prototype.getFooterStyles = function() {
            var style = ".grid" + this.id + " .ui-grid-footer-aggregates-row { height: " + this.options.columnFooterHeight + "px; }";
            style += " .grid" + this.id + " .ui-grid-footer-info { height: " + this.options.gridFooterHeight + "px; }";
            return style;
        };
        Grid.prototype.hasFooter = function() {
            return this.options.showGridFooter || this.options.showColumnFooter;
        };
        Grid.prototype.isRTL = function() {
            return this.rtl;
        };
        Grid.prototype.registerColumnBuilder = function registerColumnBuilder(columnBuilder) {
            this.columnBuilders.push(columnBuilder);
        };
        Grid.prototype.buildColumnDefsFromData = function(dataRows) {
            this.options.columnDefs = gridUtil.getColumnsFromData(dataRows, this.options.excludeProperties);
        };
        Grid.prototype.registerRowBuilder = function registerRowBuilder(rowBuilder) {
            this.rowBuilders.push(rowBuilder);
        };
        Grid.prototype.registerDataChangeCallback = function registerDataChangeCallback(callback, types, _this) {
            var uid = gridUtil.nextUid();
            if (!types) {
                types = [ uiGridConstants.dataChange.ALL ];
            }
            if (!Array.isArray(types)) {
                gridUtil.logError("Expected types to be an array or null in registerDataChangeCallback, value passed was: " + types);
            }
            this.dataChangeCallbacks[uid] = {
                "callback": callback,
                "types": types,
                "_this": _this
            };
            var self = this;
            var deregisterFunction = function() {
                delete self.dataChangeCallbacks[uid];
            };
            return deregisterFunction;
        };
        Grid.prototype.callDataChangeCallbacks = function callDataChangeCallbacks(type, options) {
            angular.forEach(this.dataChangeCallbacks, function(callback, uid) {
                if (callback.types.indexOf(uiGridConstants.dataChange.ALL) !== -1 || callback.types.indexOf(type) !== -1 || type === uiGridConstants.dataChange.ALL) {
                    if (callback._this) {
                        callback.callback.apply(callback._this, this);
                    } else {
                        callback.callback(this);
                    }
                }
            }, this);
        };
        Grid.prototype.notifyDataChange = function notifyDataChange(type) {
            var constants = uiGridConstants.dataChange;
            if (type === constants.ALL || type === constants.COLUMN || type === constants.EDIT || type === constants.ROW || type === constants.OPTIONS) {
                this.callDataChangeCallbacks(type);
            } else {
                gridUtil.logError("Notified of a data change, but the type was not recognised, so no action taken, type was: " + type);
            }
        };
        Grid.prototype.columnRefreshCallback = function columnRefreshCallback(grid) {
            grid.buildColumns();
            grid.queueGridRefresh();
        };
        Grid.prototype.processRowsCallback = function processRowsCallback(grid) {
            grid.queueGridRefresh();
        };
        Grid.prototype.updateFooterHeightCallback = function updateFooterHeightCallback(grid) {
            grid.footerHeight = grid.calcFooterHeight();
            grid.columnFooterHeight = grid.calcColumnFooterHeight();
        };
        Grid.prototype.getColumn = function getColumn(name) {
            var columns = this.columns.filter(function(column) {
                return column.colDef.name === name;
            });
            return columns.length > 0 ? columns[0] : null;
        };
        Grid.prototype.getColDef = function getColDef(name) {
            var colDefs = this.options.columnDefs.filter(function(colDef) {
                return colDef.name === name;
            });
            return colDefs.length > 0 ? colDefs[0] : null;
        };
        Grid.prototype.assignTypes = function() {
            var self = this;
            self.options.columnDefs.forEach(function(colDef, index) {
                if (!colDef.type) {
                    var col = new GridColumn(colDef, index, self);
                    var firstRow = self.rows.length > 0 ? self.rows[0] : null;
                    if (firstRow) {
                        colDef.type = gridUtil.guessType(self.getCellValue(firstRow, col));
                    } else {
                        colDef.type = "string";
                    }
                }
            });
        };
        Grid.prototype.isRowHeaderColumn = function isRowHeaderColumn(column) {
            return this.rowHeaderColumns.indexOf(column) !== -1;
        };
        Grid.prototype.addRowHeaderColumn = function addRowHeaderColumn(colDef) {
            var self = this;
            var rowHeaderCol = new GridColumn(colDef, gridUtil.nextUid(), self);
            rowHeaderCol.isRowHeader = true;
            if (self.isRTL()) {
                self.createRightContainer();
                rowHeaderCol.renderContainer = "right";
            } else {
                self.createLeftContainer();
                rowHeaderCol.renderContainer = "left";
            }
            self.columnBuilders[0](colDef, rowHeaderCol, self.options).then(function() {
                rowHeaderCol.enableFiltering = false;
                rowHeaderCol.enableSorting = false;
                rowHeaderCol.enableHiding = false;
                self.rowHeaderColumns.push(rowHeaderCol);
                self.buildColumns().then(function() {
                    self.preCompileCellTemplates();
                    self.queueGridRefresh();
                });
            });
        };
        Grid.prototype.getOnlyDataColumns = function getOnlyDataColumns() {
            var self = this;
            var cols = [];
            self.columns.forEach(function(col) {
                if (self.rowHeaderColumns.indexOf(col) === -1) {
                    cols.push(col);
                }
            });
            return cols;
        };
        Grid.prototype.buildColumns = function buildColumns(opts) {
            var options = {
                "orderByColumnDefs": false
            };
            angular.extend(options, opts);
            var self = this;
            var builderPromises = [];
            var headerOffset = self.rowHeaderColumns.length;
            var i;
            for (i = 0; i < self.columns.length; i++) {
                if (!self.getColDef(self.columns[i].name)) {
                    self.columns.splice(i, 1);
                    i--;
                }
            }
            self.rowHeaderColumns.forEach(function(rowHeaderColumn) {
                self.columns.unshift(rowHeaderColumn);
            });
            self.options.columnDefs.forEach(function(colDef, index) {
                self.preprocessColDef(colDef);
                var col = self.getColumn(colDef.name);
                if (!col) {
                    col = new GridColumn(colDef, gridUtil.nextUid(), self);
                    self.columns.splice(index + headerOffset, 0, col);
                } else {
                    col.updateColumnDef(colDef, false);
                }
                self.columnBuilders.forEach(function(builder) {
                    builderPromises.push(builder.call(self, colDef, col, self.options));
                });
            });
            if (!!options.orderByColumnDefs) {
                var columnCache = self.columns.slice(0);
                var len = Math.min(self.options.columnDefs.length, self.columns.length);
                for (i = 0; i < len; i++) {
                    if (self.columns[i + headerOffset].name !== self.options.columnDefs[i].name) {
                        columnCache[i + headerOffset] = self.getColumn(self.options.columnDefs[i].name);
                    } else {
                        columnCache[i + headerOffset] = self.columns[i + headerOffset];
                    }
                }
                self.columns.length = 0;
                Array.prototype.splice.apply(self.columns, [ 0, 0 ].concat(columnCache));
            }
            return $q.all(builderPromises).then(function() {
                if (self.rows.length > 0) {
                    self.assignTypes();
                }
            });
        };
        Grid.prototype.preCompileCellTemplates = function() {
            var self = this;
            var preCompileTemplate = function(col) {
                var html = col.cellTemplate.replace(uiGridConstants.MODEL_COL_FIELD, self.getQualifiedColField(col));
                html = html.replace(uiGridConstants.COL_FIELD, "grid.getCellValue(row, col)");
                var compiledElementFn = $compile(html);
                col.compiledElementFn = compiledElementFn;
                if (col.compiledElementFnDefer) {
                    col.compiledElementFnDefer.resolve(col.compiledElementFn);
                }
            };
            this.columns.forEach(function(col) {
                if (col.cellTemplate) {
                    preCompileTemplate(col);
                } else if (col.cellTemplatePromise) {
                    col.cellTemplatePromise.then(function() {
                        preCompileTemplate(col);
                    });
                }
            });
        };
        Grid.prototype.getQualifiedColField = function(col) {
            return "row.entity." + gridUtil.preEval(col.field);
        };
        Grid.prototype.createLeftContainer = function() {
            if (!this.hasLeftContainer()) {
                this.renderContainers.left = new GridRenderContainer("left", this, {
                    "disableColumnOffset": true
                });
            }
        };
        Grid.prototype.createRightContainer = function() {
            if (!this.hasRightContainer()) {
                this.renderContainers.right = new GridRenderContainer("right", this, {
                    "disableColumnOffset": true
                });
            }
        };
        Grid.prototype.hasLeftContainer = function() {
            return this.renderContainers.left !== undefined;
        };
        Grid.prototype.hasRightContainer = function() {
            return this.renderContainers.right !== undefined;
        };
        Grid.prototype.preprocessColDef = function preprocessColDef(colDef) {
            var self = this;
            if (!colDef.field && !colDef.name) {
                throw new Error("colDef.name or colDef.field property is required");
            }
            if (colDef.name === undefined && colDef.field !== undefined) {
                var newName = colDef.field, counter = 2;
                while (self.getColumn(newName)) {
                    newName = colDef.field + counter.toString();
                    counter++;
                }
                colDef.name = newName;
            }
        };
        Grid.prototype.newInN = function newInN(o, n, oAccessor, nAccessor) {
            var self = this;
            var t = [];
            for (var i = 0; i < n.length; i++) {
                var nV = nAccessor ? n[i][nAccessor] : n[i];
                var found = false;
                for (var j = 0; j < o.length; j++) {
                    var oV = oAccessor ? o[j][oAccessor] : o[j];
                    if (self.options.rowEquality(nV, oV)) {
                        found = true;
                        break;
                    }
                }
                if (!found) {
                    t.push(nV);
                }
            }
            return t;
        };
        Grid.prototype.getRow = function getRow(rowEntity, lookInRows) {
            var self = this;
            lookInRows = typeof lookInRows === "undefined" ? self.rows : lookInRows;
            var rows = lookInRows.filter(function(row) {
                return self.options.rowEquality(row.entity, rowEntity);
            });
            return rows.length > 0 ? rows[0] : null;
        };
        Grid.prototype.modifyRows = function modifyRows(newRawData) {
            var self = this;
            var oldRows = self.rows.slice(0);
            var oldRowHash = self.rowHashMap || self.createRowHashMap();
            self.rowHashMap = self.createRowHashMap();
            self.rows.length = 0;
            newRawData.forEach(function(newEntity, i) {
                var newRow;
                if (self.options.enableRowHashing) {
                    newRow = oldRowHash.get(newEntity);
                } else {
                    newRow = self.getRow(newEntity, oldRows);
                }
                if (!newRow) {
                    newRow = self.processRowBuilders(new GridRow(newEntity, i, self));
                }
                self.rows.push(newRow);
                self.rowHashMap.put(newEntity, newRow);
            });
            self.assignTypes();
            var p1 = $q.when(self.processRowsProcessors(self.rows)).then(function(renderableRows) {
                return self.setVisibleRows(renderableRows);
            });
            var p2 = $q.when(self.processColumnsProcessors(self.columns)).then(function(renderableColumns) {
                return self.setVisibleColumns(renderableColumns);
            });
            return $q.all([ p1, p2 ]);
        };
        Grid.prototype.addRows = function addRows(newRawData) {
            var self = this;
            var existingRowCount = self.rows.length;
            for (var i = 0; i < newRawData.length; i++) {
                var newRow = self.processRowBuilders(new GridRow(newRawData[i], i + existingRowCount, self));
                if (self.options.enableRowHashing) {
                    var found = self.rowHashMap.get(newRow.entity);
                    if (found) {
                        found.row = newRow;
                    }
                }
                self.rows.push(newRow);
            }
        };
        Grid.prototype.processRowBuilders = function processRowBuilders(gridRow) {
            var self = this;
            self.rowBuilders.forEach(function(builder) {
                builder.call(self, gridRow, self.options);
            });
            return gridRow;
        };
        Grid.prototype.registerStyleComputation = function registerStyleComputation(styleComputationInfo) {
            this.styleComputations.push(styleComputationInfo);
        };
        Grid.prototype.registerRowsProcessor = function registerRowsProcessor(processor, priority) {
            if (!angular.isFunction(processor)) {
                throw "Attempt to register non-function rows processor: " + processor;
            }
            this.rowsProcessors.push({
                "processor": processor,
                "priority": priority
            });
            this.rowsProcessors.sort(function sortByPriority(a, b) {
                return a.priority - b.priority;
            });
        };
        Grid.prototype.removeRowsProcessor = function removeRowsProcessor(processor) {
            var idx = -1;
            this.rowsProcessors.forEach(function(rowsProcessor, index) {
                if (rowsProcessor.processor === processor) {
                    idx = index;
                }
            });
            if (idx !== -1) {
                this.rowsProcessors.splice(idx, 1);
            }
        };
        Grid.prototype.processRowsProcessors = function processRowsProcessors(renderableRows) {
            var self = this;
            var myRenderableRows = renderableRows.slice(0);
            if (self.rowsProcessors.length === 0) {
                return $q.when(myRenderableRows);
            }
            var i = 0;
            var finished = $q.defer();
            function startProcessor(i, renderedRowsToProcess) {
                var processor = self.rowsProcessors[i].processor;
                return $q.when(processor.call(self, renderedRowsToProcess, self.columns)).then(function handleProcessedRows(processedRows) {
                    if (!processedRows) {
                        throw "Processor at index " + i + " did not return a set of renderable rows";
                    }
                    if (!angular.isArray(processedRows)) {
                        throw "Processor at index " + i + " did not return an array";
                    }
                    i++;
                    if (i <= self.rowsProcessors.length - 1) {
                        return startProcessor(i, processedRows);
                    } else {
                        finished.resolve(processedRows);
                    }
                });
            }
            startProcessor(0, myRenderableRows);
            return finished.promise;
        };
        Grid.prototype.setVisibleRows = function setVisibleRows(rows) {
            var self = this;
            for (var i in self.renderContainers) {
                var container = self.renderContainers[i];
                container.canvasHeightShouldUpdate = true;
                if (typeof container.visibleRowCache === "undefined") {
                    container.visibleRowCache = [];
                } else {
                    container.visibleRowCache.length = 0;
                }
            }
            for (var ri = 0; ri < rows.length; ri++) {
                var row = rows[ri];
                var targetContainer = typeof row.renderContainer !== "undefined" && row.renderContainer ? row.renderContainer : "body";
                if (row.visible) {
                    self.renderContainers[targetContainer].visibleRowCache.push(row);
                }
            }
            self.api.core.raise.rowsRendered(this.api);
        };
        Grid.prototype.registerColumnsProcessor = function registerColumnsProcessor(processor, priority) {
            if (!angular.isFunction(processor)) {
                throw "Attempt to register non-function rows processor: " + processor;
            }
            this.columnsProcessors.push({
                "processor": processor,
                "priority": priority
            });
            this.columnsProcessors.sort(function sortByPriority(a, b) {
                return a.priority - b.priority;
            });
        };
        Grid.prototype.removeColumnsProcessor = function removeColumnsProcessor(processor) {
            var idx = this.columnsProcessors.indexOf(processor);
            if (typeof idx !== "undefined" && idx !== undefined) {
                this.columnsProcessors.splice(idx, 1);
            }
        };
        Grid.prototype.processColumnsProcessors = function processColumnsProcessors(renderableColumns) {
            var self = this;
            var myRenderableColumns = renderableColumns.slice(0);
            if (self.columnsProcessors.length === 0) {
                return $q.when(myRenderableColumns);
            }
            var i = 0;
            var finished = $q.defer();
            function startProcessor(i, renderedColumnsToProcess) {
                var processor = self.columnsProcessors[i].processor;
                return $q.when(processor.call(self, renderedColumnsToProcess, self.rows)).then(function handleProcessedRows(processedColumns) {
                    if (!processedColumns) {
                        throw "Processor at index " + i + " did not return a set of renderable rows";
                    }
                    if (!angular.isArray(processedColumns)) {
                        throw "Processor at index " + i + " did not return an array";
                    }
                    i++;
                    if (i <= self.columnsProcessors.length - 1) {
                        return startProcessor(i, myRenderableColumns);
                    } else {
                        finished.resolve(myRenderableColumns);
                    }
                });
            }
            startProcessor(0, myRenderableColumns);
            return finished.promise;
        };
        Grid.prototype.setVisibleColumns = function setVisibleColumns(columns) {
            var self = this;
            for (var i in self.renderContainers) {
                var container = self.renderContainers[i];
                container.visibleColumnCache.length = 0;
            }
            for (var ci = 0; ci < columns.length; ci++) {
                var column = columns[ci];
                if (column.visible) {
                    if (typeof column.renderContainer !== "undefined" && column.renderContainer) {
                        self.renderContainers[column.renderContainer].visibleColumnCache.push(column);
                    } else {
                        self.renderContainers.body.visibleColumnCache.push(column);
                    }
                }
            }
        };
        Grid.prototype.handleWindowResize = function handleWindowResize($event) {
            var self = this;
            self.gridWidth = gridUtil.elementWidth(self.element);
            self.gridHeight = gridUtil.elementHeight(self.element);
            return self.queueRefresh();
        };
        Grid.prototype.queueRefresh = function queueRefresh() {
            var self = this;
            if (self.refreshCanceller) {
                $timeout.cancel(self.refreshCanceller);
            }
            self.refreshCanceller = $timeout(function() {
                self.refreshCanvas(true);
            });
            self.refreshCanceller.then(function() {
                self.refreshCanceller = null;
            });
            return self.refreshCanceller;
        };
        Grid.prototype.queueGridRefresh = function queueGridRefresh() {
            var self = this;
            if (self.gridRefreshCanceller) {
                $timeout.cancel(self.gridRefreshCanceller);
            }
            self.gridRefreshCanceller = $timeout(function() {
                self.refresh(true);
            });
            self.gridRefreshCanceller.then(function() {
                self.gridRefreshCanceller = null;
            });
            return self.gridRefreshCanceller;
        };
        Grid.prototype.updateCanvasHeight = function updateCanvasHeight() {
            var self = this;
            for (var containerId in self.renderContainers) {
                if (self.renderContainers.hasOwnProperty(containerId)) {
                    var container = self.renderContainers[containerId];
                    container.canvasHeightShouldUpdate = true;
                }
            }
        };
        Grid.prototype.buildStyles = function buildStyles() {
            var self = this;
            self.customStyles = "";
            self.styleComputations.sort(function(a, b) {
                if (a.priority === null) {
                    return 1;
                }
                if (b.priority === null) {
                    return -1;
                }
                if (a.priority === null && b.priority === null) {
                    return 0;
                }
                return a.priority - b.priority;
            }).forEach(function(compInfo) {
                var ret = compInfo.func.call(self);
                if (angular.isString(ret)) {
                    self.customStyles += "\n" + ret;
                }
            });
        };
        Grid.prototype.minColumnsToRender = function minColumnsToRender() {
            var self = this;
            var viewport = this.getViewportWidth();
            var min = 0;
            var totalWidth = 0;
            self.columns.forEach(function(col, i) {
                if (totalWidth < viewport) {
                    totalWidth += col.drawnWidth;
                    min++;
                } else {
                    var currWidth = 0;
                    for (var j = i; j >= i - min; j--) {
                        currWidth += self.columns[j].drawnWidth;
                    }
                    if (currWidth < viewport) {
                        min++;
                    }
                }
            });
            return min;
        };
        Grid.prototype.getBodyHeight = function getBodyHeight() {
            var bodyHeight = this.getViewportHeight();
            return bodyHeight;
        };
        Grid.prototype.getViewportHeight = function getViewportHeight() {
            var self = this;
            var viewPortHeight = this.gridHeight - this.headerHeight - this.footerHeight;
            var adjustment = self.getViewportAdjustment();
            viewPortHeight = viewPortHeight + adjustment.height;
            return viewPortHeight;
        };
        Grid.prototype.getViewportWidth = function getViewportWidth() {
            var self = this;
            var viewPortWidth = this.gridWidth;
            var adjustment = self.getViewportAdjustment();
            viewPortWidth = viewPortWidth + adjustment.width;
            return viewPortWidth;
        };
        Grid.prototype.getHeaderViewportWidth = function getHeaderViewportWidth() {
            var viewPortWidth = this.getViewportWidth();
            return viewPortWidth;
        };
        Grid.prototype.addVerticalScrollSync = function(containerId, callBackFn) {
            this.verticalScrollSyncCallBackFns[containerId] = callBackFn;
        };
        Grid.prototype.addHorizontalScrollSync = function(containerId, callBackFn) {
            this.horizontalScrollSyncCallBackFns[containerId] = callBackFn;
        };
        Grid.prototype.scrollContainers = function(sourceContainerId, scrollEvent) {
            if (scrollEvent.y) {
                var verts = [ "body", "left", "right" ];
                this.flagScrollingVertically(scrollEvent);
                if (sourceContainerId === "body") {
                    verts = [ "left", "right" ];
                } else if (sourceContainerId === "left") {
                    verts = [ "body", "right" ];
                } else if (sourceContainerId === "right") {
                    verts = [ "body", "left" ];
                }
                for (var i = 0; i < verts.length; i++) {
                    var id = verts[i];
                    if (this.verticalScrollSyncCallBackFns[id]) {
                        this.verticalScrollSyncCallBackFns[id](scrollEvent);
                    }
                }
            }
            if (scrollEvent.x) {
                var horizs = [ "body", "bodyheader", "bodyfooter" ];
                this.flagScrollingHorizontally(scrollEvent);
                if (sourceContainerId === "body") {
                    horizs = [ "bodyheader", "bodyfooter" ];
                }
                for (var j = 0; j < horizs.length; j++) {
                    var idh = horizs[j];
                    if (this.horizontalScrollSyncCallBackFns[idh]) {
                        this.horizontalScrollSyncCallBackFns[idh](scrollEvent);
                    }
                }
            }
        };
        Grid.prototype.registerViewportAdjuster = function registerViewportAdjuster(func) {
            this.viewportAdjusters.push(func);
        };
        Grid.prototype.removeViewportAdjuster = function registerViewportAdjuster(func) {
            var idx = this.viewportAdjusters.indexOf(func);
            if (typeof idx !== "undefined" && idx !== undefined) {
                this.viewportAdjusters.splice(idx, 1);
            }
        };
        Grid.prototype.getViewportAdjustment = function getViewportAdjustment() {
            var self = this;
            var adjustment = {
                "height": 0,
                "width": 0
            };
            self.viewportAdjusters.forEach(function(func) {
                adjustment = func.call(this, adjustment);
            });
            return adjustment;
        };
        Grid.prototype.getVisibleRowCount = function getVisibleRowCount() {
            return this.renderContainers.body.visibleRowCache.length;
        };
        Grid.prototype.getVisibleRows = function getVisibleRows() {
            return this.renderContainers.body.visibleRowCache;
        };
        Grid.prototype.getVisibleColumnCount = function getVisibleColumnCount() {
            return this.renderContainers.body.visibleColumnCache.length;
        };
        Grid.prototype.searchRows = function searchRows(renderableRows) {
            return rowSearcher.search(this, renderableRows, this.columns);
        };
        Grid.prototype.sortByColumn = function sortByColumn(renderableRows) {
            return rowSorter.sort(this, renderableRows, this.columns);
        };
        Grid.prototype.getCellValue = function getCellValue(row, col) {
            if (typeof row.entity["$$" + col.uid] !== "undefined") {
                return row.entity["$$" + col.uid].rendered;
            } else if (this.options.flatEntityAccess && typeof col.field !== "undefined") {
                return row.entity[col.field];
            } else {
                if (!col.cellValueGetterCache) {
                    col.cellValueGetterCache = $parse(row.getEntityQualifiedColField(col));
                }
                return col.cellValueGetterCache(row);
            }
        };
        Grid.prototype.getCellDisplayValue = function getCellDisplayValue(row, col) {
            if (!col.cellDisplayGetterCache) {
                var custom_filter = col.cellFilter ? " | " + col.cellFilter : "";
                if (typeof row.entity["$$" + col.uid] !== "undefined") {
                    col.cellDisplayGetterCache = $parse(row.entity["$$" + col.uid].rendered + custom_filter);
                } else if (this.options.flatEntityAccess && typeof col.field !== "undefined") {
                    col.cellDisplayGetterCache = $parse(row.entity[col.field] + custom_filter);
                } else {
                    col.cellDisplayGetterCache = $parse(row.getEntityQualifiedColField(col) + custom_filter);
                }
            }
            return col.cellDisplayGetterCache(row);
        };
        Grid.prototype.getNextColumnSortPriority = function getNextColumnSortPriority() {
            var self = this, p = 0;
            self.columns.forEach(function(col) {
                if (col.sort && col.sort.priority !== undefined && col.sort.priority >= p) {
                    p = col.sort.priority + 1;
                }
            });
            return p;
        };
        Grid.prototype.resetColumnSorting = function resetColumnSorting(excludeCol) {
            var self = this;
            self.columns.forEach(function(col) {
                if (col !== excludeCol && !col.suppressRemoveSort) {
                    col.sort = {};
                }
            });
        };
        Grid.prototype.getColumnSorting = function getColumnSorting() {
            var self = this;
            var sortedCols = [], myCols;
            myCols = self.columns.slice(0);
            myCols.sort(rowSorter.prioritySort).forEach(function(col) {
                if (col.sort && typeof col.sort.direction !== "undefined" && col.sort.direction && (col.sort.direction === uiGridConstants.ASC || col.sort.direction === uiGridConstants.DESC)) {
                    sortedCols.push(col);
                }
            });
            return sortedCols;
        };
        Grid.prototype.sortColumn = function sortColumn(column, directionOrAdd, add) {
            var self = this, direction = null;
            if (typeof column === "undefined" || !column) {
                throw new Error("No column parameter provided");
            }
            if (typeof directionOrAdd === "boolean") {
                add = directionOrAdd;
            } else {
                direction = directionOrAdd;
            }
            if (!add) {
                self.resetColumnSorting(column);
                column.sort.priority = undefined;
                column.sort.priority = self.getNextColumnSortPriority();
            } else if (!column.sort.priority) {
                column.sort.priority = self.getNextColumnSortPriority();
            }
            if (!direction) {
                var i = column.sortDirectionCycle.indexOf(column.sort.direction ? column.sort.direction : null);
                i = (i + 1) % column.sortDirectionCycle.length;
                if (column.colDef && column.suppressRemoveSort && !column.sortDirectionCycle[i]) {
                    i = (i + 1) % column.sortDirectionCycle.length;
                }
                if (column.sortDirectionCycle[i]) {
                    column.sort.direction = column.sortDirectionCycle[i];
                } else {
                    column.sort = {};
                }
            } else {
                column.sort.direction = direction;
            }
            self.api.core.raise.sortChanged(self, self.getColumnSorting());
            return $q.when(column);
        };
        Grid.prototype.renderingComplete = function() {
            if (angular.isFunction(this.options.onRegisterApi)) {
                this.options.onRegisterApi(this.api);
            }
            this.api.core.raise.renderingComplete(this.api);
        };
        Grid.prototype.createRowHashMap = function createRowHashMap() {
            var self = this;
            var hashMap = new RowHashMap();
            hashMap.grid = self;
            return hashMap;
        };
        Grid.prototype.refresh = function refresh(rowsAltered) {
            var self = this;
            var p1 = self.processRowsProcessors(self.rows).then(function(renderableRows) {
                self.setVisibleRows(renderableRows);
            });
            var p2 = self.processColumnsProcessors(self.columns).then(function(renderableColumns) {
                self.setVisibleColumns(renderableColumns);
            });
            return $q.all([ p1, p2 ]).then(function() {
                self.redrawInPlace(rowsAltered);
                self.refreshCanvas(true);
            });
        };
        Grid.prototype.refreshRows = function refreshRows() {
            var self = this;
            return self.processRowsProcessors(self.rows).then(function(renderableRows) {
                self.setVisibleRows(renderableRows);
                self.redrawInPlace();
                self.refreshCanvas(true);
            });
        };
        Grid.prototype.refreshCanvas = function(buildStyles) {
            var self = this;
            if (buildStyles) {
                self.buildStyles();
            }
            var p = $q.defer();
            var containerHeadersToRecalc = [];
            for (var containerId in self.renderContainers) {
                if (self.renderContainers.hasOwnProperty(containerId)) {
                    var container = self.renderContainers[containerId];
                    if (container.canvasWidth === null || isNaN(container.canvasWidth)) {
                        continue;
                    }
                    if (container.header || container.headerCanvas) {
                        container.explicitHeaderHeight = container.explicitHeaderHeight || null;
                        container.explicitHeaderCanvasHeight = container.explicitHeaderCanvasHeight || null;
                        containerHeadersToRecalc.push(container);
                    }
                }
            }
            if (containerHeadersToRecalc.length > 0) {
                if (buildStyles) {
                    self.buildStyles();
                }
                $timeout(function() {
                    var rebuildStyles = false;
                    var maxHeaderHeight = 0;
                    var maxHeaderCanvasHeight = 0;
                    var i, container;
                    var getHeight = function(oldVal, newVal) {
                        if (oldVal !== newVal) {
                            rebuildStyles = true;
                        }
                        return newVal;
                    };
                    for (i = 0; i < containerHeadersToRecalc.length; i++) {
                        container = containerHeadersToRecalc[i];
                        if (container.canvasWidth === null || isNaN(container.canvasWidth)) {
                            continue;
                        }
                        if (container.header) {
                            var headerHeight = container.headerHeight = getHeight(container.headerHeight, parseInt(gridUtil.outerElementHeight(container.header), 10));
                            var topBorder = gridUtil.getBorderSize(container.header, "top");
                            var bottomBorder = gridUtil.getBorderSize(container.header, "bottom");
                            var innerHeaderHeight = parseInt(headerHeight - topBorder - bottomBorder, 10);
                            innerHeaderHeight = innerHeaderHeight < 0 ? 0 : innerHeaderHeight;
                            container.innerHeaderHeight = innerHeaderHeight;
                            if (!container.explicitHeaderHeight && innerHeaderHeight > maxHeaderHeight) {
                                maxHeaderHeight = innerHeaderHeight;
                            }
                        }
                        if (container.headerCanvas) {
                            var headerCanvasHeight = container.headerCanvasHeight = getHeight(container.headerCanvasHeight, parseInt(gridUtil.outerElementHeight(container.headerCanvas), 10));
                            if (!container.explicitHeaderCanvasHeight && headerCanvasHeight > maxHeaderCanvasHeight) {
                                maxHeaderCanvasHeight = headerCanvasHeight;
                            }
                        }
                    }
                    for (i = 0; i < containerHeadersToRecalc.length; i++) {
                        container = containerHeadersToRecalc[i];
                        if (maxHeaderHeight > 0 && typeof container.headerHeight !== "undefined" && container.headerHeight !== null && (container.explicitHeaderHeight || container.headerHeight < maxHeaderHeight)) {
                            container.explicitHeaderHeight = getHeight(container.explicitHeaderHeight, maxHeaderHeight);
                        }
                        if (maxHeaderCanvasHeight > 0 && typeof container.headerCanvasHeight !== "undefined" && container.headerCanvasHeight !== null && (container.explicitHeaderCanvasHeight || container.headerCanvasHeight < maxHeaderCanvasHeight)) {
                            container.explicitHeaderCanvasHeight = getHeight(container.explicitHeaderCanvasHeight, maxHeaderCanvasHeight);
                        }
                    }
                    if (buildStyles && rebuildStyles) {
                        self.buildStyles();
                    }
                    p.resolve();
                });
            } else {
                $timeout(function() {
                    p.resolve();
                });
            }
            return p.promise;
        };
        Grid.prototype.redrawInPlace = function redrawInPlace(rowsAdded) {
            var self = this;
            for (var i in self.renderContainers) {
                var container = self.renderContainers[i];
                if (rowsAdded) {
                    container.adjustRows(container.prevScrollTop, null);
                    container.adjustColumns(container.prevScrollLeft, null);
                } else {
                    container.adjustRows(null, container.prevScrolltopPercentage);
                    container.adjustColumns(null, container.prevScrollleftPercentage);
                }
            }
        };
        Grid.prototype.hasLeftContainerColumns = function() {
            return this.hasLeftContainer() && this.renderContainers.left.renderedColumns.length > 0;
        };
        Grid.prototype.hasRightContainerColumns = function() {
            return this.hasRightContainer() && this.renderContainers.right.renderedColumns.length > 0;
        };
        Grid.prototype.scrollToIfNecessary = function(gridRow, gridCol) {
            var self = this;
            var scrollEvent = new ScrollEvent(self, "uiGrid.scrollToIfNecessary");
            var visRowCache = self.renderContainers.body.visibleRowCache;
            var visColCache = self.renderContainers.body.visibleColumnCache;
            var topBound = self.renderContainers.body.prevScrollTop + self.headerHeight;
            topBound = topBound < 0 ? 0 : topBound;
            var leftBound = self.renderContainers.body.prevScrollLeft;
            var bottomBound = self.renderContainers.body.prevScrollTop + self.gridHeight - self.renderContainers.body.headerHeight - self.footerHeight - self.scrollbarWidth;
            var rightBound = self.renderContainers.body.prevScrollLeft + Math.ceil(self.renderContainers.body.getViewportWidth());
            if (gridRow !== null) {
                var seekRowIndex = visRowCache.indexOf(gridRow);
                var scrollLength = self.renderContainers.body.getCanvasHeight() - self.renderContainers.body.getViewportHeight();
                var pixelsToSeeRow = seekRowIndex * self.options.rowHeight + self.headerHeight;
                pixelsToSeeRow = pixelsToSeeRow < 0 ? 0 : pixelsToSeeRow;
                var scrollPixels, percentage;
                if (pixelsToSeeRow < topBound) {
                    scrollPixels = self.renderContainers.body.prevScrollTop - (topBound - pixelsToSeeRow);
                    percentage = scrollPixels / scrollLength;
                    scrollEvent.y = {
                        "percentage": percentage
                    };
                } else if (pixelsToSeeRow > bottomBound) {
                    scrollPixels = pixelsToSeeRow - bottomBound + self.renderContainers.body.prevScrollTop;
                    percentage = scrollPixels / scrollLength;
                    scrollEvent.y = {
                        "percentage": percentage
                    };
                }
            }
            if (gridCol !== null) {
                var seekColumnIndex = visColCache.indexOf(gridCol);
                var horizScrollLength = self.renderContainers.body.getCanvasWidth() - self.renderContainers.body.getViewportWidth();
                var columnLeftEdge = 0;
                for (var i = 0; i < seekColumnIndex; i++) {
                    var col = visColCache[i];
                    columnLeftEdge += col.drawnWidth;
                }
                columnLeftEdge = columnLeftEdge < 0 ? 0 : columnLeftEdge;
                var columnRightEdge = columnLeftEdge + gridCol.drawnWidth;
                columnRightEdge = columnRightEdge < 0 ? 0 : columnRightEdge;
                var horizScrollPixels, horizPercentage;
                if (columnLeftEdge < leftBound) {
                    horizScrollPixels = self.renderContainers.body.prevScrollLeft - (leftBound - columnLeftEdge);
                    horizPercentage = horizScrollPixels / horizScrollLength;
                    horizPercentage = horizPercentage > 1 ? 1 : horizPercentage;
                    scrollEvent.x = {
                        "percentage": horizPercentage
                    };
                } else if (columnRightEdge > rightBound) {
                    horizScrollPixels = columnRightEdge - rightBound + self.renderContainers.body.prevScrollLeft;
                    horizPercentage = horizScrollPixels / horizScrollLength;
                    horizPercentage = horizPercentage > 1 ? 1 : horizPercentage;
                    scrollEvent.x = {
                        "percentage": horizPercentage
                    };
                }
            }
            var deferred = $q.defer();
            if (scrollEvent.y || scrollEvent.x) {
                scrollEvent.withDelay = false;
                self.scrollContainers("", scrollEvent);
                var dereg = self.api.core.on.scrollEnd(null, function() {
                    deferred.resolve(scrollEvent);
                    dereg();
                });
            } else {
                deferred.resolve();
            }
            return deferred.promise;
        };
        Grid.prototype.scrollTo = function(rowEntity, colDef) {
            var gridRow = null, gridCol = null;
            if (rowEntity !== null && typeof rowEntity !== "undefined") {
                gridRow = this.getRow(rowEntity);
            }
            if (colDef !== null && typeof colDef !== "undefined") {
                gridCol = this.getColumn(colDef.name ? colDef.name : colDef.field);
            }
            return this.scrollToIfNecessary(gridRow, gridCol);
        };
        Grid.prototype.clearAllFilters = function clearAllFilters(refreshRows, clearConditions, clearFlags) {
            if (refreshRows === undefined) {
                refreshRows = true;
            }
            if (clearConditions === undefined) {
                clearConditions = false;
            }
            if (clearFlags === undefined) {
                clearFlags = false;
            }
            this.columns.forEach(function(column) {
                column.filters.forEach(function(filter) {
                    filter.term = undefined;
                    if (clearConditions) {
                        filter.condition = undefined;
                    }
                    if (clearFlags) {
                        filter.flags = undefined;
                    }
                });
            });
            if (refreshRows) {
                return this.refreshRows();
            }
        };
        function RowHashMap() {}
        RowHashMap.prototype = {
            "put": function(key, value) {
                this[this.grid.options.rowIdentity(key)] = value;
            },
            "get": function(key) {
                return this[this.grid.options.rowIdentity(key)];
            },
            "remove": function(key) {
                var value = this[key = this.grid.options.rowIdentity(key)];
                delete this[key];
                return value;
            }
        };
        return Grid;
    } ]);
})();

(function() {
    angular.module("ui.grid").factory("GridApi", [ "$q", "$rootScope", "gridUtil", "uiGridConstants", "GridRow", "uiGridGridMenuService", function($q, $rootScope, gridUtil, uiGridConstants, GridRow, uiGridGridMenuService) {
        var GridApi = function GridApi(grid) {
            this.grid = grid;
            this.listeners = [];
            this.registerEvent("core", "renderingComplete");
            this.registerEvent("core", "filterChanged");
            this.registerMethod("core", "setRowInvisible", GridRow.prototype.setRowInvisible);
            this.registerMethod("core", "clearRowInvisible", GridRow.prototype.clearRowInvisible);
            this.registerMethod("core", "getVisibleRows", this.grid.getVisibleRows);
            this.registerEvent("core", "rowsVisibleChanged");
            this.registerEvent("core", "rowsRendered");
            this.registerEvent("core", "scrollBegin");
            this.registerEvent("core", "scrollEnd");
            this.registerEvent("core", "canvasHeightChanged");
        };
        GridApi.prototype.suppressEvents = function(listenerFuncs, callBackFn) {
            var self = this;
            var listeners = angular.isArray(listenerFuncs) ? listenerFuncs : [ listenerFuncs ];
            var foundListeners = self.listeners.filter(function(listener) {
                return listeners.some(function(l) {
                    return listener.handler === l;
                });
            });
            foundListeners.forEach(function(l) {
                l.dereg();
            });
            callBackFn();
            foundListeners.forEach(function(l) {
                l.dereg = registerEventWithAngular(l.eventId, l.handler, self.grid, l._this);
            });
        };
        GridApi.prototype.registerEvent = function(featureName, eventName) {
            var self = this;
            if (!self[featureName]) {
                self[featureName] = {};
            }
            var feature = self[featureName];
            if (!feature.on) {
                feature.on = {};
                feature.raise = {};
            }
            var eventId = self.grid.id + featureName + eventName;
            feature.raise[eventName] = function() {
                $rootScope.$emit.apply($rootScope, [ eventId ].concat(Array.prototype.slice.call(arguments)));
            };
            feature.on[eventName] = function(scope, handler, _this) {
                if (scope !== null && typeof scope.$on === "undefined") {
                    gridUtil.logError("asked to listen on " + featureName + ".on." + eventName + " but scope wasn't passed in the input parameters.  It is legitimate to pass null, but you've passed something else, so you probably forgot to provide scope rather than did it deliberately, not registering");
                    return;
                }
                var deregAngularOn = registerEventWithAngular(eventId, handler, self.grid, _this);
                var listener = {
                    "handler": handler,
                    "dereg": deregAngularOn,
                    "eventId": eventId,
                    "scope": scope,
                    "_this": _this
                };
                self.listeners.push(listener);
                var removeListener = function() {
                    listener.dereg();
                    var index = self.listeners.indexOf(listener);
                    self.listeners.splice(index, 1);
                };
                if (scope) {
                    scope.$on("$destroy", function() {
                        removeListener();
                    });
                }
                return removeListener;
            };
        };
        function registerEventWithAngular(eventId, handler, grid, _this) {
            return $rootScope.$on(eventId, function(event) {
                var args = Array.prototype.slice.call(arguments);
                args.splice(0, 1);
                handler.apply(_this ? _this : grid.api, args);
            });
        }
        GridApi.prototype.registerEventsFromObject = function(eventObjectMap) {
            var self = this;
            var features = [];
            angular.forEach(eventObjectMap, function(featProp, featPropName) {
                var feature = {
                    "name": featPropName,
                    "events": []
                };
                angular.forEach(featProp, function(prop, propName) {
                    feature.events.push(propName);
                });
                features.push(feature);
            });
            features.forEach(function(feature) {
                feature.events.forEach(function(event) {
                    self.registerEvent(feature.name, event);
                });
            });
        };
        GridApi.prototype.registerMethod = function(featureName, methodName, callBackFn, _this) {
            if (!this[featureName]) {
                this[featureName] = {};
            }
            var feature = this[featureName];
            feature[methodName] = gridUtil.createBoundedWrapper(_this || this.grid, callBackFn);
        };
        GridApi.prototype.registerMethodsFromObject = function(methodMap, _this) {
            var self = this;
            var features = [];
            angular.forEach(methodMap, function(featProp, featPropName) {
                var feature = {
                    "name": featPropName,
                    "methods": []
                };
                angular.forEach(featProp, function(prop, propName) {
                    feature.methods.push({
                        "name": propName,
                        "fn": prop
                    });
                });
                features.push(feature);
            });
            features.forEach(function(feature) {
                feature.methods.forEach(function(method) {
                    self.registerMethod(feature.name, method.name, method.fn, _this);
                });
            });
        };
        return GridApi;
    } ]);
})();

(function() {
    angular.module("ui.grid").factory("GridColumn", [ "gridUtil", "uiGridConstants", "i18nService", function(gridUtil, uiGridConstants, i18nService) {
        function GridColumn(colDef, uid, grid) {
            var self = this;
            self.grid = grid;
            self.uid = uid;
            self.updateColumnDef(colDef, true);
            self.aggregationValue = undefined;
            self.updateAggregationValue = function() {
                if (!self.aggregationType) {
                    self.aggregationValue = undefined;
                    return;
                }
                var result = 0;
                var visibleRows = self.grid.getVisibleRows();
                var cellValues = function() {
                    var values = [];
                    visibleRows.forEach(function(row) {
                        var cellValue = self.grid.getCellValue(row, self);
                        var cellNumber = Number(cellValue);
                        if (!isNaN(cellNumber)) {
                            values.push(cellNumber);
                        }
                    });
                    return values;
                };
                if (angular.isFunction(self.aggregationType)) {
                    self.aggregationValue = self.aggregationType(visibleRows, self);
                } else if (self.aggregationType === uiGridConstants.aggregationTypes.count) {
                    self.aggregationValue = self.grid.getVisibleRowCount();
                } else if (self.aggregationType === uiGridConstants.aggregationTypes.sum) {
                    cellValues().forEach(function(value) {
                        result += value;
                    });
                    self.aggregationValue = result;
                } else if (self.aggregationType === uiGridConstants.aggregationTypes.avg) {
                    cellValues().forEach(function(value) {
                        result += value;
                    });
                    result = result / cellValues().length;
                    self.aggregationValue = result;
                } else if (self.aggregationType === uiGridConstants.aggregationTypes.min) {
                    self.aggregationValue = Math.min.apply(null, cellValues());
                } else if (self.aggregationType === uiGridConstants.aggregationTypes.max) {
                    self.aggregationValue = Math.max.apply(null, cellValues());
                } else {
                    self.aggregationValue = "\xa0";
                }
            };
            this.getAggregationValue = function() {
                return self.aggregationValue;
            };
        }
        GridColumn.prototype.hideColumn = function() {
            this.colDef.visible = false;
        };
        GridColumn.prototype.setPropertyOrDefault = function(colDef, propName, defaultValue) {
            var self = this;
            if (typeof colDef[propName] !== "undefined" && colDef[propName]) {
                self[propName] = colDef[propName];
            } else if (typeof self[propName] !== "undefined") {
                self[propName] = self[propName];
            } else {
                self[propName] = defaultValue ? defaultValue : {};
            }
        };
        GridColumn.prototype.updateColumnDef = function(colDef, isNew) {
            var self = this;
            self.colDef = colDef;
            if (colDef.name === undefined) {
                throw new Error("colDef.name is required for column at index " + self.grid.options.columnDefs.indexOf(colDef));
            }
            self.displayName = colDef.displayName === undefined ? gridUtil.readableColumnName(colDef.name) : colDef.displayName;
            if (!angular.isNumber(self.width) || !self.hasCustomWidth || colDef.allowCustomWidthOverride) {
                var colDefWidth = colDef.width;
                var parseErrorMsg = "Cannot parse column width '" + colDefWidth + "' for column named '" + colDef.name + "'";
                self.hasCustomWidth = false;
                if (!angular.isString(colDefWidth) && !angular.isNumber(colDefWidth)) {
                    self.width = "*";
                } else if (angular.isString(colDefWidth)) {
                    if (gridUtil.endsWith(colDefWidth, "%")) {
                        var percentStr = colDefWidth.replace(/%/g, "");
                        var percent = parseInt(percentStr, 10);
                        if (isNaN(percent)) {
                            throw new Error(parseErrorMsg);
                        }
                        self.width = colDefWidth;
                    } else if (colDefWidth.match(/^(\d+)$/)) {
                        self.width = parseInt(colDefWidth.match(/^(\d+)$/)[1], 10);
                    } else if (colDefWidth.match(/^\*+$/)) {
                        self.width = colDefWidth;
                    } else {
                        throw new Error(parseErrorMsg);
                    }
                } else {
                    self.width = colDefWidth;
                }
            }
            [ "minWidth", "maxWidth" ].forEach(function(name) {
                var minOrMaxWidth = colDef[name];
                var parseErrorMsg = "Cannot parse column " + name + " '" + minOrMaxWidth + "' for column named '" + colDef.name + "'";
                if (!angular.isString(minOrMaxWidth) && !angular.isNumber(minOrMaxWidth)) {
                    self[name] = name === "minWidth" ? 30 : 9e3;
                } else if (angular.isString(minOrMaxWidth)) {
                    if (minOrMaxWidth.match(/^(\d+)$/)) {
                        self[name] = parseInt(minOrMaxWidth.match(/^(\d+)$/)[1], 10);
                    } else {
                        throw new Error(parseErrorMsg);
                    }
                } else {
                    self[name] = minOrMaxWidth;
                }
            });
            self.field = colDef.field === undefined ? colDef.name : colDef.field;
            if (typeof self.field !== "string") {
                gridUtil.logError("Field is not a string, this is likely to break the code, Field is: " + self.field);
            }
            self.name = colDef.name;
            self.displayName = colDef.displayName === undefined ? gridUtil.readableColumnName(colDef.name) : colDef.displayName;
            self.aggregationType = angular.isDefined(colDef.aggregationType) ? colDef.aggregationType : null;
            self.footerCellTemplate = angular.isDefined(colDef.footerCellTemplate) ? colDef.footerCellTemplate : null;
            if (typeof colDef.cellTooltip === "undefined" || colDef.cellTooltip === false) {
                self.cellTooltip = false;
            } else if (colDef.cellTooltip === true) {
                self.cellTooltip = function(row, col) {
                    return self.grid.getCellValue(row, col);
                };
            } else if (typeof colDef.cellTooltip === "function") {
                self.cellTooltip = colDef.cellTooltip;
            } else {
                self.cellTooltip = function(row, col) {
                    return col.colDef.cellTooltip;
                };
            }
            if (typeof colDef.headerTooltip === "undefined" || colDef.headerTooltip === false) {
                self.headerTooltip = false;
            } else if (colDef.headerTooltip === true) {
                self.headerTooltip = function(col) {
                    return col.displayName;
                };
            } else if (typeof colDef.headerTooltip === "function") {
                self.headerTooltip = colDef.headerTooltip;
            } else {
                self.headerTooltip = function(col) {
                    return col.colDef.headerTooltip;
                };
            }
            self.footerCellClass = colDef.footerCellClass;
            self.cellClass = colDef.cellClass;
            self.headerCellClass = colDef.headerCellClass;
            self.cellFilter = colDef.cellFilter ? colDef.cellFilter : "";
            self.sortCellFiltered = colDef.sortCellFiltered ? true : false;
            self.filterCellFiltered = colDef.filterCellFiltered ? true : false;
            self.headerCellFilter = colDef.headerCellFilter ? colDef.headerCellFilter : "";
            self.footerCellFilter = colDef.footerCellFilter ? colDef.footerCellFilter : "";
            self.visible = gridUtil.isNullOrUndefined(colDef.visible) || colDef.visible;
            self.headerClass = colDef.headerClass;
            self.enableSorting = typeof colDef.enableSorting !== "undefined" ? colDef.enableSorting : true;
            self.sortingAlgorithm = colDef.sortingAlgorithm;
            self.sortDirectionCycle = typeof colDef.sortDirectionCycle !== "undefined" ? colDef.sortDirectionCycle : [ null, uiGridConstants.ASC, uiGridConstants.DESC ];
            if (typeof self.suppressRemoveSort === "undefined") {
                self.suppressRemoveSort = typeof colDef.suppressRemoveSort !== "undefined" ? colDef.suppressRemoveSort : false;
            }
            self.enableFiltering = typeof colDef.enableFiltering !== "undefined" ? colDef.enableFiltering : true;
            self.setPropertyOrDefault(colDef, "menuItems", []);
            if (isNew) {
                self.setPropertyOrDefault(colDef, "sort");
            }
            var defaultFilters = [];
            if (colDef.filter) {
                defaultFilters.push(colDef.filter);
            } else if (colDef.filters) {
                defaultFilters = colDef.filters;
            } else {
                defaultFilters.push({});
            }
            if (isNew) {
                self.setPropertyOrDefault(colDef, "filter");
                self.setPropertyOrDefault(colDef, "filters", defaultFilters);
            } else if (self.filters.length === defaultFilters.length) {
                self.filters.forEach(function(filter, index) {
                    if (typeof defaultFilters[index].placeholder !== "undefined") {
                        filter.placeholder = defaultFilters[index].placeholder;
                    }
                    if (typeof defaultFilters[index].ariaLabel !== "undefined") {
                        filter.ariaLabel = defaultFilters[index].ariaLabel;
                    }
                    if (typeof defaultFilters[index].flags !== "undefined") {
                        filter.flags = defaultFilters[index].flags;
                    }
                    if (typeof defaultFilters[index].type !== "undefined") {
                        filter.type = defaultFilters[index].type;
                    }
                    if (typeof defaultFilters[index].selectOptions !== "undefined") {
                        filter.selectOptions = defaultFilters[index].selectOptions;
                    }
                });
            }
        };
        GridColumn.prototype.unsort = function() {
            this.sort = {};
            this.grid.api.core.raise.sortChanged(this.grid, this.grid.getColumnSorting());
        };
        GridColumn.prototype.getColClass = function(prefixDot) {
            var cls = uiGridConstants.COL_CLASS_PREFIX + this.uid;
            return prefixDot ? "." + cls : cls;
        };
        GridColumn.prototype.isPinnedLeft = function() {
            return this.renderContainer === "left";
        };
        GridColumn.prototype.isPinnedRight = function() {
            return this.renderContainer === "right";
        };
        GridColumn.prototype.getColClassDefinition = function() {
            return " .grid" + this.grid.id + " " + this.getColClass(true) + " { min-width: " + this.drawnWidth + "px; max-width: " + this.drawnWidth + "px; }";
        };
        GridColumn.prototype.getRenderContainer = function getRenderContainer() {
            var self = this;
            var containerId = self.renderContainer;
            if (containerId === null || containerId === "" || containerId === undefined) {
                containerId = "body";
            }
            return self.grid.renderContainers[containerId];
        };
        GridColumn.prototype.showColumn = function() {
            this.colDef.visible = true;
        };
        GridColumn.prototype.getAggregationText = function() {
            var self = this;
            if (self.colDef.aggregationHideLabel) {
                return "";
            } else if (self.colDef.aggregationLabel) {
                return self.colDef.aggregationLabel;
            } else {
                switch (self.colDef.aggregationType) {
                  case uiGridConstants.aggregationTypes.count:
                    return i18nService.getSafeText("aggregation.count");

                  case uiGridConstants.aggregationTypes.sum:
                    return i18nService.getSafeText("aggregation.sum");

                  case uiGridConstants.aggregationTypes.avg:
                    return i18nService.getSafeText("aggregation.avg");

                  case uiGridConstants.aggregationTypes.min:
                    return i18nService.getSafeText("aggregation.min");

                  case uiGridConstants.aggregationTypes.max:
                    return i18nService.getSafeText("aggregation.max");

                  default:
                    return "";
                }
            }
        };
        GridColumn.prototype.getCellTemplate = function() {
            var self = this;
            return self.cellTemplatePromise;
        };
        GridColumn.prototype.getCompiledElementFn = function() {
            var self = this;
            return self.compiledElementFnDefer.promise;
        };
        return GridColumn;
    } ]);
})();

(function() {
    angular.module("ui.grid").factory("GridOptions", [ "gridUtil", "uiGridConstants", function(gridUtil, uiGridConstants) {
        return {
            "initialize": function(baseOptions) {
                baseOptions.onRegisterApi = baseOptions.onRegisterApi || angular.noop();
                baseOptions.data = baseOptions.data || [];
                baseOptions.columnDefs = baseOptions.columnDefs || [];
                baseOptions.excludeProperties = baseOptions.excludeProperties || [ "$$hashKey" ];
                baseOptions.enableRowHashing = baseOptions.enableRowHashing !== false;
                baseOptions.rowIdentity = baseOptions.rowIdentity || function rowIdentity(row) {
                    return gridUtil.hashKey(row);
                };
                baseOptions.getRowIdentity = baseOptions.getRowIdentity || function getRowIdentity(row) {
                    return row.$$hashKey;
                };
                baseOptions.flatEntityAccess = baseOptions.flatEntityAccess === true;
                baseOptions.showHeader = typeof baseOptions.showHeader !== "undefined" ? baseOptions.showHeader : true;
                if (!baseOptions.showHeader) {
                    baseOptions.headerRowHeight = 0;
                } else {
                    baseOptions.headerRowHeight = typeof baseOptions.headerRowHeight !== "undefined" ? baseOptions.headerRowHeight : 30;
                }
                baseOptions.rowHeight = baseOptions.rowHeight || 30;
                baseOptions.minRowsToShow = typeof baseOptions.minRowsToShow !== "undefined" ? baseOptions.minRowsToShow : 10;
                baseOptions.showGridFooter = baseOptions.showGridFooter === true;
                baseOptions.showColumnFooter = baseOptions.showColumnFooter === true;
                baseOptions.columnFooterHeight = typeof baseOptions.columnFooterHeight !== "undefined" ? baseOptions.columnFooterHeight : 30;
                baseOptions.gridFooterHeight = typeof baseOptions.gridFooterHeight !== "undefined" ? baseOptions.gridFooterHeight : 30;
                baseOptions.columnWidth = typeof baseOptions.columnWidth !== "undefined" ? baseOptions.columnWidth : 50;
                baseOptions.maxVisibleColumnCount = typeof baseOptions.maxVisibleColumnCount !== "undefined" ? baseOptions.maxVisibleColumnCount : 200;
                baseOptions.virtualizationThreshold = typeof baseOptions.virtualizationThreshold !== "undefined" ? baseOptions.virtualizationThreshold : 20;
                baseOptions.columnVirtualizationThreshold = typeof baseOptions.columnVirtualizationThreshold !== "undefined" ? baseOptions.columnVirtualizationThreshold : 10;
                baseOptions.excessRows = typeof baseOptions.excessRows !== "undefined" ? baseOptions.excessRows : 4;
                baseOptions.scrollThreshold = typeof baseOptions.scrollThreshold !== "undefined" ? baseOptions.scrollThreshold : 4;
                baseOptions.excessColumns = typeof baseOptions.excessColumns !== "undefined" ? baseOptions.excessColumns : 4;
                baseOptions.horizontalScrollThreshold = typeof baseOptions.horizontalScrollThreshold !== "undefined" ? baseOptions.horizontalScrollThreshold : 2;
                baseOptions.aggregationCalcThrottle = typeof baseOptions.aggregationCalcThrottle !== "undefined" ? baseOptions.aggregationCalcThrottle : 500;
                baseOptions.wheelScrollThrottle = typeof baseOptions.wheelScrollThrottle !== "undefined" ? baseOptions.wheelScrollThrottle : 70;
                baseOptions.scrollDebounce = typeof baseOptions.scrollDebounce !== "undefined" ? baseOptions.scrollDebounce : 300;
                baseOptions.enableSorting = baseOptions.enableSorting !== false;
                baseOptions.enableFiltering = baseOptions.enableFiltering === true;
                baseOptions.enableColumnMenus = baseOptions.enableColumnMenus !== false;
                baseOptions.enableVerticalScrollbar = typeof baseOptions.enableVerticalScrollbar !== "undefined" ? baseOptions.enableVerticalScrollbar : uiGridConstants.scrollbars.ALWAYS;
                baseOptions.enableHorizontalScrollbar = typeof baseOptions.enableHorizontalScrollbar !== "undefined" ? baseOptions.enableHorizontalScrollbar : uiGridConstants.scrollbars.ALWAYS;
                baseOptions.enableMinHeightCheck = baseOptions.enableMinHeightCheck !== false;
                baseOptions.minimumColumnSize = typeof baseOptions.minimumColumnSize !== "undefined" ? baseOptions.minimumColumnSize : 10;
                baseOptions.rowEquality = baseOptions.rowEquality || function(entityA, entityB) {
                    return entityA === entityB;
                };
                baseOptions.headerTemplate = baseOptions.headerTemplate || null;
                baseOptions.footerTemplate = baseOptions.footerTemplate || "ui-grid/ui-grid-footer";
                baseOptions.gridFooterTemplate = baseOptions.gridFooterTemplate || "ui-grid/ui-grid-grid-footer";
                baseOptions.rowTemplate = baseOptions.rowTemplate || "ui-grid/ui-grid-row";
                baseOptions.appScopeProvider = baseOptions.appScopeProvider || null;
                return baseOptions;
            }
        };
    } ]);
})();

(function() {
    angular.module("ui.grid").factory("GridRenderContainer", [ "gridUtil", "uiGridConstants", function(gridUtil, uiGridConstants) {
        function GridRenderContainer(name, grid, options) {
            var self = this;
            self.name = name;
            self.grid = grid;
            self.visibleRowCache = [];
            self.visibleColumnCache = [];
            self.renderedRows = [];
            self.renderedColumns = [];
            self.prevScrollTop = 0;
            self.prevScrolltopPercentage = 0;
            self.prevRowScrollIndex = 0;
            self.prevScrollLeft = 0;
            self.prevScrollleftPercentage = 0;
            self.prevColumnScrollIndex = 0;
            self.columnStyles = "";
            self.viewportAdjusters = [];
            self.hasHScrollbar = false;
            self.hasVScrollbar = false;
            self.canvasHeightShouldUpdate = true;
            self.$$canvasHeight = 0;
            if (options && angular.isObject(options)) {
                angular.extend(self, options);
            }
            grid.registerStyleComputation({
                "priority": 5,
                "func": function() {
                    self.updateColumnWidths();
                    return self.columnStyles;
                }
            });
        }
        GridRenderContainer.prototype.reset = function reset() {
            this.visibleColumnCache.length = 0;
            this.visibleRowCache.length = 0;
            this.renderedRows.length = 0;
            this.renderedColumns.length = 0;
        };
        GridRenderContainer.prototype.containsColumn = function(col) {
            return this.visibleColumnCache.indexOf(col) !== -1;
        };
        GridRenderContainer.prototype.minRowsToRender = function minRowsToRender() {
            var self = this;
            var minRows = 0;
            var rowAddedHeight = 0;
            var viewPortHeight = self.getViewportHeight();
            for (var i = self.visibleRowCache.length - 1; rowAddedHeight < viewPortHeight && i >= 0; i--) {
                rowAddedHeight += self.visibleRowCache[i].height;
                minRows++;
            }
            return minRows;
        };
        GridRenderContainer.prototype.minColumnsToRender = function minColumnsToRender() {
            var self = this;
            var viewportWidth = this.getViewportWidth();
            var min = 0;
            var totalWidth = 0;
            for (var i = 0; i < self.visibleColumnCache.length; i++) {
                var col = self.visibleColumnCache[i];
                if (totalWidth < viewportWidth) {
                    totalWidth += col.drawnWidth ? col.drawnWidth : 0;
                    min++;
                } else {
                    var currWidth = 0;
                    for (var j = i; j >= i - min; j--) {
                        currWidth += self.visibleColumnCache[j].drawnWidth ? self.visibleColumnCache[j].drawnWidth : 0;
                    }
                    if (currWidth < viewportWidth) {
                        min++;
                    }
                }
            }
            return min;
        };
        GridRenderContainer.prototype.getVisibleRowCount = function getVisibleRowCount() {
            return this.visibleRowCache.length;
        };
        GridRenderContainer.prototype.registerViewportAdjuster = function registerViewportAdjuster(func) {
            this.viewportAdjusters.push(func);
        };
        GridRenderContainer.prototype.removeViewportAdjuster = function removeViewportAdjuster(func) {
            var idx = this.viewportAdjusters.indexOf(func);
            if (idx > -1) {
                this.viewportAdjusters.splice(idx, 1);
            }
        };
        GridRenderContainer.prototype.getViewportAdjustment = function getViewportAdjustment() {
            var self = this;
            var adjustment = {
                "height": 0,
                "width": 0
            };
            self.viewportAdjusters.forEach(function(func) {
                adjustment = func.call(this, adjustment);
            });
            return adjustment;
        };
        GridRenderContainer.prototype.getMargin = function getMargin(side) {
            var self = this;
            var amount = 0;
            self.viewportAdjusters.forEach(function(func) {
                var adjustment = func.call(this, {
                    "height": 0,
                    "width": 0
                });
                if (adjustment.side && adjustment.side === side) {
                    amount += adjustment.width * -1;
                }
            });
            return amount;
        };
        GridRenderContainer.prototype.getViewportHeight = function getViewportHeight() {
            var self = this;
            var headerHeight = self.headerHeight ? self.headerHeight : self.grid.headerHeight;
            var viewPortHeight = self.grid.gridHeight - headerHeight - self.grid.footerHeight;
            var adjustment = self.getViewportAdjustment();
            viewPortHeight = viewPortHeight + adjustment.height;
            return viewPortHeight;
        };
        GridRenderContainer.prototype.getViewportWidth = function getViewportWidth() {
            var self = this;
            var viewportWidth = self.grid.gridWidth;
            var adjustment = self.getViewportAdjustment();
            viewportWidth = viewportWidth + adjustment.width;
            return viewportWidth;
        };
        GridRenderContainer.prototype.getHeaderViewportWidth = function getHeaderViewportWidth() {
            var self = this;
            var viewportWidth = this.getViewportWidth();
            return viewportWidth;
        };
        GridRenderContainer.prototype.getCanvasHeight = function getCanvasHeight() {
            var self = this;
            if (!self.canvasHeightShouldUpdate) {
                return self.$$canvasHeight;
            }
            var oldCanvasHeight = self.$$canvasHeight;
            self.$$canvasHeight = 0;
            self.visibleRowCache.forEach(function(row) {
                self.$$canvasHeight += row.height;
            });
            self.canvasHeightShouldUpdate = false;
            self.grid.api.core.raise.canvasHeightChanged(oldCanvasHeight, self.$$canvasHeight);
            return self.$$canvasHeight;
        };
        GridRenderContainer.prototype.getVerticalScrollLength = function getVerticalScrollLength() {
            return this.getCanvasHeight() - this.getViewportHeight() + this.grid.scrollbarHeight;
        };
        GridRenderContainer.prototype.getCanvasWidth = function getCanvasWidth() {
            var self = this;
            var ret = self.canvasWidth;
            return ret;
        };
        GridRenderContainer.prototype.setRenderedRows = function setRenderedRows(newRows) {
            this.renderedRows.length = newRows.length;
            for (var i = 0; i < newRows.length; i++) {
                this.renderedRows[i] = newRows[i];
            }
        };
        GridRenderContainer.prototype.setRenderedColumns = function setRenderedColumns(newColumns) {
            var self = this;
            this.renderedColumns.length = newColumns.length;
            for (var i = 0; i < newColumns.length; i++) {
                this.renderedColumns[i] = newColumns[i];
            }
            this.updateColumnOffset();
        };
        GridRenderContainer.prototype.updateColumnOffset = function updateColumnOffset() {
            var hiddenColumnsWidth = 0;
            for (var i = 0; i < this.currentFirstColumn; i++) {
                hiddenColumnsWidth += this.visibleColumnCache[i].drawnWidth;
            }
            this.columnOffset = hiddenColumnsWidth;
        };
        GridRenderContainer.prototype.scrollVertical = function(newScrollTop) {
            var vertScrollPercentage = -1;
            if (newScrollTop !== this.prevScrollTop) {
                var yDiff = newScrollTop - this.prevScrollTop;
                if (yDiff > 0) {
                    this.grid.scrollDirection = uiGridConstants.scrollDirection.DOWN;
                }
                if (yDiff < 0) {
                    this.grid.scrollDirection = uiGridConstants.scrollDirection.UP;
                }
                var vertScrollLength = this.getVerticalScrollLength();
                vertScrollPercentage = newScrollTop / vertScrollLength;
                if (vertScrollPercentage > 1) {
                    vertScrollPercentage = 1;
                }
                if (vertScrollPercentage < 0) {
                    vertScrollPercentage = 0;
                }
                this.adjustScrollVertical(newScrollTop, vertScrollPercentage);
                return vertScrollPercentage;
            }
        };
        GridRenderContainer.prototype.scrollHorizontal = function(newScrollLeft) {
            var horizScrollPercentage = -1;
            if (newScrollLeft !== this.prevScrollLeft) {
                var xDiff = newScrollLeft - this.prevScrollLeft;
                if (xDiff > 0) {
                    this.grid.scrollDirection = uiGridConstants.scrollDirection.RIGHT;
                }
                if (xDiff < 0) {
                    this.grid.scrollDirection = uiGridConstants.scrollDirection.LEFT;
                }
                var horizScrollLength = this.canvasWidth - this.getViewportWidth();
                if (horizScrollLength !== 0) {
                    horizScrollPercentage = newScrollLeft / horizScrollLength;
                } else {
                    horizScrollPercentage = 0;
                }
                this.adjustScrollHorizontal(newScrollLeft, horizScrollPercentage);
                return horizScrollPercentage;
            }
        };
        GridRenderContainer.prototype.adjustScrollVertical = function adjustScrollVertical(scrollTop, scrollPercentage, force) {
            if (this.prevScrollTop === scrollTop && !force) {
                return;
            }
            if (typeof scrollTop === "undefined" || scrollTop === undefined || scrollTop === null) {
                scrollTop = (this.getCanvasHeight() - this.getViewportHeight()) * scrollPercentage;
            }
            this.adjustRows(scrollTop, scrollPercentage, false);
            this.prevScrollTop = scrollTop;
            this.prevScrolltopPercentage = scrollPercentage;
            this.grid.queueRefresh();
        };
        GridRenderContainer.prototype.adjustScrollHorizontal = function adjustScrollHorizontal(scrollLeft, scrollPercentage, force) {
            if (this.prevScrollLeft === scrollLeft && !force) {
                return;
            }
            if (typeof scrollLeft === "undefined" || scrollLeft === undefined || scrollLeft === null) {
                scrollLeft = (this.getCanvasWidth() - this.getViewportWidth()) * scrollPercentage;
            }
            this.adjustColumns(scrollLeft, scrollPercentage);
            this.prevScrollLeft = scrollLeft;
            this.prevScrollleftPercentage = scrollPercentage;
            this.grid.queueRefresh();
        };
        GridRenderContainer.prototype.adjustRows = function adjustRows(scrollTop, scrollPercentage, postDataLoaded) {
            var self = this;
            var minRows = self.minRowsToRender();
            var rowCache = self.visibleRowCache;
            var maxRowIndex = rowCache.length - minRows;
            if ((typeof scrollPercentage === "undefined" || scrollPercentage === null) && scrollTop) {
                scrollPercentage = scrollTop / self.getVerticalScrollLength();
            }
            var rowIndex = Math.ceil(Math.min(maxRowIndex, maxRowIndex * scrollPercentage));
            if (rowIndex > maxRowIndex) {
                rowIndex = maxRowIndex;
            }
            var newRange = [];
            if (rowCache.length > self.grid.options.virtualizationThreshold) {
                if (!(typeof scrollTop === "undefined" || scrollTop === null)) {
                    if (!self.grid.suppressParentScrollDown && self.prevScrollTop < scrollTop && rowIndex < self.prevRowScrollIndex + self.grid.options.scrollThreshold && rowIndex < maxRowIndex) {
                        return;
                    }
                    if (!self.grid.suppressParentScrollUp && self.prevScrollTop > scrollTop && rowIndex > self.prevRowScrollIndex - self.grid.options.scrollThreshold && rowIndex < maxRowIndex) {
                        return;
                    }
                }
                var rangeStart = {};
                var rangeEnd = {};
                rangeStart = Math.max(0, rowIndex - self.grid.options.excessRows);
                rangeEnd = Math.min(rowCache.length, rowIndex + minRows + self.grid.options.excessRows);
                newRange = [ rangeStart, rangeEnd ];
            } else {
                var maxLen = self.visibleRowCache.length;
                newRange = [ 0, Math.max(maxLen, minRows + self.grid.options.excessRows) ];
            }
            self.updateViewableRowRange(newRange);
            self.prevRowScrollIndex = rowIndex;
        };
        GridRenderContainer.prototype.adjustColumns = function adjustColumns(scrollLeft, scrollPercentage) {
            var self = this;
            var minCols = self.minColumnsToRender();
            var columnCache = self.visibleColumnCache;
            var maxColumnIndex = columnCache.length - minCols;
            if ((typeof scrollPercentage === "undefined" || scrollPercentage === null) && scrollLeft) {
                var horizScrollLength = self.getCanvasWidth() - self.getViewportWidth();
                scrollPercentage = scrollLeft / horizScrollLength;
            }
            var colIndex = Math.ceil(Math.min(maxColumnIndex, maxColumnIndex * scrollPercentage));
            if (colIndex > maxColumnIndex) {
                colIndex = maxColumnIndex;
            }
            var newRange = [];
            if (columnCache.length > self.grid.options.columnVirtualizationThreshold && self.getCanvasWidth() > self.getViewportWidth()) {
                var rangeStart = Math.max(0, colIndex - self.grid.options.excessColumns);
                var rangeEnd = Math.min(columnCache.length, colIndex + minCols + self.grid.options.excessColumns);
                newRange = [ rangeStart, rangeEnd ];
            } else {
                var maxLen = self.visibleColumnCache.length;
                newRange = [ 0, Math.max(maxLen, minCols + self.grid.options.excessColumns) ];
            }
            self.updateViewableColumnRange(newRange);
            self.prevColumnScrollIndex = colIndex;
        };
        GridRenderContainer.prototype.updateViewableRowRange = function updateViewableRowRange(renderedRange) {
            var rowArr = this.visibleRowCache.slice(renderedRange[0], renderedRange[1]);
            this.currentTopRow = renderedRange[0];
            this.setRenderedRows(rowArr);
        };
        GridRenderContainer.prototype.updateViewableColumnRange = function updateViewableColumnRange(renderedRange) {
            var columnArr = this.visibleColumnCache.slice(renderedRange[0], renderedRange[1]);
            this.currentFirstColumn = renderedRange[0];
            this.setRenderedColumns(columnArr);
        };
        GridRenderContainer.prototype.headerCellWrapperStyle = function() {
            var self = this;
            if (self.currentFirstColumn !== 0) {
                var offset = self.columnOffset;
                if (self.grid.isRTL()) {
                    return {
                        "margin-right": offset + "px"
                    };
                } else {
                    return {
                        "margin-left": offset + "px"
                    };
                }
            }
            return null;
        };
        GridRenderContainer.prototype.updateColumnWidths = function() {
            var self = this;
            var asterisksArray = [], asteriskNum = 0, usedWidthSum = 0, ret = "";
            var availableWidth = self.grid.getViewportWidth() - self.grid.scrollbarWidth;
            var columnCache = [];
            angular.forEach(self.grid.renderContainers, function(container, name) {
                columnCache = columnCache.concat(container.visibleColumnCache);
            });
            columnCache.forEach(function(column, i) {
                var width = 0;
                if (!column.visible) {
                    return;
                }
                if (angular.isNumber(column.width)) {
                    width = parseInt(column.width, 10);
                    usedWidthSum = usedWidthSum + width;
                    column.drawnWidth = width;
                } else if (gridUtil.endsWith(column.width, "%")) {
                    width = parseInt(parseInt(column.width.replace(/%/g, ""), 10) / 100 * availableWidth);
                    if (width > column.maxWidth) {
                        width = column.maxWidth;
                    }
                    if (width < column.minWidth) {
                        width = column.minWidth;
                    }
                    usedWidthSum = usedWidthSum + width;
                    column.drawnWidth = width;
                } else if (angular.isString(column.width) && column.width.indexOf("*") !== -1) {
                    asteriskNum = asteriskNum + column.width.length;
                    asterisksArray.push(column);
                }
            });
            var remainingWidth = availableWidth - usedWidthSum;
            var i, column, colWidth;
            if (asterisksArray.length > 0) {
                var asteriskVal = remainingWidth / asteriskNum;
                asterisksArray.forEach(function(column) {
                    var width = parseInt(column.width.length * asteriskVal, 10);
                    if (width > column.maxWidth) {
                        width = column.maxWidth;
                    }
                    if (width < column.minWidth) {
                        width = column.minWidth;
                    }
                    usedWidthSum = usedWidthSum + width;
                    column.drawnWidth = width;
                });
            }
            var processColumnUpwards = function(column) {
                if (column.drawnWidth < column.maxWidth && leftoverWidth > 0) {
                    column.drawnWidth++;
                    usedWidthSum++;
                    leftoverWidth--;
                    columnsToChange = true;
                }
            };
            var leftoverWidth = availableWidth - usedWidthSum;
            var columnsToChange = true;
            while (leftoverWidth > 0 && columnsToChange) {
                columnsToChange = false;
                asterisksArray.forEach(processColumnUpwards);
            }
            var processColumnDownwards = function(column) {
                if (column.drawnWidth > column.minWidth && excessWidth > 0) {
                    column.drawnWidth--;
                    usedWidthSum--;
                    excessWidth--;
                    columnsToChange = true;
                }
            };
            var excessWidth = usedWidthSum - availableWidth;
            columnsToChange = true;
            while (excessWidth > 0 && columnsToChange) {
                columnsToChange = false;
                asterisksArray.forEach(processColumnDownwards);
            }
            var canvasWidth = 0;
            self.visibleColumnCache.forEach(function(column) {
                if (column.visible) {
                    canvasWidth = canvasWidth + column.drawnWidth;
                }
            });
            columnCache.forEach(function(column) {
                ret = ret + column.getColClassDefinition();
            });
            self.canvasWidth = canvasWidth;
            this.columnStyles = ret;
        };
        GridRenderContainer.prototype.needsHScrollbarPlaceholder = function() {
            return this.grid.options.enableHorizontalScrollbar && !this.hasHScrollbar && !this.grid.disableScrolling;
        };
        GridRenderContainer.prototype.getViewportStyle = function() {
            var self = this;
            var styles = {};
            self.hasHScrollbar = false;
            self.hasVScrollbar = false;
            if (self.grid.disableScrolling) {
                styles["overflow-x"] = "hidden";
                styles["overflow-y"] = "hidden";
                return styles;
            }
            if (self.name === "body") {
                self.hasHScrollbar = self.grid.options.enableHorizontalScrollbar !== uiGridConstants.scrollbars.NEVER;
                if (!self.grid.isRTL()) {
                    if (!self.grid.hasRightContainerColumns()) {
                        self.hasVScrollbar = self.grid.options.enableVerticalScrollbar !== uiGridConstants.scrollbars.NEVER;
                    }
                } else {
                    if (!self.grid.hasLeftContainerColumns()) {
                        self.hasVScrollbar = self.grid.options.enableVerticalScrollbar !== uiGridConstants.scrollbars.NEVER;
                    }
                }
            } else if (self.name === "left") {
                self.hasVScrollbar = self.grid.isRTL() ? self.grid.options.enableVerticalScrollbar !== uiGridConstants.scrollbars.NEVER : false;
            } else {
                self.hasVScrollbar = !self.grid.isRTL() ? self.grid.options.enableVerticalScrollbar !== uiGridConstants.scrollbars.NEVER : false;
            }
            styles["overflow-x"] = self.hasHScrollbar ? "scroll" : "hidden";
            styles["overflow-y"] = self.hasVScrollbar ? "scroll" : "hidden";
            return styles;
        };
        return GridRenderContainer;
    } ]);
})();

(function() {
    angular.module("ui.grid").factory("GridRow", [ "gridUtil", function(gridUtil) {
        function GridRow(entity, index, grid) {
            this.grid = grid;
            this.entity = entity;
            this.uid = gridUtil.nextUid();
            this.visible = true;
            this.$$height = grid.options.rowHeight;
        }
        Object.defineProperty(GridRow.prototype, "height", {
            "get": function() {
                return this.$$height;
            },
            "set": function(height) {
                if (height !== this.$$height) {
                    this.grid.updateCanvasHeight();
                    this.$$height = height;
                }
            }
        });
        GridRow.prototype.getQualifiedColField = function(col) {
            return "row." + this.getEntityQualifiedColField(col);
        };
        GridRow.prototype.getEntityQualifiedColField = function(col) {
            return gridUtil.preEval("entity." + col.field);
        };
        GridRow.prototype.setRowInvisible = function(row) {
            if (row && row.setThisRowInvisible) {
                row.setThisRowInvisible("user");
            }
        };
        GridRow.prototype.clearRowInvisible = function(row) {
            if (row && row.clearThisRowInvisible) {
                row.clearThisRowInvisible("user");
            }
        };
        GridRow.prototype.setThisRowInvisible = function(reason, fromRowsProcessor) {
            if (!this.invisibleReason) {
                this.invisibleReason = {};
            }
            this.invisibleReason[reason] = true;
            this.evaluateRowVisibility(fromRowsProcessor);
        };
        GridRow.prototype.clearThisRowInvisible = function(reason, fromRowsProcessor) {
            if (typeof this.invisibleReason !== "undefined") {
                delete this.invisibleReason[reason];
            }
            this.evaluateRowVisibility(fromRowsProcessor);
        };
        GridRow.prototype.evaluateRowVisibility = function(fromRowProcessor) {
            var newVisibility = true;
            if (typeof this.invisibleReason !== "undefined") {
                angular.forEach(this.invisibleReason, function(value, key) {
                    if (value) {
                        newVisibility = false;
                    }
                });
            }
            if (typeof this.visible === "undefined" || this.visible !== newVisibility) {
                this.visible = newVisibility;
                if (!fromRowProcessor) {
                    this.grid.queueGridRefresh();
                    this.grid.api.core.raise.rowsVisibleChanged(this);
                }
            }
        };
        return GridRow;
    } ]);
})();

(function() {
    "use strict";
    angular.module("ui.grid").factory("GridRowColumn", [ "$parse", "$filter", function GridRowColumnFactory($parse, $filter) {
        var GridRowColumn = function GridRowColumn(row, col) {
            if (!(this instanceof GridRowColumn)) {
                throw "Using GridRowColumn as a function insead of as a constructor. Must be called with `new` keyword";
            }
            this.row = row;
            this.col = col;
        };
        GridRowColumn.prototype.getIntersectionValueRaw = function() {
            var getter = $parse(this.row.getEntityQualifiedColField(this.col));
            var context = this.row;
            return getter(context);
        };
        GridRowColumn.prototype.getIntersectionValueFiltered = function() {
            var value = this.getIntersectionValueRaw();
            if (this.col.cellFilter && this.col.cellFilter !== "") {
                var getFilterIfExists = function(filterName) {
                    try {
                        return $filter(filterName);
                    } catch (e) {
                        return null;
                    }
                };
                var filter = getFilterIfExists(this.col.cellFilter);
                if (filter) {
                    value = filter(value);
                } else {
                    var re = /([^:]*):([^:]*):?([\s\S]+)?/;
                    var matches;
                    if ((matches = re.exec(this.col.cellFilter)) !== null) {
                        value = $filter(matches[1])(value, matches[2], matches[3]);
                    }
                }
            }
            return value;
        };
        return GridRowColumn;
    } ]);
})();

(function() {
    angular.module("ui.grid").factory("ScrollEvent", [ "gridUtil", function(gridUtil) {
        function ScrollEvent(grid, sourceRowContainer, sourceColContainer, source) {
            var self = this;
            if (!grid) {
                throw new Error("grid argument is required");
            }
            self.grid = grid;
            self.source = source;
            self.withDelay = true;
            self.sourceRowContainer = sourceRowContainer;
            self.sourceColContainer = sourceColContainer;
            self.newScrollLeft = null;
            self.newScrollTop = null;
            self.x = null;
            self.y = null;
            self.verticalScrollLength = -9999999;
            self.horizontalScrollLength = -999999;
            self.fireThrottledScrollingEvent = gridUtil.throttle(function(sourceContainerId) {
                self.grid.scrollContainers(sourceContainerId, self);
            }, self.grid.options.wheelScrollThrottle, {
                "trailing": true
            });
        }
        ScrollEvent.prototype.getNewScrollLeft = function(colContainer, viewport) {
            var self = this;
            if (!self.newScrollLeft) {
                var scrollWidth = colContainer.getCanvasWidth() - colContainer.getViewportWidth();
                var oldScrollLeft = gridUtil.normalizeScrollLeft(viewport, self.grid);
                var scrollXPercentage;
                if (typeof self.x.percentage !== "undefined" && self.x.percentage !== undefined) {
                    scrollXPercentage = self.x.percentage;
                } else if (typeof self.x.pixels !== "undefined" && self.x.pixels !== undefined) {
                    scrollXPercentage = self.x.percentage = (oldScrollLeft + self.x.pixels) / scrollWidth;
                } else {
                    throw new Error("No percentage or pixel value provided for scroll event X axis");
                }
                return Math.max(0, scrollXPercentage * scrollWidth);
            }
            return self.newScrollLeft;
        };
        ScrollEvent.prototype.getNewScrollTop = function(rowContainer, viewport) {
            var self = this;
            if (!self.newScrollTop) {
                var scrollLength = rowContainer.getVerticalScrollLength();
                var oldScrollTop = viewport[0].scrollTop;
                var scrollYPercentage;
                if (typeof self.y.percentage !== "undefined" && self.y.percentage !== undefined) {
                    scrollYPercentage = self.y.percentage;
                } else if (typeof self.y.pixels !== "undefined" && self.y.pixels !== undefined) {
                    scrollYPercentage = self.y.percentage = (oldScrollTop + self.y.pixels) / scrollLength;
                } else {
                    throw new Error("No percentage or pixel value provided for scroll event Y axis");
                }
                return Math.max(0, scrollYPercentage * scrollLength);
            }
            return self.newScrollTop;
        };
        ScrollEvent.prototype.atTop = function(scrollTop) {
            return this.y && (this.y.percentage === 0 || this.verticalScrollLength < 0) && scrollTop === 0;
        };
        ScrollEvent.prototype.atBottom = function(scrollTop) {
            return this.y && (this.y.percentage === 1 || this.verticalScrollLength === 0) && scrollTop > 0;
        };
        ScrollEvent.prototype.atLeft = function(scrollLeft) {
            return this.x && (this.x.percentage === 0 || this.horizontalScrollLength < 0) && scrollLeft === 0;
        };
        ScrollEvent.prototype.atRight = function(scrollLeft) {
            return this.x && (this.x.percentage === 1 || this.horizontalScrollLength === 0) && scrollLeft > 0;
        };
        ScrollEvent.Sources = {
            "ViewPortScroll": "ViewPortScroll",
            "RenderContainerMouseWheel": "RenderContainerMouseWheel",
            "RenderContainerTouchMove": "RenderContainerTouchMove",
            "Other": 99
        };
        return ScrollEvent;
    } ]);
})();

(function() {
    "use strict";
    angular.module("ui.grid").service("gridClassFactory", [ "gridUtil", "$q", "$compile", "$templateCache", "uiGridConstants", "Grid", "GridColumn", "GridRow", function(gridUtil, $q, $compile, $templateCache, uiGridConstants, Grid, GridColumn, GridRow) {
        var service = {
            "createGrid": function(options) {
                options = typeof options !== "undefined" ? options : {};
                options.id = gridUtil.newId();
                var grid = new Grid(options);
                if (grid.options.rowTemplate) {
                    var rowTemplateFnPromise = $q.defer();
                    grid.getRowTemplateFn = rowTemplateFnPromise.promise;
                    gridUtil.getTemplate(grid.options.rowTemplate).then(function(template) {
                        var rowTemplateFn = $compile(template);
                        rowTemplateFnPromise.resolve(rowTemplateFn);
                    }, function(res) {
                        throw new Error("Couldn't fetch/use row template '" + grid.options.rowTemplate + "'");
                    });
                }
                grid.registerColumnBuilder(service.defaultColumnBuilder);
                grid.registerRowBuilder(service.rowTemplateAssigner);
                grid.registerRowsProcessor(function allRowsVisible(rows) {
                    rows.forEach(function(row) {
                        row.evaluateRowVisibility(true);
                    }, 50);
                    return rows;
                });
                grid.registerColumnsProcessor(function allColumnsVisible(columns) {
                    columns.forEach(function(column) {
                        column.visible = true;
                    });
                    return columns;
                }, 50);
                grid.registerColumnsProcessor(function(renderableColumns) {
                    renderableColumns.forEach(function(column) {
                        if (column.colDef.visible === false) {
                            column.visible = false;
                        }
                    });
                    return renderableColumns;
                }, 50);
                grid.registerRowsProcessor(grid.searchRows, 100);
                if (grid.options.externalSort && angular.isFunction(grid.options.externalSort)) {
                    grid.registerRowsProcessor(grid.options.externalSort, 200);
                } else {
                    grid.registerRowsProcessor(grid.sortByColumn, 200);
                }
                return grid;
            },
            "defaultColumnBuilder": function(colDef, col, gridOptions) {
                var templateGetPromises = [];
                var processTemplate = function(templateType, providedType, defaultTemplate, filterType, tooltipType) {
                    if (!colDef[templateType]) {
                        col[providedType] = defaultTemplate;
                    } else {
                        col[providedType] = colDef[templateType];
                    }
                    templateGetPromises.push(gridUtil.getTemplate(col[providedType]).then(function(template) {
                        if (angular.isFunction(template)) {
                            template = template();
                        }
                        var tooltipCall = tooltipType === "cellTooltip" ? "col.cellTooltip(row,col)" : "col.headerTooltip(col)";
                        if (tooltipType && col[tooltipType] === false) {
                            template = template.replace(uiGridConstants.TOOLTIP, "");
                        } else if (tooltipType && col[tooltipType]) {
                            template = template.replace(uiGridConstants.TOOLTIP, 'title="{{' + tooltipCall + ' CUSTOM_FILTERS }}"');
                        }
                        if (filterType) {
                            col[templateType] = template.replace(uiGridConstants.CUSTOM_FILTERS, function() {
                                return col[filterType] ? "|" + col[filterType] : "";
                            });
                        } else {
                            col[templateType] = template;
                        }
                    }, function(res) {
                        throw new Error("Couldn't fetch/use colDef." + templateType + " '" + colDef[templateType] + "'");
                    }));
                };
                processTemplate("cellTemplate", "providedCellTemplate", "ui-grid/uiGridCell", "cellFilter", "cellTooltip");
                col.cellTemplatePromise = templateGetPromises[0];
                processTemplate("headerCellTemplate", "providedHeaderCellTemplate", "ui-grid/uiGridHeaderCell", "headerCellFilter", "headerTooltip");
                processTemplate("footerCellTemplate", "providedFooterCellTemplate", "ui-grid/uiGridFooterCell", "footerCellFilter");
                processTemplate("filterHeaderTemplate", "providedFilterHeaderTemplate", "ui-grid/ui-grid-filter");
                col.compiledElementFnDefer = $q.defer();
                return $q.all(templateGetPromises);
            },
            "rowTemplateAssigner": function rowTemplateAssigner(row) {
                var grid = this;
                if (!row.rowTemplate) {
                    row.rowTemplate = grid.options.rowTemplate;
                    row.getRowTemplateFn = grid.getRowTemplateFn;
                } else {
                    var perRowTemplateFnPromise = $q.defer();
                    row.getRowTemplateFn = perRowTemplateFnPromise.promise;
                    gridUtil.getTemplate(row.rowTemplate).then(function(template) {
                        var rowTemplateFn = $compile(template);
                        perRowTemplateFnPromise.resolve(rowTemplateFn);
                    }, function(res) {
                        throw new Error("Couldn't fetch/use row template '" + row.rowTemplate + "'");
                    });
                }
                return row.getRowTemplateFn;
            }
        };
        return service;
    } ]);
})();

(function() {
    var module = angular.module("ui.grid");
    function escapeRegExp(str) {
        return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
    }
    module.service("rowSearcher", [ "gridUtil", "uiGridConstants", function(gridUtil, uiGridConstants) {
        var defaultCondition = uiGridConstants.filter.CONTAINS;
        var rowSearcher = {};
        rowSearcher.getTerm = function getTerm(filter) {
            if (typeof filter.term === "undefined") {
                return filter.term;
            }
            var term = filter.term;
            if (typeof term === "string") {
                term = term.trim();
            }
            return term;
        };
        rowSearcher.stripTerm = function stripTerm(filter) {
            var term = rowSearcher.getTerm(filter);
            if (typeof term === "string") {
                return escapeRegExp(term.replace(/(^\*|\*$)/g, ""));
            } else {
                return term;
            }
        };
        rowSearcher.guessCondition = function guessCondition(filter) {
            if (typeof filter.term === "undefined" || !filter.term) {
                return defaultCondition;
            }
            var term = rowSearcher.getTerm(filter);
            if (/\*/.test(term)) {
                var regexpFlags = "";
                if (!filter.flags || !filter.flags.caseSensitive) {
                    regexpFlags += "i";
                }
                var reText = term.replace(/(\\)?\*/g, function($0, $1) {
                    return $1 ? $0 : "[\\s\\S]*?";
                });
                return new RegExp("^" + reText + "$", regexpFlags);
            } else {
                return defaultCondition;
            }
        };
        rowSearcher.setupFilters = function setupFilters(filters) {
            var newFilters = [];
            var filtersLength = filters.length;
            for (var i = 0; i < filtersLength; i++) {
                var filter = filters[i];
                if (filter.noTerm || !gridUtil.isNullOrUndefined(filter.term)) {
                    var newFilter = {};
                    var regexpFlags = "";
                    if (!filter.flags || !filter.flags.caseSensitive) {
                        regexpFlags += "i";
                    }
                    if (!gridUtil.isNullOrUndefined(filter.term)) {
                        newFilter.term = rowSearcher.stripTerm(filter);
                    }
                    if (filter.condition) {
                        newFilter.condition = filter.condition;
                    } else {
                        newFilter.condition = rowSearcher.guessCondition(filter);
                    }
                    newFilter.flags = angular.extend({
                        "caseSensitive": false,
                        "date": false
                    }, filter.flags);
                    if (newFilter.condition === uiGridConstants.filter.STARTS_WITH) {
                        newFilter.startswithRE = new RegExp("^" + newFilter.term, regexpFlags);
                    }
                    if (newFilter.condition === uiGridConstants.filter.ENDS_WITH) {
                        newFilter.endswithRE = new RegExp(newFilter.term + "$", regexpFlags);
                    }
                    if (newFilter.condition === uiGridConstants.filter.CONTAINS) {
                        newFilter.containsRE = new RegExp(newFilter.term, regexpFlags);
                    }
                    if (newFilter.condition === uiGridConstants.filter.EXACT) {
                        newFilter.exactRE = new RegExp("^" + newFilter.term + "$", regexpFlags);
                    }
                    newFilters.push(newFilter);
                }
            }
            return newFilters;
        };
        rowSearcher.runColumnFilter = function runColumnFilter(grid, row, column, filter) {
            var conditionType = typeof filter.condition;
            var term = filter.term;
            var value;
            if (column.filterCellFiltered) {
                value = grid.getCellDisplayValue(row, column);
            } else {
                value = grid.getCellValue(row, column);
            }
            if (filter.condition instanceof RegExp) {
                return filter.condition.test(value);
            }
            if (conditionType === "function") {
                return filter.condition(term, value, row, column);
            }
            if (filter.startswithRE) {
                return filter.startswithRE.test(value);
            }
            if (filter.endswithRE) {
                return filter.endswithRE.test(value);
            }
            if (filter.containsRE) {
                return filter.containsRE.test(value);
            }
            if (filter.exactRE) {
                return filter.exactRE.test(value);
            }
            if (filter.condition === uiGridConstants.filter.NOT_EQUAL) {
                var regex = new RegExp("^" + term + "$");
                return !regex.exec(value);
            }
            if (typeof value === "number" && typeof term === "string") {
                var tempFloat = parseFloat(term.replace(/\\\./, ".").replace(/\\\-/, "-"));
                if (!isNaN(tempFloat)) {
                    term = tempFloat;
                }
            }
            if (filter.flags.date === true) {
                value = new Date(value);
                term = new Date(term.replace(/\\/g, ""));
            }
            if (filter.condition === uiGridConstants.filter.GREATER_THAN) {
                return value > term;
            }
            if (filter.condition === uiGridConstants.filter.GREATER_THAN_OR_EQUAL) {
                return value >= term;
            }
            if (filter.condition === uiGridConstants.filter.LESS_THAN) {
                return value < term;
            }
            if (filter.condition === uiGridConstants.filter.LESS_THAN_OR_EQUAL) {
                return value <= term;
            }
            return true;
        };
        rowSearcher.searchColumn = function searchColumn(grid, row, column, filters) {
            if (grid.options.useExternalFiltering) {
                return true;
            }
            var filtersLength = filters.length;
            for (var i = 0; i < filtersLength; i++) {
                var filter = filters[i];
                var ret = rowSearcher.runColumnFilter(grid, row, column, filter);
                if (!ret) {
                    return false;
                }
            }
            return true;
        };
        rowSearcher.search = function search(grid, rows, columns) {
            if (!rows) {
                return;
            }
            if (!grid.options.enableFiltering) {
                return rows;
            }
            var filterData = [];
            var colsLength = columns.length;
            var hasTerm = function(filters) {
                var hasTerm = false;
                filters.forEach(function(filter) {
                    if (!gridUtil.isNullOrUndefined(filter.term) && filter.term !== "" || filter.noTerm) {
                        hasTerm = true;
                    }
                });
                return hasTerm;
            };
            for (var i = 0; i < colsLength; i++) {
                var col = columns[i];
                if (typeof col.filters !== "undefined" && hasTerm(col.filters)) {
                    filterData.push({
                        "col": col,
                        "filters": rowSearcher.setupFilters(col.filters)
                    });
                }
            }
            if (filterData.length > 0) {
                var foreachRow = function(grid, row, col, filters) {
                    if (row.visible && !rowSearcher.searchColumn(grid, row, col, filters)) {
                        row.visible = false;
                    }
                };
                var foreachFilterCol = function(grid, filterData) {
                    var rowsLength = rows.length;
                    for (var i = 0; i < rowsLength; i++) {
                        foreachRow(grid, rows[i], filterData.col, filterData.filters);
                    }
                };
                var filterDataLength = filterData.length;
                for (var j = 0; j < filterDataLength; j++) {
                    foreachFilterCol(grid, filterData[j]);
                }
                if (grid.api.core.raise.rowsVisibleChanged) {
                    grid.api.core.raise.rowsVisibleChanged();
                }
            }
            return rows;
        };
        return rowSearcher;
    } ]);
})();

(function() {
    var module = angular.module("ui.grid");
    module.service("rowSorter", [ "$parse", "uiGridConstants", function($parse, uiGridConstants) {
        var currencyRegexStr = "(" + uiGridConstants.CURRENCY_SYMBOLS.map(function(a) {
            return "\\" + a;
        }).join("|") + ")?";
        var numberStrRegex = new RegExp("^[-+]?" + currencyRegexStr + "[\\d,.]+" + currencyRegexStr + "%?$");
        var rowSorter = {
            "colSortFnCache": {}
        };
        rowSorter.guessSortFn = function guessSortFn(itemType) {
            switch (itemType) {
              case "number":
                return rowSorter.sortNumber;

              case "numberStr":
                return rowSorter.sortNumberStr;

              case "boolean":
                return rowSorter.sortBool;

              case "string":
                return rowSorter.sortAlpha;

              case "date":
                return rowSorter.sortDate;

              case "object":
                return rowSorter.basicSort;

              default:
                throw new Error("No sorting function found for type:" + itemType);
            }
        };
        rowSorter.handleNulls = function handleNulls(a, b) {
            if (!a && a !== 0 && a !== false || !b && b !== 0 && b !== false) {
                if (!a && a !== 0 && a !== false && (!b && b !== 0 && b !== false)) {
                    return 0;
                } else if (!a && a !== 0 && a !== false) {
                    return 1;
                } else if (!b && b !== 0 && b !== false) {
                    return -1;
                }
            }
            return null;
        };
        rowSorter.basicSort = function basicSort(a, b) {
            var nulls = rowSorter.handleNulls(a, b);
            if (nulls !== null) {
                return nulls;
            } else {
                if (a === b) {
                    return 0;
                }
                if (a < b) {
                    return -1;
                }
                return 1;
            }
        };
        rowSorter.sortNumber = function sortNumber(a, b) {
            var nulls = rowSorter.handleNulls(a, b);
            if (nulls !== null) {
                return nulls;
            } else {
                return a - b;
            }
        };
        rowSorter.sortNumberStr = function sortNumberStr(a, b) {
            var nulls = rowSorter.handleNulls(a, b);
            if (nulls !== null) {
                return nulls;
            } else {
                var numA, numB, badA = false, badB = false;
                numA = parseFloat(a.replace(/[^0-9.-]/g, ""));
                if (isNaN(numA)) {
                    badA = true;
                }
                numB = parseFloat(b.replace(/[^0-9.-]/g, ""));
                if (isNaN(numB)) {
                    badB = true;
                }
                if (badA && badB) {
                    return 0;
                }
                if (badA) {
                    return 1;
                }
                if (badB) {
                    return -1;
                }
                return numA - numB;
            }
        };
        rowSorter.sortAlpha = function sortAlpha(a, b) {
            var nulls = rowSorter.handleNulls(a, b);
            if (nulls !== null) {
                return nulls;
            } else {
                var strA = a.toString().toLowerCase(), strB = b.toString().toLowerCase();
                return strA === strB ? 0 : strA.localeCompare(strB);
            }
        };
        rowSorter.sortDate = function sortDate(a, b) {
            var nulls = rowSorter.handleNulls(a, b);
            if (nulls !== null) {
                return nulls;
            } else {
                if (!(a instanceof Date)) {
                    a = new Date(a);
                }
                if (!(b instanceof Date)) {
                    b = new Date(b);
                }
                var timeA = a.getTime(), timeB = b.getTime();
                return timeA === timeB ? 0 : timeA < timeB ? -1 : 1;
            }
        };
        rowSorter.sortBool = function sortBool(a, b) {
            var nulls = rowSorter.handleNulls(a, b);
            if (nulls !== null) {
                return nulls;
            } else {
                if (a && b) {
                    return 0;
                }
                if (!a && !b) {
                    return 0;
                } else {
                    return a ? 1 : -1;
                }
            }
        };
        rowSorter.getSortFn = function getSortFn(grid, col, rows) {
            var sortFn, item;
            if (rowSorter.colSortFnCache[col.colDef.name]) {
                sortFn = rowSorter.colSortFnCache[col.colDef.name];
            } else if (col.sortingAlgorithm !== undefined) {
                sortFn = col.sortingAlgorithm;
                rowSorter.colSortFnCache[col.colDef.name] = col.sortingAlgorithm;
            } else if (col.sortCellFiltered && col.cellFilter) {
                sortFn = rowSorter.sortAlpha;
                rowSorter.colSortFnCache[col.colDef.name] = sortFn;
            } else {
                sortFn = rowSorter.guessSortFn(col.colDef.type);
                if (sortFn) {
                    rowSorter.colSortFnCache[col.colDef.name] = sortFn;
                } else {
                    sortFn = rowSorter.sortAlpha;
                }
            }
            return sortFn;
        };
        rowSorter.prioritySort = function(a, b) {
            if (a.sort.priority !== undefined && b.sort.priority !== undefined) {
                if (a.sort.priority < b.sort.priority) {
                    return -1;
                } else if (a.sort.priority === b.sort.priority) {
                    return 0;
                } else {
                    return 1;
                }
            } else if (a.sort.priority || a.sort.priority === undefined) {
                return -1;
            } else if (b.sort.priority || b.sort.priority === undefined) {
                return 1;
            } else {
                return 0;
            }
        };
        rowSorter.sort = function rowSorterSort(grid, rows, columns) {
            if (!rows) {
                return;
            }
            if (grid.options.useExternalSorting) {
                return rows;
            }
            var sortCols = [];
            columns.forEach(function(col) {
                if (col.sort && !col.sort.ignoreSort && col.sort.direction && (col.sort.direction === uiGridConstants.ASC || col.sort.direction === uiGridConstants.DESC)) {
                    sortCols.push(col);
                }
            });
            sortCols = sortCols.sort(rowSorter.prioritySort);
            if (sortCols.length === 0) {
                return rows;
            }
            var col, direction;
            var setIndex = function(row, idx) {
                row.entity.$$uiGridIndex = idx;
            };
            rows.forEach(setIndex);
            var r = rows.slice(0);
            var rowSortFn = function(rowA, rowB) {
                var tem = 0, idx = 0, sortFn;
                while (tem === 0 && idx < sortCols.length) {
                    col = sortCols[idx];
                    direction = sortCols[idx].sort.direction;
                    sortFn = rowSorter.getSortFn(grid, col, r);
                    var propA, propB;
                    if (col.sortCellFiltered) {
                        propA = grid.getCellDisplayValue(rowA, col);
                        propB = grid.getCellDisplayValue(rowB, col);
                    } else {
                        propA = grid.getCellValue(rowA, col);
                        propB = grid.getCellValue(rowB, col);
                    }
                    tem = sortFn(propA, propB, rowA, rowB, direction);
                    idx++;
                }
                if (tem === 0) {
                    return rowA.entity.$$uiGridIndex - rowB.entity.$$uiGridIndex;
                }
                if (direction === uiGridConstants.ASC) {
                    return tem;
                } else {
                    return 0 - tem;
                }
            };
            var newRows = rows.sort(rowSortFn);
            var clearIndex = function(row, idx) {
                delete row.entity.$$uiGridIndex;
            };
            rows.forEach(clearIndex);
            return newRows;
        };
        return rowSorter;
    } ]);
})();

(function() {
    var module = angular.module("ui.grid");
    var bindPolyfill;
    if (typeof Function.prototype.bind !== "function") {
        bindPolyfill = function() {
            var slice = Array.prototype.slice;
            return function(context) {
                var fn = this, args = slice.call(arguments, 1);
                if (args.length) {
                    return function() {
                        return arguments.length ? fn.apply(context, args.concat(slice.call(arguments))) : fn.apply(context, args);
                    };
                }
                return function() {
                    return arguments.length ? fn.apply(context, arguments) : fn.call(context);
                };
            };
        };
    }
    function getStyles(elem) {
        var e = elem;
        if (typeof e.length !== "undefined" && e.length) {
            e = elem[0];
        }
        return e.ownerDocument.defaultView.getComputedStyle(e, null);
    }
    var rnumnonpx = new RegExp("^(" + /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source + ")(?!px)[a-z%]+$", "i"), rdisplayswap = /^(block|none|table(?!-c[ea]).+)/, cssShow = {
        "position": "absolute",
        "visibility": "hidden",
        "display": "block"
    };
    function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
        var i = extra === (isBorderBox ? "border" : "content") ? 4 : name === "width" ? 1 : 0, val = 0;
        var sides = [ "Top", "Right", "Bottom", "Left" ];
        for (;i < 4; i += 2) {
            var side = sides[i];
            if (extra === "margin") {
                var marg = parseFloat(styles[extra + side]);
                if (!isNaN(marg)) {
                    val += marg;
                }
            }
            if (isBorderBox) {
                if (extra === "content") {
                    var padd = parseFloat(styles["padding" + side]);
                    if (!isNaN(padd)) {
                        val -= padd;
                    }
                }
                if (extra !== "margin") {
                    var bordermarg = parseFloat(styles["border" + side + "Width"]);
                    if (!isNaN(bordermarg)) {
                        val -= bordermarg;
                    }
                }
            } else {
                var nocontentPad = parseFloat(styles["padding" + side]);
                if (!isNaN(nocontentPad)) {
                    val += nocontentPad;
                }
                if (extra !== "padding") {
                    var nocontentnopad = parseFloat(styles["border" + side + "Width"]);
                    if (!isNaN(nocontentnopad)) {
                        val += nocontentnopad;
                    }
                }
            }
        }
        return val;
    }
    function getWidthOrHeight(elem, name, extra) {
        var valueIsBorderBox = true, val, styles = getStyles(elem), isBorderBox = styles["boxSizing"] === "border-box";
        if (val <= 0 || val == null) {
            val = styles[name];
            if (val < 0 || val == null) {
                val = elem.style[name];
            }
            if (rnumnonpx.test(val)) {
                return val;
            }
            valueIsBorderBox = isBorderBox && (true || val === elem.style[name]);
            val = parseFloat(val) || 0;
        }
        var ret = val + augmentWidthOrHeight(elem, name, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox, styles);
        return ret;
    }
    function getLineHeight(elm) {
        elm = angular.element(elm)[0];
        var parent = elm.parentElement;
        if (!parent) {
            parent = document.getElementsByTagName("body")[0];
        }
        return parseInt(getStyles(parent).fontSize) || parseInt(getStyles(elm).fontSize) || 16;
    }
    var uid = [ "0", "0", "0", "0" ];
    var uidPrefix = "uiGrid-";
    module.service("gridUtil", [ "$log", "$window", "$document", "$http", "$templateCache", "$timeout", "$interval", "$injector", "$q", "$interpolate", "uiGridConstants", function($log, $window, $document, $http, $templateCache, $timeout, $interval, $injector, $q, $interpolate, uiGridConstants) {
        var s = {
            "augmentWidthOrHeight": augmentWidthOrHeight,
            "getStyles": getStyles,
            "createBoundedWrapper": function(object, method) {
                return function() {
                    return method.apply(object, arguments);
                };
            },
            "readableColumnName": function(columnName) {
                if (typeof columnName === "undefined" || columnName === undefined || columnName === null) {
                    return columnName;
                }
                if (typeof columnName !== "string") {
                    columnName = String(columnName);
                }
                return columnName.replace(/_+/g, " ").replace(/^[A-Z]+$/, function(match) {
                    return angular.lowercase(angular.uppercase(match.charAt(0)) + match.slice(1));
                }).replace(/([\w\u00C0-\u017F]+)/g, function(match) {
                    return angular.uppercase(match.charAt(0)) + match.slice(1);
                }).replace(/(\w+?(?=[A-Z]))/g, "$1 ");
            },
            "getColumnsFromData": function(data, excludeProperties) {
                var columnDefs = [];
                if (!data || typeof data[0] === "undefined" || data[0] === undefined) {
                    return [];
                }
                if (angular.isUndefined(excludeProperties)) {
                    excludeProperties = [];
                }
                var item = data[0];
                angular.forEach(item, function(prop, propName) {
                    if (excludeProperties.indexOf(propName) === -1) {
                        columnDefs.push({
                            "name": propName
                        });
                    }
                });
                return columnDefs;
            },
            "newId": function() {
                var seedId = new Date().getTime();
                return function() {
                    return seedId += 1;
                };
            }(),
            "getTemplate": function(template) {
                if ($templateCache.get(template)) {
                    return s.postProcessTemplate($templateCache.get(template));
                }
                if (template.hasOwnProperty("then")) {
                    return template.then(s.postProcessTemplate);
                }
                try {
                    if (angular.element(template).length > 0) {
                        return $q.when(template).then(s.postProcessTemplate);
                    }
                } catch (err) {}
                s.logDebug("fetching url", template);
                return $http({
                    "method": "GET",
                    "url": template
                }).then(function(result) {
                    var templateHtml = result.data.trim();
                    $templateCache.put(template, templateHtml);
                    return templateHtml;
                }, function(err) {
                    throw new Error("Could not get template " + template + ": " + err);
                }).then(s.postProcessTemplate);
            },
            "postProcessTemplate": function(template) {
                var startSym = $interpolate.startSymbol(), endSym = $interpolate.endSymbol();
                if (startSym !== "{{" || endSym !== "}}") {
                    template = template.replace(/\{\{/g, startSym);
                    template = template.replace(/\}\}/g, endSym);
                }
                return $q.when(template);
            },
            "guessType": function(item) {
                var itemType = typeof item;
                switch (itemType) {
                  case "number":
                  case "boolean":
                  case "string":
                    return itemType;

                  default:
                    if (angular.isDate(item)) {
                        return "date";
                    }
                    return "object";
                }
            },
            "elementWidth": function(elem) {},
            "elementHeight": function(elem) {},
            "getScrollbarWidth": function() {
                var outer = document.createElement("div");
                outer.style.visibility = "hidden";
                outer.style.width = "100px";
                outer.style.msOverflowStyle = "scrollbar";
                document.body.appendChild(outer);
                var widthNoScroll = outer.offsetWidth;
                outer.style.overflow = "scroll";
                var inner = document.createElement("div");
                inner.style.width = "100%";
                outer.appendChild(inner);
                var widthWithScroll = inner.offsetWidth;
                outer.parentNode.removeChild(outer);
                return widthNoScroll - widthWithScroll;
            },
            "swap": function(elem, options, callback, args) {
                var ret, name, old = {};
                for (name in options) {
                    old[name] = elem.style[name];
                    elem.style[name] = options[name];
                }
                ret = callback.apply(elem, args || []);
                for (name in options) {
                    elem.style[name] = old[name];
                }
                return ret;
            },
            "fakeElement": function(elem, options, callback, args) {
                var ret, name, newElement = angular.element(elem).clone()[0];
                for (name in options) {
                    newElement.style[name] = options[name];
                }
                angular.element(document.body).append(newElement);
                ret = callback.call(newElement, newElement);
                angular.element(newElement).remove();
                return ret;
            },
            "normalizeWheelEvent": function(event) {
                var lowestDelta, lowestDeltaXY;
                var orgEvent = event || window.event, args = [].slice.call(arguments, 1), delta = 0, deltaX = 0, deltaY = 0, absDelta = 0, absDeltaXY = 0, fn;
                if (orgEvent.originalEvent) {
                    orgEvent = orgEvent.originalEvent;
                }
                if (orgEvent.wheelDelta) {
                    delta = orgEvent.wheelDelta;
                }
                if (orgEvent.detail) {
                    delta = orgEvent.detail * -1;
                }
                deltaY = delta;
                if (orgEvent.axis !== undefined && orgEvent.axis === orgEvent.HORIZONTAL_AXIS) {
                    deltaY = 0;
                    deltaX = delta * -1;
                }
                if (orgEvent.deltaY) {
                    deltaY = orgEvent.deltaY * -1;
                    delta = deltaY;
                }
                if (orgEvent.deltaX) {
                    deltaX = orgEvent.deltaX;
                    delta = deltaX * -1;
                }
                if (orgEvent.wheelDeltaY !== undefined) {
                    deltaY = orgEvent.wheelDeltaY;
                }
                if (orgEvent.wheelDeltaX !== undefined) {
                    deltaX = orgEvent.wheelDeltaX;
                }
                absDelta = Math.abs(delta);
                if (!lowestDelta || absDelta < lowestDelta) {
                    lowestDelta = absDelta;
                }
                absDeltaXY = Math.max(Math.abs(deltaY), Math.abs(deltaX));
                if (!lowestDeltaXY || absDeltaXY < lowestDeltaXY) {
                    lowestDeltaXY = absDeltaXY;
                }
                fn = delta > 0 ? "floor" : "ceil";
                delta = Math[fn](delta / lowestDelta);
                deltaX = Math[fn](deltaX / lowestDeltaXY);
                deltaY = Math[fn](deltaY / lowestDeltaXY);
                return {
                    "delta": delta,
                    "deltaX": deltaX,
                    "deltaY": deltaY
                };
            },
            "isTouchEnabled": function() {
                var bool;
                if ("ontouchstart" in $window || $window.DocumentTouch && $document instanceof DocumentTouch) {
                    bool = true;
                }
                return bool;
            },
            "isNullOrUndefined": function(obj) {
                if (obj === undefined || obj === null) {
                    return true;
                }
                return false;
            },
            "endsWith": function(str, suffix) {
                if (!str || !suffix || typeof str !== "string") {
                    return false;
                }
                return str.indexOf(suffix, str.length - suffix.length) !== -1;
            },
            "arrayContainsObjectWithProperty": function(array, propertyName, propertyValue) {
                var found = false;
                angular.forEach(array, function(object) {
                    if (object[propertyName] === propertyValue) {
                        found = true;
                    }
                });
                return found;
            },
            "numericAndNullSort": function(a, b) {
                if (a === null) {
                    return 1;
                }
                if (b === null) {
                    return -1;
                }
                if (a === null && b === null) {
                    return 0;
                }
                return a - b;
            },
            "disableAnimations": function(element) {
                var $animate;
                try {
                    $animate = $injector.get("$animate");
                    if (angular.version.major > 1 || angular.version.major === 1 && angular.version.minor >= 4) {
                        $animate.enabled(element, false);
                    } else {
                        $animate.enabled(false, element);
                    }
                } catch (e) {}
            },
            "enableAnimations": function(element) {
                var $animate;
                try {
                    $animate = $injector.get("$animate");
                    if (angular.version.major > 1 || angular.version.major === 1 && angular.version.minor >= 4) {
                        $animate.enabled(element, true);
                    } else {
                        $animate.enabled(true, element);
                    }
                    return $animate;
                } catch (e) {}
            },
            "nextUid": function nextUid() {
                var index = uid.length;
                var digit;
                while (index) {
                    index--;
                    digit = uid[index].charCodeAt(0);
                    if (digit === 57) {
                        uid[index] = "A";
                        return uidPrefix + uid.join("");
                    }
                    if (digit === 90) {
                        uid[index] = "0";
                    } else {
                        uid[index] = String.fromCharCode(digit + 1);
                        return uidPrefix + uid.join("");
                    }
                }
                uid.unshift("0");
                return uidPrefix + uid.join("");
            },
            "hashKey": function hashKey(obj) {
                var objType = typeof obj, key;
                if (objType === "object" && obj !== null) {
                    if (typeof (key = obj.$$hashKey) === "function") {
                        key = obj.$$hashKey();
                    } else if (typeof obj.$$hashKey !== "undefined" && obj.$$hashKey) {
                        key = obj.$$hashKey;
                    } else if (key === undefined) {
                        key = obj.$$hashKey = s.nextUid();
                    }
                } else {
                    key = obj;
                }
                return objType + ":" + key;
            },
            "resetUids": function() {
                uid = [ "0", "0", "0" ];
            },
            "logError": function(logMessage) {
                if (uiGridConstants.LOG_ERROR_MESSAGES) {
                    $log.error(logMessage);
                }
            },
            "logWarn": function(logMessage) {
                if (uiGridConstants.LOG_WARN_MESSAGES) {
                    $log.warn(logMessage);
                }
            },
            "logDebug": function() {
                if (uiGridConstants.LOG_DEBUG_MESSAGES) {
                    $log.debug.apply($log, arguments);
                }
            }
        };
        s.focus = {
            "queue": [],
            "byId": function(id, Grid) {
                this._purgeQueue();
                var promise = $timeout(function() {
                    var elementID = (Grid && Grid.id ? Grid.id + "-" : "") + id;
                    var element = $window.document.getElementById(elementID);
                    if (element) {
                        element.focus();
                    } else {
                        s.logWarn("[focus.byId] Element id " + elementID + " was not found.");
                    }
                });
                this.queue.push(promise);
                return promise;
            },
            "byElement": function(element) {
                if (!angular.isElement(element)) {
                    s.logWarn("Trying to focus on an element that isn't an element.");
                    return $q.reject("not-element");
                }
                element = angular.element(element);
                this._purgeQueue();
                var promise = $timeout(function() {
                    if (element) {
                        element[0].focus();
                    }
                });
                this.queue.push(promise);
                return promise;
            },
            "bySelector": function(parentElement, querySelector, aSync) {
                var self = this;
                if (!angular.isElement(parentElement)) {
                    throw new Error("The parent element is not an element.");
                }
                parentElement = angular.element(parentElement);
                var focusBySelector = function() {
                    var element = parentElement[0].querySelector(querySelector);
                    return self.byElement(element);
                };
                this._purgeQueue();
                if (aSync) {
                    var promise = $timeout(focusBySelector);
                    this.queue.push($timeout(focusBySelector));
                    return promise;
                } else {
                    return focusBySelector();
                }
            },
            "_purgeQueue": function() {
                this.queue.forEach(function(element) {
                    $timeout.cancel(element);
                });
                this.queue = [];
            }
        };
        [ "width", "height" ].forEach(function(name) {
            var capsName = angular.uppercase(name.charAt(0)) + name.substr(1);
            s["element" + capsName] = function(elem, extra) {
                var e = elem;
                if (e && typeof e.length !== "undefined" && e.length) {
                    e = elem[0];
                }
                if (e) {
                    var styles = getStyles(e);
                    return e.offsetWidth === 0 && rdisplayswap.test(styles.display) ? s.swap(e, cssShow, function() {
                        return getWidthOrHeight(e, name, extra);
                    }) : getWidthOrHeight(e, name, extra);
                } else {
                    return null;
                }
            };
            s["outerElement" + capsName] = function(elem, margin) {
                return elem ? s["element" + capsName].call(this, elem, margin ? "margin" : "border") : null;
            };
        });
        s.closestElm = function closestElm(el, selector) {
            if (typeof el.length !== "undefined" && el.length) {
                el = el[0];
            }
            var matchesFn;
            [ "matches", "webkitMatchesSelector", "mozMatchesSelector", "msMatchesSelector", "oMatchesSelector" ].some(function(fn) {
                if (typeof document.body[fn] === "function") {
                    matchesFn = fn;
                    return true;
                }
                return false;
            });
            var parent;
            while (el !== null) {
                parent = el.parentElement;
                if (parent !== null && parent[matchesFn](selector)) {
                    return parent;
                }
                el = parent;
            }
            return null;
        };
        s.type = function(obj) {
            var text = Function.prototype.toString.call(obj.constructor);
            return text.match(/function (.*?)\(/)[1];
        };
        s.getBorderSize = function getBorderSize(elem, borderType) {
            if (typeof elem.length !== "undefined" && elem.length) {
                elem = elem[0];
            }
            var styles = getStyles(elem);
            if (borderType) {
                borderType = "border" + borderType.charAt(0).toUpperCase() + borderType.slice(1);
            } else {
                borderType = "border";
            }
            borderType += "Width";
            var val = parseInt(styles[borderType], 10);
            if (isNaN(val)) {
                return 0;
            } else {
                return val;
            }
        };
        s.detectBrowser = function detectBrowser() {
            var userAgent = $window.navigator.userAgent;
            var browsers = {
                "chrome": /chrome/i,
                "safari": /safari/i,
                "firefox": /firefox/i,
                "ie": /internet explorer|trident\//i
            };
            for (var key in browsers) {
                if (browsers[key].test(userAgent)) {
                    return key;
                }
            }
            return "unknown";
        };
        s.rtlScrollType = function rtlScrollType() {
            if (rtlScrollType.type) {
                return rtlScrollType.type;
            }
            var definer = angular.element('<div dir="rtl" style="font-size: 14px; width: 1px; height: 1px; position: absolute; top: -1000px; overflow: scroll">A</div>')[0], type = "reverse";
            document.body.appendChild(definer);
            if (definer.scrollLeft > 0) {
                type = "default";
            } else {
                definer.scrollLeft = 1;
                if (definer.scrollLeft === 0) {
                    type = "negative";
                }
            }
            angular.element(definer).remove();
            rtlScrollType.type = type;
            return type;
        };
        s.normalizeScrollLeft = function normalizeScrollLeft(element, grid) {
            if (typeof element.length !== "undefined" && element.length) {
                element = element[0];
            }
            var scrollLeft = element.scrollLeft;
            if (grid.isRTL()) {
                switch (s.rtlScrollType()) {
                  case "default":
                    return element.scrollWidth - scrollLeft - element.clientWidth;

                  case "negative":
                    return Math.abs(scrollLeft);

                  case "reverse":
                    return scrollLeft;
                }
            }
            return scrollLeft;
        };
        s.denormalizeScrollLeft = function denormalizeScrollLeft(element, scrollLeft, grid) {
            if (typeof element.length !== "undefined" && element.length) {
                element = element[0];
            }
            if (grid.isRTL()) {
                switch (s.rtlScrollType()) {
                  case "default":
                    var maxScrollLeft = element.scrollWidth - element.clientWidth;
                    return maxScrollLeft - scrollLeft;

                  case "negative":
                    return scrollLeft * -1;

                  case "reverse":
                    return scrollLeft;
                }
            }
            return scrollLeft;
        };
        s.preEval = function(path) {
            var m = uiGridConstants.BRACKET_REGEXP.exec(path);
            if (m) {
                return (m[1] ? s.preEval(m[1]) : m[1]) + m[2] + (m[3] ? s.preEval(m[3]) : m[3]);
            } else {
                path = path.replace(uiGridConstants.APOS_REGEXP, "\\'");
                var parts = path.split(uiGridConstants.DOT_REGEXP);
                var preparsed = [ parts.shift() ];
                angular.forEach(parts, function(part) {
                    preparsed.push(part.replace(uiGridConstants.FUNC_REGEXP, "']$1"));
                });
                return preparsed.join("['");
            }
        };
        s.debounce = function(func, wait, immediate) {
            var timeout, args, context, result;
            function debounce() {
                context = this;
                args = arguments;
                var later = function() {
                    timeout = null;
                    if (!immediate) {
                        result = func.apply(context, args);
                    }
                };
                var callNow = immediate && !timeout;
                if (timeout) {
                    $timeout.cancel(timeout);
                }
                timeout = $timeout(later, wait, false);
                if (callNow) {
                    result = func.apply(context, args);
                }
                return result;
            }
            debounce.cancel = function() {
                $timeout.cancel(timeout);
                timeout = null;
            };
            return debounce;
        };
        s.throttle = function(func, wait, options) {
            options = options || {};
            var lastCall = 0, queued = null, context, args;
            function runFunc(endDate) {
                lastCall = +new Date();
                func.apply(context, args);
                $interval(function() {
                    queued = null;
                }, 0, 1, false);
            }
            return function() {
                context = this;
                args = arguments;
                if (queued === null) {
                    var sinceLast = +new Date() - lastCall;
                    if (sinceLast > wait) {
                        runFunc();
                    } else if (options.trailing) {
                        queued = $interval(runFunc, wait - sinceLast, 1, false);
                    }
                }
            };
        };
        s.on = {};
        s.off = {};
        s._events = {};
        s.addOff = function(eventName) {
            s.off[eventName] = function(elm, fn) {
                var idx = s._events[eventName].indexOf(fn);
                if (idx > 0) {
                    s._events[eventName].removeAt(idx);
                }
            };
        };
        var mouseWheeltoBind = "onwheel" in document || document.documentMode >= 9 ? [ "wheel" ] : [ "mousewheel", "DomMouseScroll", "MozMousePixelScroll" ], nullLowestDeltaTimeout, lowestDelta;
        s.on.mousewheel = function(elm, fn) {
            if (!elm || !fn) {
                return;
            }
            var $elm = angular.element(elm);
            $elm.data("mousewheel-line-height", getLineHeight($elm));
            $elm.data("mousewheel-page-height", s.elementHeight($elm));
            if (!$elm.data("mousewheel-callbacks")) {
                $elm.data("mousewheel-callbacks", {});
            }
            var cbs = $elm.data("mousewheel-callbacks");
            cbs[fn] = (Function.prototype.bind || bindPolyfill).call(mousewheelHandler, $elm[0], fn);
            for (var i = mouseWheeltoBind.length; i; ) {
                $elm.on(mouseWheeltoBind[--i], cbs[fn]);
            }
        };
        s.off.mousewheel = function(elm, fn) {
            var $elm = angular.element(elm);
            var cbs = $elm.data("mousewheel-callbacks");
            var handler = cbs[fn];
            if (handler) {
                for (var i = mouseWheeltoBind.length; i; ) {
                    $elm.off(mouseWheeltoBind[--i], handler);
                }
            }
            delete cbs[fn];
            if (Object.keys(cbs).length === 0) {
                $elm.removeData("mousewheel-line-height");
                $elm.removeData("mousewheel-page-height");
                $elm.removeData("mousewheel-callbacks");
            }
        };
        function mousewheelHandler(fn, event) {
            var $elm = angular.element(this);
            var delta = 0, deltaX = 0, deltaY = 0, absDelta = 0, offsetX = 0, offsetY = 0;
            if (event.originalEvent) {
                event = event.originalEvent;
            }
            if ("detail" in event) {
                deltaY = event.detail * -1;
            }
            if ("wheelDelta" in event) {
                deltaY = event.wheelDelta;
            }
            if ("wheelDeltaY" in event) {
                deltaY = event.wheelDeltaY;
            }
            if ("wheelDeltaX" in event) {
                deltaX = event.wheelDeltaX * -1;
            }
            if ("axis" in event && event.axis === event.HORIZONTAL_AXIS) {
                deltaX = deltaY * -1;
                deltaY = 0;
            }
            delta = deltaY === 0 ? deltaX : deltaY;
            if ("deltaY" in event) {
                deltaY = event.deltaY * -1;
                delta = deltaY;
            }
            if ("deltaX" in event) {
                deltaX = event.deltaX;
                if (deltaY === 0) {
                    delta = deltaX * -1;
                }
            }
            if (deltaY === 0 && deltaX === 0) {
                return;
            }
            if (event.deltaMode === 1) {
                var lineHeight = $elm.data("mousewheel-line-height");
                delta *= lineHeight;
                deltaY *= lineHeight;
                deltaX *= lineHeight;
            } else if (event.deltaMode === 2) {
                var pageHeight = $elm.data("mousewheel-page-height");
                delta *= pageHeight;
                deltaY *= pageHeight;
                deltaX *= pageHeight;
            }
            absDelta = Math.max(Math.abs(deltaY), Math.abs(deltaX));
            if (!lowestDelta || absDelta < lowestDelta) {
                lowestDelta = absDelta;
                if (shouldAdjustOldDeltas(event, absDelta)) {
                    lowestDelta /= 40;
                }
            }
            delta = Math[delta >= 1 ? "floor" : "ceil"](delta / lowestDelta);
            deltaX = Math[deltaX >= 1 ? "floor" : "ceil"](deltaX / lowestDelta);
            deltaY = Math[deltaY >= 1 ? "floor" : "ceil"](deltaY / lowestDelta);
            event.deltaMode = 0;
            var newEvent = {
                "originalEvent": event,
                "deltaX": deltaX,
                "deltaY": deltaY,
                "deltaFactor": lowestDelta,
                "preventDefault": function() {
                    event.preventDefault();
                },
                "stopPropagation": function() {
                    event.stopPropagation();
                }
            };
            if (nullLowestDeltaTimeout) {
                clearTimeout(nullLowestDeltaTimeout);
            }
            nullLowestDeltaTimeout = setTimeout(nullLowestDelta, 200);
            fn.call($elm[0], newEvent);
        }
        function nullLowestDelta() {
            lowestDelta = null;
        }
        function shouldAdjustOldDeltas(orgEvent, absDelta) {
            return orgEvent.type === "mousewheel" && absDelta % 120 === 0;
        }
        return s;
    } ]);
    module.filter("px", function() {
        return function(str) {
            if (str.match(/^[\d\.]+$/)) {
                return str + "px";
            } else {
                return str;
            }
        };
    });
})();

(function() {
    angular.module("ui.grid").config([ "$provide", function($provide) {
        $provide.decorator("i18nService", [ "$delegate", function($delegate) {
            var lang = {
                "aggregate": {
                    "label": "polo\u017eky"
                },
                "groupPanel": {
                    "description": "P\u0159esu\u0148te z\xe1hlav\xed zde pro vytvo\u0159en\xed skupiny dle sloupce."
                },
                "search": {
                    "placeholder": "Hledat...",
                    "showingItems": "Zobrazuji polo\u017eky:",
                    "selectedItems": "Vybran\xe9 polo\u017eky:",
                    "totalItems": "Celkem polo\u017eek:",
                    "size": "Velikost strany:",
                    "first": "Prvn\xed strana",
                    "next": "Dal\u0161\xed strana",
                    "previous": "P\u0159edchoz\xed strana",
                    "last": "Posledn\xed strana"
                },
                "menu": {
                    "text": "Vyberte sloupec:"
                },
                "sort": {
                    "ascending": "Se\u0159adit od A-Z",
                    "descending": "Se\u0159adit od Z-A",
                    "remove": "Odebrat se\u0159azen\xed"
                },
                "column": {
                    "hide": "Schovat sloupec"
                },
                "aggregation": {
                    "count": "celkem \u0159\xe1dk\u016f: ",
                    "sum": "celkem: ",
                    "avg": "avg: ",
                    "min": "min.: ",
                    "max": "max.: "
                },
                "pinning": {
                    "pinLeft": "Zamknout vlevo",
                    "pinRight": "Zamknout vpravo",
                    "unpin": "Odemknout"
                },
                "gridMenu": {
                    "columns": "Sloupce:",
                    "importerTitle": "Importovat soubor",
                    "exporterAllAsCsv": "Exportovat v\u0161echna data do csv",
                    "exporterVisibleAsCsv": "Exportovat viditeln\xe1 data do csv",
                    "exporterSelectedAsCsv": "Exportovat vybran\xe1 data do csv",
                    "exporterAllAsPdf": "Exportovat v\u0161echna data do pdf",
                    "exporterVisibleAsPdf": "Exportovat viditeln\xe1 data do pdf",
                    "exporterSelectedAsPdf": "Exportovat vybran\xe1 data do pdf",
                    "clearAllFilters": "Odstranit v\u0161echny filtry"
                },
                "importer": {
                    "noHeaders": "N\xe1zvy sloupc\u016f se nepoda\u0159ilo z\xedskat, obsahuje soubor z\xe1hlav\xed?",
                    "noObjects": "Data se nepoda\u0159ilo zpracovat, obsahuje soubor \u0159\xe1dky mimo z\xe1hlav\xed?",
                    "invalidCsv": "Soubor nelze zpracovat, jedn\xe1 se o CSV?",
                    "invalidJson": "Soubor nelze zpracovat, je to JSON?",
                    "jsonNotArray": "Soubor mus\xed obsahovat json. Ukon\u010duji.."
                },
                "pagination": {
                    "sizes": "polo\u017eek na str\xe1nku",
                    "totalItems": "polo\u017eek"
                },
                "grouping": {
                    "group": "Seskupit",
                    "ungroup": "Odebrat seskupen\xed",
                    "aggregate_count": "Agregace: Count",
                    "aggregate_sum": "Agregace: Sum",
                    "aggregate_max": "Agregace: Max",
                    "aggregate_min": "Agregace: Min",
                    "aggregate_avg": "Agregace: Avg",
                    "aggregate_remove": "Agregace: Odebrat"
                }
            };
            $delegate.add("cs", lang);
            $delegate.add("cz", lang);
            $delegate.add("cs-cz", lang);
            $delegate.add("cs-CZ", lang);
            return $delegate;
        } ]);
    } ]);
})();

(function() {
    angular.module("ui.grid").config([ "$provide", function($provide) {
        $provide.decorator("i18nService", [ "$delegate", function($delegate) {
            $delegate.add("da", {
                "aggregate": {
                    "label": "artikler"
                },
                "groupPanel": {
                    "description": "Grup\xe9r r\xe6kker udfra en kolonne ved at tr\xe6kke dens overskift hertil."
                },
                "search": {
                    "placeholder": "S\xf8g...",
                    "showingItems": "Viste r\xe6kker:",
                    "selectedItems": "Valgte r\xe6kker:",
                    "totalItems": "R\xe6kker totalt:",
                    "size": "Side st\xf8rrelse:",
                    "first": "F\xf8rste side",
                    "next": "N\xe6ste side",
                    "previous": "Forrige side",
                    "last": "Sidste side"
                },
                "menu": {
                    "text": "V\xe6lg kolonner:"
                },
                "sort": {
                    "ascending": "Sorter stigende",
                    "descending": "Sorter faldende",
                    "none": "Sorter ingen",
                    "remove": "Fjern sortering"
                },
                "column": {
                    "hide": "Skjul kolonne"
                },
                "aggregation": {
                    "count": "antal r\xe6kker: ",
                    "sum": "sum: ",
                    "avg": "gns: ",
                    "min": "min: ",
                    "max": "max: "
                },
                "gridMenu": {
                    "columns": "Columns:",
                    "importerTitle": "Import file",
                    "exporterAllAsCsv": "Export all data as csv",
                    "exporterVisibleAsCsv": "Export visible data as csv",
                    "exporterSelectedAsCsv": "Export selected data as csv",
                    "exporterAllAsPdf": "Export all data as pdf",
                    "exporterVisibleAsPdf": "Export visible data as pdf",
                    "exporterSelectedAsPdf": "Export selected data as pdf",
                    "clearAllFilters": "Clear all filters"
                },
                "importer": {
                    "noHeaders": "Column names were unable to be derived, does the file have a header?",
                    "noObjects": "Objects were not able to be derived, was there data in the file other than headers?",
                    "invalidCsv": "File was unable to be processed, is it valid CSV?",
                    "invalidJson": "File was unable to be processed, is it valid Json?",
                    "jsonNotArray": "Imported json file must contain an array, aborting."
                }
            });
            return $delegate;
        } ]);
    } ]);
})();

(function() {
    angular.module("ui.grid").config([ "$provide", function($provide) {
        $provide.decorator("i18nService", [ "$delegate", function($delegate) {
            $delegate.add("de", {
                "headerCell": {
                    "aria": {
                        "defaultFilterLabel": "Filter f\xfcr Spalte",
                        "removeFilter": "Filter l\xf6schen",
                        "columnMenuButtonLabel": "Spaltenmen\xfc"
                    },
                    "priority": "Priorit\xe4t:",
                    "filterLabel": "Filter f\xfcr Spalte: "
                },
                "aggregate": {
                    "label": "Eintrag"
                },
                "groupPanel": {
                    "description": "Ziehen Sie eine Spalten\xfcberschrift hierhin, um nach dieser Spalte zu gruppieren."
                },
                "search": {
                    "placeholder": "Suche...",
                    "showingItems": "Zeige Eintr\xe4ge:",
                    "selectedItems": "Ausgew\xe4hlte Eintr\xe4ge:",
                    "totalItems": "Eintr\xe4ge gesamt:",
                    "size": "Eintr\xe4ge pro Seite:",
                    "first": "Erste Seite",
                    "next": "N\xe4chste Seite",
                    "previous": "Vorherige Seite",
                    "last": "Letzte Seite"
                },
                "menu": {
                    "text": "Spalten ausw\xe4hlen:"
                },
                "sort": {
                    "ascending": "aufsteigend sortieren",
                    "descending": "absteigend sortieren",
                    "none": "keine Sortierung",
                    "remove": "Sortierung zur\xfccksetzen"
                },
                "column": {
                    "hide": "Spalte ausblenden"
                },
                "aggregation": {
                    "count": "Zeilen insgesamt: ",
                    "sum": "gesamt: ",
                    "avg": "Durchschnitt: ",
                    "min": "min: ",
                    "max": "max: "
                },
                "pinning": {
                    "pinLeft": "Links anheften",
                    "pinRight": "Rechts anheften",
                    "unpin": "L\xf6sen"
                },
                "columnMenu": {
                    "close": "Schlie\xdfen"
                },
                "gridMenu": {
                    "aria": {
                        "buttonLabel": "Tabellenmen\xfc"
                    },
                    "columns": "Spalten:",
                    "importerTitle": "Datei importieren",
                    "exporterAllAsCsv": "Alle Daten als CSV exportieren",
                    "exporterVisibleAsCsv": "sichtbare Daten als CSV exportieren",
                    "exporterSelectedAsCsv": "markierte Daten als CSV exportieren",
                    "exporterAllAsPdf": "Alle Daten als PDF exportieren",
                    "exporterVisibleAsPdf": "sichtbare Daten als PDF exportieren",
                    "exporterSelectedAsPdf": "markierte Daten als CSV exportieren",
                    "clearAllFilters": "Alle Filter zur\xfccksetzen"
                },
                "importer": {
                    "noHeaders": "Es konnten keine Spaltennamen ermittelt werden. Sind in der Datei Spaltendefinitionen enthalten?",
                    "noObjects": "Es konnten keine Zeileninformationen gelesen werden, Sind in der Datei au\xdfer den Spaltendefinitionen auch Daten enthalten?",
                    "invalidCsv": "Die Datei konnte nicht eingelesen werden, ist es eine g\xfcltige CSV-Datei?",
                    "invalidJson": "Die Datei konnte nicht eingelesen werden. Enth\xe4lt sie g\xfcltiges JSON?",
                    "jsonNotArray": "Die importierte JSON-Datei mu\xdf ein Array enthalten. Breche Import ab."
                },
                "pagination": {
                    "aria": {
                        "pageToFirst": "Zum Anfang",
                        "pageBack": "Seite zur\xfcck",
                        "pageSelected": "Ausgw\xe4hlte Seite",
                        "pageForward": "Seite vor",
                        "pageToLast": "Zum Ende"
                    },
                    "sizes": "Eintr\xe4ge pro Seite",
                    "totalItems": "Eintr\xe4ge",
                    "through": "bis",
                    "of": "von"
                },
                "grouping": {
                    "group": "Gruppieren",
                    "ungroup": "Gruppierung aufheben",
                    "aggregate_count": "Agg: Anzahl",
                    "aggregate_sum": "Agg: Summe",
                    "aggregate_max": "Agg: Maximum",
                    "aggregate_min": "Agg: Minimum",
                    "aggregate_avg": "Agg: Mittelwert",
                    "aggregate_remove": "Aggregation entfernen"
                }
            });
            return $delegate;
        } ]);
    } ]);
})();

(function() {
    angular.module("ui.grid").config([ "$provide", function($provide) {
        $provide.decorator("i18nService", [ "$delegate", function($delegate) {
            $delegate.add("en", {
                "headerCell": {
                    "aria": {
                        "defaultFilterLabel": "Filter for column",
                        "removeFilter": "Remove Filter",
                        "columnMenuButtonLabel": "Column Menu"
                    },
                    "priority": "Priority:",
                    "filterLabel": "Filter for column: "
                },
                "aggregate": {
                    "label": "items"
                },
                "groupPanel": {
                    "description": "Drag a column header here and drop it to group by that column."
                },
                "search": {
                    "placeholder": "Search...",
                    "showingItems": "Showing Items:",
                    "selectedItems": "Selected Items:",
                    "totalItems": "Total Items:",
                    "size": "Page Size:",
                    "first": "First Page",
                    "next": "Next Page",
                    "previous": "Previous Page",
                    "last": "Last Page"
                },
                "menu": {
                    "text": "Choose Columns:"
                },
                "sort": {
                    "ascending": "Sort Ascending",
                    "descending": "Sort Descending",
                    "none": "Sort None",
                    "remove": "Remove Sort"
                },
                "column": {
                    "hide": "Hide Column"
                },
                "aggregation": {
                    "count": "total rows: ",
                    "sum": "total: ",
                    "avg": "avg: ",
                    "min": "min: ",
                    "max": "max: "
                },
                "pinning": {
                    "pinLeft": "Pin Left",
                    "pinRight": "Pin Right",
                    "unpin": "Unpin"
                },
                "columnMenu": {
                    "close": "Close"
                },
                "gridMenu": {
                    "aria": {
                        "buttonLabel": "Grid Menu"
                    },
                    "columns": "Columns:",
                    "importerTitle": "Import file",
                    "exporterAllAsCsv": "Export all data as csv",
                    "exporterVisibleAsCsv": "Export visible data as csv",
                    "exporterSelectedAsCsv": "Export selected data as csv",
                    "exporterAllAsPdf": "Export all data as pdf",
                    "exporterVisibleAsPdf": "Export visible data as pdf",
                    "exporterSelectedAsPdf": "Export selected data as pdf",
                    "clearAllFilters": "Clear all filters"
                },
                "importer": {
                    "noHeaders": "Column names were unable to be derived, does the file have a header?",
                    "noObjects": "Objects were not able to be derived, was there data in the file other than headers?",
                    "invalidCsv": "File was unable to be processed, is it valid CSV?",
                    "invalidJson": "File was unable to be processed, is it valid Json?",
                    "jsonNotArray": "Imported json file must contain an array, aborting."
                },
                "pagination": {
                    "aria": {
                        "pageToFirst": "Page to first",
                        "pageBack": "Page back",
                        "pageSelected": "Selected page",
                        "pageForward": "Page forward",
                        "pageToLast": "Page to last"
                    },
                    "sizes": "items per page",
                    "totalItems": "items",
                    "through": "through",
                    "of": "of"
                },
                "grouping": {
                    "group": "Group",
                    "ungroup": "Ungroup",
                    "aggregate_count": "Agg: Count",
                    "aggregate_sum": "Agg: Sum",
                    "aggregate_max": "Agg: Max",
                    "aggregate_min": "Agg: Min",
                    "aggregate_avg": "Agg: Avg",
                    "aggregate_remove": "Agg: Remove"
                },
                "validate": {
                    "error": "Error:",
                    "minLength": "Value should be at least THRESHOLD characters long.",
                    "maxLength": "Value should be at most THRESHOLD characters long.",
                    "required": "A value is needed."
                }
            });
            return $delegate;
        } ]);
    } ]);
})();

(function() {
    angular.module("ui.grid").config([ "$provide", function($provide) {
        $provide.decorator("i18nService", [ "$delegate", function($delegate) {
            $delegate.add("es", {
                "aggregate": {
                    "label": "Art\xedculos"
                },
                "groupPanel": {
                    "description": "Arrastre un encabezado de columna aqu\xed y su\xe9ltelo para agrupar por esa columna."
                },
                "search": {
                    "placeholder": "Buscar...",
                    "showingItems": "Art\xedculos Mostrados:",
                    "selectedItems": "Art\xedculos Seleccionados:",
                    "totalItems": "Art\xedculos Totales:",
                    "size": "Tama\xf1o de P\xe1gina:",
                    "first": "Primera P\xe1gina",
                    "next": "P\xe1gina Siguiente",
                    "previous": "P\xe1gina Anterior",
                    "last": "\xdaltima P\xe1gina"
                },
                "menu": {
                    "text": "Elegir columnas:"
                },
                "sort": {
                    "ascending": "Orden Ascendente",
                    "descending": "Orden Descendente",
                    "remove": "Sin Ordenar"
                },
                "column": {
                    "hide": "Ocultar la columna"
                },
                "aggregation": {
                    "count": "filas totales: ",
                    "sum": "total: ",
                    "avg": "media: ",
                    "min": "min: ",
                    "max": "max: "
                },
                "pinning": {
                    "pinLeft": "Fijar a la Izquierda",
                    "pinRight": "Fijar a la Derecha",
                    "unpin": "Quitar Fijaci\xf3n"
                },
                "gridMenu": {
                    "columns": "Columnas:",
                    "importerTitle": "Importar archivo",
                    "exporterAllAsCsv": "Exportar todo como csv",
                    "exporterVisibleAsCsv": "Exportar vista como csv",
                    "exporterSelectedAsCsv": "Exportar selecci\xf3n como csv",
                    "exporterAllAsPdf": "Exportar todo como pdf",
                    "exporterVisibleAsPdf": "Exportar vista como pdf",
                    "exporterSelectedAsPdf": "Exportar selecci\xf3n como pdf",
                    "clearAllFilters": "Limpiar todos los filtros"
                },
                "importer": {
                    "noHeaders": "No fue posible derivar los nombres de las columnas, \xbftiene encabezados el archivo?",
                    "noObjects": "No fue posible obtener registros, \xbfcontiene datos el archivo, aparte de los encabezados?",
                    "invalidCsv": "No fue posible procesar el archivo, \xbfes un CSV v\xe1lido?",
                    "invalidJson": "No fue posible procesar el archivo, \xbfes un Json v\xe1lido?",
                    "jsonNotArray": "El archivo json importado debe contener un array, abortando."
                },
                "pagination": {
                    "sizes": "registros por p\xe1gina",
                    "totalItems": "registros",
                    "of": "de"
                },
                "grouping": {
                    "group": "Agrupar",
                    "ungroup": "Desagrupar",
                    "aggregate_count": "Agr: Cont",
                    "aggregate_sum": "Agr: Sum",
                    "aggregate_max": "Agr: M\xe1x",
                    "aggregate_min": "Agr: Min",
                    "aggregate_avg": "Agr: Prom",
                    "aggregate_remove": "Agr: Quitar"
                }
            });
            return $delegate;
        } ]);
    } ]);
})();

(function() {
    angular.module("ui.grid").config([ "$provide", function($provide) {
        $provide.decorator("i18nService", [ "$delegate", function($delegate) {
            $delegate.add("fa", {
                "aggregate": {
                    "label": "\u0642\u0644\u0645"
                },
                "groupPanel": {
                    "description": "\u0639\u0646\u0648\u0627\u0646 \u06cc\u06a9 \u0633\u062a\u0648\u0646 \u0631\u0627 \u0628\u06af\u06cc\u0631 \u0648 \u0628\u0647 \u06af\u0631\u0648\u0647\u06cc \u0627\u0632 \u0622\u0646 \u0633\u062a\u0648\u0646 \u0631\u0647\u0627 \u06a9\u0646."
                },
                "search": {
                    "placeholder": "\u062c\u0633\u062a\u062c\u0648...",
                    "showingItems": "\u0646\u0645\u0627\u06cc\u0634 \u0627\u0642\u0644\u0627\u0645:",
                    "selectedItems": "\u0642\u0644\u0645\u200c\u0647\u0627\u06cc \u0627\u0646\u062a\u062e\u0627\u0628 \u0634\u062f\u0647:",
                    "totalItems": "\u0645\u062c\u0645\u0648\u0639 \u0627\u0642\u0644\u0627\u0645:",
                    "size": "\u0627\u0646\u062f\u0627\u0632\u0647\u200c\u06cc \u0635\u0641\u062d\u0647:",
                    "first": "\u0627\u0648\u0644\u06cc\u0646 \u0635\u0641\u062d\u0647",
                    "next": "\u0635\u0641\u062d\u0647\u200c\u06cc\u200c\u0628\u0639\u062f\u06cc",
                    "previous": "\u0635\u0641\u062d\u0647\u200c\u06cc\u200c \u0642\u0628\u0644\u06cc",
                    "last": "\u0622\u062e\u0631\u06cc\u0646 \u0635\u0641\u062d\u0647"
                },
                "menu": {
                    "text": "\u0633\u062a\u0648\u0646\u200c\u0647\u0627\u06cc \u0627\u0646\u062a\u062e\u0627\u0628\u06cc:"
                },
                "sort": {
                    "ascending": "\u062a\u0631\u062a\u06cc\u0628 \u0635\u0639\u0648\u062f\u06cc",
                    "descending": "\u062a\u0631\u062a\u06cc\u0628 \u0646\u0632\u0648\u0644\u06cc",
                    "remove": "\u062d\u0630\u0641 \u0645\u0631\u062a\u0628 \u06a9\u0631\u062f\u0646"
                },
                "column": {
                    "hide": "\u067e\u0646\u0647\u0627\u0646\u200c\u06a9\u0631\u062f\u0646 \u0633\u062a\u0648\u0646"
                },
                "aggregation": {
                    "count": "\u062a\u0639\u062f\u0627\u062f: ",
                    "sum": "\u0645\u062c\u0645\u0648\u0639: ",
                    "avg": "\u0645\u06cc\u0627\u0646\u06af\u06cc\u0646: ",
                    "min": "\u06a9\u0645\u062a\u0631\u06cc\u0646: ",
                    "max": "\u0628\u06cc\u0634\u062a\u0631\u06cc\u0646: "
                },
                "pinning": {
                    "pinLeft": "\u067e\u06cc\u0646 \u06a9\u0631\u062f\u0646 \u0633\u0645\u062a \u0686\u067e",
                    "pinRight": "\u067e\u06cc\u0646 \u06a9\u0631\u062f\u0646 \u0633\u0645\u062a \u0631\u0627\u0633\u062a",
                    "unpin": "\u062d\u0630\u0641 \u067e\u06cc\u0646"
                },
                "gridMenu": {
                    "columns": "\u0633\u062a\u0648\u0646\u200c\u0647\u0627:",
                    "importerTitle": "\u0648\u0627\u0631\u062f \u06a9\u0631\u062f\u0646 \u0641\u0627\u06cc\u0644",
                    "exporterAllAsCsv": "\u062e\u0631\u0648\u062c\u06cc \u062a\u0645\u0627\u0645 \u062f\u0627\u062f\u0647\u200c\u0647\u0627 \u062f\u0631 \u0641\u0627\u06cc\u0644 csv",
                    "exporterVisibleAsCsv": "\u062e\u0631\u0648\u062c\u06cc \u062f\u0627\u062f\u0647\u200c\u0647\u0627\u06cc \u0642\u0627\u0628\u0644 \u0645\u0634\u0627\u0647\u062f\u0647 \u062f\u0631 \u0641\u0627\u06cc\u0644 csv",
                    "exporterSelectedAsCsv": "\u062e\u0631\u0648\u062c\u06cc \u062f\u0627\u062f\u0647\u200c\u0647\u0627\u06cc \u0627\u0646\u062a\u062e\u0627\u0628\u200c\u0634\u062f\u0647 \u062f\u0631 \u0641\u0627\u06cc\u0644 csv",
                    "exporterAllAsPdf": "\u062e\u0631\u0648\u062c\u06cc \u062a\u0645\u0627\u0645 \u062f\u0627\u062f\u0647\u200c\u0647\u0627 \u062f\u0631 \u0641\u0627\u06cc\u0644 pdf",
                    "exporterVisibleAsPdf": "\u062e\u0631\u0648\u062c\u06cc \u062f\u0627\u062f\u0647\u200c\u0647\u0627\u06cc \u0642\u0627\u0628\u0644 \u0645\u0634\u0627\u0647\u062f\u0647 \u062f\u0631 \u0641\u0627\u06cc\u0644 pdf",
                    "exporterSelectedAsPdf": "\u062e\u0631\u0648\u062c\u06cc \u062f\u0627\u062f\u0647\u200c\u0647\u0627\u06cc \u0627\u0646\u062a\u062e\u0627\u0628\u200c\u0634\u062f\u0647 \u062f\u0631 \u0641\u0627\u06cc\u0644 pdf",
                    "clearAllFilters": "\u067e\u0627\u06a9 \u06a9\u0631\u062f\u0646 \u062a\u0645\u0627\u0645 \u0641\u06cc\u0644\u062a\u0631"
                },
                "importer": {
                    "noHeaders": "\u0646\u0627\u0645 \u0633\u062a\u0648\u0646 \u0642\u0627\u0628\u0644 \u0627\u0633\u062a\u062e\u0631\u0627\u062c \u0646\u06cc\u0633\u062a. \u0622\u06cc\u0627 \u0641\u0627\u06cc\u0644 \u0639\u0646\u0648\u0627\u0646 \u062f\u0627\u0631\u062f\u061f",
                    "noObjects": "\u0627\u0634\u06cc\u0627 \u0642\u0627\u0628\u0644 \u0627\u0633\u062a\u062e\u0631\u0627\u062c \u0646\u06cc\u0633\u062a\u0646\u062f. \u0622\u06cc\u0627 \u0628\u0647 \u062c\u0632 \u0639\u0646\u0648\u0627\u0646\u200c\u0647\u0627 \u062f\u0631 \u0641\u0627\u06cc\u0644 \u062f\u0627\u062f\u0647 \u0648\u062c\u0648\u062f \u062f\u0627\u0631\u062f\u061f",
                    "invalidCsv": "\u0641\u0627\u06cc\u0644 \u0642\u0627\u0628\u0644 \u067e\u0631\u062f\u0627\u0632\u0634 \u0646\u06cc\u0633\u062a. \u0622\u06cc\u0627 \u0641\u0631\u0645\u062a  csv  \u0645\u0639\u062a\u0628\u0631 \u0627\u0633\u062a\u061f",
                    "invalidJson": "\u0641\u0627\u06cc\u0644 \u0642\u0627\u0628\u0644 \u067e\u0631\u062f\u0627\u0632\u0634 \u0646\u06cc\u0633\u062a. \u0622\u06cc\u0627 \u0641\u0631\u0645\u062a json   \u0645\u0639\u062a\u0628\u0631 \u0627\u0633\u062a\u061f",
                    "jsonNotArray": "\u0641\u0627\u06cc\u0644 json \u0648\u0627\u0631\u062f \u0634\u062f\u0647 \u0628\u0627\u06cc\u062f \u062d\u0627\u0648\u06cc \u0622\u0631\u0627\u06cc\u0647 \u0628\u0627\u0634\u062f. \u0639\u0645\u0644\u06cc\u0627\u062a \u0633\u0627\u0642\u0637 \u0634\u062f."
                },
                "pagination": {
                    "sizes": "\u0627\u0642\u0644\u0627\u0645 \u062f\u0631 \u0647\u0631 \u0635\u0641\u062d\u0647",
                    "totalItems": "\u0627\u0642\u0644\u0627\u0645",
                    "of": "\u0627\u0632"
                },
                "grouping": {
                    "group": "\u06af\u0631\u0648\u0647\u200c\u0628\u0646\u062f\u06cc",
                    "ungroup": "\u062d\u0630\u0641 \u06af\u0631\u0648\u0647\u200c\u0628\u0646\u062f\u06cc",
                    "aggregate_count": "Agg: \u062a\u0639\u062f\u0627\u062f",
                    "aggregate_sum": "Agg: \u062c\u0645\u0639",
                    "aggregate_max": "Agg: \u0628\u06cc\u0634\u06cc\u0646\u0647",
                    "aggregate_min": "Agg: \u06a9\u0645\u06cc\u0646\u0647",
                    "aggregate_avg": "Agg: \u0645\u06cc\u0627\u0646\u06af\u06cc\u0646",
                    "aggregate_remove": "Agg: \u062d\u0630\u0641"
                }
            });
            return $delegate;
        } ]);
    } ]);
})();

(function() {
    angular.module("ui.grid").config([ "$provide", function($provide) {
        $provide.decorator("i18nService", [ "$delegate", function($delegate) {
            $delegate.add("fi", {
                "aggregate": {
                    "label": "rivit"
                },
                "groupPanel": {
                    "description": "Raahaa ja pudota otsikko t\xe4h\xe4n ryhmitt\xe4\xe4ksesi sarakkeen mukaan."
                },
                "search": {
                    "placeholder": "Hae...",
                    "showingItems": "N\xe4ytet\xe4\xe4n rivej\xe4:",
                    "selectedItems": "Valitut rivit:",
                    "totalItems": "Rivej\xe4 yht.:",
                    "size": "N\xe4yt\xe4:",
                    "first": "Ensimm\xe4inen sivu",
                    "next": "Seuraava sivu",
                    "previous": "Edellinen sivu",
                    "last": "Viimeinen sivu"
                },
                "menu": {
                    "text": "Valitse sarakkeet:"
                },
                "sort": {
                    "ascending": "J\xe4rjest\xe4 nouseva",
                    "descending": "J\xe4rjest\xe4 laskeva",
                    "remove": "Poista j\xe4rjestys"
                },
                "column": {
                    "hide": "Piilota sarake"
                },
                "aggregation": {
                    "count": "Rivej\xe4 yht.: ",
                    "sum": "Summa: ",
                    "avg": "K.a.: ",
                    "min": "Min: ",
                    "max": "Max: "
                },
                "pinning": {
                    "pinLeft": "Lukitse vasemmalle",
                    "pinRight": "Lukitse oikealle",
                    "unpin": "Poista lukitus"
                },
                "gridMenu": {
                    "columns": "Sarakkeet:",
                    "importerTitle": "Tuo tiedosto",
                    "exporterAllAsCsv": "Vie tiedot csv-muodossa",
                    "exporterVisibleAsCsv": "Vie n\xe4kyv\xe4 tieto csv-muodossa",
                    "exporterSelectedAsCsv": "Vie valittu tieto csv-muodossa",
                    "exporterAllAsPdf": "Vie tiedot pdf-muodossa",
                    "exporterVisibleAsPdf": "Vie n\xe4kyv\xe4 tieto pdf-muodossa",
                    "exporterSelectedAsPdf": "Vie valittu tieto pdf-muodossa",
                    "clearAllFilters": "Puhdista kaikki suodattimet"
                },
                "importer": {
                    "noHeaders": "Sarakkeen nimi\xe4 ei voitu p\xe4\xe4tell\xe4, onko tiedostossa otsikkorivi\xe4?",
                    "noObjects": "Tietoja ei voitu lukea, onko tiedostossa muuta kuin otsikkot?",
                    "invalidCsv": "Tiedostoa ei voitu k\xe4sitell\xe4, oliko se CSV-muodossa?",
                    "invalidJson": "Tiedostoa ei voitu k\xe4sitell\xe4, oliko se JSON-muodossa?",
                    "jsonNotArray": "Tiedosto ei sis\xe4lt\xe4nyt taulukkoa, lopetetaan."
                }
            });
            return $delegate;
        } ]);
    } ]);
})();

(function() {
    angular.module("ui.grid").config([ "$provide", function($provide) {
        $provide.decorator("i18nService", [ "$delegate", function($delegate) {
            $delegate.add("fr", {
                "aggregate": {
                    "label": "\xe9l\xe9ments"
                },
                "groupPanel": {
                    "description": "Faites glisser une en-t\xeate de colonne ici pour cr\xe9er un groupe de colonnes."
                },
                "search": {
                    "placeholder": "Recherche...",
                    "showingItems": "Affichage des \xe9l\xe9ments :",
                    "selectedItems": "\xc9l\xe9ments s\xe9lectionn\xe9s :",
                    "totalItems": "Nombre total d'\xe9l\xe9ments:",
                    "size": "Taille de page:",
                    "first": "Premi\xe8re page",
                    "next": "Page Suivante",
                    "previous": "Page pr\xe9c\xe9dente",
                    "last": "Derni\xe8re page"
                },
                "menu": {
                    "text": "Choisir des colonnes :"
                },
                "sort": {
                    "ascending": "Trier par ordre croissant",
                    "descending": "Trier par ordre d\xe9croissant",
                    "remove": "Enlever le tri"
                },
                "column": {
                    "hide": "Cacher la colonne"
                },
                "aggregation": {
                    "count": "lignes totales: ",
                    "sum": "total: ",
                    "avg": "moy: ",
                    "min": "min: ",
                    "max": "max: "
                },
                "pinning": {
                    "pinLeft": "\xc9pingler \xe0 gauche",
                    "pinRight": "\xc9pingler \xe0 droite",
                    "unpin": "D\xe9tacher"
                },
                "gridMenu": {
                    "columns": "Colonnes:",
                    "importerTitle": "Importer un fichier",
                    "exporterAllAsCsv": "Exporter toutes les donn\xe9es en CSV",
                    "exporterVisibleAsCsv": "Exporter les donn\xe9es visibles en CSV",
                    "exporterSelectedAsCsv": "Exporter les donn\xe9es s\xe9lectionn\xe9es en CSV",
                    "exporterAllAsPdf": "Exporter toutes les donn\xe9es en PDF",
                    "exporterVisibleAsPdf": "Exporter les donn\xe9es visibles en PDF",
                    "exporterSelectedAsPdf": "Exporter les donn\xe9es s\xe9lectionn\xe9es en PDF",
                    "clearAllFilters": "Nettoyez tous les filtres"
                },
                "importer": {
                    "noHeaders": "Impossible de d\xe9terminer le nom des colonnes, le fichier poss\xe8de-t-il une en-t\xeate ?",
                    "noObjects": "Aucun objet trouv\xe9, le fichier poss\xe8de-t-il des donn\xe9es autres que l'en-t\xeate ?",
                    "invalidCsv": "Le fichier n'a pas pu \xeatre trait\xe9, le CSV est-il valide ?",
                    "invalidJson": "Le fichier n'a pas pu \xeatre trait\xe9, le JSON est-il valide ?",
                    "jsonNotArray": "Le fichier JSON import\xe9 doit contenir un tableau, abandon."
                },
                "pagination": {
                    "sizes": "\xe9l\xe9ments par page",
                    "totalItems": "\xe9l\xe9ments",
                    "of": "sur"
                },
                "grouping": {
                    "group": "Grouper",
                    "ungroup": "D\xe9grouper",
                    "aggregate_count": "Agg: Compte",
                    "aggregate_sum": "Agg: Somme",
                    "aggregate_max": "Agg: Max",
                    "aggregate_min": "Agg: Min",
                    "aggregate_avg": "Agg: Moy",
                    "aggregate_remove": "Agg: Retirer"
                }
            });
            return $delegate;
        } ]);
    } ]);
})();

(function() {
    angular.module("ui.grid").config([ "$provide", function($provide) {
        $provide.decorator("i18nService", [ "$delegate", function($delegate) {
            $delegate.add("he", {
                "aggregate": {
                    "label": "items"
                },
                "groupPanel": {
                    "description": "\u05d2\u05e8\u05d5\u05e8 \u05e2\u05de\u05d5\u05d3\u05d4 \u05dc\u05db\u05d0\u05df \u05d5\u05e9\u05d7\u05e8\u05e8 \u05d1\u05db\u05d3\u05d9 \u05dc\u05e7\u05d1\u05e5 \u05e2\u05de\u05d5\u05d3\u05d4 \u05d6\u05d5."
                },
                "search": {
                    "placeholder": "\u05d7\u05e4\u05e9...",
                    "showingItems": "\u05de\u05e6\u05d9\u05d2:",
                    "selectedItems": '\u05e1\u05d4"\u05db \u05e0\u05d1\u05d7\u05e8\u05d5:',
                    "totalItems": '\u05e1\u05d4"\u05db \u05e8\u05e9\u05d5\u05de\u05d5\u05ea:',
                    "size": "\u05ea\u05d5\u05e6\u05d0\u05d5\u05ea \u05d1\u05d3\u05e3:",
                    "first": "\u05d3\u05e3 \u05e8\u05d0\u05e9\u05d5\u05df",
                    "next": "\u05d3\u05e3 \u05d4\u05d1\u05d0",
                    "previous": "\u05d3\u05e3 \u05e7\u05d5\u05d3\u05dd",
                    "last": "\u05d3\u05e3 \u05d0\u05d7\u05e8\u05d5\u05df"
                },
                "menu": {
                    "text": "\u05d1\u05d7\u05e8 \u05e2\u05de\u05d5\u05d3\u05d5\u05ea:"
                },
                "sort": {
                    "ascending": "\u05e1\u05d3\u05e8 \u05e2\u05d5\u05dc\u05d4",
                    "descending": "\u05e1\u05d3\u05e8 \u05d9\u05d5\u05e8\u05d3",
                    "remove": "\u05d1\u05d8\u05dc"
                },
                "column": {
                    "hide": "\u05d8\u05d5\u05e8 \u05d4\u05e1\u05ea\u05e8"
                },
                "aggregation": {
                    "count": "total rows: ",
                    "sum": "total: ",
                    "avg": "avg: ",
                    "min": "min: ",
                    "max": "max: "
                },
                "gridMenu": {
                    "columns": "Columns:",
                    "importerTitle": "Import file",
                    "exporterAllAsCsv": "Export all data as csv",
                    "exporterVisibleAsCsv": "Export visible data as csv",
                    "exporterSelectedAsCsv": "Export selected data as csv",
                    "exporterAllAsPdf": "Export all data as pdf",
                    "exporterVisibleAsPdf": "Export visible data as pdf",
                    "exporterSelectedAsPdf": "Export selected data as pdf",
                    "clearAllFilters": "Clean all filters"
                },
                "importer": {
                    "noHeaders": "Column names were unable to be derived, does the file have a header?",
                    "noObjects": "Objects were not able to be derived, was there data in the file other than headers?",
                    "invalidCsv": "File was unable to be processed, is it valid CSV?",
                    "invalidJson": "File was unable to be processed, is it valid Json?",
                    "jsonNotArray": "Imported json file must contain an array, aborting."
                }
            });
            return $delegate;
        } ]);
    } ]);
})();

(function() {
    angular.module("ui.grid").config([ "$provide", function($provide) {
        $provide.decorator("i18nService", [ "$delegate", function($delegate) {
            $delegate.add("hy", {
                "aggregate": {
                    "label": "\u057f\u057e\u0575\u0561\u056c\u0576\u0565\u0580"
                },
                "groupPanel": {
                    "description": "\u0538\u057d\u057f \u057d\u0575\u0561\u0576 \u056d\u0574\u0562\u0561\u057e\u0578\u0580\u0565\u056c\u0578\u0582 \u0570\u0561\u0574\u0561\u0580 \u0584\u0561\u0577\u0565\u0584 \u0587 \u0563\u0581\u0565\u0584 \u057e\u0565\u0580\u0576\u0561\u0563\u056b\u0580\u0576 \u0561\u0575\u057d\u057f\u0565\u0572\u0589"
                },
                "search": {
                    "placeholder": "\u0553\u0576\u057f\u0580\u0578\u0582\u0574...",
                    "showingItems": "\u0551\u0578\u0582\u0581\u0561\u0564\u0580\u057e\u0561\u056e \u057f\u057e\u0575\u0561\u056c\u0576\u0565\u0580\u055d",
                    "selectedItems": "\u0538\u0576\u057f\u0580\u057e\u0561\u056e:",
                    "totalItems": "\u0538\u0576\u0564\u0561\u0574\u0565\u0576\u0568\u055d",
                    "size": "\u054f\u0578\u0572\u0565\u0580\u056b \u0584\u0561\u0576\u0561\u056f\u0568 \u0567\u057b\u0578\u0582\u0574\u055d",
                    "first": "\u0531\u057c\u0561\u057b\u056b\u0576 \u0567\u057b",
                    "next": "\u0540\u0561\u057b\u0578\u0580\u0564 \u0567\u057b",
                    "previous": "\u0546\u0561\u056d\u0578\u0580\u0564 \u0567\u057b",
                    "last": "\u054e\u0565\u0580\u057b\u056b\u0576 \u0567\u057b"
                },
                "menu": {
                    "text": "\u0538\u0576\u057f\u0580\u0565\u056c \u057d\u0575\u0578\u0582\u0576\u0565\u0580\u0568:"
                },
                "sort": {
                    "ascending": "\u0531\u0573\u0574\u0561\u0576 \u056f\u0561\u0580\u0563\u0578\u057e",
                    "descending": "\u0546\u057e\u0561\u0566\u0574\u0561\u0576 \u056f\u0561\u0580\u0563\u0578\u057e",
                    "remove": "\u0540\u0561\u0576\u0565\u056c "
                },
                "column": {
                    "hide": "\u0539\u0561\u0584\u0581\u0576\u0565\u056c \u057d\u0575\u0578\u0582\u0576\u0568"
                },
                "aggregation": {
                    "count": "\u0568\u0576\u0564\u0561\u0574\u0565\u0576\u0568 \u057f\u0578\u0572\u055d ",
                    "sum": "\u0568\u0576\u0564\u0561\u0574\u0565\u0576\u0568\u055d ",
                    "avg": "\u0574\u056b\u057b\u056b\u0576\u055d ",
                    "min": "\u0574\u056b\u0576\u055d ",
                    "max": "\u0574\u0561\u0584\u057d\u055d "
                },
                "pinning": {
                    "pinLeft": "\u053f\u057a\u0581\u0576\u0565\u056c \u0571\u0561\u056d \u056f\u0578\u0572\u0574\u0578\u0582\u0574",
                    "pinRight": "\u053f\u057a\u0581\u0576\u0565\u056c \u0561\u057b \u056f\u0578\u0572\u0574\u0578\u0582\u0574",
                    "unpin": "\u0531\u0580\u0571\u0561\u056f\u0565\u056c"
                },
                "gridMenu": {
                    "columns": "\u054d\u0575\u0578\u0582\u0576\u0565\u0580:",
                    "importerTitle": "\u0546\u0565\u0580\u0574\u0578\u0582\u056e\u0565\u056c \u0586\u0561\u0575\u056c",
                    "exporterAllAsCsv": "\u0531\u0580\u057f\u0561\u0570\u0561\u0576\u0565\u056c \u0561\u0574\u0562\u0578\u0572\u057b\u0568 CSV",
                    "exporterVisibleAsCsv": "\u0531\u0580\u057f\u0561\u0570\u0561\u0576\u0565\u056c \u0565\u0580\u0587\u0561\u0581\u0578\u0572 \u057f\u057e\u0575\u0561\u056c\u0576\u0565\u0580\u0568 CSV",
                    "exporterSelectedAsCsv": "\u0531\u0580\u057f\u0561\u0570\u0561\u0576\u0565\u056c \u0568\u0576\u057f\u0580\u057e\u0561\u056e \u057f\u057e\u0575\u0561\u056c\u0576\u0565\u0580\u0568 CSV",
                    "exporterAllAsPdf": "\u0531\u0580\u057f\u0561\u0570\u0561\u0576\u0565\u056c PDF",
                    "exporterVisibleAsPdf": "\u0531\u0580\u057f\u0561\u0570\u0561\u0576\u0565\u056c \u0565\u0580\u0587\u0561\u0581\u0578\u0572 \u057f\u057e\u0575\u0561\u056c\u0576\u0565\u0580\u0568 PDF",
                    "exporterSelectedAsPdf": "\u0531\u0580\u057f\u0561\u0570\u0561\u0576\u0565\u056c \u0568\u0576\u057f\u0580\u057e\u0561\u056e \u057f\u057e\u0575\u0561\u056c\u0576\u0565\u0580\u0568 PDF",
                    "clearAllFilters": "\u0544\u0561\u0584\u0580\u0565\u056c \u0562\u0578\u056c\u0578\u0580 \u0586\u056b\u056c\u057f\u0580\u0565\u0580\u0568"
                },
                "importer": {
                    "noHeaders": "\u0540\u0576\u0561\u0580\u0561\u057e\u0578\u0580 \u0579\u0565\u0572\u0561\u057e \u0578\u0580\u0578\u0577\u0565\u056c \u057d\u0575\u0561\u0576 \u057e\u0565\u0580\u0576\u0561\u0563\u0580\u0565\u0580\u0568\u0589 \u0531\u0580\u0564\u0575\u0578\u055e\u0584 \u0586\u0561\u0575\u056c\u0568 \u0578\u0582\u0576\u056b \u057e\u0565\u0580\u0576\u0561\u0563\u0580\u0565\u0580\u0589",
                    "noObjects": "\u0540\u0576\u0561\u0580\u0561\u057e\u0578\u0580 \u0579\u0565\u0572\u0561\u057e \u056f\u0561\u0580\u0564\u0561\u056c \u057f\u057e\u0575\u0561\u056c\u0576\u0565\u0580\u0568\u0589 \u0531\u0580\u0564\u0575\u0578\u055e\u0584 \u0586\u0561\u0575\u056c\u0578\u0582\u0574 \u056f\u0561\u0576 \u057f\u057e\u0575\u0561\u056c\u0576\u0565\u0580\u0589",
                    "invalidCsv": "\u0540\u0576\u0561\u0580\u0561\u057e\u0578\u0580 \u0579\u0565\u0572\u0561\u057e \u0574\u0577\u0561\u056f\u0565\u056c \u0586\u0561\u0575\u056c\u0568\u0589 \u0531\u0580\u0564\u0575\u0578\u055e\u0584 \u0561\u0575\u0576 \u057e\u0561\u057e\u0565\u0580 CSV \u0567\u0589",
                    "invalidJson": "\u0540\u0576\u0561\u0580\u0561\u057e\u0578\u0580 \u0579\u0565\u0572\u0561\u057e \u0574\u0577\u0561\u056f\u0565\u056c \u0586\u0561\u0575\u056c\u0568\u0589 \u0531\u0580\u0564\u0575\u0578\u055e\u0584 \u0561\u0575\u0576 \u057e\u0561\u057e\u0565\u0580 Json \u0567\u0589",
                    "jsonNotArray": "\u0546\u0565\u0580\u0574\u0578\u0582\u056e\u057e\u0561\u056e json \u0586\u0561\u0575\u056c\u0568 \u057a\u0565\u057f\u0584 \u0567 \u057a\u0561\u0580\u0578\u0582\u0576\u0561\u056f\u056b \u0566\u0561\u0576\u0563\u057e\u0561\u056e, \u056f\u0561\u057d\u0565\u0581\u057e\u0578\u0582\u0574 \u0567\u0589"
                }
            });
            return $delegate;
        } ]);
    } ]);
})();

(function() {
    angular.module("ui.grid").config([ "$provide", function($provide) {
        $provide.decorator("i18nService", [ "$delegate", function($delegate) {
            $delegate.add("it", {
                "aggregate": {
                    "label": "elementi"
                },
                "groupPanel": {
                    "description": "Trascina un'intestazione all'interno del gruppo della colonna."
                },
                "search": {
                    "placeholder": "Ricerca...",
                    "showingItems": "Mostra:",
                    "selectedItems": "Selezionati:",
                    "totalItems": "Totali:",
                    "size": "Tot Pagine:",
                    "first": "Prima",
                    "next": "Prossima",
                    "previous": "Precedente",
                    "last": "Ultima"
                },
                "menu": {
                    "text": "Scegli le colonne:"
                },
                "sort": {
                    "ascending": "Asc.",
                    "descending": "Desc.",
                    "remove": "Annulla ordinamento"
                },
                "column": {
                    "hide": "Nascondi"
                },
                "aggregation": {
                    "count": "righe totali: ",
                    "sum": "tot: ",
                    "avg": "media: ",
                    "min": "minimo: ",
                    "max": "massimo: "
                },
                "pinning": {
                    "pinLeft": "Blocca a sx",
                    "pinRight": "Blocca a dx",
                    "unpin": "Blocca in alto"
                },
                "gridMenu": {
                    "columns": "Colonne:",
                    "importerTitle": "Importa",
                    "exporterAllAsCsv": "Esporta tutti i dati in CSV",
                    "exporterVisibleAsCsv": "Esporta i dati visibili in CSV",
                    "exporterSelectedAsCsv": "Esporta i dati selezionati in CSV",
                    "exporterAllAsPdf": "Esporta tutti i dati in PDF",
                    "exporterVisibleAsPdf": "Esporta i dati visibili in PDF",
                    "exporterSelectedAsPdf": "Esporta i dati selezionati in PDF",
                    "clearAllFilters": "Pulire tutti i filtri"
                },
                "importer": {
                    "noHeaders": "Impossibile reperire i nomi delle colonne, sicuro che siano indicati all'interno del file?",
                    "noObjects": "Impossibile reperire gli oggetti, sicuro che siano indicati all'interno del file?",
                    "invalidCsv": "Impossibile elaborare il file, sicuro che sia un CSV?",
                    "invalidJson": "Impossibile elaborare il file, sicuro che sia un JSON valido?",
                    "jsonNotArray": "Errore! Il file JSON da importare deve contenere un array."
                },
                "grouping": {
                    "group": "Raggruppa",
                    "ungroup": "Separa",
                    "aggregate_count": "Agg: N. Elem.",
                    "aggregate_sum": "Agg: Somma",
                    "aggregate_max": "Agg: Massimo",
                    "aggregate_min": "Agg: Minimo",
                    "aggregate_avg": "Agg: Media",
                    "aggregate_remove": "Agg: Rimuovi"
                },
                "validate": {
                    "error": "Errore:",
                    "minLength": "Lunghezza minima pari a THRESHOLD caratteri.",
                    "maxLength": "Lunghezza massima pari a THRESHOLD caratteri.",
                    "required": "Necessario inserire un valore."
                }
            });
            return $delegate;
        } ]);
    } ]);
})();

(function() {
    angular.module("ui.grid").config([ "$provide", function($provide) {
        $provide.decorator("i18nService", [ "$delegate", function($delegate) {
            $delegate.add("ja", {
                "aggregate": {
                    "label": "\u9805\u76ee"
                },
                "groupPanel": {
                    "description": "\u3053\u3053\u306b\u5217\u30d8\u30c3\u30c0\u3092\u30c9\u30e9\u30c3\u30b0\u30a2\u30f3\u30c9\u30c9\u30ed\u30c3\u30d7\u3057\u3066\u3001\u305d\u306e\u5217\u3067\u30b0\u30eb\u30fc\u30d7\u5316\u3057\u307e\u3059\u3002"
                },
                "search": {
                    "placeholder": "\u691c\u7d22...",
                    "showingItems": "\u8868\u793a\u4e2d\u306e\u9805\u76ee:",
                    "selectedItems": "\u9078\u629e\u3057\u305f\u9805\u76ee:",
                    "totalItems": "\u9805\u76ee\u306e\u7dcf\u6570:",
                    "size": "\u30da\u30fc\u30b8\u30b5\u30a4\u30ba:",
                    "first": "\u6700\u521d\u306e\u30da\u30fc\u30b8",
                    "next": "\u6b21\u306e\u30da\u30fc\u30b8",
                    "previous": "\u524d\u306e\u30da\u30fc\u30b8",
                    "last": "\u524d\u306e\u30da\u30fc\u30b8"
                },
                "menu": {
                    "text": "\u5217\u306e\u9078\u629e:"
                },
                "sort": {
                    "ascending": "\u6607\u9806\u306b\u4e26\u3079\u66ff\u3048",
                    "descending": "\u964d\u9806\u306b\u4e26\u3079\u66ff\u3048",
                    "remove": "\u4e26\u3079\u66ff\u3048\u306e\u89e3\u9664"
                },
                "column": {
                    "hide": "\u5217\u306e\u975e\u8868\u793a"
                },
                "aggregation": {
                    "count": "\u5408\u8a08\u884c\u6570: ",
                    "sum": "\u5408\u8a08: ",
                    "avg": "\u5e73\u5747: ",
                    "min": "\u6700\u5c0f: ",
                    "max": "\u6700\u5927: "
                },
                "pinning": {
                    "pinLeft": "\u5de6\u306b\u56fa\u5b9a",
                    "pinRight": "\u53f3\u306b\u56fa\u5b9a",
                    "unpin": "\u56fa\u5b9a\u89e3\u9664"
                },
                "gridMenu": {
                    "columns": "\u5217:",
                    "importerTitle": "\u30d5\u30a1\u30a4\u30eb\u306e\u30a4\u30f3\u30dd\u30fc\u30c8",
                    "exporterAllAsCsv": "\u3059\u3079\u3066\u306e\u30c7\u30fc\u30bf\u3092CSV\u5f62\u5f0f\u3067\u30a8\u30af\u30b9\u30dd\u30fc\u30c8",
                    "exporterVisibleAsCsv": "\u8868\u793a\u4e2d\u306e\u30c7\u30fc\u30bf\u3092CSV\u5f62\u5f0f\u3067\u30a8\u30af\u30b9\u30dd\u30fc\u30c8",
                    "exporterSelectedAsCsv": "\u9078\u629e\u3057\u305f\u30c7\u30fc\u30bf\u3092CSV\u5f62\u5f0f\u3067\u30a8\u30af\u30b9\u30dd\u30fc\u30c8",
                    "exporterAllAsPdf": "\u3059\u3079\u3066\u306e\u30c7\u30fc\u30bf\u3092PDF\u5f62\u5f0f\u3067\u30a8\u30af\u30b9\u30dd\u30fc\u30c8",
                    "exporterVisibleAsPdf": "\u8868\u793a\u4e2d\u306e\u30c7\u30fc\u30bf\u3092PDF\u5f62\u5f0f\u3067\u30a8\u30af\u30b9\u30dd\u30fc\u30c8",
                    "exporterSelectedAsPdf": "\u9078\u629e\u3057\u305f\u30c7\u30fc\u30bf\u3092PDF\u5f62\u5f0f\u3067\u30a8\u30af\u30b9\u30dd\u30fc\u30c8",
                    "clearAllFilters": "\u3059\u3079\u3066\u306e\u30d5\u30a3\u30eb\u30bf\u3092\u6e05\u6383\u3057\u3066\u304f\u3060\u3055\u3044"
                },
                "importer": {
                    "noHeaders": "\u5217\u540d\u3092\u53d6\u5f97\u3067\u304d\u307e\u305b\u3093\u3002\u30d5\u30a1\u30a4\u30eb\u306b\u30d8\u30c3\u30c0\u304c\u542b\u307e\u308c\u3066\u3044\u308b\u3053\u3068\u3092\u78ba\u8a8d\u3057\u3066\u304f\u3060\u3055\u3044\u3002",
                    "noObjects": "\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3092\u53d6\u5f97\u3067\u304d\u307e\u305b\u3093\u3002\u30d5\u30a1\u30a4\u30eb\u306b\u30d8\u30c3\u30c0\u4ee5\u5916\u306e\u30c7\u30fc\u30bf\u304c\u542b\u307e\u308c\u3066\u3044\u308b\u3053\u3068\u3092\u78ba\u8a8d\u3057\u3066\u304f\u3060\u3055\u3044\u3002",
                    "invalidCsv": "\u30d5\u30a1\u30a4\u30eb\u3092\u51e6\u7406\u3067\u304d\u307e\u305b\u3093\u3002\u30d5\u30a1\u30a4\u30eb\u304c\u6709\u52b9\u306aCSV\u5f62\u5f0f\u3067\u3042\u308b\u3053\u3068\u3092\u78ba\u8a8d\u3057\u3066\u304f\u3060\u3055\u3044\u3002",
                    "invalidJson": "\u30d5\u30a1\u30a4\u30eb\u3092\u51e6\u7406\u3067\u304d\u307e\u305b\u3093\u3002\u30d5\u30a1\u30a4\u30eb\u304c\u6709\u52b9\u306aJSON\u5f62\u5f0f\u3067\u3042\u308b\u3053\u3068\u3092\u78ba\u8a8d\u3057\u3066\u304f\u3060\u3055\u3044\u3002",
                    "jsonNotArray": "\u30a4\u30f3\u30dd\u30fc\u30c8\u3057\u305fJSON\u30d5\u30a1\u30a4\u30eb\u306b\u306f\u914d\u5217\u304c\u542b\u307e\u308c\u3066\u3044\u308b\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u3002\u51e6\u7406\u3092\u4e2d\u6b62\u3057\u307e\u3059\u3002"
                },
                "pagination": {
                    "aria": {
                        "pageToFirst": "\u6700\u521d\u306e\u30da\u30fc\u30b8",
                        "pageBack": "\u524d\u306e\u30da\u30fc\u30b8",
                        "pageSelected": "\u73fe\u5728\u306e\u30da\u30fc\u30b8",
                        "pageForward": "\u6b21\u306e\u30da\u30fc\u30b8",
                        "pageToLast": "\u6700\u5f8c\u306e\u30da\u30fc\u30b8"
                    },
                    "sizes": "\u9805\u76ee/\u30da\u30fc\u30b8",
                    "totalItems": "\u9805\u76ee",
                    "through": "\u304b\u3089",
                    "of": "\u9805\u76ee/\u5168"
                }
            });
            return $delegate;
        } ]);
    } ]);
})();

(function() {
    angular.module("ui.grid").config([ "$provide", function($provide) {
        $provide.decorator("i18nService", [ "$delegate", function($delegate) {
            $delegate.add("ko", {
                "aggregate": {
                    "label": "\uc544\uc774\ud15c"
                },
                "groupPanel": {
                    "description": "\uceec\ub7fc\uc73c\ub85c \uadf8\ub8f9\ud551\ud558\uae30 \uc704\ud574\uc11c\ub294 \uceec\ub7fc \ud5e4\ub354\ub97c \ub04c\uc5b4 \ub5a8\uc5b4\ub728\ub824 \uc8fc\uc138\uc694."
                },
                "search": {
                    "placeholder": "\uac80\uc0c9...",
                    "showingItems": "\ud56d\ubaa9 \ubcf4\uc5ec\uc8fc\uae30:",
                    "selectedItems": "\uc120\ud0dd \ud56d\ubaa9:",
                    "totalItems": "\uc804\uccb4 \ud56d\ubaa9:",
                    "size": "\ud398\uc774\uc9c0 \ud06c\uae30:",
                    "first": "\uccab\ubc88\uc9f8 \ud398\uc774\uc9c0",
                    "next": "\ub2e4\uc74c \ud398\uc774\uc9c0",
                    "previous": "\uc774\uc804 \ud398\uc774\uc9c0",
                    "last": "\ub9c8\uc9c0\ub9c9 \ud398\uc774\uc9c0"
                },
                "menu": {
                    "text": "\uceec\ub7fc\uc744 \uc120\ud0dd\ud558\uc138\uc694:"
                },
                "sort": {
                    "ascending": "\uc624\ub984\ucc28\uc21c \uc815\ub82c",
                    "descending": "\ub0b4\ub9bc\ucc28\uc21c \uc815\ub82c",
                    "remove": "\uc18c\ud305 \uc81c\uac70"
                },
                "column": {
                    "hide": "\uceec\ub7fc \uc81c\uac70"
                },
                "aggregation": {
                    "count": "\uc804\uccb4 \uac2f\uc218: ",
                    "sum": "\uc804\uccb4: ",
                    "avg": "\ud3c9\uade0: ",
                    "min": "\ucd5c\uc18c: ",
                    "max": "\ucd5c\ub300: "
                },
                "pinning": {
                    "pinLeft": "\uc67c\ucabd \ud540",
                    "pinRight": "\uc624\ub978\ucabd \ud540",
                    "unpin": "\ud540 \uc81c\uac70"
                },
                "gridMenu": {
                    "columns": "\uceec\ub7fc:",
                    "importerTitle": "\ud30c\uc77c \uac00\uc838\uc624\uae30",
                    "exporterAllAsCsv": "csv\ub85c \ubaa8\ub4e0 \ub370\uc774\ud130 \ub0b4\ubcf4\ub0b4\uae30",
                    "exporterVisibleAsCsv": "csv\ub85c \ubcf4\uc774\ub294 \ub370\uc774\ud130 \ub0b4\ubcf4\ub0b4\uae30",
                    "exporterSelectedAsCsv": "csv\ub85c \uc120\ud0dd\ub41c \ub370\uc774\ud130 \ub0b4\ubcf4\ub0b4\uae30",
                    "exporterAllAsPdf": "pdf\ub85c \ubaa8\ub4e0 \ub370\uc774\ud130 \ub0b4\ubcf4\ub0b4\uae30",
                    "exporterVisibleAsPdf": "pdf\ub85c \ubcf4\uc774\ub294 \ub370\uc774\ud130 \ub0b4\ubcf4\ub0b4\uae30",
                    "exporterSelectedAsPdf": "pdf\ub85c \uc120\ud0dd \ub370\uc774\ud130 \ub0b4\ubcf4\ub0b4\uae30",
                    "clearAllFilters": "\ubaa8\ub4e0 \ud544\ud130\ub97c \uccad\uc18c"
                },
                "importer": {
                    "noHeaders": "\uceec\ub7fc\uba85\uc774 \uc9c0\uc815\ub418\uc5b4 \uc788\uc9c0 \uc54a\uc2b5\ub2c8\ub2e4. \ud30c\uc77c\uc5d0 \ud5e4\ub354\uac00 \uba85\uc2dc\ub418\uc5b4 \uc788\ub294\uc9c0 \ud655\uc778\ud574 \uc8fc\uc138\uc694.",
                    "noObjects": "\ub370\uc774\ud130\uac00 \uc9c0\uc815\ub418\uc5b4 \uc788\uc9c0 \uc54a\uc2b5\ub2c8\ub2e4. \ub370\uc774\ud130\uac00 \ud30c\uc77c\uc5d0 \uc788\ub294\uc9c0 \ud655\uc778\ud574 \uc8fc\uc138\uc694.",
                    "invalidCsv": "\ud30c\uc77c\uc744 \ucc98\ub9ac\ud560 \uc218 \uc5c6\uc2b5\ub2c8\ub2e4. \uc62c\ubc14\ub978 csv\uc778\uc9c0 \ud655\uc778\ud574 \uc8fc\uc138\uc694.",
                    "invalidJson": "\ud30c\uc77c\uc744 \ucc98\ub9ac\ud560 \uc218 \uc5c6\uc2b5\ub2c8\ub2e4. \uc62c\ubc14\ub978 json\uc778\uc9c0 \ud655\uc778\ud574 \uc8fc\uc138\uc694.",
                    "jsonNotArray": "json \ud30c\uc77c\uc740 \ubc30\uc5f4\uc744 \ud3ec\ud568\ud574\uc57c \ud569\ub2c8\ub2e4."
                },
                "pagination": {
                    "sizes": "\ud398\uc774\uc9c0\ub2f9 \ud56d\ubaa9",
                    "totalItems": "\uc804\uccb4 \ud56d\ubaa9"
                }
            });
            return $delegate;
        } ]);
    } ]);
})();

(function() {
    angular.module("ui.grid").config([ "$provide", function($provide) {
        $provide.decorator("i18nService", [ "$delegate", function($delegate) {
            $delegate.add("nl", {
                "aggregate": {
                    "label": "items"
                },
                "groupPanel": {
                    "description": "Sleep hier een kolomnaam heen om op te groeperen."
                },
                "search": {
                    "placeholder": "Zoeken...",
                    "showingItems": "Getoonde items:",
                    "selectedItems": "Geselecteerde items:",
                    "totalItems": "Totaal aantal items:",
                    "size": "Items per pagina:",
                    "first": "Eerste pagina",
                    "next": "Volgende pagina",
                    "previous": "Vorige pagina",
                    "last": "Laatste pagina"
                },
                "menu": {
                    "text": "Kies kolommen:"
                },
                "sort": {
                    "ascending": "Sorteer oplopend",
                    "descending": "Sorteer aflopend",
                    "remove": "Verwijder sortering"
                },
                "column": {
                    "hide": "Verberg kolom"
                },
                "aggregation": {
                    "count": "Aantal rijen: ",
                    "sum": "Som: ",
                    "avg": "Gemiddelde: ",
                    "min": "Min: ",
                    "max": "Max: "
                },
                "pinning": {
                    "pinLeft": "Zet links vast",
                    "pinRight": "Zet rechts vast",
                    "unpin": "Maak los"
                },
                "gridMenu": {
                    "columns": "Kolommen:",
                    "importerTitle": "Importeer bestand",
                    "exporterAllAsCsv": "Exporteer alle data als csv",
                    "exporterVisibleAsCsv": "Exporteer zichtbare data als csv",
                    "exporterSelectedAsCsv": "Exporteer geselecteerde data als csv",
                    "exporterAllAsPdf": "Exporteer alle data als pdf",
                    "exporterVisibleAsPdf": "Exporteer zichtbare data als pdf",
                    "exporterSelectedAsPdf": "Exporteer geselecteerde data als pdf",
                    "clearAllFilters": "Reinig alle filters"
                },
                "importer": {
                    "noHeaders": "Kolomnamen kunnen niet worden afgeleid. Heeft het bestand een header?",
                    "noObjects": "Objecten kunnen niet worden afgeleid. Bevat het bestand data naast de headers?",
                    "invalidCsv": "Het bestand kan niet verwerkt worden. Is het een valide csv bestand?",
                    "invalidJson": "Het bestand kan niet verwerkt worden. Is het valide json?",
                    "jsonNotArray": "Het json bestand moet een array bevatten. De actie wordt geannuleerd."
                },
                "pagination": {
                    "sizes": "items per pagina",
                    "totalItems": "items",
                    "of": "van de"
                },
                "grouping": {
                    "group": "Groepeer",
                    "ungroup": "Groepering opheffen",
                    "aggregate_count": "Agg: Aantal",
                    "aggregate_sum": "Agg: Som",
                    "aggregate_max": "Agg: Max",
                    "aggregate_min": "Agg: Min",
                    "aggregate_avg": "Agg: Gem",
                    "aggregate_remove": "Agg: Verwijder"
                }
            });
            return $delegate;
        } ]);
    } ]);
})();

(function() {
    angular.module("ui.grid").config([ "$provide", function($provide) {
        $provide.decorator("i18nService", [ "$delegate", function($delegate) {
            $delegate.add("pl", {
                "headerCell": {
                    "aria": {
                        "defaultFilterLabel": "Filter dla kolumny",
                        "removeFilter": "Usu\u0144 filter",
                        "columnMenuButtonLabel": "Menu kolumny"
                    },
                    "priority": "Prioritet:",
                    "filterLabel": "Filtr dla kolumny: "
                },
                "aggregate": {
                    "label": "pozycji"
                },
                "groupPanel": {
                    "description": "Przeci\u0105gnij nag\u0142\xf3wek kolumny tutaj, aby pogrupowa\u0107 wed\u0142ug niej."
                },
                "search": {
                    "placeholder": "Szukaj...",
                    "showingItems": "Widoczne pozycje:",
                    "selectedItems": "Zaznaczone pozycje:",
                    "totalItems": "Wszystkich pozycji:",
                    "size": "Rozmiar strony:",
                    "first": "Pierwsza strona",
                    "next": "Nast\u0119pna strona",
                    "previous": "Poprzednia strona",
                    "last": "Ostatnia strona"
                },
                "menu": {
                    "text": "Wybierz kolumny:"
                },
                "sort": {
                    "ascending": "Sortuj rosn\u0105co",
                    "descending": "Sortuj malej\u0105co",
                    "none": "Brak sortowania",
                    "remove": "Wy\u0142\u0105cz sortowanie"
                },
                "column": {
                    "hide": "Ukryj kolumne"
                },
                "aggregation": {
                    "count": "Razem pozycji: ",
                    "sum": "Razem: ",
                    "avg": "\u015arednia: ",
                    "min": "Min: ",
                    "max": "Max: "
                },
                "pinning": {
                    "pinLeft": "Przypnij do lewej",
                    "pinRight": "Przypnij do prawej",
                    "unpin": "Odepnij"
                },
                "columnMenu": {
                    "close": "Zamknij"
                },
                "gridMenu": {
                    "aria": {
                        "buttonLabel": "Menu Grida"
                    },
                    "columns": "Kolumny:",
                    "importerTitle": "Importuj plik",
                    "exporterAllAsCsv": "Eksportuj wszystkie dane do csv",
                    "exporterVisibleAsCsv": "Eksportuj widoczne dane do csv",
                    "exporterSelectedAsCsv": "Eksportuj zaznaczone dane do csv",
                    "exporterAllAsPdf": "Eksportuj wszystkie dane do pdf",
                    "exporterVisibleAsPdf": "Eksportuj widoczne dane do pdf",
                    "exporterSelectedAsPdf": "Eksportuj zaznaczone dane do pdf",
                    "clearAllFilters": "Wyczy\u015b\u0107 filtry"
                },
                "importer": {
                    "noHeaders": "Nie uda\u0142o si\u0119 wczyta\u0107 nazw kolumn. Czy plik posiada nag\u0142\xf3wek?",
                    "noObjects": "Nie udalo si\u0119 wczyta\u0107 pozycji. Czy plik zawiera dane??",
                    "invalidCsv": "Nie uda\u0142o si\u0119 przetworzy\u0107 pliku, jest to prawidlowy plik CSV??",
                    "invalidJson": "Nie uda\u0142o si\u0119 przetworzy\u0107 pliku, jest to prawidlowy plik Json?",
                    "jsonNotArray": "Importowany plik json musi zawiera\u0107 tablic\u0119, importowanie przerwane."
                },
                "pagination": {
                    "aria": {
                        "pageToFirst": "Pierwsza strona",
                        "pageBack": "Poprzednia strona",
                        "pageSelected": "Wybrana strona",
                        "pageForward": "Nast\u0119pna strona",
                        "pageToLast": "Ostatnia strona"
                    },
                    "sizes": "pozycji na stron\u0119",
                    "totalItems": "pozycji",
                    "through": "do",
                    "of": "z"
                },
                "grouping": {
                    "group": "Grupuj",
                    "ungroup": "Rozgrupuj",
                    "aggregate_count": "Zbiorczo: Razem",
                    "aggregate_sum": "Zbiorczo: Suma",
                    "aggregate_max": "Zbiorczo: Max",
                    "aggregate_min": "Zbiorczo: Min",
                    "aggregate_avg": "Zbiorczo: \u015arednia",
                    "aggregate_remove": "Zbiorczo: Usu\u0144"
                }
            });
            return $delegate;
        } ]);
    } ]);
})();

(function() {
    angular.module("ui.grid").config([ "$provide", function($provide) {
        $provide.decorator("i18nService", [ "$delegate", function($delegate) {
            $delegate.add("pt-br", {
                "headerCell": {
                    "aria": {
                        "defaultFilterLabel": "Filtro por coluna",
                        "removeFilter": "Remover filtro",
                        "columnMenuButtonLabel": "Menu coluna"
                    },
                    "priority": "Prioridade:",
                    "filterLabel": "Filtro por coluna: "
                },
                "aggregate": {
                    "label": "itens"
                },
                "groupPanel": {
                    "description": "Arraste e solte uma coluna aqui para agrupar por essa coluna"
                },
                "search": {
                    "placeholder": "Procurar...",
                    "showingItems": "Mostrando os Itens:",
                    "selectedItems": "Items Selecionados:",
                    "totalItems": "Total de Itens:",
                    "size": "Tamanho da P\xe1gina:",
                    "first": "Primeira P\xe1gina",
                    "next": "Pr\xf3xima P\xe1gina",
                    "previous": "P\xe1gina Anterior",
                    "last": "\xdaltima P\xe1gina"
                },
                "menu": {
                    "text": "Selecione as colunas:"
                },
                "sort": {
                    "ascending": "Ordenar Ascendente",
                    "descending": "Ordenar Descendente",
                    "none": "Nenhuma Ordem",
                    "remove": "Remover Ordena\xe7\xe3o"
                },
                "column": {
                    "hide": "Esconder coluna"
                },
                "aggregation": {
                    "count": "total de linhas: ",
                    "sum": "total: ",
                    "avg": "med: ",
                    "min": "min: ",
                    "max": "max: "
                },
                "pinning": {
                    "pinLeft": "Fixar Esquerda",
                    "pinRight": "Fixar Direita",
                    "unpin": "Desprender"
                },
                "columnMenu": {
                    "close": "Fechar"
                },
                "gridMenu": {
                    "aria": {
                        "buttonLabel": "Menu Grid"
                    },
                    "columns": "Colunas:",
                    "importerTitle": "Importar arquivo",
                    "exporterAllAsCsv": "Exportar todos os dados como csv",
                    "exporterVisibleAsCsv": "Exportar dados vis\xedveis como csv",
                    "exporterSelectedAsCsv": "Exportar dados selecionados como csv",
                    "exporterAllAsPdf": "Exportar todos os dados como pdf",
                    "exporterVisibleAsPdf": "Exportar dados vis\xedveis como pdf",
                    "exporterSelectedAsPdf": "Exportar dados selecionados como pdf",
                    "clearAllFilters": "Limpar todos os filtros"
                },
                "importer": {
                    "noHeaders": "Nomes de colunas n\xe3o puderam ser derivados. O arquivo tem um cabe\xe7alho?",
                    "noObjects": "Objetos n\xe3o puderam ser derivados. Havia dados no arquivo, al\xe9m dos cabe\xe7alhos?",
                    "invalidCsv": "Arquivo n\xe3o pode ser processado. \xc9 um CSV v\xe1lido?",
                    "invalidJson": "Arquivo n\xe3o pode ser processado. \xc9 um Json v\xe1lido?",
                    "jsonNotArray": "Arquivo json importado tem que conter um array. Abortando."
                },
                "pagination": {
                    "aria": {
                        "pageToFirst": "Primeira p\xe1gina",
                        "pageBack": "P\xe1gina anterior",
                        "pageSelected": "P\xe1gina Selecionada",
                        "pageForward": "Proxima",
                        "pageToLast": "Anterior"
                    },
                    "sizes": "itens por p\xe1gina",
                    "totalItems": "itens",
                    "through": "atrav\xe9s dos",
                    "of": "de"
                },
                "grouping": {
                    "group": "Agrupar",
                    "ungroup": "Desagrupar",
                    "aggregate_count": "Agr: Contar",
                    "aggregate_sum": "Agr: Soma",
                    "aggregate_max": "Agr: Max",
                    "aggregate_min": "Agr: Min",
                    "aggregate_avg": "Agr: Med",
                    "aggregate_remove": "Agr: Remover"
                }
            });
            return $delegate;
        } ]);
    } ]);
})();

(function() {
    angular.module("ui.grid").config([ "$provide", function($provide) {
        $provide.decorator("i18nService", [ "$delegate", function($delegate) {
            $delegate.add("pt", {
                "headerCell": {
                    "aria": {
                        "defaultFilterLabel": "Filtro por coluna",
                        "removeFilter": "Remover filtro",
                        "columnMenuButtonLabel": "Menu coluna"
                    },
                    "priority": "Prioridade:",
                    "filterLabel": "Filtro por coluna: "
                },
                "aggregate": {
                    "label": "itens"
                },
                "groupPanel": {
                    "description": "Arraste e solte uma coluna aqui para agrupar por essa coluna"
                },
                "search": {
                    "placeholder": "Procurar...",
                    "showingItems": "Mostrando os Itens:",
                    "selectedItems": "Itens Selecionados:",
                    "totalItems": "Total de Itens:",
                    "size": "Tamanho da P\xe1gina:",
                    "first": "Primeira P\xe1gina",
                    "next": "Pr\xf3xima P\xe1gina",
                    "previous": "P\xe1gina Anterior",
                    "last": "\xdaltima P\xe1gina"
                },
                "menu": {
                    "text": "Selecione as colunas:"
                },
                "sort": {
                    "ascending": "Ordenar Ascendente",
                    "descending": "Ordenar Descendente",
                    "none": "Nenhuma Ordem",
                    "remove": "Remover Ordena\xe7\xe3o"
                },
                "column": {
                    "hide": "Esconder coluna"
                },
                "aggregation": {
                    "count": "total de linhas: ",
                    "sum": "total: ",
                    "avg": "med: ",
                    "min": "min: ",
                    "max": "max: "
                },
                "pinning": {
                    "pinLeft": "Fixar Esquerda",
                    "pinRight": "Fixar Direita",
                    "unpin": "Desprender"
                },
                "columnMenu": {
                    "close": "Fechar"
                },
                "gridMenu": {
                    "aria": {
                        "buttonLabel": "Menu Grid"
                    },
                    "columns": "Colunas:",
                    "importerTitle": "Importar ficheiro",
                    "exporterAllAsCsv": "Exportar todos os dados como csv",
                    "exporterVisibleAsCsv": "Exportar dados vis\xedveis como csv",
                    "exporterSelectedAsCsv": "Exportar dados selecionados como csv",
                    "exporterAllAsPdf": "Exportar todos os dados como pdf",
                    "exporterVisibleAsPdf": "Exportar dados vis\xedveis como pdf",
                    "exporterSelectedAsPdf": "Exportar dados selecionados como pdf",
                    "clearAllFilters": "Limpar todos os filtros"
                },
                "importer": {
                    "noHeaders": "Nomes de colunas n\xe3o puderam ser derivados. O ficheiro tem um cabe\xe7alho?",
                    "noObjects": "Objetos n\xe3o puderam ser derivados. Havia dados no ficheiro, al\xe9m dos cabe\xe7alhos?",
                    "invalidCsv": "Ficheiro n\xe3o pode ser processado. \xc9 um CSV v\xe1lido?",
                    "invalidJson": "Ficheiro n\xe3o pode ser processado. \xc9 um Json v\xe1lido?",
                    "jsonNotArray": "Ficheiro json importado tem que conter um array. Interrompendo."
                },
                "pagination": {
                    "aria": {
                        "pageToFirst": "Primeira p\xe1gina",
                        "pageBack": "P\xe1gina anterior",
                        "pageSelected": "P\xe1gina Selecionada",
                        "pageForward": "Pr\xf3xima",
                        "pageToLast": "Anterior"
                    },
                    "sizes": "itens por p\xe1gina",
                    "totalItems": "itens",
                    "through": "atrav\xe9s dos",
                    "of": "de"
                },
                "grouping": {
                    "group": "Agrupar",
                    "ungroup": "Desagrupar",
                    "aggregate_count": "Agr: Contar",
                    "aggregate_sum": "Agr: Soma",
                    "aggregate_max": "Agr: Max",
                    "aggregate_min": "Agr: Min",
                    "aggregate_avg": "Agr: Med",
                    "aggregate_remove": "Agr: Remover"
                }
            });
            return $delegate;
        } ]);
    } ]);
})();

(function() {
    angular.module("ui.grid").config([ "$provide", function($provide) {
        $provide.decorator("i18nService", [ "$delegate", function($delegate) {
            $delegate.add("ro", {
                "headerCell": {
                    "aria": {
                        "defaultFilterLabel": "Filtru pentru coloana",
                        "removeFilter": "Sterge filtru",
                        "columnMenuButtonLabel": "Column Menu"
                    },
                    "priority": "Prioritate:",
                    "filterLabel": "Filtru pentru coloana:"
                },
                "aggregate": {
                    "label": "Elemente"
                },
                "groupPanel": {
                    "description": "Trage un cap de coloana aici pentru a grupa elementele dupa coloana respectiva"
                },
                "search": {
                    "placeholder": "Cauta...",
                    "showingItems": "Arata elementele:",
                    "selectedItems": "Elementele selectate:",
                    "totalItems": "Total elemente:",
                    "size": "Marime pagina:",
                    "first": "Prima pagina",
                    "next": "Pagina urmatoare",
                    "previous": "Pagina anterioara",
                    "last": "Ultima pagina"
                },
                "menu": {
                    "text": "Alege coloane:"
                },
                "sort": {
                    "ascending": "Ordoneaza crescator",
                    "descending": "Ordoneaza descrescator",
                    "none": "Fara ordonare",
                    "remove": "Sterge ordonarea"
                },
                "column": {
                    "hide": "Ascunde coloana"
                },
                "aggregation": {
                    "count": "total linii: ",
                    "sum": "total: ",
                    "avg": "medie: ",
                    "min": "min: ",
                    "max": "max: "
                },
                "pinning": {
                    "pinLeft": "Pin la stanga",
                    "pinRight": "Pin la dreapta",
                    "unpin": "Sterge pinul"
                },
                "columnMenu": {
                    "close": "Inchide"
                },
                "gridMenu": {
                    "aria": {
                        "buttonLabel": "Grid Menu"
                    },
                    "columns": "Coloane:",
                    "importerTitle": "Incarca fisier",
                    "exporterAllAsCsv": "Exporta toate datele ca csv",
                    "exporterVisibleAsCsv": "Exporta datele vizibile ca csv",
                    "exporterSelectedAsCsv": "Exporta datele selectate ca csv",
                    "exporterAllAsPdf": "Exporta toate datele ca pdf",
                    "exporterVisibleAsPdf": "Exporta datele vizibile ca pdf",
                    "exporterSelectedAsPdf": "Exporta datele selectate ca csv pdf",
                    "clearAllFilters": "Sterge toate filtrele"
                },
                "importer": {
                    "noHeaders": "Numele coloanelor nu a putut fi incarcat, acest fisier are un header?",
                    "noObjects": "Datele nu au putut fi incarcate, exista date in fisier in afara numelor de coloane?",
                    "invalidCsv": "Fisierul nu a putut fi procesat, ati incarcat un CSV valid ?",
                    "invalidJson": "Fisierul nu a putut fi procesat, ati incarcat un Json valid?",
                    "jsonNotArray": "Json-ul incarcat trebuie sa contina un array, inchidere."
                },
                "pagination": {
                    "aria": {
                        "pageToFirst": "Prima pagina",
                        "pageBack": "O pagina inapoi",
                        "pageSelected": "Pagina selectata",
                        "pageForward": "O pagina inainte",
                        "pageToLast": "Ultima pagina"
                    },
                    "sizes": "Elemente per pagina",
                    "totalItems": "elemente",
                    "through": "prin",
                    "of": "of"
                },
                "grouping": {
                    "group": "Grupeaza",
                    "ungroup": "Opreste gruparea",
                    "aggregate_count": "Agg: Count",
                    "aggregate_sum": "Agg: Sum",
                    "aggregate_max": "Agg: Max",
                    "aggregate_min": "Agg: Min",
                    "aggregate_avg": "Agg: Avg",
                    "aggregate_remove": "Agg: Remove"
                }
            });
            return $delegate;
        } ]);
    } ]);
})();

(function() {
    angular.module("ui.grid").config([ "$provide", function($provide) {
        $provide.decorator("i18nService", [ "$delegate", function($delegate) {
            $delegate.add("ru", {
                "headerCell": {
                    "aria": {
                        "defaultFilterLabel": "\u0424\u0438\u043b\u044c\u0442\u0440 \u0441\u0442\u043e\u043b\u0431\u0446\u0430",
                        "removeFilter": "\u0423\u0434\u0430\u043b\u0438\u0442\u044c \u0444\u0438\u043b\u044c\u0442\u0440",
                        "columnMenuButtonLabel": "\u041c\u0435\u043d\u044e \u0441\u0442\u043e\u043b\u0431\u0446\u0430"
                    },
                    "priority": "\u041f\u0440\u0438\u043e\u0440\u0438\u0442\u0435\u0442:",
                    "filterLabel": "\u0424\u0438\u043b\u044c\u0442\u0440 \u0441\u0442\u043e\u043b\u0431\u0446\u0430: "
                },
                "aggregate": {
                    "label": "\u044d\u043b\u0435\u043c\u0435\u043d\u0442\u044b"
                },
                "groupPanel": {
                    "description": "\u0414\u043b\u044f \u0433\u0440\u0443\u043f\u043f\u0438\u0440\u043e\u0432\u043a\u0438 \u043f\u043e \u0441\u0442\u043e\u043b\u0431\u0446\u0443 \u043f\u0435\u0440\u0435\u0442\u0430\u0449\u0438\u0442\u0435 \u0441\u044e\u0434\u0430 \u0435\u0433\u043e \u043d\u0430\u0437\u0432\u0430\u043d\u0438\u0435."
                },
                "search": {
                    "placeholder": "\u041f\u043e\u0438\u0441\u043a...",
                    "showingItems": "\u041f\u043e\u043a\u0430\u0437\u0430\u0442\u044c \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u044b:",
                    "selectedItems": "\u0412\u044b\u0431\u0440\u0430\u043d\u043d\u044b\u0435 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u044b:",
                    "totalItems": "\u0412\u0441\u0435\u0433\u043e \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432:",
                    "size": "\u0420\u0430\u0437\u043c\u0435\u0440 \u0441\u0442\u0440\u0430\u043d\u0438\u0446\u044b:",
                    "first": "\u041f\u0435\u0440\u0432\u0430\u044f \u0441\u0442\u0440\u0430\u043d\u0438\u0446\u0430",
                    "next": "\u0421\u043b\u0435\u0434\u0443\u044e\u0449\u0430\u044f \u0441\u0442\u0440\u0430\u043d\u0438\u0446\u0430",
                    "previous": "\u041f\u0440\u0435\u0434\u044b\u0434\u0443\u0449\u0430\u044f \u0441\u0442\u0440\u0430\u043d\u0438\u0446\u0430",
                    "last": "\u041f\u043e\u0441\u043b\u0435\u0434\u043d\u044f\u044f \u0441\u0442\u0440\u0430\u043d\u0438\u0446\u0430"
                },
                "menu": {
                    "text": "\u0412\u044b\u0431\u0440\u0430\u0442\u044c \u0441\u0442\u043e\u043b\u0431\u0446\u044b:"
                },
                "sort": {
                    "ascending": "\u041f\u043e \u0432\u043e\u0437\u0440\u0430\u0441\u0442\u0430\u043d\u0438\u044e",
                    "descending": "\u041f\u043e \u0443\u0431\u044b\u0432\u0430\u043d\u0438\u044e",
                    "none": "\u0411\u0435\u0437 \u0441\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u043a\u0438",
                    "remove": "\u0423\u0431\u0440\u0430\u0442\u044c \u0441\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u043a\u0443"
                },
                "column": {
                    "hide": "\u0421\u043f\u0440\u044f\u0442\u0430\u0442\u044c \u0441\u0442\u043e\u043b\u0431\u0435\u0446"
                },
                "aggregation": {
                    "count": "\u0432\u0441\u0435\u0433\u043e \u0441\u0442\u0440\u043e\u043a: ",
                    "sum": "\u0438\u0442\u043e\u0433\u043e: ",
                    "avg": "\u0441\u0440\u0435\u0434\u043d\u0435\u0435: ",
                    "min": "\u043c\u0438\u043d: ",
                    "max": "\u043c\u0430\u043a\u0441: "
                },
                "pinning": {
                    "pinLeft": "\u0417\u0430\u043a\u0440\u0435\u043f\u0438\u0442\u044c \u0441\u043b\u0435\u0432\u0430",
                    "pinRight": "\u0417\u0430\u043a\u0440\u0435\u043f\u0438\u0442\u044c \u0441\u043f\u0440\u0430\u0432\u0430",
                    "unpin": "\u041e\u0442\u043a\u0440\u0435\u043f\u0438\u0442\u044c"
                },
                "columnMenu": {
                    "close": "\u0417\u0430\u043a\u0440\u044b\u0442\u044c"
                },
                "gridMenu": {
                    "aria": {
                        "buttonLabel": "\u041c\u0435\u043d\u044e"
                    },
                    "columns": "\u0421\u0442\u043e\u043b\u0431\u0446\u044b:",
                    "importerTitle": "\u0418\u043c\u043f\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u0444\u0430\u0439\u043b",
                    "exporterAllAsCsv": "\u042d\u043a\u0441\u043f\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u0432\u0441\u0451 \u0432 CSV",
                    "exporterVisibleAsCsv": "\u042d\u043a\u0441\u043f\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u0432\u0438\u0434\u0438\u043c\u044b\u0435 \u0434\u0430\u043d\u043d\u044b\u0435 \u0432 CSV",
                    "exporterSelectedAsCsv": "\u042d\u043a\u0441\u043f\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u0432\u044b\u0431\u0440\u0430\u043d\u043d\u044b\u0435 \u0434\u0430\u043d\u043d\u044b\u0435 \u0432 CSV",
                    "exporterAllAsPdf": "\u042d\u043a\u0441\u043f\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u0432\u0441\u0451 \u0432 PDF",
                    "exporterVisibleAsPdf": "\u042d\u043a\u0441\u043f\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u0432\u0438\u0434\u0438\u043c\u044b\u0435 \u0434\u0430\u043d\u043d\u044b\u0435 \u0432 PDF",
                    "exporterSelectedAsPdf": "\u042d\u043a\u0441\u043f\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u0432\u044b\u0431\u0440\u0430\u043d\u043d\u044b\u0435 \u0434\u0430\u043d\u043d\u044b\u0435 \u0432 PDF",
                    "clearAllFilters": "\u041e\u0447\u0438\u0441\u0442\u0438\u0442\u0435 \u0432\u0441\u0435 \u0444\u0438\u043b\u044c\u0442\u0440\u044b"
                },
                "importer": {
                    "noHeaders": "\u041d\u0435 \u0443\u0434\u0430\u043b\u043e\u0441\u044c \u043f\u043e\u043b\u0443\u0447\u0438\u0442\u044c \u043d\u0430\u0437\u0432\u0430\u043d\u0438\u044f \u0441\u0442\u043e\u043b\u0431\u0446\u043e\u0432, \u0435\u0441\u0442\u044c \u043b\u0438 \u0432 \u0444\u0430\u0439\u043b\u0435 \u0437\u0430\u0433\u043e\u043b\u043e\u0432\u043e\u043a?",
                    "noObjects": "\u041d\u0435 \u0443\u0434\u0430\u043b\u043e\u0441\u044c \u043f\u043e\u043b\u0443\u0447\u0438\u0442\u044c \u0434\u0430\u043d\u043d\u044b\u0435, \u0435\u0441\u0442\u044c \u043b\u0438 \u0432 \u0444\u0430\u0439\u043b\u0435 \u0441\u0442\u0440\u043e\u043a\u0438 \u043a\u0440\u043e\u043c\u0435 \u0437\u0430\u0433\u043e\u043b\u043e\u0432\u043a\u0430?",
                    "invalidCsv": "\u041d\u0435 \u0443\u0434\u0430\u043b\u043e\u0441\u044c \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u0430\u0442\u044c \u0444\u0430\u0439\u043b, \u044d\u0442\u043e \u043f\u0440\u0430\u0432\u0438\u043b\u044c\u043d\u044b\u0439 CSV-\u0444\u0430\u0439\u043b?",
                    "invalidJson": "\u041d\u0435 \u0443\u0434\u0430\u043b\u043e\u0441\u044c \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u0430\u0442\u044c \u0444\u0430\u0439\u043b, \u044d\u0442\u043e \u043f\u0440\u0430\u0432\u0438\u043b\u044c\u043d\u044b\u0439 JSON?",
                    "jsonNotArray": "\u0418\u043c\u043f\u043e\u0440\u0442\u0438\u0440\u0443\u0435\u043c\u044b\u0439 JSON-\u0444\u0430\u0439\u043b \u0434\u043e\u043b\u0436\u0435\u043d \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0442\u044c \u043c\u0430\u0441\u0441\u0438\u0432, \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u044f \u043e\u0442\u043c\u0435\u043d\u0435\u043d\u0430."
                },
                "pagination": {
                    "aria": {
                        "pageToFirst": "\u041f\u0435\u0440\u0432\u0430\u044f \u0441\u0442\u0440\u0430\u043d\u0438\u0446\u0430",
                        "pageBack": "\u041f\u0440\u0435\u0434\u044b\u0434\u0443\u0449\u0430\u044f \u0441\u0442\u0440\u0430\u043d\u0438\u0446\u0430",
                        "pageSelected": "\u0412\u044b\u0431\u0440\u0430\u043d\u043d\u0430\u044f \u0441\u0442\u0440\u0430\u043d\u0438\u0446\u0430",
                        "pageForward": "\u0421\u043b\u0435\u0434\u0443\u044e\u0449\u0430\u044f \u0441\u0442\u0440\u0430\u043d\u0438\u0446\u0430",
                        "pageToLast": "\u041f\u043e\u0441\u043b\u0435\u0434\u043d\u044f\u044f \u0441\u0442\u0440\u0430\u043d\u0438\u0446\u0430"
                    },
                    "sizes": "\u0441\u0442\u0440\u043e\u043a \u043d\u0430 \u0441\u0442\u0440\u0430\u043d\u0438\u0446\u0443",
                    "totalItems": "\u0441\u0442\u0440\u043e\u043a",
                    "through": "\u043f\u043e",
                    "of": "\u0438\u0437"
                },
                "grouping": {
                    "group": "\u0413\u0440\u0443\u043f\u043f\u0438\u0440\u043e\u0432\u0430\u0442\u044c",
                    "ungroup": "\u0420\u0430\u0437\u0433\u0440\u0443\u043f\u043f\u0438\u0440\u043e\u0432\u0430\u0442\u044c",
                    "aggregate_count": "\u0413\u0440\u0443\u043f\u043f\u0438\u0440\u043e\u0432\u0430\u0442\u044c: Count",
                    "aggregate_sum": "\u0414\u043b\u044f \u0433\u0440\u0443\u043f\u043f\u044b: \u0421\u0443\u043c\u043c\u0430",
                    "aggregate_max": "\u0414\u043b\u044f \u0433\u0440\u0443\u043f\u043f\u044b: \u041c\u0430\u043a\u0441\u0438\u043c\u0443\u043c",
                    "aggregate_min": "\u0414\u043b\u044f \u0433\u0440\u0443\u043f\u043f\u044b: \u041c\u0438\u043d\u0438\u043c\u0443\u043c",
                    "aggregate_avg": "\u0414\u043b\u044f \u0433\u0440\u0443\u043f\u043f\u044b: \u0421\u0440\u0435\u0434\u043d\u0435\u0435",
                    "aggregate_remove": "\u0414\u043b\u044f \u0433\u0440\u0443\u043f\u043f\u044b: \u041f\u0443\u0441\u0442\u043e"
                }
            });
            return $delegate;
        } ]);
    } ]);
})();

(function() {
    angular.module("ui.grid").config([ "$provide", function($provide) {
        $provide.decorator("i18nService", [ "$delegate", function($delegate) {
            $delegate.add("sk", {
                "aggregate": {
                    "label": "items"
                },
                "groupPanel": {
                    "description": "Pretiahni sem n\xe1zov st\u013apca pre zoskupenie pod\u013ea toho st\u013apca."
                },
                "search": {
                    "placeholder": "H\u013eadaj...",
                    "showingItems": "Zobrazujem polo\u017eky:",
                    "selectedItems": "Vybrat\xe9 polo\u017eky:",
                    "totalItems": "Po\u010det polo\u017eiek:",
                    "size": "Po\u010det:",
                    "first": "Prv\xe1 strana",
                    "next": "\u010eal\u0161ia strana",
                    "previous": "Predch\xe1dzaj\xfaca strana",
                    "last": "Posledn\xe1 strana"
                },
                "menu": {
                    "text": "Vyberte st\u013apce:"
                },
                "sort": {
                    "ascending": "Zotriedi\u0165 vzostupne",
                    "descending": "Zotriedi\u0165 zostupne",
                    "remove": "Vymaza\u0165 triedenie"
                },
                "aggregation": {
                    "count": "total rows: ",
                    "sum": "total: ",
                    "avg": "avg: ",
                    "min": "min: ",
                    "max": "max: "
                },
                "gridMenu": {
                    "columns": "Columns:",
                    "importerTitle": "Import file",
                    "exporterAllAsCsv": "Export all data as csv",
                    "exporterVisibleAsCsv": "Export visible data as csv",
                    "exporterSelectedAsCsv": "Export selected data as csv",
                    "exporterAllAsPdf": "Export all data as pdf",
                    "exporterVisibleAsPdf": "Export visible data as pdf",
                    "exporterSelectedAsPdf": "Export selected data as pdf",
                    "clearAllFilters": "Clear all filters"
                },
                "importer": {
                    "noHeaders": "Column names were unable to be derived, does the file have a header?",
                    "noObjects": "Objects were not able to be derived, was there data in the file other than headers?",
                    "invalidCsv": "File was unable to be processed, is it valid CSV?",
                    "invalidJson": "File was unable to be processed, is it valid Json?",
                    "jsonNotArray": "Imported json file must contain an array, aborting."
                }
            });
            return $delegate;
        } ]);
    } ]);
})();

(function() {
    angular.module("ui.grid").config([ "$provide", function($provide) {
        $provide.decorator("i18nService", [ "$delegate", function($delegate) {
            $delegate.add("sv", {
                "aggregate": {
                    "label": "Artiklar"
                },
                "groupPanel": {
                    "description": "Dra en kolumnrubrik hit och sl\xe4pp den f\xf6r att gruppera efter den kolumnen."
                },
                "search": {
                    "placeholder": "S\xf6k...",
                    "showingItems": "Visar artiklar:",
                    "selectedItems": "Valda artiklar:",
                    "totalItems": "Antal artiklar:",
                    "size": "Sidstorlek:",
                    "first": "F\xf6rsta sidan",
                    "next": "N\xe4sta sida",
                    "previous": "F\xf6reg\xe5ende sida",
                    "last": "Sista sidan"
                },
                "menu": {
                    "text": "V\xe4lj kolumner:"
                },
                "sort": {
                    "ascending": "Sortera stigande",
                    "descending": "Sortera fallande",
                    "remove": "Inaktivera sortering"
                },
                "column": {
                    "hide": "G\xf6m kolumn"
                },
                "aggregation": {
                    "count": "Antal rader: ",
                    "sum": "Summa: ",
                    "avg": "Genomsnitt: ",
                    "min": "Min: ",
                    "max": "Max: "
                },
                "pinning": {
                    "pinLeft": "F\xe4st v\xe4nster",
                    "pinRight": "F\xe4st h\xf6ger",
                    "unpin": "L\xf6sg\xf6r"
                },
                "gridMenu": {
                    "columns": "Kolumner:",
                    "importerTitle": "Importera fil",
                    "exporterAllAsCsv": "Exportera all data som CSV",
                    "exporterVisibleAsCsv": "Exportera synlig data som CSV",
                    "exporterSelectedAsCsv": "Exportera markerad data som CSV",
                    "exporterAllAsPdf": "Exportera all data som PDF",
                    "exporterVisibleAsPdf": "Exportera synlig data som PDF",
                    "exporterSelectedAsPdf": "Exportera markerad data som PDF",
                    "clearAllFilters": "Reng\xf6r alla filter"
                },
                "importer": {
                    "noHeaders": "Kolumnnamn kunde inte h\xe4rledas. Har filen ett sidhuvud?",
                    "noObjects": "Objekt kunde inte h\xe4rledas. Har filen data undantaget sidhuvud?",
                    "invalidCsv": "Filen kunde inte behandlas, \xe4r den en giltig CSV?",
                    "invalidJson": "Filen kunde inte behandlas, \xe4r den en giltig JSON?",
                    "jsonNotArray": "Importerad JSON-fil m\xe5ste inneh\xe5lla ett f\xe4lt. Import avbruten."
                },
                "pagination": {
                    "sizes": "Artiklar per sida",
                    "totalItems": "Artiklar"
                }
            });
            return $delegate;
        } ]);
    } ]);
})();

(function() {
    angular.module("ui.grid").config([ "$provide", function($provide) {
        $provide.decorator("i18nService", [ "$delegate", function($delegate) {
            $delegate.add("ta", {
                "aggregate": {
                    "label": "\u0b89\u0bb0\u0bc1\u0baa\u0bcd\u0baa\u0b9f\u0bbf\u0b95\u0bb3\u0bcd"
                },
                "groupPanel": {
                    "description": "\u0b92\u0bb0\u0bc1 \u0baa\u0ba4\u0bcd\u0ba4\u0bbf\u0baf\u0bc8 \u0b95\u0bc1\u0bb4\u0bc1\u0bb5\u0bbe\u0b95 \u0b85\u0bae\u0bc8\u0b95\u0bcd\u0b95 \u0b85\u0baa\u0bcd\u0baa\u0ba4\u0bcd\u0ba4\u0bbf\u0baf\u0bbf\u0ba9\u0bcd \u0ba4\u0bb2\u0bc8\u0baa\u0bcd\u0baa\u0bc8 \u0b87\u0b99\u0bcd\u0b95\u0bc7  \u0b87\u0bb4\u0bc1\u0ba4\u0bcd\u0ba4\u0bc1 \u0bb5\u0bb0\u0bb5\u0bc1\u0bae\u0bcd "
                },
                "search": {
                    "placeholder": "\u0ba4\u0bc7\u0b9f\u0bb2\u0bcd ...",
                    "showingItems": "\u0b89\u0bb0\u0bc1\u0baa\u0bcd\u0baa\u0b9f\u0bbf\u0b95\u0bb3\u0bc8 \u0b95\u0bbe\u0ba3\u0bcd\u0baa\u0bbf\u0ba4\u0bcd\u0ba4\u0bb2\u0bcd:",
                    "selectedItems": "\u0ba4\u0bc7\u0bb0\u0bcd\u0ba8\u0bcd\u0ba4\u0bc6\u0b9f\u0bc1\u0b95\u0bcd\u0b95\u0baa\u0bcd\u0baa\u0b9f\u0bcd\u0b9f  \u0b89\u0bb0\u0bc1\u0baa\u0bcd\u0baa\u0b9f\u0bbf\u0b95\u0bb3\u0bcd:",
                    "totalItems": "\u0bae\u0bca\u0ba4\u0bcd\u0ba4 \u0b89\u0bb0\u0bc1\u0baa\u0bcd\u0baa\u0b9f\u0bbf\u0b95\u0bb3\u0bcd:",
                    "size": "\u0baa\u0b95\u0bcd\u0b95 \u0b85\u0bb3\u0bb5\u0bc1: ",
                    "first": "\u0bae\u0bc1\u0ba4\u0bb2\u0bcd \u0baa\u0b95\u0bcd\u0b95\u0bae\u0bcd",
                    "next": "\u0b85\u0b9f\u0bc1\u0ba4\u0bcd\u0ba4 \u0baa\u0b95\u0bcd\u0b95\u0bae\u0bcd",
                    "previous": "\u0bae\u0bc1\u0ba8\u0bcd\u0ba4\u0bc8\u0baf \u0baa\u0b95\u0bcd\u0b95\u0bae\u0bcd ",
                    "last": "\u0b87\u0bb1\u0bc1\u0ba4\u0bbf \u0baa\u0b95\u0bcd\u0b95\u0bae\u0bcd"
                },
                "menu": {
                    "text": "\u0baa\u0ba4\u0bcd\u0ba4\u0bbf\u0b95\u0bb3\u0bc8 \u0ba4\u0bc7\u0bb0\u0bcd\u0ba8\u0bcd\u0ba4\u0bc6\u0b9f\u0bc1:"
                },
                "sort": {
                    "ascending": "\u0bae\u0bc7\u0bb2\u0bbf\u0bb0\u0bc1\u0ba8\u0bcd\u0ba4\u0bc1 \u0b95\u0bc0\u0bb4\u0bbe\u0b95",
                    "descending": "\u0b95\u0bc0\u0bb4\u0bbf\u0bb0\u0bc1\u0ba8\u0bcd\u0ba4\u0bc1 \u0bae\u0bc7\u0bb2\u0bbe\u0b95",
                    "remove": "\u0bb5\u0bb0\u0bbf\u0b9a\u0bc8\u0baf\u0bc8 \u0ba8\u0bc0\u0b95\u0bcd\u0b95\u0bc1"
                },
                "column": {
                    "hide": "\u0baa\u0ba4\u0bcd\u0ba4\u0bbf\u0baf\u0bc8 \u0bae\u0bb1\u0bc8\u0ba4\u0bcd\u0ba4\u0bc1 \u0bb5\u0bc8 "
                },
                "aggregation": {
                    "count": "\u0bae\u0bca\u0ba4\u0bcd\u0ba4 \u0bb5\u0bb0\u0bbf\u0b95\u0bb3\u0bcd:",
                    "sum": "\u0bae\u0bca\u0ba4\u0bcd\u0ba4\u0bae\u0bcd: ",
                    "avg": "\u0b9a\u0bb0\u0bbe\u0b9a\u0bb0\u0bbf: ",
                    "min": "\u0b95\u0bc1\u0bb1\u0bc8\u0ba8\u0bcd\u0ba4\u0baa\u0b9f\u0bcd\u0b9a: ",
                    "max": "\u0b85\u0ba4\u0bbf\u0b95\u0baa\u0b9f\u0bcd\u0b9a: "
                },
                "pinning": {
                    "pinLeft": "\u0b87\u0b9f\u0ba4\u0bc1\u0baa\u0bc1\u0bb1\u0bae\u0bbe\u0b95 \u0ba4\u0bc8\u0b95\u0bcd\u0b95 ",
                    "pinRight": "\u0bb5\u0bb2\u0ba4\u0bc1\u0baa\u0bc1\u0bb1\u0bae\u0bbe\u0b95 \u0ba4\u0bc8\u0b95\u0bcd\u0b95",
                    "unpin": "\u0baa\u0bbf\u0bb0\u0bbf"
                },
                "gridMenu": {
                    "columns": "\u0baa\u0ba4\u0bcd\u0ba4\u0bbf\u0b95\u0bb3\u0bcd:",
                    "importerTitle": "\u0b95\u0bcb\u0baa\u0bcd\u0baa\u0bc1 : \u0baa\u0b9f\u0bbf\u0ba4\u0bcd\u0ba4\u0bb2\u0bcd",
                    "exporterAllAsCsv": "\u0b8e\u0bb2\u0bcd\u0bb2\u0bbe \u0ba4\u0bb0\u0bb5\u0bc1\u0b95\u0bb3\u0bc8\u0baf\u0bc1\u0bae\u0bcd \u0b95\u0bcb\u0baa\u0bcd\u0baa\u0bbe\u0b95\u0bcd\u0b95\u0bc1: csv",
                    "exporterVisibleAsCsv": "\u0b87\u0bb0\u0bc1\u0b95\u0bcd\u0b95\u0bc1\u0bae\u0bcd \u0ba4\u0bb0\u0bb5\u0bc1\u0b95\u0bb3\u0bc8 \u0b95\u0bcb\u0baa\u0bcd\u0baa\u0bbe\u0b95\u0bcd\u0b95\u0bc1: csv",
                    "exporterSelectedAsCsv": "\u0ba4\u0bc7\u0bb0\u0bcd\u0ba8\u0bcd\u0ba4\u0bc6\u0b9f\u0bc1\u0ba4\u0bcd\u0ba4 \u0ba4\u0bb0\u0bb5\u0bc1\u0b95\u0bb3\u0bc8 \u0b95\u0bcb\u0baa\u0bcd\u0baa\u0bbe\u0b95\u0bcd\u0b95\u0bc1: csv",
                    "exporterAllAsPdf": "\u0b8e\u0bb2\u0bcd\u0bb2\u0bbe \u0ba4\u0bb0\u0bb5\u0bc1\u0b95\u0bb3\u0bc8\u0baf\u0bc1\u0bae\u0bcd \u0b95\u0bcb\u0baa\u0bcd\u0baa\u0bbe\u0b95\u0bcd\u0b95\u0bc1: pdf",
                    "exporterVisibleAsPdf": "\u0b87\u0bb0\u0bc1\u0b95\u0bcd\u0b95\u0bc1\u0bae\u0bcd \u0ba4\u0bb0\u0bb5\u0bc1\u0b95\u0bb3\u0bc8 \u0b95\u0bcb\u0baa\u0bcd\u0baa\u0bbe\u0b95\u0bcd\u0b95\u0bc1: pdf",
                    "exporterSelectedAsPdf": "\u0ba4\u0bc7\u0bb0\u0bcd\u0ba8\u0bcd\u0ba4\u0bc6\u0b9f\u0bc1\u0ba4\u0bcd\u0ba4 \u0ba4\u0bb0\u0bb5\u0bc1\u0b95\u0bb3\u0bc8 \u0b95\u0bcb\u0baa\u0bcd\u0baa\u0bbe\u0b95\u0bcd\u0b95\u0bc1: pdf",
                    "clearAllFilters": "Clear all filters"
                },
                "importer": {
                    "noHeaders": "\u0baa\u0ba4\u0bcd\u0ba4\u0bbf\u0baf\u0bbf\u0ba9\u0bcd \u0ba4\u0bb2\u0bc8\u0baa\u0bcd\u0baa\u0bc1\u0b95\u0bb3\u0bc8 \u0baa\u0bc6\u0bb1 \u0b87\u0baf\u0bb2\u0bb5\u0bbf\u0bb2\u0bcd\u0bb2\u0bc8, \u0b95\u0bcb\u0baa\u0bcd\u0baa\u0bbf\u0bb1\u0bcd\u0b95\u0bc1 \u0ba4\u0bb2\u0bc8\u0baa\u0bcd\u0baa\u0bc1 \u0b89\u0bb3\u0bcd\u0bb3\u0ba4\u0bbe?",
                    "noObjects": "\u0b87\u0bb2\u0b95\u0bcd\u0b95\u0bc1\u0b95\u0bb3\u0bc8 \u0b89\u0bb0\u0bc1\u0bb5\u0bbe\u0b95\u0bcd\u0b95 \u0bae\u0bc1\u0b9f\u0bbf\u0baf\u0bb5\u0bbf\u0bb2\u0bcd\u0bb2\u0bc8, \u0b95\u0bcb\u0baa\u0bcd\u0baa\u0bbf\u0bb2\u0bcd \u0ba4\u0bb2\u0bc8\u0baa\u0bcd\u0baa\u0bc1\u0b95\u0bb3\u0bc8 \u0ba4\u0bb5\u0bbf\u0bb0 \u0ba4\u0bb0\u0bb5\u0bc1 \u0b8f\u0ba4\u0bc7\u0ba9\u0bc1\u0bae\u0bcd \u0b89\u0bb3\u0bcd\u0bb3\u0ba4\u0bbe? ",
                    "invalidCsv": "\u0b9a\u0bb0\u0bbf\u0bb5\u0bb0 \u0ba8\u0b9f\u0bc8\u0bae\u0bc1\u0bb1\u0bc8 \u0baa\u0b9f\u0bc1\u0ba4\u0bcd\u0ba4 \u0b87\u0baf\u0bb2\u0bb5\u0bbf\u0bb2\u0bcd\u0bb2\u0bc8, \u0b95\u0bcb\u0baa\u0bcd\u0baa\u0bc1 \u0b9a\u0bb0\u0bbf\u0ba4\u0bbe\u0ba9\u0bbe? - csv",
                    "invalidJson": "\u0b9a\u0bb0\u0bbf\u0bb5\u0bb0 \u0ba8\u0b9f\u0bc8\u0bae\u0bc1\u0bb1\u0bc8 \u0baa\u0b9f\u0bc1\u0ba4\u0bcd\u0ba4 \u0b87\u0baf\u0bb2\u0bb5\u0bbf\u0bb2\u0bcd\u0bb2\u0bc8, \u0b95\u0bcb\u0baa\u0bcd\u0baa\u0bc1 \u0b9a\u0bb0\u0bbf\u0ba4\u0bbe\u0ba9\u0bbe? - json",
                    "jsonNotArray": "\u0baa\u0b9f\u0bbf\u0ba4\u0bcd\u0ba4 \u0b95\u0bcb\u0baa\u0bcd\u0baa\u0bbf\u0bb2\u0bcd \u0bb5\u0bb0\u0bbf\u0b9a\u0bc8\u0b95\u0bb3\u0bcd \u0b89\u0bb3\u0bcd\u0bb3\u0ba4\u0bc1, \u0ba8\u0b9f\u0bc8\u0bae\u0bc1\u0bb1\u0bc8 \u0bb0\u0ba4\u0bcd\u0ba4\u0bc1 \u0b9a\u0bc6\u0baf\u0bcd : json"
                },
                "pagination": {
                    "sizes": "\u0b89\u0bb0\u0bc1\u0baa\u0bcd\u0baa\u0b9f\u0bbf\u0b95\u0bb3\u0bcd / \u0baa\u0b95\u0bcd\u0b95\u0bae\u0bcd",
                    "totalItems": "\u0b89\u0bb0\u0bc1\u0baa\u0bcd\u0baa\u0b9f\u0bbf\u0b95\u0bb3\u0bcd "
                },
                "grouping": {
                    "group": "\u0b95\u0bc1\u0bb4\u0bc1",
                    "ungroup": "\u0baa\u0bbf\u0bb0\u0bbf",
                    "aggregate_count": "\u0bae\u0ba4\u0bbf\u0baa\u0bcd\u0baa\u0bc0\u0b9f\u0bcd\u0b9f\u0bc1 : \u0b8e\u0ba3\u0bcd\u0ba3\u0bc1",
                    "aggregate_sum": "\u0bae\u0ba4\u0bbf\u0baa\u0bcd\u0baa\u0bc0\u0b9f\u0bcd\u0b9f\u0bc1 : \u0b95\u0bc2\u0b9f\u0bcd\u0b9f\u0bb2\u0bcd",
                    "aggregate_max": "\u0bae\u0ba4\u0bbf\u0baa\u0bcd\u0baa\u0bc0\u0b9f\u0bcd\u0b9f\u0bc1 : \u0b85\u0ba4\u0bbf\u0b95\u0baa\u0b9f\u0bcd\u0b9a\u0bae\u0bcd",
                    "aggregate_min": "\u0bae\u0ba4\u0bbf\u0baa\u0bcd\u0baa\u0bc0\u0b9f\u0bcd\u0b9f\u0bc1 : \u0b95\u0bc1\u0bb1\u0bc8\u0ba8\u0bcd\u0ba4\u0baa\u0b9f\u0bcd\u0b9a\u0bae\u0bcd",
                    "aggregate_avg": "\u0bae\u0ba4\u0bbf\u0baa\u0bcd\u0baa\u0bc0\u0b9f\u0bcd\u0b9f\u0bc1 : \u0b9a\u0bb0\u0bbe\u0b9a\u0bb0\u0bbf",
                    "aggregate_remove": "\u0bae\u0ba4\u0bbf\u0baa\u0bcd\u0baa\u0bc0\u0b9f\u0bcd\u0b9f\u0bc1 : \u0ba8\u0bc0\u0b95\u0bcd\u0b95\u0bc1"
                }
            });
            return $delegate;
        } ]);
    } ]);
})();

(function() {
    angular.module("ui.grid").config([ "$provide", function($provide) {
        $provide.decorator("i18nService", [ "$delegate", function($delegate) {
            $delegate.add("tr", {
                "headerCell": {
                    "aria": {
                        "defaultFilterLabel": "S\xfctun i\xe7in filtre",
                        "removeFilter": "Filtreyi Kald\u0131r",
                        "columnMenuButtonLabel": "S\xfctun Men\xfcs\xfc"
                    },
                    "priority": "\xd6ncelik:",
                    "filterLabel": "S\xfctun i\xe7in filtre: "
                },
                "aggregate": {
                    "label": "kay\u0131tlar"
                },
                "groupPanel": {
                    "description": "S\xfctuna g\xf6re gruplamak i\xe7in s\xfctun ba\u015fl\u0131\u011f\u0131n\u0131 buraya s\xfcr\xfckleyin ve b\u0131rak\u0131n."
                },
                "search": {
                    "placeholder": "Arama...",
                    "showingItems": "G\xf6sterilen Kay\u0131t:",
                    "selectedItems": "Se\xe7ili Kay\u0131t:",
                    "totalItems": "Toplam Kay\u0131t:",
                    "size": "Sayfa Boyutu:",
                    "first": "\u0130lk Sayfa",
                    "next": "Sonraki Sayfa",
                    "previous": "\xd6nceki Sayfa",
                    "last": "Son Sayfa"
                },
                "menu": {
                    "text": "S\xfctunlar\u0131 Se\xe7:"
                },
                "sort": {
                    "ascending": "Artan S\u0131rada S\u0131rala",
                    "descending": "Azalan S\u0131rada S\u0131rala",
                    "none": "S\u0131ralama Yapma",
                    "remove": "S\u0131ralamay\u0131 Kald\u0131r"
                },
                "column": {
                    "hide": "S\xfctunu Gizle"
                },
                "aggregation": {
                    "count": "toplam sat\u0131r: ",
                    "sum": "toplam: ",
                    "avg": "ort: ",
                    "min": "min: ",
                    "max": "maks: "
                },
                "pinning": {
                    "pinLeft": "Sola Sabitle",
                    "pinRight": "Sa\u011fa Sabitle",
                    "unpin": "Sabitlemeyi Kald\u0131r"
                },
                "columnMenu": {
                    "close": "Kapat"
                },
                "gridMenu": {
                    "aria": {
                        "buttonLabel": "Tablo Men\xfc"
                    },
                    "columns": "S\xfctunlar:",
                    "importerTitle": "Dosya i\xe7eri aktar",
                    "exporterAllAsCsv": "B\xfct\xfcn veriyi CSV olarak d\u0131\u015far\u0131 aktar",
                    "exporterVisibleAsCsv": "G\xf6r\xfcnen veriyi CSV olarak d\u0131\u015far\u0131 aktar",
                    "exporterSelectedAsCsv": "Se\xe7ili veriyi CSV olarak d\u0131\u015far\u0131 aktar",
                    "exporterAllAsPdf": "B\xfct\xfcn veriyi PDF olarak d\u0131\u015far\u0131 aktar",
                    "exporterVisibleAsPdf": "G\xf6r\xfcnen veriyi PDF olarak d\u0131\u015far\u0131 aktar",
                    "exporterSelectedAsPdf": "Se\xe7ili veriyi PDF olarak d\u0131\u015far\u0131 aktar",
                    "clearAllFilters": "B\xfct\xfcn filtreleri kald\u0131r"
                },
                "importer": {
                    "noHeaders": "S\xfctun isimleri \xfcretilemiyor, dosyan\u0131n bir ba\u015fl\u0131\u011f\u0131 var m\u0131?",
                    "noObjects": "Nesneler \xfcretilemiyor, dosyada ba\u015fl\u0131ktan ba\u015fka bir veri var m\u0131?",
                    "invalidCsv": "Dosya i\u015flenemedi, ge\xe7erli bir CSV dosyas\u0131 m\u0131?",
                    "invalidJson": "Dosya i\u015flenemedi, ge\xe7erli bir Json dosyas\u0131 m\u0131?",
                    "jsonNotArray": "Al\u0131nan Json dosyas\u0131nda bir dizi bulunmal\u0131d\u0131r, i\u015flem iptal ediliyor."
                },
                "pagination": {
                    "aria": {
                        "pageToFirst": "\u0130lk sayfaya",
                        "pageBack": "Geri git",
                        "pageSelected": "Se\xe7ili sayfa",
                        "pageForward": "\u0130leri git",
                        "pageToLast": "Sona git"
                    },
                    "sizes": "Sayfadaki nesne say\u0131s\u0131",
                    "totalItems": "kay\u0131tlar",
                    "through": "",
                    "of": ""
                },
                "grouping": {
                    "group": "Grupla",
                    "ungroup": "Gruplama",
                    "aggregate_count": "Yekun: Say\u0131",
                    "aggregate_sum": "Yekun: Toplam",
                    "aggregate_max": "Yekun: Maks",
                    "aggregate_min": "Yekun: Min",
                    "aggregate_avg": "Yekun: Ort",
                    "aggregate_remove": "Yekun: Sil"
                }
            });
            return $delegate;
        } ]);
    } ]);
})();

(function() {
    var DIRECTIVE_ALIASES = [ "uiT", "uiTranslate" ];
    var FILTER_ALIASES = [ "t", "uiTranslate" ];
    var module = angular.module("ui.grid.i18n");
    module.constant("i18nConstants", {
        "MISSING": "[MISSING]",
        "UPDATE_EVENT": "$uiI18n",
        "LOCALE_DIRECTIVE_ALIAS": "uiI18n",
        "DEFAULT_LANG": "en"
    });
    module.service("i18nService", [ "$log", "i18nConstants", "$rootScope", function($log, i18nConstants, $rootScope) {
        var langCache = {
            "_langs": {},
            "current": null,
            "get": function(lang) {
                return this._langs[lang.toLowerCase()];
            },
            "add": function(lang, strings) {
                var lower = lang.toLowerCase();
                if (!this._langs[lower]) {
                    this._langs[lower] = {};
                }
                angular.extend(this._langs[lower], strings);
            },
            "getAllLangs": function() {
                var langs = [];
                if (!this._langs) {
                    return langs;
                }
                for (var key in this._langs) {
                    langs.push(key);
                }
                return langs;
            },
            "setCurrent": function(lang) {
                this.current = lang.toLowerCase();
            },
            "getCurrentLang": function() {
                return this.current;
            }
        };
        var service = {
            "add": function(langs, stringMaps) {
                if (typeof langs === "object") {
                    angular.forEach(langs, function(lang) {
                        if (lang) {
                            langCache.add(lang, stringMaps);
                        }
                    });
                } else {
                    langCache.add(langs, stringMaps);
                }
            },
            "getAllLangs": function() {
                return langCache.getAllLangs();
            },
            "get": function(lang) {
                var language = lang ? lang : service.getCurrentLang();
                return langCache.get(language);
            },
            "getSafeText": function(path, lang) {
                var language = lang ? lang : service.getCurrentLang();
                var trans = langCache.get(language);
                if (!trans) {
                    return i18nConstants.MISSING;
                }
                var paths = path.split(".");
                var current = trans;
                for (var i = 0; i < paths.length; ++i) {
                    if (current[paths[i]] === undefined || current[paths[i]] === null) {
                        return i18nConstants.MISSING;
                    } else {
                        current = current[paths[i]];
                    }
                }
                return current;
            },
            "setCurrentLang": function(lang) {
                if (lang) {
                    langCache.setCurrent(lang);
                    $rootScope.$broadcast(i18nConstants.UPDATE_EVENT);
                }
            },
            "getCurrentLang": function() {
                var lang = langCache.getCurrentLang();
                if (!lang) {
                    lang = i18nConstants.DEFAULT_LANG;
                    langCache.setCurrent(lang);
                }
                return lang;
            }
        };
        return service;
    } ]);
    var localeDirective = function(i18nService, i18nConstants) {
        return {
            "compile": function() {
                return {
                    "pre": function($scope, $elm, $attrs) {
                        var alias = i18nConstants.LOCALE_DIRECTIVE_ALIAS;
                        var lang = $scope.$eval($attrs[alias]);
                        if (lang) {
                            $scope.$watch($attrs[alias], function() {
                                i18nService.setCurrentLang(lang);
                            });
                        } else if ($attrs.$$observers) {
                            $attrs.$observe(alias, function() {
                                i18nService.setCurrentLang($attrs[alias] || i18nConstants.DEFAULT_LANG);
                            });
                        }
                    }
                };
            }
        };
    };
    module.directive("uiI18n", [ "i18nService", "i18nConstants", localeDirective ]);
    var uitDirective = function($parse, i18nService, i18nConstants) {
        return {
            "restrict": "EA",
            "compile": function() {
                return {
                    "pre": function($scope, $elm, $attrs) {
                        var alias1 = DIRECTIVE_ALIASES[0], alias2 = DIRECTIVE_ALIASES[1];
                        var token = $attrs[alias1] || $attrs[alias2] || $elm.html();
                        var missing = i18nConstants.MISSING + token;
                        var observer;
                        if ($attrs.$$observers) {
                            var prop = $attrs[alias1] ? alias1 : alias2;
                            observer = $attrs.$observe(prop, function(result) {
                                if (result) {
                                    $elm.html($parse(result)(i18nService.getCurrentLang()) || missing);
                                }
                            });
                        }
                        var getter = $parse(token);
                        var listener = $scope.$on(i18nConstants.UPDATE_EVENT, function(evt) {
                            if (observer) {
                                observer($attrs[alias1] || $attrs[alias2]);
                            } else {
                                $elm.html(getter(i18nService.get()) || missing);
                            }
                        });
                        $scope.$on("$destroy", listener);
                        $elm.html(getter(i18nService.get()) || missing);
                    }
                };
            }
        };
    };
    angular.forEach(DIRECTIVE_ALIASES, function(alias) {
        module.directive(alias, [ "$parse", "i18nService", "i18nConstants", uitDirective ]);
    });
    var uitFilter = function($parse, i18nService, i18nConstants) {
        return function(data) {
            var getter = $parse(data);
            return getter(i18nService.get()) || i18nConstants.MISSING + data;
        };
    };
    angular.forEach(FILTER_ALIASES, function(alias) {
        module.filter(alias, [ "$parse", "i18nService", "i18nConstants", uitFilter ]);
    });
})();

(function() {
    angular.module("ui.grid").config([ "$provide", function($provide) {
        $provide.decorator("i18nService", [ "$delegate", function($delegate) {
            $delegate.add("zh-cn", {
                "headerCell": {
                    "aria": {
                        "defaultFilterLabel": "\u5217\u8fc7\u6ee4\u5668",
                        "removeFilter": "\u79fb\u9664\u8fc7\u6ee4\u5668",
                        "columnMenuButtonLabel": "\u5217\u83dc\u5355"
                    },
                    "priority": "\u4f18\u5148\u7ea7:",
                    "filterLabel": "\u5217\u8fc7\u6ee4\u5668: "
                },
                "aggregate": {
                    "label": "\u884c"
                },
                "groupPanel": {
                    "description": "\u62d6\u66f3\u8868\u5934\u5230\u6b64\u5904\u8fdb\u884c\u5206\u7ec4"
                },
                "search": {
                    "placeholder": "\u67e5\u627e",
                    "showingItems": "\u5df2\u663e\u793a\u884c\u6570\uff1a",
                    "selectedItems": "\u5df2\u9009\u62e9\u884c\u6570\uff1a",
                    "totalItems": "\u603b\u884c\u6570\uff1a",
                    "size": "\u6bcf\u9875\u663e\u793a\u884c\u6570\uff1a",
                    "first": "\u9996\u9875",
                    "next": "\u4e0b\u4e00\u9875",
                    "previous": "\u4e0a\u4e00\u9875",
                    "last": "\u672b\u9875"
                },
                "menu": {
                    "text": "\u9009\u62e9\u5217\uff1a"
                },
                "sort": {
                    "ascending": "\u5347\u5e8f",
                    "descending": "\u964d\u5e8f",
                    "none": "\u65e0\u5e8f",
                    "remove": "\u53d6\u6d88\u6392\u5e8f"
                },
                "column": {
                    "hide": "\u9690\u85cf\u5217"
                },
                "aggregation": {
                    "count": "\u8ba1\u6570\uff1a",
                    "sum": "\u6c42\u548c\uff1a",
                    "avg": "\u5747\u503c\uff1a",
                    "min": "\u6700\u5c0f\u503c\uff1a",
                    "max": "\u6700\u5927\u503c\uff1a"
                },
                "pinning": {
                    "pinLeft": "\u5de6\u4fa7\u56fa\u5b9a",
                    "pinRight": "\u53f3\u4fa7\u56fa\u5b9a",
                    "unpin": "\u53d6\u6d88\u56fa\u5b9a"
                },
                "columnMenu": {
                    "close": "\u5173\u95ed"
                },
                "gridMenu": {
                    "aria": {
                        "buttonLabel": "\u8868\u683c\u83dc\u5355"
                    },
                    "columns": "\u5217\uff1a",
                    "importerTitle": "\u5bfc\u5165\u6587\u4ef6",
                    "exporterAllAsCsv": "\u5bfc\u51fa\u5168\u90e8\u6570\u636e\u5230CSV",
                    "exporterVisibleAsCsv": "\u5bfc\u51fa\u53ef\u89c1\u6570\u636e\u5230CSV",
                    "exporterSelectedAsCsv": "\u5bfc\u51fa\u5df2\u9009\u6570\u636e\u5230CSV",
                    "exporterAllAsPdf": "\u5bfc\u51fa\u5168\u90e8\u6570\u636e\u5230PDF",
                    "exporterVisibleAsPdf": "\u5bfc\u51fa\u53ef\u89c1\u6570\u636e\u5230PDF",
                    "exporterSelectedAsPdf": "\u5bfc\u51fa\u5df2\u9009\u6570\u636e\u5230PDF",
                    "clearAllFilters": "\u6e05\u9664\u6240\u6709\u8fc7\u6ee4\u5668"
                },
                "importer": {
                    "noHeaders": "\u65e0\u6cd5\u83b7\u53d6\u5217\u540d\uff0c\u786e\u5b9a\u6587\u4ef6\u5305\u542b\u8868\u5934\uff1f",
                    "noObjects": "\u65e0\u6cd5\u83b7\u53d6\u6570\u636e\uff0c\u786e\u5b9a\u6587\u4ef6\u5305\u542b\u6570\u636e\uff1f",
                    "invalidCsv": "\u65e0\u6cd5\u5904\u7406\u6587\u4ef6\uff0c\u786e\u5b9a\u662f\u5408\u6cd5\u7684CSV\u6587\u4ef6\uff1f",
                    "invalidJson": "\u65e0\u6cd5\u5904\u7406\u6587\u4ef6\uff0c\u786e\u5b9a\u662f\u5408\u6cd5\u7684JSON\u6587\u4ef6\uff1f",
                    "jsonNotArray": "\u5bfc\u5165\u7684\u6587\u4ef6\u4e0d\u662fJSON\u6570\u7ec4\uff01"
                },
                "pagination": {
                    "aria": {
                        "pageToFirst": "\u7b2c\u4e00\u9875",
                        "pageBack": "\u4e0a\u4e00\u9875",
                        "pageSelected": "\u5f53\u524d\u9875",
                        "pageForward": "\u4e0b\u4e00\u9875",
                        "pageToLast": "\u6700\u540e\u4e00\u9875"
                    },
                    "sizes": "\u884c\u6bcf\u9875",
                    "totalItems": "\u884c",
                    "through": "\u81f3",
                    "of": "\u5171"
                },
                "grouping": {
                    "group": "\u5206\u7ec4",
                    "ungroup": "\u53d6\u6d88\u5206\u7ec4",
                    "aggregate_count": "\u5408\u8ba1: \u8ba1\u6570",
                    "aggregate_sum": "\u5408\u8ba1: \u6c42\u548c",
                    "aggregate_max": "\u5408\u8ba1: \u6700\u5927",
                    "aggregate_min": "\u5408\u8ba1: \u6700\u5c0f",
                    "aggregate_avg": "\u5408\u8ba1: \u5e73\u5747",
                    "aggregate_remove": "\u5408\u8ba1: \u79fb\u9664"
                }
            });
            return $delegate;
        } ]);
    } ]);
})();

(function() {
    angular.module("ui.grid").config([ "$provide", function($provide) {
        $provide.decorator("i18nService", [ "$delegate", function($delegate) {
            $delegate.add("zh-tw", {
                "aggregate": {
                    "label": "\u884c"
                },
                "groupPanel": {
                    "description": "\u62d6\u66f3\u8868\u982d\u5230\u6b64\u8655\u9032\u884c\u5206\u7d44"
                },
                "search": {
                    "placeholder": "\u67e5\u627e",
                    "showingItems": "\u5df2\u986f\u793a\u884c\u6578\uff1a",
                    "selectedItems": "\u5df2\u9078\u64c7\u884c\u6578\uff1a",
                    "totalItems": "\u7e3d\u884c\u6578\uff1a",
                    "size": "\u6bcf\u9801\u986f\u793a\u884c\u6578\uff1a",
                    "first": "\u9996\u9801",
                    "next": "\u4e0b\u58f9\u9801",
                    "previous": "\u4e0a\u58f9\u9801",
                    "last": "\u672b\u9801"
                },
                "menu": {
                    "text": "\u9078\u64c7\u5217\uff1a"
                },
                "sort": {
                    "ascending": "\u5347\u5e8f",
                    "descending": "\u964d\u5e8f",
                    "remove": "\u53d6\u6d88\u6392\u5e8f"
                },
                "column": {
                    "hide": "\u96b1\u85cf\u5217"
                },
                "aggregation": {
                    "count": "\u8a08\u6578\uff1a",
                    "sum": "\u6c42\u548c\uff1a",
                    "avg": "\u5747\u503c\uff1a",
                    "min": "\u6700\u5c0f\u503c\uff1a",
                    "max": "\u6700\u5927\u503c\uff1a"
                },
                "pinning": {
                    "pinLeft": "\u5de6\u5074\u56fa\u5b9a",
                    "pinRight": "\u53f3\u5074\u56fa\u5b9a",
                    "unpin": "\u53d6\u6d88\u56fa\u5b9a"
                },
                "gridMenu": {
                    "columns": "\u5217\uff1a",
                    "importerTitle": "\u5c0e\u5165\u6587\u4ef6",
                    "exporterAllAsCsv": "\u5c0e\u51fa\u5168\u90e8\u6578\u64da\u5230CSV",
                    "exporterVisibleAsCsv": "\u5c0e\u51fa\u53ef\u898b\u6578\u64da\u5230CSV",
                    "exporterSelectedAsCsv": "\u5c0e\u51fa\u5df2\u9078\u6578\u64da\u5230CSV",
                    "exporterAllAsPdf": "\u5c0e\u51fa\u5168\u90e8\u6578\u64da\u5230PDF",
                    "exporterVisibleAsPdf": "\u5c0e\u51fa\u53ef\u898b\u6578\u64da\u5230PDF",
                    "exporterSelectedAsPdf": "\u5c0e\u51fa\u5df2\u9078\u6578\u64da\u5230PDF",
                    "clearAllFilters": "\u6e05\u9664\u6240\u6709\u8fc7\u6ee4\u5668"
                },
                "importer": {
                    "noHeaders": "\u7121\u6cd5\u7372\u53d6\u5217\u540d\uff0c\u78ba\u5b9a\u6587\u4ef6\u5305\u542b\u8868\u982d\uff1f",
                    "noObjects": "\u7121\u6cd5\u7372\u53d6\u6578\u64da\uff0c\u78ba\u5b9a\u6587\u4ef6\u5305\u542b\u6578\u64da\uff1f",
                    "invalidCsv": "\u7121\u6cd5\u8655\u7406\u6587\u4ef6\uff0c\u78ba\u5b9a\u662f\u5408\u6cd5\u7684CSV\u6587\u4ef6\uff1f",
                    "invalidJson": "\u7121\u6cd5\u8655\u7406\u6587\u4ef6\uff0c\u78ba\u5b9a\u662f\u5408\u6cd5\u7684JSON\u6587\u4ef6\uff1f",
                    "jsonNotArray": "\u5c0e\u5165\u7684\u6587\u4ef6\u4e0d\u662fJSON\u6578\u7d44\uff01"
                },
                "pagination": {
                    "sizes": "\u884c\u6bcf\u9801",
                    "totalItems": "\u884c"
                }
            });
            return $delegate;
        } ]);
    } ]);
})();

(function() {
    "use strict";
    var module = angular.module("ui.grid.autoResize", [ "ui.grid" ]);
    module.directive("uiGridAutoResize", [ "$timeout", "gridUtil", function($timeout, gridUtil) {
        return {
            "require": "uiGrid",
            "scope": false,
            "link": function($scope, $elm, $attrs, uiGridCtrl) {
                var prevGridWidth, prevGridHeight;
                function getDimensions() {
                    prevGridHeight = gridUtil.elementHeight($elm);
                    prevGridWidth = gridUtil.elementWidth($elm);
                }
                getDimensions();
                var resizeTimeoutId;
                function startTimeout() {
                    clearTimeout(resizeTimeoutId);
                    resizeTimeoutId = setTimeout(function() {
                        var newGridHeight = gridUtil.elementHeight($elm);
                        var newGridWidth = gridUtil.elementWidth($elm);
                        if (newGridHeight !== prevGridHeight || newGridWidth !== prevGridWidth) {
                            uiGridCtrl.grid.gridHeight = newGridHeight;
                            uiGridCtrl.grid.gridWidth = newGridWidth;
                            $scope.$apply(function() {
                                uiGridCtrl.grid.refresh().then(function() {
                                    getDimensions();
                                    startTimeout();
                                });
                            });
                        } else {
                            startTimeout();
                        }
                    }, 250);
                }
                startTimeout();
                $scope.$on("$destroy", function() {
                    clearTimeout(resizeTimeoutId);
                });
            }
        };
    } ]);
})();

(function() {
    "use strict";
    var module = angular.module("ui.grid.cellNav", [ "ui.grid" ]);
    module.constant("uiGridCellNavConstants", {
        "FEATURE_NAME": "gridCellNav",
        "CELL_NAV_EVENT": "cellNav",
        "direction": {
            "LEFT": 0,
            "RIGHT": 1,
            "UP": 2,
            "DOWN": 3,
            "PG_UP": 4,
            "PG_DOWN": 5
        },
        "EVENT_TYPE": {
            "KEYDOWN": 0,
            "CLICK": 1,
            "CLEAR": 2
        }
    });
    module.factory("uiGridCellNavFactory", [ "gridUtil", "uiGridConstants", "uiGridCellNavConstants", "GridRowColumn", "$q", function(gridUtil, uiGridConstants, uiGridCellNavConstants, GridRowColumn, $q) {
        var UiGridCellNav = function UiGridCellNav(rowContainer, colContainer, leftColContainer, rightColContainer) {
            this.rows = rowContainer.visibleRowCache;
            this.columns = colContainer.visibleColumnCache;
            this.leftColumns = leftColContainer ? leftColContainer.visibleColumnCache : [];
            this.rightColumns = rightColContainer ? rightColContainer.visibleColumnCache : [];
            this.bodyContainer = rowContainer;
        };
        UiGridCellNav.prototype.getFocusableCols = function() {
            var allColumns = this.leftColumns.concat(this.columns, this.rightColumns);
            return allColumns.filter(function(col) {
                return col.colDef.allowCellFocus;
            });
        };
        UiGridCellNav.prototype.getFocusableRows = function() {
            return this.rows.filter(function(row) {
                return row.allowCellFocus !== false;
            });
        };
        UiGridCellNav.prototype.getNextRowCol = function(direction, curRow, curCol) {
            switch (direction) {
              case uiGridCellNavConstants.direction.LEFT:
                return this.getRowColLeft(curRow, curCol);

              case uiGridCellNavConstants.direction.RIGHT:
                return this.getRowColRight(curRow, curCol);

              case uiGridCellNavConstants.direction.UP:
                return this.getRowColUp(curRow, curCol);

              case uiGridCellNavConstants.direction.DOWN:
                return this.getRowColDown(curRow, curCol);

              case uiGridCellNavConstants.direction.PG_UP:
                return this.getRowColPageUp(curRow, curCol);

              case uiGridCellNavConstants.direction.PG_DOWN:
                return this.getRowColPageDown(curRow, curCol);
            }
        };
        UiGridCellNav.prototype.initializeSelection = function() {
            var focusableCols = this.getFocusableCols();
            var focusableRows = this.getFocusableRows();
            if (focusableCols.length === 0 || focusableRows.length === 0) {
                return null;
            }
            var curRowIndex = 0;
            var curColIndex = 0;
            return new GridRowColumn(focusableRows[0], focusableCols[0]);
        };
        UiGridCellNav.prototype.getRowColLeft = function(curRow, curCol) {
            var focusableCols = this.getFocusableCols();
            var focusableRows = this.getFocusableRows();
            var curColIndex = focusableCols.indexOf(curCol);
            var curRowIndex = focusableRows.indexOf(curRow);
            if (curColIndex === -1) {
                curColIndex = 1;
            }
            var nextColIndex = curColIndex === 0 ? focusableCols.length - 1 : curColIndex - 1;
            if (nextColIndex > curColIndex) {
                if (curRowIndex === 0) {
                    return new GridRowColumn(curRow, focusableCols[nextColIndex]);
                } else {
                    return new GridRowColumn(focusableRows[curRowIndex - 1], focusableCols[nextColIndex]);
                }
            } else {
                return new GridRowColumn(curRow, focusableCols[nextColIndex]);
            }
        };
        UiGridCellNav.prototype.getRowColRight = function(curRow, curCol) {
            var focusableCols = this.getFocusableCols();
            var focusableRows = this.getFocusableRows();
            var curColIndex = focusableCols.indexOf(curCol);
            var curRowIndex = focusableRows.indexOf(curRow);
            if (curColIndex === -1) {
                curColIndex = 0;
            }
            var nextColIndex = curColIndex === focusableCols.length - 1 ? 0 : curColIndex + 1;
            if (nextColIndex < curColIndex) {
                if (curRowIndex === focusableRows.length - 1) {
                    return new GridRowColumn(curRow, focusableCols[nextColIndex]);
                } else {
                    return new GridRowColumn(focusableRows[curRowIndex + 1], focusableCols[nextColIndex]);
                }
            } else {
                return new GridRowColumn(curRow, focusableCols[nextColIndex]);
            }
        };
        UiGridCellNav.prototype.getRowColDown = function(curRow, curCol) {
            var focusableCols = this.getFocusableCols();
            var focusableRows = this.getFocusableRows();
            var curColIndex = focusableCols.indexOf(curCol);
            var curRowIndex = focusableRows.indexOf(curRow);
            if (curColIndex === -1) {
                curColIndex = 0;
            }
            if (curRowIndex === focusableRows.length - 1) {
                return new GridRowColumn(curRow, focusableCols[curColIndex]);
            } else {
                return new GridRowColumn(focusableRows[curRowIndex + 1], focusableCols[curColIndex]);
            }
        };
        UiGridCellNav.prototype.getRowColPageDown = function(curRow, curCol) {
            var focusableCols = this.getFocusableCols();
            var focusableRows = this.getFocusableRows();
            var curColIndex = focusableCols.indexOf(curCol);
            var curRowIndex = focusableRows.indexOf(curRow);
            if (curColIndex === -1) {
                curColIndex = 0;
            }
            var pageSize = this.bodyContainer.minRowsToRender();
            if (curRowIndex >= focusableRows.length - pageSize) {
                return new GridRowColumn(focusableRows[focusableRows.length - 1], focusableCols[curColIndex]);
            } else {
                return new GridRowColumn(focusableRows[curRowIndex + pageSize], focusableCols[curColIndex]);
            }
        };
        UiGridCellNav.prototype.getRowColUp = function(curRow, curCol) {
            var focusableCols = this.getFocusableCols();
            var focusableRows = this.getFocusableRows();
            var curColIndex = focusableCols.indexOf(curCol);
            var curRowIndex = focusableRows.indexOf(curRow);
            if (curColIndex === -1) {
                curColIndex = 0;
            }
            if (curRowIndex === 0) {
                return new GridRowColumn(curRow, focusableCols[curColIndex]);
            } else {
                return new GridRowColumn(focusableRows[curRowIndex - 1], focusableCols[curColIndex]);
            }
        };
        UiGridCellNav.prototype.getRowColPageUp = function(curRow, curCol) {
            var focusableCols = this.getFocusableCols();
            var focusableRows = this.getFocusableRows();
            var curColIndex = focusableCols.indexOf(curCol);
            var curRowIndex = focusableRows.indexOf(curRow);
            if (curColIndex === -1) {
                curColIndex = 0;
            }
            var pageSize = this.bodyContainer.minRowsToRender();
            if (curRowIndex - pageSize < 0) {
                return new GridRowColumn(focusableRows[0], focusableCols[curColIndex]);
            } else {
                return new GridRowColumn(focusableRows[curRowIndex - pageSize], focusableCols[curColIndex]);
            }
        };
        return UiGridCellNav;
    } ]);
    module.service("uiGridCellNavService", [ "gridUtil", "uiGridConstants", "uiGridCellNavConstants", "$q", "uiGridCellNavFactory", "GridRowColumn", "ScrollEvent", function(gridUtil, uiGridConstants, uiGridCellNavConstants, $q, UiGridCellNav, GridRowColumn, ScrollEvent) {
        var service = {
            "initializeGrid": function(grid) {
                grid.registerColumnBuilder(service.cellNavColumnBuilder);
                grid.cellNav = {};
                grid.cellNav.lastRowCol = null;
                grid.cellNav.focusedCells = [];
                service.defaultGridOptions(grid.options);
                var publicApi = {
                    "events": {
                        "cellNav": {
                            "navigate": function(newRowCol, oldRowCol) {},
                            "viewPortKeyDown": function(event, rowCol) {},
                            "viewPortKeyPress": function(event, rowCol) {}
                        }
                    },
                    "methods": {
                        "cellNav": {
                            "scrollToFocus": function(rowEntity, colDef) {
                                return service.scrollToFocus(grid, rowEntity, colDef);
                            },
                            "getFocusedCell": function() {
                                return grid.cellNav.lastRowCol;
                            },
                            "getCurrentSelection": function() {
                                return grid.cellNav.focusedCells;
                            },
                            "rowColSelectIndex": function(rowCol) {
                                var index = -1;
                                for (var i = 0; i < grid.cellNav.focusedCells.length; i++) {
                                    if (grid.cellNav.focusedCells[i].col.uid === rowCol.col.uid && grid.cellNav.focusedCells[i].row.uid === rowCol.row.uid) {
                                        index = i;
                                        break;
                                    }
                                }
                                return index;
                            }
                        }
                    }
                };
                grid.api.registerEventsFromObject(publicApi.events);
                grid.api.registerMethodsFromObject(publicApi.methods);
            },
            "defaultGridOptions": function(gridOptions) {
                gridOptions.modifierKeysToMultiSelectCells = gridOptions.modifierKeysToMultiSelectCells === true;
            },
            "decorateRenderContainers": function(grid) {
                var rightContainer = grid.hasRightContainer() ? grid.renderContainers.right : null;
                var leftContainer = grid.hasLeftContainer() ? grid.renderContainers.left : null;
                if (leftContainer !== null) {
                    grid.renderContainers.left.cellNav = new UiGridCellNav(grid.renderContainers.body, leftContainer, rightContainer, grid.renderContainers.body);
                }
                if (rightContainer !== null) {
                    grid.renderContainers.right.cellNav = new UiGridCellNav(grid.renderContainers.body, rightContainer, grid.renderContainers.body, leftContainer);
                }
                grid.renderContainers.body.cellNav = new UiGridCellNav(grid.renderContainers.body, grid.renderContainers.body, leftContainer, rightContainer);
            },
            "getDirection": function(evt) {
                if (evt.keyCode === uiGridConstants.keymap.LEFT || evt.keyCode === uiGridConstants.keymap.TAB && evt.shiftKey) {
                    return uiGridCellNavConstants.direction.LEFT;
                }
                if (evt.keyCode === uiGridConstants.keymap.RIGHT || evt.keyCode === uiGridConstants.keymap.TAB) {
                    return uiGridCellNavConstants.direction.RIGHT;
                }
                if (evt.keyCode === uiGridConstants.keymap.UP || evt.keyCode === uiGridConstants.keymap.ENTER && evt.shiftKey) {
                    return uiGridCellNavConstants.direction.UP;
                }
                if (evt.keyCode === uiGridConstants.keymap.PG_UP) {
                    return uiGridCellNavConstants.direction.PG_UP;
                }
                if (evt.keyCode === uiGridConstants.keymap.DOWN || evt.keyCode === uiGridConstants.keymap.ENTER && !(evt.ctrlKey || evt.altKey)) {
                    return uiGridCellNavConstants.direction.DOWN;
                }
                if (evt.keyCode === uiGridConstants.keymap.PG_DOWN) {
                    return uiGridCellNavConstants.direction.PG_DOWN;
                }
                return null;
            },
            "cellNavColumnBuilder": function(colDef, col, gridOptions) {
                var promises = [];
                colDef.allowCellFocus = colDef.allowCellFocus === undefined ? true : colDef.allowCellFocus;
                return $q.all(promises);
            },
            "scrollToFocus": function(grid, rowEntity, colDef) {
                var gridRow = null, gridCol = null;
                if (typeof rowEntity !== "undefined" && rowEntity !== null) {
                    gridRow = grid.getRow(rowEntity);
                }
                if (typeof colDef !== "undefined" && colDef !== null) {
                    gridCol = grid.getColumn(colDef.name ? colDef.name : colDef.field);
                }
                return grid.api.core.scrollToIfNecessary(gridRow, gridCol).then(function() {
                    var rowCol = {
                        "row": gridRow,
                        "col": gridCol
                    };
                    if (gridRow !== null && gridCol !== null) {
                        grid.cellNav.broadcastCellNav(rowCol);
                    }
                });
            },
            "getLeftWidth": function(grid, upToCol) {
                var width = 0;
                if (!upToCol) {
                    return width;
                }
                var lastIndex = grid.renderContainers.body.visibleColumnCache.indexOf(upToCol);
                grid.renderContainers.body.visibleColumnCache.forEach(function(col, index) {
                    if (index < lastIndex) {
                        width += col.drawnWidth;
                    }
                });
                var percentage = lastIndex === 0 ? 0 : (lastIndex + 1) / grid.renderContainers.body.visibleColumnCache.length;
                width += upToCol.drawnWidth * percentage;
                return width;
            }
        };
        return service;
    } ]);
    module.directive("uiGridCellnav", [ "gridUtil", "uiGridCellNavService", "uiGridCellNavConstants", "uiGridConstants", "GridRowColumn", "$timeout", "$compile", function(gridUtil, uiGridCellNavService, uiGridCellNavConstants, uiGridConstants, GridRowColumn, $timeout, $compile) {
        return {
            "replace": true,
            "priority": -150,
            "require": "^uiGrid",
            "scope": false,
            "controller": function() {},
            "compile": function() {
                return {
                    "pre": function($scope, $elm, $attrs, uiGridCtrl) {
                        var _scope = $scope;
                        var grid = uiGridCtrl.grid;
                        uiGridCellNavService.initializeGrid(grid);
                        uiGridCtrl.cellNav = {};
                        uiGridCtrl.cellNav.makeRowCol = function(obj) {
                            if (!(obj instanceof GridRowColumn)) {
                                obj = new GridRowColumn(obj.row, obj.col);
                            }
                            return obj;
                        };
                        uiGridCtrl.cellNav.getActiveCell = function() {
                            var elms = $elm[0].getElementsByClassName("ui-grid-cell-focus");
                            if (elms.length > 0) {
                                return elms[0];
                            }
                            return undefined;
                        };
                        uiGridCtrl.cellNav.broadcastCellNav = grid.cellNav.broadcastCellNav = function(newRowCol, modifierDown, originEvt) {
                            modifierDown = !(modifierDown === undefined || !modifierDown);
                            newRowCol = uiGridCtrl.cellNav.makeRowCol(newRowCol);
                            uiGridCtrl.cellNav.broadcastFocus(newRowCol, modifierDown, originEvt);
                            _scope.$broadcast(uiGridCellNavConstants.CELL_NAV_EVENT, newRowCol, modifierDown, originEvt);
                        };
                        uiGridCtrl.cellNav.clearFocus = grid.cellNav.clearFocus = function() {
                            grid.cellNav.focusedCells = [];
                            _scope.$broadcast(uiGridCellNavConstants.CELL_NAV_EVENT);
                        };
                        uiGridCtrl.cellNav.broadcastFocus = function(rowCol, modifierDown, originEvt) {
                            modifierDown = !(modifierDown === undefined || !modifierDown);
                            rowCol = uiGridCtrl.cellNav.makeRowCol(rowCol);
                            var row = rowCol.row, col = rowCol.col;
                            var rowColSelectIndex = uiGridCtrl.grid.api.cellNav.rowColSelectIndex(rowCol);
                            if (grid.cellNav.lastRowCol === null || rowColSelectIndex === -1) {
                                var newRowCol = new GridRowColumn(row, col);
                                if (grid.cellNav.lastRowCol === null || grid.cellNav.lastRowCol.row !== newRowCol.row || grid.cellNav.lastRowCol.col !== newRowCol.col) {
                                    grid.api.cellNav.raise.navigate(newRowCol, grid.cellNav.lastRowCol);
                                    grid.cellNav.lastRowCol = newRowCol;
                                }
                                if (uiGridCtrl.grid.options.modifierKeysToMultiSelectCells && modifierDown) {
                                    grid.cellNav.focusedCells.push(rowCol);
                                } else {
                                    grid.cellNav.focusedCells = [ rowCol ];
                                }
                            } else if (grid.options.modifierKeysToMultiSelectCells && modifierDown && rowColSelectIndex >= 0) {
                                grid.cellNav.focusedCells.splice(rowColSelectIndex, 1);
                            }
                        };
                        uiGridCtrl.cellNav.handleKeyDown = function(evt) {
                            var direction = uiGridCellNavService.getDirection(evt);
                            if (direction === null) {
                                return null;
                            }
                            var containerId = "body";
                            if (evt.uiGridTargetRenderContainerId) {
                                containerId = evt.uiGridTargetRenderContainerId;
                            }
                            var lastRowCol = uiGridCtrl.grid.api.cellNav.getFocusedCell();
                            if (lastRowCol) {
                                var rowCol = uiGridCtrl.grid.renderContainers[containerId].cellNav.getNextRowCol(direction, lastRowCol.row, lastRowCol.col);
                                var focusableCols = uiGridCtrl.grid.renderContainers[containerId].cellNav.getFocusableCols();
                                var rowColSelectIndex = uiGridCtrl.grid.api.cellNav.rowColSelectIndex(rowCol);
                                if (direction === uiGridCellNavConstants.direction.LEFT && rowCol.col === focusableCols[focusableCols.length - 1] && rowCol.row === lastRowCol.row && evt.keyCode === uiGridConstants.keymap.TAB && evt.shiftKey) {
                                    grid.cellNav.focusedCells.splice(rowColSelectIndex, 1);
                                    uiGridCtrl.cellNav.clearFocus();
                                    return true;
                                } else if (direction === uiGridCellNavConstants.direction.RIGHT && rowCol.col === focusableCols[0] && rowCol.row === lastRowCol.row && evt.keyCode === uiGridConstants.keymap.TAB && !evt.shiftKey) {
                                    grid.cellNav.focusedCells.splice(rowColSelectIndex, 1);
                                    uiGridCtrl.cellNav.clearFocus();
                                    return true;
                                }
                                grid.scrollToIfNecessary(rowCol.row, rowCol.col).then(function() {
                                    uiGridCtrl.cellNav.broadcastCellNav(rowCol);
                                });
                                evt.stopPropagation();
                                evt.preventDefault();
                                return false;
                            }
                        };
                    },
                    "post": function($scope, $elm, $attrs, uiGridCtrl) {
                        var _scope = $scope;
                        var grid = uiGridCtrl.grid;
                        function addAriaLiveRegion() {
                            var ariaNotifierDomElt = "<div " + 'id="' + grid.id + '-aria-speakable" ' + 'class="ui-grid-a11y-ariascreenreader-speakable ui-grid-offscreen" ' + 'aria-live="assertive" ' + 'role="region" ' + 'aria-atomic="true" ' + 'aria-hidden="false" ' + 'aria-relevant="additions" ' + ">" + "&nbsp;" + "</div>";
                            var ariaNotifier = $compile(ariaNotifierDomElt)($scope);
                            $elm.prepend(ariaNotifier);
                            $scope.$on(uiGridCellNavConstants.CELL_NAV_EVENT, function(evt, rowCol, modifierDown, originEvt) {
                                if (originEvt && originEvt.type === "focus") {
                                    return;
                                }
                                function setNotifyText(text) {
                                    if (text === ariaNotifier.text()) {
                                        return;
                                    }
                                    ariaNotifier[0].style.clip = "rect(0px,0px,0px,0px)";
                                    ariaNotifier[0].innerHTML = "";
                                    ariaNotifier[0].style.visibility = "hidden";
                                    ariaNotifier[0].style.visibility = "visible";
                                    if (text !== "") {
                                        ariaNotifier[0].style.clip = "auto";
                                        ariaNotifier[0].appendChild(document.createTextNode(text + " "));
                                        ariaNotifier[0].style.visibility = "hidden";
                                        ariaNotifier[0].style.visibility = "visible";
                                    }
                                }
                                var values = [];
                                var currentSelection = grid.api.cellNav.getCurrentSelection();
                                for (var i = 0; i < currentSelection.length; i++) {
                                    values.push(currentSelection[i].getIntersectionValueFiltered());
                                }
                                var cellText = values.toString();
                                setNotifyText(cellText);
                            });
                        }
                        addAriaLiveRegion();
                    }
                };
            }
        };
    } ]);
    module.directive("uiGridRenderContainer", [ "$timeout", "$document", "gridUtil", "uiGridConstants", "uiGridCellNavService", "$compile", "uiGridCellNavConstants", function($timeout, $document, gridUtil, uiGridConstants, uiGridCellNavService, $compile, uiGridCellNavConstants) {
        return {
            "replace": true,
            "priority": -99999,
            "require": [ "^uiGrid", "uiGridRenderContainer", "?^uiGridCellnav" ],
            "scope": false,
            "compile": function() {
                return {
                    "post": function($scope, $elm, $attrs, controllers) {
                        var uiGridCtrl = controllers[0], renderContainerCtrl = controllers[1], uiGridCellnavCtrl = controllers[2];
                        if (!uiGridCtrl.grid.api.cellNav) {
                            return;
                        }
                        var containerId = renderContainerCtrl.containerId;
                        var grid = uiGridCtrl.grid;
                        uiGridCellNavService.decorateRenderContainers(grid);
                        if (containerId !== "body") {
                            return;
                        }
                        if (uiGridCtrl.grid.options.modifierKeysToMultiSelectCells) {
                            $elm.attr("aria-multiselectable", true);
                        } else {
                            $elm.attr("aria-multiselectable", false);
                        }
                        var focuser = $compile('<div class="ui-grid-focuser" role="region" aria-live="assertive" aria-atomic="false" tabindex="0" aria-controls="' + grid.id + "-aria-speakable " + grid.id + "-grid-container" + '" aria-owns="' + grid.id + "-grid-container" + '"></div>')($scope);
                        $elm.append(focuser);
                        focuser.on("focus", function(evt) {
                            evt.uiGridTargetRenderContainerId = containerId;
                            var rowCol = uiGridCtrl.grid.api.cellNav.getFocusedCell();
                            if (rowCol === null) {
                                rowCol = uiGridCtrl.grid.renderContainers[containerId].cellNav.getNextRowCol(uiGridCellNavConstants.direction.DOWN, null, null);
                                if (rowCol.row && rowCol.col) {
                                    uiGridCtrl.cellNav.broadcastCellNav(rowCol);
                                }
                            }
                        });
                        uiGridCellnavCtrl.setAriaActivedescendant = function(id) {
                            $elm.attr("aria-activedescendant", id);
                        };
                        uiGridCellnavCtrl.removeAriaActivedescendant = function(id) {
                            if ($elm.attr("aria-activedescendant") === id) {
                                $elm.attr("aria-activedescendant", "");
                            }
                        };
                        uiGridCtrl.focus = function() {
                            gridUtil.focus.byElement(focuser[0]);
                        };
                        var viewPortKeyDownWasRaisedForRowCol = null;
                        focuser.on("keydown", function(evt) {
                            evt.uiGridTargetRenderContainerId = containerId;
                            var rowCol = uiGridCtrl.grid.api.cellNav.getFocusedCell();
                            var result = uiGridCtrl.cellNav.handleKeyDown(evt);
                            if (result === null) {
                                uiGridCtrl.grid.api.cellNav.raise.viewPortKeyDown(evt, rowCol);
                                viewPortKeyDownWasRaisedForRowCol = rowCol;
                            }
                        });
                        focuser.on("keypress", function(evt) {
                            if (viewPortKeyDownWasRaisedForRowCol) {
                                $timeout(function() {
                                    uiGridCtrl.grid.api.cellNav.raise.viewPortKeyPress(evt, viewPortKeyDownWasRaisedForRowCol);
                                }, 4);
                                viewPortKeyDownWasRaisedForRowCol = null;
                            }
                        });
                        $scope.$on("$destroy", function() {
                            focuser.off();
                        });
                    }
                };
            }
        };
    } ]);
    module.directive("uiGridViewport", [ "$timeout", "$document", "gridUtil", "uiGridConstants", "uiGridCellNavService", "uiGridCellNavConstants", "$log", "$compile", function($timeout, $document, gridUtil, uiGridConstants, uiGridCellNavService, uiGridCellNavConstants, $log, $compile) {
        return {
            "replace": true,
            "priority": -99999,
            "require": [ "^uiGrid", "^uiGridRenderContainer", "?^uiGridCellnav" ],
            "scope": false,
            "compile": function() {
                return {
                    "pre": function($scope, $elm, $attrs, uiGridCtrl) {},
                    "post": function($scope, $elm, $attrs, controllers) {
                        var uiGridCtrl = controllers[0], renderContainerCtrl = controllers[1];
                        if (!uiGridCtrl.grid.api.cellNav) {
                            return;
                        }
                        var containerId = renderContainerCtrl.containerId;
                        if (containerId !== "body") {
                            return;
                        }
                        var grid = uiGridCtrl.grid;
                        grid.api.core.on.scrollBegin($scope, function(args) {
                            var lastRowCol = uiGridCtrl.grid.api.cellNav.getFocusedCell();
                            if (lastRowCol === null) {
                                return;
                            }
                            if (!renderContainerCtrl.colContainer.containsColumn(lastRowCol.col)) {
                                return;
                            }
                            uiGridCtrl.cellNav.clearFocus();
                        });
                        grid.api.core.on.scrollEnd($scope, function(args) {
                            var lastRowCol = uiGridCtrl.grid.api.cellNav.getFocusedCell();
                            if (lastRowCol === null) {
                                return;
                            }
                            if (!renderContainerCtrl.colContainer.containsColumn(lastRowCol.col)) {
                                return;
                            }
                            uiGridCtrl.cellNav.broadcastCellNav(lastRowCol);
                        });
                        grid.api.cellNav.on.navigate($scope, function() {
                            uiGridCtrl.focus();
                        });
                    }
                };
            }
        };
    } ]);
    module.directive("uiGridCell", [ "$timeout", "$document", "uiGridCellNavService", "gridUtil", "uiGridCellNavConstants", "uiGridConstants", "GridRowColumn", function($timeout, $document, uiGridCellNavService, gridUtil, uiGridCellNavConstants, uiGridConstants, GridRowColumn) {
        return {
            "priority": -150,
            "restrict": "A",
            "require": [ "^uiGrid", "?^uiGridCellnav" ],
            "scope": false,
            "link": function($scope, $elm, $attrs, controllers) {
                var uiGridCtrl = controllers[0], uiGridCellnavCtrl = controllers[1];
                if (!uiGridCtrl.grid.api.cellNav) {
                    return;
                }
                if (!$scope.col.colDef.allowCellFocus) {
                    return;
                }
                var grid = uiGridCtrl.grid;
                $scope.focused = false;
                $elm.attr("tabindex", -1);
                $elm.find("div").on("click", function(evt) {
                    uiGridCtrl.cellNav.broadcastCellNav(new GridRowColumn($scope.row, $scope.col), evt.ctrlKey || evt.metaKey, evt);
                    evt.stopPropagation();
                    $scope.$apply();
                });
                $elm.on("mousedown", preventMouseDown);
                if (uiGridCtrl.grid.api.edit) {
                    uiGridCtrl.grid.api.edit.on.beginCellEdit($scope, function() {
                        $elm.off("mousedown", preventMouseDown);
                    });
                    uiGridCtrl.grid.api.edit.on.afterCellEdit($scope, function() {
                        $elm.on("mousedown", preventMouseDown);
                    });
                    uiGridCtrl.grid.api.edit.on.cancelCellEdit($scope, function() {
                        $elm.on("mousedown", preventMouseDown);
                    });
                }
                function preventMouseDown(evt) {
                    evt.preventDefault();
                }
                $elm.on("focus", function(evt) {
                    uiGridCtrl.cellNav.broadcastCellNav(new GridRowColumn($scope.row, $scope.col), false, evt);
                    evt.stopPropagation();
                    $scope.$apply();
                });
                $scope.$on(uiGridCellNavConstants.CELL_NAV_EVENT, function(evt, rowCol, modifierDown) {
                    var isFocused = grid.cellNav.focusedCells.some(function(focusedRowCol, index) {
                        return focusedRowCol.row === $scope.row && focusedRowCol.col === $scope.col;
                    });
                    if (isFocused) {
                        setFocused();
                    } else {
                        clearFocus();
                    }
                });
                function setFocused() {
                    if (!$scope.focused) {
                        var div = $elm.find("div");
                        div.addClass("ui-grid-cell-focus");
                        $elm.attr("aria-selected", true);
                        uiGridCellnavCtrl.setAriaActivedescendant($elm.attr("id"));
                        $scope.focused = true;
                    }
                }
                function clearFocus() {
                    if ($scope.focused) {
                        var div = $elm.find("div");
                        div.removeClass("ui-grid-cell-focus");
                        $elm.attr("aria-selected", false);
                        uiGridCellnavCtrl.removeAriaActivedescendant($elm.attr("id"));
                        $scope.focused = false;
                    }
                }
                $scope.$on("$destroy", function() {
                    $elm.find("div").off();
                    $elm.off();
                });
            }
        };
    } ]);
})();

(function() {
    "use strict";
    var module = angular.module("ui.grid.edit", [ "ui.grid" ]);
    module.constant("uiGridEditConstants", {
        "EDITABLE_CELL_TEMPLATE": /EDITABLE_CELL_TEMPLATE/g,
        "EDITABLE_CELL_DIRECTIVE": /editable_cell_directive/g,
        "events": {
            "BEGIN_CELL_EDIT": "uiGridEventBeginCellEdit",
            "END_CELL_EDIT": "uiGridEventEndCellEdit",
            "CANCEL_CELL_EDIT": "uiGridEventCancelCellEdit"
        }
    });
    module.service("uiGridEditService", [ "$q", "uiGridConstants", "gridUtil", function($q, uiGridConstants, gridUtil) {
        var service = {
            "initializeGrid": function(grid) {
                service.defaultGridOptions(grid.options);
                grid.registerColumnBuilder(service.editColumnBuilder);
                grid.edit = {};
                var publicApi = {
                    "events": {
                        "edit": {
                            "afterCellEdit": function(rowEntity, colDef, newValue, oldValue) {},
                            "beginCellEdit": function(rowEntity, colDef, triggerEvent) {},
                            "cancelCellEdit": function(rowEntity, colDef) {}
                        }
                    },
                    "methods": {
                        "edit": {}
                    }
                };
                grid.api.registerEventsFromObject(publicApi.events);
            },
            "defaultGridOptions": function(gridOptions) {
                gridOptions.cellEditableCondition = gridOptions.cellEditableCondition === undefined ? true : gridOptions.cellEditableCondition;
                gridOptions.enableCellEditOnFocus = gridOptions.enableCellEditOnFocus === undefined ? false : gridOptions.enableCellEditOnFocus;
            },
            "editColumnBuilder": function(colDef, col, gridOptions) {
                var promises = [];
                colDef.enableCellEdit = colDef.enableCellEdit === undefined ? gridOptions.enableCellEdit === undefined ? colDef.type !== "object" : gridOptions.enableCellEdit : colDef.enableCellEdit;
                colDef.cellEditableCondition = colDef.cellEditableCondition === undefined ? gridOptions.cellEditableCondition : colDef.cellEditableCondition;
                if (colDef.enableCellEdit) {
                    colDef.editableCellTemplate = colDef.editableCellTemplate || gridOptions.editableCellTemplate || "ui-grid/cellEditor";
                    promises.push(gridUtil.getTemplate(colDef.editableCellTemplate).then(function(template) {
                        col.editableCellTemplate = template;
                    }, function(res) {
                        throw new Error("Couldn't fetch/use colDef.editableCellTemplate '" + colDef.editableCellTemplate + "'");
                    }));
                }
                colDef.enableCellEditOnFocus = colDef.enableCellEditOnFocus === undefined ? gridOptions.enableCellEditOnFocus : colDef.enableCellEditOnFocus;
                return $q.all(promises);
            },
            "isStartEditKey": function(evt) {
                if (evt.metaKey || evt.keyCode === uiGridConstants.keymap.ESC || evt.keyCode === uiGridConstants.keymap.SHIFT || evt.keyCode === uiGridConstants.keymap.CTRL || evt.keyCode === uiGridConstants.keymap.ALT || evt.keyCode === uiGridConstants.keymap.WIN || evt.keyCode === uiGridConstants.keymap.CAPSLOCK || evt.keyCode === uiGridConstants.keymap.LEFT || evt.keyCode === uiGridConstants.keymap.TAB && evt.shiftKey || evt.keyCode === uiGridConstants.keymap.RIGHT || evt.keyCode === uiGridConstants.keymap.TAB || evt.keyCode === uiGridConstants.keymap.UP || evt.keyCode === uiGridConstants.keymap.ENTER && evt.shiftKey || evt.keyCode === uiGridConstants.keymap.DOWN || evt.keyCode === uiGridConstants.keymap.ENTER) {
                    return false;
                }
                return true;
            }
        };
        return service;
    } ]);
    module.directive("uiGridEdit", [ "gridUtil", "uiGridEditService", function(gridUtil, uiGridEditService) {
        return {
            "replace": true,
            "priority": 0,
            "require": "^uiGrid",
            "scope": false,
            "compile": function() {
                return {
                    "pre": function($scope, $elm, $attrs, uiGridCtrl) {
                        uiGridEditService.initializeGrid(uiGridCtrl.grid);
                    },
                    "post": function($scope, $elm, $attrs, uiGridCtrl) {}
                };
            }
        };
    } ]);
    module.directive("uiGridViewport", [ "uiGridEditConstants", function(uiGridEditConstants) {
        return {
            "replace": true,
            "priority": -99998,
            "require": [ "^uiGrid", "^uiGridRenderContainer" ],
            "scope": false,
            "compile": function() {
                return {
                    "post": function($scope, $elm, $attrs, controllers) {
                        var uiGridCtrl = controllers[0];
                        if (!uiGridCtrl.grid.api.edit || !uiGridCtrl.grid.api.cellNav) {
                            return;
                        }
                        var containerId = controllers[1].containerId;
                        if (containerId !== "body") {
                            return;
                        }
                        $scope.$on(uiGridEditConstants.events.CANCEL_CELL_EDIT, function() {
                            uiGridCtrl.focus();
                        });
                        $scope.$on(uiGridEditConstants.events.END_CELL_EDIT, function() {
                            uiGridCtrl.focus();
                        });
                    }
                };
            }
        };
    } ]);
    module.directive("uiGridCell", [ "$compile", "$injector", "$timeout", "uiGridConstants", "uiGridEditConstants", "gridUtil", "$parse", "uiGridEditService", "$rootScope", "$q", function($compile, $injector, $timeout, uiGridConstants, uiGridEditConstants, gridUtil, $parse, uiGridEditService, $rootScope, $q) {
        var touchstartTimeout = 500;
        if ($injector.has("uiGridCellNavService")) {
            var uiGridCellNavService = $injector.get("uiGridCellNavService");
        }
        return {
            "priority": -100,
            "restrict": "A",
            "scope": false,
            "require": "?^uiGrid",
            "link": function($scope, $elm, $attrs, uiGridCtrl) {
                var html;
                var origCellValue;
                var inEdit = false;
                var cellModel;
                var cancelTouchstartTimeout;
                var editCellScope;
                if (!$scope.col.colDef.enableCellEdit) {
                    return;
                }
                var cellNavNavigateDereg = function() {};
                var viewPortKeyDownDereg = function() {};
                var setEditable = function() {
                    if ($scope.col.colDef.enableCellEdit && $scope.row.enableCellEdit !== false) {
                        if (!$scope.beginEditEventsWired) {
                            registerBeginEditEvents();
                        }
                    } else {
                        if ($scope.beginEditEventsWired) {
                            cancelBeginEditEvents();
                        }
                    }
                };
                setEditable();
                var rowWatchDereg = $scope.$watch("row", function(n, o) {
                    if (n !== o) {
                        setEditable();
                    }
                });
                $scope.$on("$destroy", rowWatchDereg);
                function registerBeginEditEvents() {
                    $elm.on("dblclick", beginEdit);
                    $elm.on("touchstart", touchStart);
                    if (uiGridCtrl && uiGridCtrl.grid.api.cellNav) {
                        viewPortKeyDownDereg = uiGridCtrl.grid.api.cellNav.on.viewPortKeyDown($scope, function(evt, rowCol) {
                            if (rowCol === null) {
                                return;
                            }
                            if (rowCol.row === $scope.row && rowCol.col === $scope.col && !$scope.col.colDef.enableCellEditOnFocus) {
                                beginEditKeyDown(evt);
                            }
                        });
                        cellNavNavigateDereg = uiGridCtrl.grid.api.cellNav.on.navigate($scope, function(newRowCol, oldRowCol) {
                            if ($scope.col.colDef.enableCellEditOnFocus) {
                                if ((!oldRowCol || newRowCol.row !== oldRowCol.row || newRowCol.col !== oldRowCol.col) && newRowCol.row === $scope.row && newRowCol.col === $scope.col) {
                                    $timeout(function() {
                                        beginEdit();
                                    });
                                }
                            }
                        });
                    }
                    $scope.beginEditEventsWired = true;
                }
                function touchStart(event) {
                    if (typeof event.originalEvent !== "undefined" && event.originalEvent !== undefined) {
                        event = event.originalEvent;
                    }
                    $elm.on("touchend", touchEnd);
                    cancelTouchstartTimeout = $timeout(function() {}, touchstartTimeout);
                    cancelTouchstartTimeout.then(function() {
                        setTimeout(beginEdit, 0);
                        $elm.off("touchend", touchEnd);
                    });
                }
                function touchEnd(event) {
                    $timeout.cancel(cancelTouchstartTimeout);
                    $elm.off("touchend", touchEnd);
                }
                function cancelBeginEditEvents() {
                    $elm.off("dblclick", beginEdit);
                    $elm.off("keydown", beginEditKeyDown);
                    $elm.off("touchstart", touchStart);
                    cellNavNavigateDereg();
                    viewPortKeyDownDereg();
                    $scope.beginEditEventsWired = false;
                }
                function beginEditKeyDown(evt) {
                    if (uiGridEditService.isStartEditKey(evt)) {
                        beginEdit(evt);
                    }
                }
                function shouldEdit(col, row) {
                    return !row.isSaving && (angular.isFunction(col.colDef.cellEditableCondition) ? col.colDef.cellEditableCondition($scope) : col.colDef.cellEditableCondition);
                }
                function beginEdit(triggerEvent) {
                    $scope.grid.api.core.scrollToIfNecessary($scope.row, $scope.col).then(function() {
                        beginEditAfterScroll(triggerEvent);
                    });
                }
                function beginEditAfterScroll(triggerEvent) {
                    if (inEdit) {
                        return;
                    }
                    if (!shouldEdit($scope.col, $scope.row)) {
                        return;
                    }
                    cellModel = $parse($scope.row.getQualifiedColField($scope.col));
                    origCellValue = cellModel($scope);
                    html = $scope.col.editableCellTemplate;
                    if ($scope.col.colDef.editModelField) {
                        html = html.replace(uiGridConstants.MODEL_COL_FIELD, gridUtil.preEval("row.entity." + $scope.col.colDef.editModelField));
                    } else {
                        html = html.replace(uiGridConstants.MODEL_COL_FIELD, $scope.row.getQualifiedColField($scope.col));
                    }
                    html = html.replace(uiGridConstants.COL_FIELD, "grid.getCellValue(row, col)");
                    var optionFilter = $scope.col.colDef.editDropdownFilter ? "|" + $scope.col.colDef.editDropdownFilter : "";
                    html = html.replace(uiGridConstants.CUSTOM_FILTERS, optionFilter);
                    var inputType = "text";
                    switch ($scope.col.colDef.type) {
                      case "boolean":
                        inputType = "checkbox";
                        break;

                      case "number":
                        inputType = "number";
                        break;

                      case "date":
                        inputType = "date";
                        break;
                    }
                    html = html.replace("INPUT_TYPE", inputType);
                    var editDropdownOptionsFunction = $scope.col.colDef.editDropdownOptionsFunction;
                    if (editDropdownOptionsFunction) {
                        $q.when(editDropdownOptionsFunction($scope.row.entity, $scope.col.colDef)).then(function(result) {
                            $scope.editDropdownOptionsArray = result;
                        });
                    } else {
                        var editDropdownRowEntityOptionsArrayPath = $scope.col.colDef.editDropdownRowEntityOptionsArrayPath;
                        if (editDropdownRowEntityOptionsArrayPath) {
                            $scope.editDropdownOptionsArray = resolveObjectFromPath($scope.row.entity, editDropdownRowEntityOptionsArrayPath);
                        } else {
                            $scope.editDropdownOptionsArray = $scope.col.colDef.editDropdownOptionsArray;
                        }
                    }
                    $scope.editDropdownIdLabel = $scope.col.colDef.editDropdownIdLabel ? $scope.col.colDef.editDropdownIdLabel : "id";
                    $scope.editDropdownValueLabel = $scope.col.colDef.editDropdownValueLabel ? $scope.col.colDef.editDropdownValueLabel : "value";
                    var cellElement;
                    var createEditor = function() {
                        inEdit = true;
                        cancelBeginEditEvents();
                        var cellElement = angular.element(html);
                        $elm.append(cellElement);
                        editCellScope = $scope.$new();
                        $compile(cellElement)(editCellScope);
                        var gridCellContentsEl = angular.element($elm.children()[0]);
                        gridCellContentsEl.addClass("ui-grid-cell-contents-hidden");
                    };
                    if (!$rootScope.$$phase) {
                        $scope.$apply(createEditor);
                    } else {
                        createEditor();
                    }
                    var deregOnGridScroll = $scope.col.grid.api.core.on.scrollBegin($scope, function() {
                        if ($scope.grid.disableScrolling) {
                            return;
                        }
                        endEdit();
                        $scope.grid.api.edit.raise.afterCellEdit($scope.row.entity, $scope.col.colDef, cellModel($scope), origCellValue);
                        deregOnGridScroll();
                        deregOnEndCellEdit();
                        deregOnCancelCellEdit();
                    });
                    var deregOnEndCellEdit = $scope.$on(uiGridEditConstants.events.END_CELL_EDIT, function() {
                        endEdit();
                        $scope.grid.api.edit.raise.afterCellEdit($scope.row.entity, $scope.col.colDef, cellModel($scope), origCellValue);
                        deregOnEndCellEdit();
                        deregOnGridScroll();
                        deregOnCancelCellEdit();
                    });
                    var deregOnCancelCellEdit = $scope.$on(uiGridEditConstants.events.CANCEL_CELL_EDIT, function() {
                        cancelEdit();
                        deregOnCancelCellEdit();
                        deregOnGridScroll();
                        deregOnEndCellEdit();
                    });
                    $scope.$broadcast(uiGridEditConstants.events.BEGIN_CELL_EDIT, triggerEvent);
                    $timeout(function() {
                        $scope.grid.api.edit.raise.beginCellEdit($scope.row.entity, $scope.col.colDef, triggerEvent);
                    });
                }
                function endEdit() {
                    $scope.grid.disableScrolling = false;
                    if (!inEdit) {
                        return;
                    }
                    if (uiGridCtrl && uiGridCtrl.grid.api.cellNav) {
                        uiGridCtrl.focus();
                    }
                    var gridCellContentsEl = angular.element($elm.children()[0]);
                    editCellScope.$destroy();
                    angular.element($elm.children()[1]).remove();
                    gridCellContentsEl.removeClass("ui-grid-cell-contents-hidden");
                    inEdit = false;
                    registerBeginEditEvents();
                    $scope.grid.api.core.notifyDataChange(uiGridConstants.dataChange.EDIT);
                }
                function cancelEdit() {
                    $scope.grid.disableScrolling = false;
                    if (!inEdit) {
                        return;
                    }
                    cellModel.assign($scope, origCellValue);
                    $scope.$apply();
                    $scope.grid.api.edit.raise.cancelCellEdit($scope.row.entity, $scope.col.colDef);
                    endEdit();
                }
                function resolveObjectFromPath(object, path) {
                    path = path.replace(/\[(\w+)\]/g, ".$1");
                    path = path.replace(/^\./, "");
                    var a = path.split(".");
                    while (a.length) {
                        var n = a.shift();
                        if (n in object) {
                            object = object[n];
                        } else {
                            return;
                        }
                    }
                    return object;
                }
            }
        };
    } ]);
    module.directive("uiGridEditor", [ "gridUtil", "uiGridConstants", "uiGridEditConstants", "$timeout", "uiGridEditService", function(gridUtil, uiGridConstants, uiGridEditConstants, $timeout, uiGridEditService) {
        return {
            "scope": true,
            "require": [ "?^uiGrid", "?^uiGridRenderContainer", "ngModel" ],
            "compile": function() {
                return {
                    "pre": function($scope, $elm, $attrs) {},
                    "post": function($scope, $elm, $attrs, controllers) {
                        var uiGridCtrl, renderContainerCtrl, ngModel;
                        if (controllers[0]) {
                            uiGridCtrl = controllers[0];
                        }
                        if (controllers[1]) {
                            renderContainerCtrl = controllers[1];
                        }
                        if (controllers[2]) {
                            ngModel = controllers[2];
                        }
                        $scope.$on(uiGridEditConstants.events.BEGIN_CELL_EDIT, function(evt, triggerEvent) {
                            $timeout(function() {
                                $elm[0].focus();
                                if ($elm[0].select && $scope.col.colDef.enableCellEditOnFocus || !(uiGridCtrl && uiGridCtrl.grid.api.cellNav)) {
                                    $elm[0].select();
                                } else {
                                    try {
                                        $elm[0].setSelectionRange($elm[0].value.length, $elm[0].value.length);
                                    } catch (ex) {}
                                }
                            });
                            if (uiGridCtrl && uiGridCtrl.grid.api.cellNav) {
                                var viewPortKeyDownUnregister = uiGridCtrl.grid.api.cellNav.on.viewPortKeyPress($scope, function(evt, rowCol) {
                                    if (uiGridEditService.isStartEditKey(evt)) {
                                        ngModel.$setViewValue(String.fromCharCode(typeof evt.which === "number" ? evt.which : evt.keyCode), evt);
                                        ngModel.$render();
                                    }
                                    viewPortKeyDownUnregister();
                                });
                            }
                            $elm.on("blur", function(evt) {
                                $scope.stopEdit(evt);
                            });
                        });
                        $scope.deepEdit = false;
                        $scope.stopEdit = function(evt) {
                            if ($scope.inputForm && !$scope.inputForm.$valid) {
                                evt.stopPropagation();
                                $scope.$emit(uiGridEditConstants.events.CANCEL_CELL_EDIT);
                            } else {
                                $scope.$emit(uiGridEditConstants.events.END_CELL_EDIT);
                            }
                            $scope.deepEdit = false;
                        };
                        $elm.on("click", function(evt) {
                            if ($elm[0].type !== "checkbox") {
                                $scope.deepEdit = true;
                                $timeout(function() {
                                    $scope.grid.disableScrolling = true;
                                });
                            }
                        });
                        $elm.on("keydown", function(evt) {
                            switch (evt.keyCode) {
                              case uiGridConstants.keymap.ESC:
                                evt.stopPropagation();
                                $scope.$emit(uiGridEditConstants.events.CANCEL_CELL_EDIT);
                                break;
                            }
                            if ($scope.deepEdit && (evt.keyCode === uiGridConstants.keymap.LEFT || evt.keyCode === uiGridConstants.keymap.RIGHT || evt.keyCode === uiGridConstants.keymap.UP || evt.keyCode === uiGridConstants.keymap.DOWN)) {
                                evt.stopPropagation();
                            } else if (uiGridCtrl && uiGridCtrl.grid.api.cellNav) {
                                evt.uiGridTargetRenderContainerId = renderContainerCtrl.containerId;
                                if (uiGridCtrl.cellNav.handleKeyDown(evt) !== null) {
                                    $scope.stopEdit(evt);
                                }
                            } else {
                                switch (evt.keyCode) {
                                  case uiGridConstants.keymap.ENTER:
                                  case uiGridConstants.keymap.TAB:
                                    evt.stopPropagation();
                                    evt.preventDefault();
                                    $scope.stopEdit(evt);
                                    break;
                                }
                            }
                            return true;
                        });
                    }
                };
            }
        };
    } ]);
    module.directive("uiGridEditor", [ "$filter", function($filter) {
        function parseDateString(dateString) {
            if (typeof dateString === "undefined" || dateString === "") {
                return null;
            }
            var parts = dateString.split("-");
            if (parts.length !== 3) {
                return null;
            }
            var year = parseInt(parts[0], 10);
            var month = parseInt(parts[1], 10);
            var day = parseInt(parts[2], 10);
            if (month < 1 || year < 1 || day < 1) {
                return null;
            }
            return new Date(year, month - 1, day);
        }
        return {
            "priority": -100,
            "require": "?ngModel",
            "link": function(scope, element, attrs, ngModel) {
                if (angular.version.minor === 2 && attrs.type && attrs.type === "date" && ngModel) {
                    ngModel.$formatters.push(function(modelValue) {
                        ngModel.$setValidity(null, !modelValue || !isNaN(modelValue.getTime()));
                        return $filter("date")(modelValue, "yyyy-MM-dd");
                    });
                    ngModel.$parsers.push(function(viewValue) {
                        if (viewValue && viewValue.length > 0) {
                            var dateValue = parseDateString(viewValue);
                            ngModel.$setValidity(null, dateValue && !isNaN(dateValue.getTime()));
                            return dateValue;
                        } else {
                            ngModel.$setValidity(null, true);
                            return null;
                        }
                    });
                }
            }
        };
    } ]);
    module.directive("uiGridEditDropdown", [ "uiGridConstants", "uiGridEditConstants", function(uiGridConstants, uiGridEditConstants) {
        return {
            "require": [ "?^uiGrid", "?^uiGridRenderContainer" ],
            "scope": true,
            "compile": function() {
                return {
                    "pre": function($scope, $elm, $attrs) {},
                    "post": function($scope, $elm, $attrs, controllers) {
                        var uiGridCtrl = controllers[0];
                        var renderContainerCtrl = controllers[1];
                        $scope.$on(uiGridEditConstants.events.BEGIN_CELL_EDIT, function() {
                            $elm[0].focus();
                            $elm[0].style.width = $elm[0].parentElement.offsetWidth - 1 + "px";
                            $elm.on("blur", function(evt) {
                                $scope.stopEdit(evt);
                            });
                        });
                        $scope.stopEdit = function(evt) {
                            $scope.$emit(uiGridEditConstants.events.END_CELL_EDIT);
                        };
                        $elm.on("keydown", function(evt) {
                            switch (evt.keyCode) {
                              case uiGridConstants.keymap.ESC:
                                evt.stopPropagation();
                                $scope.$emit(uiGridEditConstants.events.CANCEL_CELL_EDIT);
                                break;
                            }
                            if (uiGridCtrl && uiGridCtrl.grid.api.cellNav) {
                                evt.uiGridTargetRenderContainerId = renderContainerCtrl.containerId;
                                if (uiGridCtrl.cellNav.handleKeyDown(evt) !== null) {
                                    $scope.stopEdit(evt);
                                }
                            } else {
                                switch (evt.keyCode) {
                                  case uiGridConstants.keymap.ENTER:
                                  case uiGridConstants.keymap.TAB:
                                    evt.stopPropagation();
                                    evt.preventDefault();
                                    $scope.stopEdit(evt);
                                    break;
                                }
                            }
                            return true;
                        });
                    }
                };
            }
        };
    } ]);
    module.directive("uiGridEditFileChooser", [ "gridUtil", "uiGridConstants", "uiGridEditConstants", "$timeout", function(gridUtil, uiGridConstants, uiGridEditConstants, $timeout) {
        return {
            "scope": true,
            "require": [ "?^uiGrid", "?^uiGridRenderContainer" ],
            "compile": function() {
                return {
                    "pre": function($scope, $elm, $attrs) {},
                    "post": function($scope, $elm, $attrs, controllers) {
                        var uiGridCtrl, renderContainerCtrl;
                        if (controllers[0]) {
                            uiGridCtrl = controllers[0];
                        }
                        if (controllers[1]) {
                            renderContainerCtrl = controllers[1];
                        }
                        var grid = uiGridCtrl.grid;
                        var handleFileSelect = function(event) {
                            var target = event.srcElement || event.target;
                            if (target && target.files && target.files.length > 0) {
                                if (typeof $scope.col.colDef.editFileChooserCallback === "function") {
                                    $scope.col.colDef.editFileChooserCallback($scope.row, $scope.col, target.files);
                                } else {
                                    gridUtil.logError("You need to set colDef.editFileChooserCallback to use the file chooser");
                                }
                                target.form.reset();
                                $scope.$emit(uiGridEditConstants.events.END_CELL_EDIT);
                            } else {
                                $scope.$emit(uiGridEditConstants.events.CANCEL_CELL_EDIT);
                            }
                        };
                        $elm[0].addEventListener("change", handleFileSelect, false);
                        $scope.$on(uiGridEditConstants.events.BEGIN_CELL_EDIT, function() {
                            $elm[0].focus();
                            $elm[0].select();
                            $elm.on("blur", function(evt) {
                                $scope.$emit(uiGridEditConstants.events.END_CELL_EDIT);
                            });
                        });
                    }
                };
            }
        };
    } ]);
})();

(function() {
    "use strict";
    var module = angular.module("ui.grid.expandable", [ "ui.grid" ]);
    module.service("uiGridExpandableService", [ "gridUtil", "$compile", function(gridUtil, $compile) {
        var service = {
            "initializeGrid": function(grid) {
                grid.expandable = {};
                grid.expandable.expandedAll = false;
                grid.options.enableExpandable = grid.options.enableExpandable !== false;
                grid.options.expandableRowHeight = grid.options.expandableRowHeight || 150;
                grid.options.expandableRowHeaderWidth = grid.options.expandableRowHeaderWidth || 40;
                if (grid.options.enableExpandable && !grid.options.expandableRowTemplate) {
                    gridUtil.logError("You have not set the expandableRowTemplate, disabling expandable module");
                    grid.options.enableExpandable = false;
                }
                var publicApi = {
                    "events": {
                        "expandable": {
                            "rowExpandedBeforeStateChanged": function(scope, row) {},
                            "rowExpandedStateChanged": function(scope, row) {}
                        }
                    },
                    "methods": {
                        "expandable": {
                            "toggleRowExpansion": function(rowEntity) {
                                var row = grid.getRow(rowEntity);
                                if (row !== null) {
                                    service.toggleRowExpansion(grid, row);
                                }
                            },
                            "expandAllRows": function() {
                                service.expandAllRows(grid);
                            },
                            "collapseAllRows": function() {
                                service.collapseAllRows(grid);
                            },
                            "toggleAllRows": function() {
                                service.toggleAllRows(grid);
                            },
                            "expandRow": function(rowEntity) {
                                var row = grid.getRow(rowEntity);
                                if (row !== null && !row.isExpanded) {
                                    service.toggleRowExpansion(grid, row);
                                }
                            },
                            "collapseRow": function(rowEntity) {
                                var row = grid.getRow(rowEntity);
                                if (row !== null && row.isExpanded) {
                                    service.toggleRowExpansion(grid, row);
                                }
                            },
                            "getExpandedRows": function() {
                                return service.getExpandedRows(grid).map(function(gridRow) {
                                    return gridRow.entity;
                                });
                            }
                        }
                    }
                };
                grid.api.registerEventsFromObject(publicApi.events);
                grid.api.registerMethodsFromObject(publicApi.methods);
            },
            "toggleRowExpansion": function(grid, row) {
                grid.api.expandable.raise.rowExpandedBeforeStateChanged(row);
                row.isExpanded = !row.isExpanded;
                if (angular.isUndefined(row.expandedRowHeight)) {
                    row.expandedRowHeight = grid.options.expandableRowHeight;
                }
                if (row.isExpanded) {
                    row.height = row.grid.options.rowHeight + row.expandedRowHeight;
                } else {
                    row.height = row.grid.options.rowHeight;
                    grid.expandable.expandedAll = false;
                }
                grid.api.expandable.raise.rowExpandedStateChanged(row);
            },
            "expandAllRows": function(grid, $scope) {
                grid.renderContainers.body.visibleRowCache.forEach(function(row) {
                    if (!row.isExpanded) {
                        service.toggleRowExpansion(grid, row);
                    }
                });
                grid.expandable.expandedAll = true;
                grid.queueGridRefresh();
            },
            "collapseAllRows": function(grid) {
                grid.renderContainers.body.visibleRowCache.forEach(function(row) {
                    if (row.isExpanded) {
                        service.toggleRowExpansion(grid, row);
                    }
                });
                grid.expandable.expandedAll = false;
                grid.queueGridRefresh();
            },
            "toggleAllRows": function(grid) {
                if (grid.expandable.expandedAll) {
                    service.collapseAllRows(grid);
                } else {
                    service.expandAllRows(grid);
                }
            },
            "getExpandedRows": function(grid) {
                return grid.rows.filter(function(row) {
                    return row.isExpanded;
                });
            }
        };
        return service;
    } ]);
    module.directive("uiGridExpandable", [ "uiGridExpandableService", "$templateCache", function(uiGridExpandableService, $templateCache) {
        return {
            "replace": true,
            "priority": 0,
            "require": "^uiGrid",
            "scope": false,
            "compile": function() {
                return {
                    "pre": function($scope, $elm, $attrs, uiGridCtrl) {
                        if (uiGridCtrl.grid.options.enableExpandableRowHeader !== false) {
                            var expandableRowHeaderColDef = {
                                "name": "expandableButtons",
                                "displayName": "",
                                "exporterSuppressExport": true,
                                "enableColumnResizing": false,
                                "enableColumnMenu": false,
                                "width": uiGridCtrl.grid.options.expandableRowHeaderWidth || 40
                            };
                            expandableRowHeaderColDef.cellTemplate = $templateCache.get("ui-grid/expandableRowHeader");
                            expandableRowHeaderColDef.headerCellTemplate = $templateCache.get("ui-grid/expandableTopRowHeader");
                            uiGridCtrl.grid.addRowHeaderColumn(expandableRowHeaderColDef);
                        }
                        uiGridExpandableService.initializeGrid(uiGridCtrl.grid);
                    },
                    "post": function($scope, $elm, $attrs, uiGridCtrl) {}
                };
            }
        };
    } ]);
    module.directive("uiGrid", [ "uiGridExpandableService", "$templateCache", function(uiGridExpandableService, $templateCache) {
        return {
            "replace": true,
            "priority": 599,
            "require": "^uiGrid",
            "scope": false,
            "compile": function() {
                return {
                    "pre": function($scope, $elm, $attrs, uiGridCtrl) {
                        uiGridCtrl.grid.api.core.on.renderingComplete($scope, function() {
                            if ($scope.row && $scope.row.grid && $scope.row.grid.options && $scope.row.grid.options.enableExpandable) {
                                uiGridCtrl.grid.parentRow = $scope.row;
                            }
                        });
                    },
                    "post": function($scope, $elm, $attrs, uiGridCtrl) {}
                };
            }
        };
    } ]);
    module.directive("uiGridExpandableRow", [ "uiGridExpandableService", "$timeout", "$compile", "uiGridConstants", "gridUtil", "$interval", "$log", function(uiGridExpandableService, $timeout, $compile, uiGridConstants, gridUtil, $interval, $log) {
        return {
            "replace": false,
            "priority": 0,
            "scope": false,
            "compile": function() {
                return {
                    "pre": function($scope, $elm, $attrs, uiGridCtrl) {
                        gridUtil.getTemplate($scope.grid.options.expandableRowTemplate).then(function(template) {
                            if ($scope.grid.options.expandableRowScope) {
                                var expandableRowScope = $scope.grid.options.expandableRowScope;
                                for (var property in expandableRowScope) {
                                    if (expandableRowScope.hasOwnProperty(property)) {
                                        $scope[property] = expandableRowScope[property];
                                    }
                                }
                            }
                            var expandedRowElement = $compile(template)($scope);
                            $elm.append(expandedRowElement);
                            $scope.row.expandedRendered = true;
                        });
                    },
                    "post": function($scope, $elm, $attrs, uiGridCtrl) {
                        $scope.$on("$destroy", function() {
                            $scope.row.expandedRendered = false;
                        });
                    }
                };
            }
        };
    } ]);
    module.directive("uiGridRow", [ "$compile", "gridUtil", "$templateCache", function($compile, gridUtil, $templateCache) {
        return {
            "priority": -200,
            "scope": false,
            "compile": function($elm, $attrs) {
                return {
                    "pre": function($scope, $elm, $attrs, controllers) {
                        $scope.expandableRow = {};
                        $scope.expandableRow.shouldRenderExpand = function() {
                            var ret = $scope.colContainer.name === "body" && $scope.grid.options.enableExpandable !== false && $scope.row.isExpanded && (!$scope.grid.isScrollingVertically || $scope.row.expandedRendered);
                            return ret;
                        };
                        $scope.expandableRow.shouldRenderFiller = function() {
                            var ret = $scope.row.isExpanded && ($scope.colContainer.name !== "body" || $scope.grid.isScrollingVertically && !$scope.row.expandedRendered);
                            return ret;
                        };
                    },
                    "post": function($scope, $elm, $attrs, controllers) {}
                };
            }
        };
    } ]);
    module.directive("uiGridViewport", [ "$compile", "gridUtil", "$templateCache", function($compile, gridUtil, $templateCache) {
        return {
            "priority": -200,
            "scope": false,
            "compile": function($elm, $attrs) {
                var rowRepeatDiv = angular.element($elm.children().children()[0]);
                var expandedRowFillerElement = $templateCache.get("ui-grid/expandableScrollFiller");
                var expandedRowElement = $templateCache.get("ui-grid/expandableRow");
                rowRepeatDiv.append(expandedRowElement);
                rowRepeatDiv.append(expandedRowFillerElement);
                return {
                    "pre": function($scope, $elm, $attrs, controllers) {},
                    "post": function($scope, $elm, $attrs, controllers) {}
                };
            }
        };
    } ]);
})();

(function() {
    "use strict";
    var module = angular.module("ui.grid.exporter", [ "ui.grid" ]);
    module.constant("uiGridExporterConstants", {
        "featureName": "exporter",
        "ALL": "all",
        "VISIBLE": "visible",
        "SELECTED": "selected",
        "CSV_CONTENT": "CSV_CONTENT",
        "BUTTON_LABEL": "BUTTON_LABEL",
        "FILE_NAME": "FILE_NAME"
    });
    module.service("uiGridExporterService", [ "$q", "uiGridExporterConstants", "gridUtil", "$compile", "$interval", "i18nService", function($q, uiGridExporterConstants, gridUtil, $compile, $interval, i18nService) {
        var service = {
            "delay": 100,
            "initializeGrid": function(grid) {
                grid.exporter = {};
                this.defaultGridOptions(grid.options);
                var publicApi = {
                    "events": {
                        "exporter": {}
                    },
                    "methods": {
                        "exporter": {
                            "csvExport": function(rowTypes, colTypes) {
                                service.csvExport(grid, rowTypes, colTypes);
                            },
                            "pdfExport": function(rowTypes, colTypes) {
                                service.pdfExport(grid, rowTypes, colTypes);
                            }
                        }
                    }
                };
                grid.api.registerEventsFromObject(publicApi.events);
                grid.api.registerMethodsFromObject(publicApi.methods);
                if (grid.api.core.addToGridMenu) {
                    service.addToMenu(grid);
                } else {
                    $interval(function() {
                        if (grid.api.core.addToGridMenu) {
                            service.addToMenu(grid);
                        }
                    }, this.delay, 1);
                }
            },
            "defaultGridOptions": function(gridOptions) {
                gridOptions.exporterSuppressMenu = gridOptions.exporterSuppressMenu === true;
                gridOptions.exporterMenuLabel = gridOptions.exporterMenuLabel ? gridOptions.exporterMenuLabel : "Export";
                gridOptions.exporterSuppressColumns = gridOptions.exporterSuppressColumns ? gridOptions.exporterSuppressColumns : [];
                gridOptions.exporterCsvColumnSeparator = gridOptions.exporterCsvColumnSeparator ? gridOptions.exporterCsvColumnSeparator : ",";
                gridOptions.exporterCsvFilename = gridOptions.exporterCsvFilename ? gridOptions.exporterCsvFilename : "download.csv";
                gridOptions.exporterPdfFilename = gridOptions.exporterPdfFilename ? gridOptions.exporterPdfFilename : "download.pdf";
                gridOptions.exporterOlderExcelCompatibility = gridOptions.exporterOlderExcelCompatibility === true;
                gridOptions.exporterPdfDefaultStyle = gridOptions.exporterPdfDefaultStyle ? gridOptions.exporterPdfDefaultStyle : {
                    "fontSize": 11
                };
                gridOptions.exporterPdfTableStyle = gridOptions.exporterPdfTableStyle ? gridOptions.exporterPdfTableStyle : {
                    "margin": [ 0, 5, 0, 15 ]
                };
                gridOptions.exporterPdfTableHeaderStyle = gridOptions.exporterPdfTableHeaderStyle ? gridOptions.exporterPdfTableHeaderStyle : {
                    "bold": true,
                    "fontSize": 12,
                    "color": "black"
                };
                gridOptions.exporterPdfHeader = gridOptions.exporterPdfHeader ? gridOptions.exporterPdfHeader : null;
                gridOptions.exporterPdfFooter = gridOptions.exporterPdfFooter ? gridOptions.exporterPdfFooter : null;
                gridOptions.exporterPdfOrientation = gridOptions.exporterPdfOrientation ? gridOptions.exporterPdfOrientation : "landscape";
                gridOptions.exporterPdfPageSize = gridOptions.exporterPdfPageSize ? gridOptions.exporterPdfPageSize : "A4";
                gridOptions.exporterPdfMaxGridWidth = gridOptions.exporterPdfMaxGridWidth ? gridOptions.exporterPdfMaxGridWidth : 720;
                gridOptions.exporterMenuAllData = gridOptions.exporterMenuAllData !== undefined ? gridOptions.exporterMenuAllData : true;
                gridOptions.exporterMenuVisibleData = gridOptions.exporterMenuVisibleData !== undefined ? gridOptions.exporterMenuVisibleData : true;
                gridOptions.exporterMenuSelectedData = gridOptions.exporterMenuSelectedData !== undefined ? gridOptions.exporterMenuSelectedData : true;
                gridOptions.exporterMenuCsv = gridOptions.exporterMenuCsv !== undefined ? gridOptions.exporterMenuCsv : true;
                gridOptions.exporterMenuPdf = gridOptions.exporterMenuPdf !== undefined ? gridOptions.exporterMenuPdf : true;
                gridOptions.exporterPdfCustomFormatter = gridOptions.exporterPdfCustomFormatter && typeof gridOptions.exporterPdfCustomFormatter === "function" ? gridOptions.exporterPdfCustomFormatter : function(docDef) {
                    return docDef;
                };
                gridOptions.exporterHeaderFilterUseName = gridOptions.exporterHeaderFilterUseName === true;
                gridOptions.exporterFieldCallback = gridOptions.exporterFieldCallback ? gridOptions.exporterFieldCallback : function(grid, row, col, value) {
                    return value;
                };
                gridOptions.exporterAllDataFn = gridOptions.exporterAllDataFn ? gridOptions.exporterAllDataFn : null;
                if (gridOptions.exporterAllDataFn == null && gridOptions.exporterAllDataPromise) {
                    gridOptions.exporterAllDataFn = gridOptions.exporterAllDataPromise;
                }
            },
            "addToMenu": function(grid) {
                grid.api.core.addToGridMenu(grid, [ {
                    "title": i18nService.getSafeText("gridMenu.exporterAllAsCsv"),
                    "action": function($event) {
                        this.grid.api.exporter.csvExport(uiGridExporterConstants.ALL, uiGridExporterConstants.ALL);
                    },
                    "shown": function() {
                        return this.grid.options.exporterMenuCsv && this.grid.options.exporterMenuAllData;
                    },
                    "order": 200
                }, {
                    "title": i18nService.getSafeText("gridMenu.exporterVisibleAsCsv"),
                    "action": function($event) {
                        this.grid.api.exporter.csvExport(uiGridExporterConstants.VISIBLE, uiGridExporterConstants.VISIBLE);
                    },
                    "shown": function() {
                        return this.grid.options.exporterMenuCsv && this.grid.options.exporterMenuVisibleData;
                    },
                    "order": 201
                }, {
                    "title": i18nService.getSafeText("gridMenu.exporterSelectedAsCsv"),
                    "action": function($event) {
                        this.grid.api.exporter.csvExport(uiGridExporterConstants.SELECTED, uiGridExporterConstants.VISIBLE);
                    },
                    "shown": function() {
                        return this.grid.options.exporterMenuCsv && this.grid.options.exporterMenuSelectedData && (this.grid.api.selection && this.grid.api.selection.getSelectedRows().length > 0);
                    },
                    "order": 202
                }, {
                    "title": i18nService.getSafeText("gridMenu.exporterAllAsPdf"),
                    "action": function($event) {
                        this.grid.api.exporter.pdfExport(uiGridExporterConstants.ALL, uiGridExporterConstants.ALL);
                    },
                    "shown": function() {
                        return this.grid.options.exporterMenuPdf && this.grid.options.exporterMenuAllData;
                    },
                    "order": 203
                }, {
                    "title": i18nService.getSafeText("gridMenu.exporterVisibleAsPdf"),
                    "action": function($event) {
                        this.grid.api.exporter.pdfExport(uiGridExporterConstants.VISIBLE, uiGridExporterConstants.VISIBLE);
                    },
                    "shown": function() {
                        return this.grid.options.exporterMenuPdf && this.grid.options.exporterMenuVisibleData;
                    },
                    "order": 204
                }, {
                    "title": i18nService.getSafeText("gridMenu.exporterSelectedAsPdf"),
                    "action": function($event) {
                        this.grid.api.exporter.pdfExport(uiGridExporterConstants.SELECTED, uiGridExporterConstants.VISIBLE);
                    },
                    "shown": function() {
                        return this.grid.options.exporterMenuPdf && this.grid.options.exporterMenuSelectedData && (this.grid.api.selection && this.grid.api.selection.getSelectedRows().length > 0);
                    },
                    "order": 205
                } ]);
            },
            "csvExport": function(grid, rowTypes, colTypes) {
                var self = this;
                this.loadAllDataIfNeeded(grid, rowTypes, colTypes).then(function() {
                    var exportColumnHeaders = grid.options.showHeader ? self.getColumnHeaders(grid, colTypes) : [];
                    var exportData = self.getData(grid, rowTypes, colTypes);
                    var csvContent = self.formatAsCsv(exportColumnHeaders, exportData, grid.options.exporterCsvColumnSeparator);
                    self.downloadFile(grid.options.exporterCsvFilename, csvContent, grid.options.exporterOlderExcelCompatibility);
                });
            },
            "loadAllDataIfNeeded": function(grid, rowTypes, colTypes) {
                if (rowTypes === uiGridExporterConstants.ALL && grid.rows.length !== grid.options.totalItems && grid.options.exporterAllDataFn) {
                    return grid.options.exporterAllDataFn().then(function() {
                        grid.modifyRows(grid.options.data);
                    });
                } else {
                    var deferred = $q.defer();
                    deferred.resolve();
                    return deferred.promise;
                }
            },
            "getColumnHeaders": function(grid, colTypes) {
                var headers = [];
                var columns;
                if (colTypes === uiGridExporterConstants.ALL) {
                    columns = grid.columns;
                } else {
                    var leftColumns = grid.renderContainers.left ? grid.renderContainers.left.visibleColumnCache.filter(function(column) {
                        return column.visible;
                    }) : [];
                    var bodyColumns = grid.renderContainers.body ? grid.renderContainers.body.visibleColumnCache.filter(function(column) {
                        return column.visible;
                    }) : [];
                    var rightColumns = grid.renderContainers.right ? grid.renderContainers.right.visibleColumnCache.filter(function(column) {
                        return column.visible;
                    }) : [];
                    columns = leftColumns.concat(bodyColumns, rightColumns);
                }
                columns.forEach(function(gridCol, index) {
                    if (gridCol.colDef.exporterSuppressExport !== true && grid.options.exporterSuppressColumns.indexOf(gridCol.name) === -1) {
                        headers.push({
                            "name": gridCol.field,
                            "displayName": grid.options.exporterHeaderFilter ? grid.options.exporterHeaderFilterUseName ? grid.options.exporterHeaderFilter(gridCol.name) : grid.options.exporterHeaderFilter(gridCol.displayName) : gridCol.displayName,
                            "width": gridCol.drawnWidth ? gridCol.drawnWidth : gridCol.width,
                            "align": gridCol.colDef.type === "number" ? "right" : "left"
                        });
                    }
                });
                return headers;
            },
            "getData": function(grid, rowTypes, colTypes, applyCellFilters) {
                var data = [];
                var rows;
                var columns;
                switch (rowTypes) {
                  case uiGridExporterConstants.ALL:
                    rows = grid.rows;
                    break;

                  case uiGridExporterConstants.VISIBLE:
                    rows = grid.getVisibleRows();
                    break;

                  case uiGridExporterConstants.SELECTED:
                    if (grid.api.selection) {
                        rows = grid.api.selection.getSelectedGridRows();
                    } else {
                        gridUtil.logError("selection feature must be enabled to allow selected rows to be exported");
                    }
                    break;
                }
                if (colTypes === uiGridExporterConstants.ALL) {
                    columns = grid.columns;
                } else {
                    var leftColumns = grid.renderContainers.left ? grid.renderContainers.left.visibleColumnCache.filter(function(column) {
                        return column.visible;
                    }) : [];
                    var bodyColumns = grid.renderContainers.body ? grid.renderContainers.body.visibleColumnCache.filter(function(column) {
                        return column.visible;
                    }) : [];
                    var rightColumns = grid.renderContainers.right ? grid.renderContainers.right.visibleColumnCache.filter(function(column) {
                        return column.visible;
                    }) : [];
                    columns = leftColumns.concat(bodyColumns, rightColumns);
                }
                rows.forEach(function(row, index) {
                    if (row.exporterEnableExporting !== false) {
                        var extractedRow = [];
                        columns.forEach(function(gridCol, index) {
                            if ((gridCol.visible || colTypes === uiGridExporterConstants.ALL) && gridCol.colDef.exporterSuppressExport !== true && grid.options.exporterSuppressColumns.indexOf(gridCol.name) === -1) {
                                var cellValue = applyCellFilters ? grid.getCellDisplayValue(row, gridCol) : grid.getCellValue(row, gridCol);
                                var extractedField = {
                                    "value": grid.options.exporterFieldCallback(grid, row, gridCol, cellValue)
                                };
                                if (gridCol.colDef.exporterPdfAlign) {
                                    extractedField.alignment = gridCol.colDef.exporterPdfAlign;
                                }
                                extractedRow.push(extractedField);
                            }
                        });
                        data.push(extractedRow);
                    }
                });
                return data;
            },
            "formatAsCsv": function(exportColumnHeaders, exportData, separator) {
                var self = this;
                var bareHeaders = exportColumnHeaders.map(function(header) {
                    return {
                        "value": header.displayName
                    };
                });
                var csv = bareHeaders.length > 0 ? self.formatRowAsCsv(this, separator)(bareHeaders) + "\n" : "";
                csv += exportData.map(this.formatRowAsCsv(this, separator)).join("\n");
                return csv;
            },
            "formatRowAsCsv": function(exporter, separator) {
                return function(row) {
                    return row.map(exporter.formatFieldAsCsv).join(separator);
                };
            },
            "formatFieldAsCsv": function(field) {
                if (field.value == null) {
                    return "";
                }
                if (typeof field.value === "number") {
                    return field.value;
                }
                if (typeof field.value === "boolean") {
                    return field.value ? "TRUE" : "FALSE";
                }
                if (typeof field.value === "string") {
                    return '"' + field.value.replace(/"/g, '""') + '"';
                }
                return JSON.stringify(field.value);
            },
            "isIE": function() {
                var match = navigator.userAgent.search(/(?:Edge|MSIE|Trident\/.*; rv:)/);
                var isIE = false;
                if (match !== -1) {
                    isIE = true;
                }
                return isIE;
            },
            "downloadFile": function(fileName, csvContent, exporterOlderExcelCompatibility) {
                var D = document;
                var a = D.createElement("a");
                var strMimeType = "application/octet-stream;charset=utf-8";
                var rawFile;
                var ieVersion;
                ieVersion = this.isIE();
                if (ieVersion && ieVersion < 10) {
                    var frame = D.createElement("iframe");
                    document.body.appendChild(frame);
                    frame.contentWindow.document.open("text/html", "replace");
                    frame.contentWindow.document.write("sep=,\r\n" + csvContent);
                    frame.contentWindow.document.close();
                    frame.contentWindow.focus();
                    frame.contentWindow.document.execCommand("SaveAs", true, fileName);
                    document.body.removeChild(frame);
                    return true;
                }
                if (navigator.msSaveBlob) {
                    return navigator.msSaveOrOpenBlob(new Blob([ exporterOlderExcelCompatibility ? "\ufeff" : "", csvContent ], {
                        "type": strMimeType
                    }), fileName);
                }
                if ("download" in a) {
                    var blob = new Blob([ exporterOlderExcelCompatibility ? "\ufeff" : "", csvContent ], {
                        "type": strMimeType
                    });
                    rawFile = URL.createObjectURL(blob);
                    a.setAttribute("download", fileName);
                } else {
                    rawFile = "data:" + strMimeType + "," + encodeURIComponent(csvContent);
                    a.setAttribute("target", "_blank");
                }
                a.href = rawFile;
                a.setAttribute("style", "display:none;");
                D.body.appendChild(a);
                setTimeout(function() {
                    if (a.click) {
                        a.click();
                    } else if (document.createEvent) {
                        var eventObj = document.createEvent("MouseEvents");
                        eventObj.initEvent("click", true, true);
                        a.dispatchEvent(eventObj);
                    }
                    D.body.removeChild(a);
                }, this.delay);
            },
            "pdfExport": function(grid, rowTypes, colTypes) {
                var self = this;
                this.loadAllDataIfNeeded(grid, rowTypes, colTypes).then(function() {
                    var exportColumnHeaders = self.getColumnHeaders(grid, colTypes);
                    var exportData = self.getData(grid, rowTypes, colTypes);
                    var docDefinition = self.prepareAsPdf(grid, exportColumnHeaders, exportData);
                    if (self.isIE() || navigator.appVersion.indexOf("Edge") !== -1) {
                        self.downloadPDF(grid.options.exporterPdfFilename, docDefinition);
                    } else {
                        pdfMake.createPdf(docDefinition).open();
                    }
                });
            },
            "downloadPDF": function(fileName, docDefinition) {
                var D = document;
                var a = D.createElement("a");
                var strMimeType = "application/octet-stream;charset=utf-8";
                var rawFile;
                var ieVersion;
                ieVersion = this.isIE();
                var doc = pdfMake.createPdf(docDefinition);
                var blob;
                doc.getBuffer(function(buffer) {
                    blob = new Blob([ buffer ]);
                    if (navigator.msSaveBlob) {
                        return navigator.msSaveBlob(blob, fileName);
                    }
                    if (ieVersion) {
                        var frame = D.createElement("iframe");
                        document.body.appendChild(frame);
                        frame.contentWindow.document.open("text/html", "replace");
                        frame.contentWindow.document.write(blob);
                        frame.contentWindow.document.close();
                        frame.contentWindow.focus();
                        frame.contentWindow.document.execCommand("SaveAs", true, fileName);
                        document.body.removeChild(frame);
                        return true;
                    }
                });
            },
            "prepareAsPdf": function(grid, exportColumnHeaders, exportData) {
                var headerWidths = this.calculatePdfHeaderWidths(grid, exportColumnHeaders);
                var headerColumns = exportColumnHeaders.map(function(header) {
                    return {
                        "text": header.displayName,
                        "style": "tableHeader"
                    };
                });
                var stringData = exportData.map(this.formatRowAsPdf(this));
                var allData = [ headerColumns ].concat(stringData);
                var docDefinition = {
                    "pageOrientation": grid.options.exporterPdfOrientation,
                    "pageSize": grid.options.exporterPdfPageSize,
                    "content": [ {
                        "style": "tableStyle",
                        "table": {
                            "headerRows": 1,
                            "widths": headerWidths,
                            "body": allData
                        }
                    } ],
                    "styles": {
                        "tableStyle": grid.options.exporterPdfTableStyle,
                        "tableHeader": grid.options.exporterPdfTableHeaderStyle
                    },
                    "defaultStyle": grid.options.exporterPdfDefaultStyle
                };
                if (grid.options.exporterPdfLayout) {
                    docDefinition.layout = grid.options.exporterPdfLayout;
                }
                if (grid.options.exporterPdfHeader) {
                    docDefinition.header = grid.options.exporterPdfHeader;
                }
                if (grid.options.exporterPdfFooter) {
                    docDefinition.footer = grid.options.exporterPdfFooter;
                }
                if (grid.options.exporterPdfCustomFormatter) {
                    docDefinition = grid.options.exporterPdfCustomFormatter(docDefinition);
                }
                return docDefinition;
            },
            "calculatePdfHeaderWidths": function(grid, exportHeaders) {
                var baseGridWidth = 0;
                exportHeaders.forEach(function(value) {
                    if (typeof value.width === "number") {
                        baseGridWidth += value.width;
                    }
                });
                var extraColumns = 0;
                exportHeaders.forEach(function(value) {
                    if (value.width === "*") {
                        extraColumns += 100;
                    }
                    if (typeof value.width === "string" && value.width.match(/(\d)*%/)) {
                        var percent = parseInt(value.width.match(/(\d)*%/)[0]);
                        value.width = baseGridWidth * percent / 100;
                        extraColumns += value.width;
                    }
                });
                var gridWidth = baseGridWidth + extraColumns;
                return exportHeaders.map(function(header) {
                    return header.width === "*" ? header.width : header.width * grid.options.exporterPdfMaxGridWidth / gridWidth;
                });
            },
            "formatRowAsPdf": function(exporter) {
                return function(row) {
                    return row.map(exporter.formatFieldAsPdfString);
                };
            },
            "formatFieldAsPdfString": function(field) {
                var returnVal;
                if (field.value == null) {
                    returnVal = "";
                } else if (typeof field.value === "number") {
                    returnVal = field.value.toString();
                } else if (typeof field.value === "boolean") {
                    returnVal = field.value ? "TRUE" : "FALSE";
                } else if (typeof field.value === "string") {
                    returnVal = field.value.replace(/"/g, '""');
                } else {
                    returnVal = JSON.stringify(field.value).replace(/^"/, "").replace(/"$/, "");
                }
                if (field.alignment && typeof field.alignment === "string") {
                    returnVal = {
                        "text": returnVal,
                        "alignment": field.alignment
                    };
                }
                return returnVal;
            }
        };
        return service;
    } ]);
    module.directive("uiGridExporter", [ "uiGridExporterConstants", "uiGridExporterService", "gridUtil", "$compile", function(uiGridExporterConstants, uiGridExporterService, gridUtil, $compile) {
        return {
            "replace": true,
            "priority": 0,
            "require": "^uiGrid",
            "scope": false,
            "link": function($scope, $elm, $attrs, uiGridCtrl) {
                uiGridExporterService.initializeGrid(uiGridCtrl.grid);
                uiGridCtrl.grid.exporter.$scope = $scope;
            }
        };
    } ]);
})();

(function() {
    "use strict";
    var module = angular.module("ui.grid.grouping", [ "ui.grid", "ui.grid.treeBase" ]);
    module.constant("uiGridGroupingConstants", {
        "featureName": "grouping",
        "rowHeaderColName": "treeBaseRowHeaderCol",
        "EXPANDED": "expanded",
        "COLLAPSED": "collapsed",
        "aggregation": {
            "COUNT": "count",
            "SUM": "sum",
            "MAX": "max",
            "MIN": "min",
            "AVG": "avg"
        }
    });
    module.service("uiGridGroupingService", [ "$q", "uiGridGroupingConstants", "gridUtil", "rowSorter", "GridRow", "gridClassFactory", "i18nService", "uiGridConstants", "uiGridTreeBaseService", function($q, uiGridGroupingConstants, gridUtil, rowSorter, GridRow, gridClassFactory, i18nService, uiGridConstants, uiGridTreeBaseService) {
        var service = {
            "initializeGrid": function(grid, $scope) {
                uiGridTreeBaseService.initializeGrid(grid, $scope);
                grid.grouping = {};
                grid.grouping.groupHeaderCache = {};
                service.defaultGridOptions(grid.options);
                grid.registerRowsProcessor(service.groupRows, 400);
                grid.registerColumnBuilder(service.groupingColumnBuilder);
                grid.registerColumnsProcessor(service.groupingColumnProcessor, 400);
                var publicApi = {
                    "events": {
                        "grouping": {
                            "aggregationChanged": {},
                            "groupingChanged": {}
                        }
                    },
                    "methods": {
                        "grouping": {
                            "getGrouping": function(getExpanded) {
                                var grouping = service.getGrouping(grid);
                                grouping.grouping.forEach(function(group) {
                                    group.colName = group.col.name;
                                    delete group.col;
                                });
                                grouping.aggregations.forEach(function(aggregation) {
                                    aggregation.colName = aggregation.col.name;
                                    delete aggregation.col;
                                });
                                grouping.aggregations = grouping.aggregations.filter(function(aggregation) {
                                    return !aggregation.aggregation.source || aggregation.aggregation.source !== "grouping";
                                });
                                if (getExpanded) {
                                    grouping.rowExpandedStates = service.getRowExpandedStates(grid.grouping.groupingHeaderCache);
                                }
                                return grouping;
                            },
                            "setGrouping": function(config) {
                                service.setGrouping(grid, config);
                            },
                            "groupColumn": function(columnName) {
                                var column = grid.getColumn(columnName);
                                service.groupColumn(grid, column);
                            },
                            "ungroupColumn": function(columnName) {
                                var column = grid.getColumn(columnName);
                                service.ungroupColumn(grid, column);
                            },
                            "clearGrouping": function() {
                                service.clearGrouping(grid);
                            },
                            "aggregateColumn": function(columnName, aggregationDef, aggregationLabel) {
                                var column = grid.getColumn(columnName);
                                service.aggregateColumn(grid, column, aggregationDef, aggregationLabel);
                            }
                        }
                    }
                };
                grid.api.registerEventsFromObject(publicApi.events);
                grid.api.registerMethodsFromObject(publicApi.methods);
                grid.api.core.on.sortChanged($scope, service.tidyPriorities);
            },
            "defaultGridOptions": function(gridOptions) {
                gridOptions.enableGrouping = gridOptions.enableGrouping !== false;
                gridOptions.groupingShowCounts = gridOptions.groupingShowCounts !== false;
                gridOptions.groupingNullLabel = typeof gridOptions.groupingNullLabel === "undefined" ? "Null" : gridOptions.groupingNullLabel;
                gridOptions.enableGroupHeaderSelection = gridOptions.enableGroupHeaderSelection === true;
            },
            "groupingColumnBuilder": function(colDef, col, gridOptions) {
                if (colDef.enableGrouping === false) {
                    return;
                }
                if (typeof col.grouping === "undefined" && typeof colDef.grouping !== "undefined") {
                    col.grouping = angular.copy(colDef.grouping);
                    if (typeof col.grouping.groupPriority !== "undefined" && col.grouping.groupPriority > -1) {
                        col.treeAggregationFn = uiGridTreeBaseService.nativeAggregations()[uiGridGroupingConstants.aggregation.COUNT].aggregationFn;
                        col.treeAggregationFinalizerFn = service.groupedFinalizerFn;
                    }
                } else if (typeof col.grouping === "undefined") {
                    col.grouping = {};
                }
                if (typeof col.grouping !== "undefined" && typeof col.grouping.groupPriority !== "undefined" && col.grouping.groupPriority >= 0) {
                    col.suppressRemoveSort = true;
                }
                var groupColumn = {
                    "name": "ui.grid.grouping.group",
                    "title": i18nService.get().grouping.group,
                    "icon": "ui-grid-icon-indent-right",
                    "shown": function() {
                        return typeof this.context.col.grouping === "undefined" || typeof this.context.col.grouping.groupPriority === "undefined" || this.context.col.grouping.groupPriority < 0;
                    },
                    "action": function() {
                        service.groupColumn(this.context.col.grid, this.context.col);
                    }
                };
                var ungroupColumn = {
                    "name": "ui.grid.grouping.ungroup",
                    "title": i18nService.get().grouping.ungroup,
                    "icon": "ui-grid-icon-indent-left",
                    "shown": function() {
                        return typeof this.context.col.grouping !== "undefined" && typeof this.context.col.grouping.groupPriority !== "undefined" && this.context.col.grouping.groupPriority >= 0;
                    },
                    "action": function() {
                        service.ungroupColumn(this.context.col.grid, this.context.col);
                    }
                };
                var aggregateRemove = {
                    "name": "ui.grid.grouping.aggregateRemove",
                    "title": i18nService.get().grouping.aggregate_remove,
                    "shown": function() {
                        return typeof this.context.col.treeAggregationFn !== "undefined";
                    },
                    "action": function() {
                        service.aggregateColumn(this.context.col.grid, this.context.col, null);
                    }
                };
                var addAggregationMenu = function(type, title) {
                    title = title || i18nService.get().grouping["aggregate_" + type] || type;
                    var menuItem = {
                        "name": "ui.grid.grouping.aggregate" + type,
                        "title": title,
                        "shown": function() {
                            return typeof this.context.col.treeAggregation === "undefined" || typeof this.context.col.treeAggregation.type === "undefined" || this.context.col.treeAggregation.type !== type;
                        },
                        "action": function() {
                            service.aggregateColumn(this.context.col.grid, this.context.col, type);
                        }
                    };
                    if (!gridUtil.arrayContainsObjectWithProperty(col.menuItems, "name", "ui.grid.grouping.aggregate" + type)) {
                        col.menuItems.push(menuItem);
                    }
                };
                if (col.colDef.groupingShowGroupingMenu !== false) {
                    if (!gridUtil.arrayContainsObjectWithProperty(col.menuItems, "name", "ui.grid.grouping.group")) {
                        col.menuItems.push(groupColumn);
                    }
                    if (!gridUtil.arrayContainsObjectWithProperty(col.menuItems, "name", "ui.grid.grouping.ungroup")) {
                        col.menuItems.push(ungroupColumn);
                    }
                }
                if (col.colDef.groupingShowAggregationMenu !== false) {
                    angular.forEach(uiGridTreeBaseService.nativeAggregations(), function(aggregationDef, name) {
                        addAggregationMenu(name);
                    });
                    angular.forEach(gridOptions.treeCustomAggregations, function(aggregationDef, name) {
                        addAggregationMenu(name, aggregationDef.menuTitle);
                    });
                    if (!gridUtil.arrayContainsObjectWithProperty(col.menuItems, "name", "ui.grid.grouping.aggregateRemove")) {
                        col.menuItems.push(aggregateRemove);
                    }
                }
            },
            "groupingColumnProcessor": function(columns, rows) {
                var grid = this;
                columns = service.moveGroupColumns(this, columns, rows);
                return columns;
            },
            "groupedFinalizerFn": function(aggregation) {
                var col = this;
                if (typeof aggregation.groupVal !== "undefined") {
                    aggregation.rendered = aggregation.groupVal;
                    if (col.grid.options.groupingShowCounts && col.colDef.type !== "date") {
                        aggregation.rendered += " (" + aggregation.value + ")";
                    }
                } else {
                    aggregation.rendered = null;
                }
            },
            "moveGroupColumns": function(grid, columns, rows) {
                if (grid.options.moveGroupColumns === false) {
                    return columns;
                }
                columns.forEach(function(column, index) {
                    column.groupingPosition = index;
                });
                columns.sort(function(a, b) {
                    var a_group, b_group;
                    if (a.isRowHeader) {
                        a_group = -1e3;
                    } else if (typeof a.grouping === "undefined" || typeof a.grouping.groupPriority === "undefined" || a.grouping.groupPriority < 0) {
                        a_group = null;
                    } else {
                        a_group = a.grouping.groupPriority;
                    }
                    if (b.isRowHeader) {
                        b_group = -1e3;
                    } else if (typeof b.grouping === "undefined" || typeof b.grouping.groupPriority === "undefined" || b.grouping.groupPriority < 0) {
                        b_group = null;
                    } else {
                        b_group = b.grouping.groupPriority;
                    }
                    if (a_group !== null && b_group === null) {
                        return -1;
                    }
                    if (b_group !== null && a_group === null) {
                        return 1;
                    }
                    if (a_group !== null && b_group !== null) {
                        return a_group - b_group;
                    }
                    return a.groupingPosition - b.groupingPosition;
                });
                columns.forEach(function(column, index) {
                    delete column.groupingPosition;
                });
                return columns;
            },
            "groupColumn": function(grid, column) {
                if (typeof column.grouping === "undefined") {
                    column.grouping = {};
                }
                var existingGrouping = service.getGrouping(grid);
                column.grouping.groupPriority = existingGrouping.grouping.length;
                if (!column.sort) {
                    column.sort = {
                        "direction": uiGridConstants.ASC
                    };
                } else if (typeof column.sort.direction === "undefined" || column.sort.direction === null) {
                    column.sort.direction = uiGridConstants.ASC;
                }
                column.treeAggregation = {
                    "type": uiGridGroupingConstants.aggregation.COUNT,
                    "source": "grouping"
                };
                column.treeAggregationFn = uiGridTreeBaseService.nativeAggregations()[uiGridGroupingConstants.aggregation.COUNT].aggregationFn;
                column.treeAggregationFinalizerFn = service.groupedFinalizerFn;
                grid.api.grouping.raise.groupingChanged(column);
                grid.api.core.raise.sortChanged(grid, grid.getColumnSorting());
                grid.queueGridRefresh();
            },
            "ungroupColumn": function(grid, column) {
                if (typeof column.grouping === "undefined") {
                    return;
                }
                delete column.grouping.groupPriority;
                delete column.treeAggregation;
                delete column.customTreeAggregationFinalizer;
                service.tidyPriorities(grid);
                grid.api.grouping.raise.groupingChanged(column);
                grid.queueGridRefresh();
            },
            "aggregateColumn": function(grid, column, aggregationType) {
                if (typeof column.grouping !== "undefined" && typeof column.grouping.groupPriority !== "undefined" && column.grouping.groupPriority >= 0) {
                    service.ungroupColumn(grid, column);
                }
                var aggregationDef = {};
                if (typeof grid.options.treeCustomAggregations[aggregationType] !== "undefined") {
                    aggregationDef = grid.options.treeCustomAggregations[aggregationType];
                } else if (typeof uiGridTreeBaseService.nativeAggregations()[aggregationType] !== "undefined") {
                    aggregationDef = uiGridTreeBaseService.nativeAggregations()[aggregationType];
                }
                column.treeAggregation = {
                    "type": aggregationType,
                    "label": i18nService.get().aggregation[aggregationDef.label] || aggregationDef.label
                };
                column.treeAggregationFn = aggregationDef.aggregationFn;
                column.treeAggregationFinalizerFn = aggregationDef.finalizerFn;
                grid.api.grouping.raise.aggregationChanged(column);
                grid.queueGridRefresh();
            },
            "setGrouping": function(grid, config) {
                if (typeof config === "undefined") {
                    return;
                }
                service.clearGrouping(grid);
                if (config.grouping && config.grouping.length && config.grouping.length > 0) {
                    config.grouping.forEach(function(group) {
                        var col = grid.getColumn(group.colName);
                        if (col) {
                            service.groupColumn(grid, col);
                        }
                    });
                }
                if (config.aggregations && config.aggregations.length) {
                    config.aggregations.forEach(function(aggregation) {
                        var col = grid.getColumn(aggregation.colName);
                        if (col) {
                            service.aggregateColumn(grid, col, aggregation.aggregation.type);
                        }
                    });
                }
                if (config.rowExpandedStates) {
                    service.applyRowExpandedStates(grid.grouping.groupingHeaderCache, config.rowExpandedStates);
                }
            },
            "clearGrouping": function(grid) {
                var currentGrouping = service.getGrouping(grid);
                if (currentGrouping.grouping.length > 0) {
                    currentGrouping.grouping.forEach(function(group) {
                        if (!group.col) {
                            group.col = grid.getColumn(group.colName);
                        }
                        service.ungroupColumn(grid, group.col);
                    });
                }
                if (currentGrouping.aggregations.length > 0) {
                    currentGrouping.aggregations.forEach(function(aggregation) {
                        if (!aggregation.col) {
                            aggregation.col = grid.getColumn(aggregation.colName);
                        }
                        service.aggregateColumn(grid, aggregation.col, null);
                    });
                }
            },
            "tidyPriorities": function(grid) {
                if ((typeof grid === "undefined" || typeof grid.grid !== "undefined") && typeof this.grid !== "undefined") {
                    grid = this.grid;
                }
                var groupArray = [];
                var sortArray = [];
                grid.columns.forEach(function(column, index) {
                    if (typeof column.grouping !== "undefined" && typeof column.grouping.groupPriority !== "undefined" && column.grouping.groupPriority >= 0) {
                        groupArray.push(column);
                    } else if (typeof column.sort !== "undefined" && typeof column.sort.priority !== "undefined" && column.sort.priority >= 0) {
                        sortArray.push(column);
                    }
                });
                groupArray.sort(function(a, b) {
                    return a.grouping.groupPriority - b.grouping.groupPriority;
                });
                groupArray.forEach(function(column, index) {
                    column.grouping.groupPriority = index;
                    column.suppressRemoveSort = true;
                    if (typeof column.sort === "undefined") {
                        column.sort = {};
                    }
                    column.sort.priority = index;
                });
                var i = groupArray.length;
                sortArray.sort(function(a, b) {
                    return a.sort.priority - b.sort.priority;
                });
                sortArray.forEach(function(column, index) {
                    column.sort.priority = i;
                    column.suppressRemoveSort = column.colDef.suppressRemoveSort;
                    i++;
                });
            },
            "groupRows": function(renderableRows) {
                if (renderableRows.length === 0) {
                    return renderableRows;
                }
                var grid = this;
                grid.grouping.oldGroupingHeaderCache = grid.grouping.groupingHeaderCache || {};
                grid.grouping.groupingHeaderCache = {};
                var processingState = service.initialiseProcessingState(grid);
                var updateProcessingState = function(groupFieldState, stateIndex) {
                    var fieldValue = grid.getCellValue(row, groupFieldState.col);
                    if (!groupFieldState.initialised || rowSorter.getSortFn(grid, groupFieldState.col, renderableRows)(fieldValue, groupFieldState.currentValue) !== 0) {
                        service.insertGroupHeader(grid, renderableRows, i, processingState, stateIndex);
                        i++;
                    }
                };
                for (var i = 0; i < renderableRows.length; i++) {
                    var row = renderableRows[i];
                    if (row.visible) {
                        processingState.forEach(updateProcessingState);
                    }
                }
                delete grid.grouping.oldGroupingHeaderCache;
                return renderableRows;
            },
            "initialiseProcessingState": function(grid) {
                var processingState = [];
                var columnSettings = service.getGrouping(grid);
                columnSettings.grouping.forEach(function(groupItem, index) {
                    processingState.push({
                        "fieldName": groupItem.field,
                        "col": groupItem.col,
                        "initialised": false,
                        "currentValue": null,
                        "currentRow": null
                    });
                });
                return processingState;
            },
            "getGrouping": function(grid) {
                var groupArray = [];
                var aggregateArray = [];
                grid.columns.forEach(function(column, columnIndex) {
                    if (column.grouping) {
                        if (typeof column.grouping.groupPriority !== "undefined" && column.grouping.groupPriority >= 0) {
                            groupArray.push({
                                "field": column.field,
                                "col": column,
                                "groupPriority": column.grouping.groupPriority,
                                "grouping": column.grouping
                            });
                        }
                    }
                    if (column.treeAggregation && column.treeAggregation.type) {
                        aggregateArray.push({
                            "field": column.field,
                            "col": column,
                            "aggregation": column.treeAggregation
                        });
                    }
                });
                groupArray.sort(function(a, b) {
                    return a.groupPriority - b.groupPriority;
                });
                groupArray.forEach(function(group, index) {
                    group.grouping.groupPriority = index;
                    group.groupPriority = index;
                    delete group.grouping;
                });
                return {
                    "grouping": groupArray,
                    "aggregations": aggregateArray
                };
            },
            "insertGroupHeader": function(grid, renderableRows, rowIndex, processingState, stateIndex) {
                var fieldName = processingState[stateIndex].fieldName;
                var col = processingState[stateIndex].col;
                var newValue = grid.getCellValue(renderableRows[rowIndex], col);
                var newDisplayValue = newValue;
                if (typeof newValue === "undefined" || newValue === null) {
                    newDisplayValue = grid.options.groupingNullLabel;
                }
                var getKeyAsValueForCacheMap = function(key) {
                    if (angular.isObject(key)) {
                        return JSON.stringify(key);
                    } else {
                        return key;
                    }
                };
                var cacheItem = grid.grouping.oldGroupingHeaderCache;
                for (var i = 0; i < stateIndex; i++) {
                    if (cacheItem && cacheItem[getKeyAsValueForCacheMap(processingState[i].currentValue)]) {
                        cacheItem = cacheItem[getKeyAsValueForCacheMap(processingState[i].currentValue)].children;
                    }
                }
                var headerRow;
                if (cacheItem && cacheItem[getKeyAsValueForCacheMap(newValue)]) {
                    headerRow = cacheItem[getKeyAsValueForCacheMap(newValue)].row;
                    headerRow.entity = {};
                } else {
                    headerRow = new GridRow({}, null, grid);
                    gridClassFactory.rowTemplateAssigner.call(grid, headerRow);
                }
                headerRow.entity["$$" + processingState[stateIndex].col.uid] = {
                    "groupVal": newDisplayValue
                };
                headerRow.treeLevel = stateIndex;
                headerRow.groupHeader = true;
                headerRow.internalRow = true;
                headerRow.enableCellEdit = false;
                headerRow.enableSelection = grid.options.enableGroupHeaderSelection;
                processingState[stateIndex].initialised = true;
                processingState[stateIndex].currentValue = newValue;
                processingState[stateIndex].currentRow = headerRow;
                service.finaliseProcessingState(processingState, stateIndex + 1);
                renderableRows.splice(rowIndex, 0, headerRow);
                cacheItem = grid.grouping.groupingHeaderCache;
                for (i = 0; i < stateIndex; i++) {
                    cacheItem = cacheItem[getKeyAsValueForCacheMap(processingState[i].currentValue)].children;
                }
                cacheItem[getKeyAsValueForCacheMap(newValue)] = {
                    "row": headerRow,
                    "children": {}
                };
            },
            "finaliseProcessingState": function(processingState, stateIndex) {
                for (var i = stateIndex; i < processingState.length; i++) {
                    processingState[i].initialised = false;
                    processingState[i].currentRow = null;
                    processingState[i].currentValue = null;
                }
            },
            "getRowExpandedStates": function(treeChildren) {
                if (typeof treeChildren === "undefined") {
                    return {};
                }
                var newChildren = {};
                angular.forEach(treeChildren, function(value, key) {
                    newChildren[key] = {
                        "state": value.row.treeNode.state
                    };
                    if (value.children) {
                        newChildren[key].children = service.getRowExpandedStates(value.children);
                    } else {
                        newChildren[key].children = {};
                    }
                });
                return newChildren;
            },
            "applyRowExpandedStates": function(currentNode, expandedStates) {
                if (typeof expandedStates === "undefined") {
                    return;
                }
                angular.forEach(expandedStates, function(value, key) {
                    if (currentNode[key]) {
                        currentNode[key].row.treeNode.state = value.state;
                        if (value.children && currentNode[key].children) {
                            service.applyRowExpandedStates(currentNode[key].children, value.children);
                        }
                    }
                });
            }
        };
        return service;
    } ]);
    module.directive("uiGridGrouping", [ "uiGridGroupingConstants", "uiGridGroupingService", "$templateCache", function(uiGridGroupingConstants, uiGridGroupingService, $templateCache) {
        return {
            "replace": true,
            "priority": 0,
            "require": "^uiGrid",
            "scope": false,
            "compile": function() {
                return {
                    "pre": function($scope, $elm, $attrs, uiGridCtrl) {
                        if (uiGridCtrl.grid.options.enableGrouping !== false) {
                            uiGridGroupingService.initializeGrid(uiGridCtrl.grid, $scope);
                        }
                    },
                    "post": function($scope, $elm, $attrs, uiGridCtrl) {}
                };
            }
        };
    } ]);
})();

(function() {
    "use strict";
    var module = angular.module("ui.grid.importer", [ "ui.grid" ]);
    module.constant("uiGridImporterConstants", {
        "featureName": "importer"
    });
    module.service("uiGridImporterService", [ "$q", "uiGridConstants", "uiGridImporterConstants", "gridUtil", "$compile", "$interval", "i18nService", "$window", function($q, uiGridConstants, uiGridImporterConstants, gridUtil, $compile, $interval, i18nService, $window) {
        var service = {
            "initializeGrid": function($scope, grid) {
                grid.importer = {
                    "$scope": $scope
                };
                this.defaultGridOptions(grid.options);
                var publicApi = {
                    "events": {
                        "importer": {}
                    },
                    "methods": {
                        "importer": {
                            "importFile": function(fileObject) {
                                service.importThisFile(grid, fileObject);
                            }
                        }
                    }
                };
                grid.api.registerEventsFromObject(publicApi.events);
                grid.api.registerMethodsFromObject(publicApi.methods);
                if (grid.options.enableImporter && grid.options.importerShowMenu) {
                    if (grid.api.core.addToGridMenu) {
                        service.addToMenu(grid);
                    } else {
                        $interval(function() {
                            if (grid.api.core.addToGridMenu) {
                                service.addToMenu(grid);
                            }
                        }, 100, 1);
                    }
                }
            },
            "defaultGridOptions": function(gridOptions) {
                if (gridOptions.enableImporter || gridOptions.enableImporter === undefined) {
                    if (!($window.hasOwnProperty("File") && $window.hasOwnProperty("FileReader") && $window.hasOwnProperty("FileList") && $window.hasOwnProperty("Blob"))) {
                        gridUtil.logError("The File APIs are not fully supported in this browser, grid importer cannot be used.");
                        gridOptions.enableImporter = false;
                    } else {
                        gridOptions.enableImporter = true;
                    }
                } else {
                    gridOptions.enableImporter = false;
                }
                gridOptions.importerProcessHeaders = gridOptions.importerProcessHeaders || service.processHeaders;
                gridOptions.importerHeaderFilter = gridOptions.importerHeaderFilter || function(displayName) {
                    return displayName;
                };
                if (!gridOptions.importerErrorCallback || typeof gridOptions.importerErrorCallback !== "function") {
                    delete gridOptions.importerErrorCallback;
                }
                if (gridOptions.enableImporter === true && !gridOptions.importerDataAddCallback) {
                    gridUtil.logError("You have not set an importerDataAddCallback, importer is disabled");
                    gridOptions.enableImporter = false;
                }
                gridOptions.importerShowMenu = gridOptions.importerShowMenu !== false;
                gridOptions.importerObjectCallback = gridOptions.importerObjectCallback || function(grid, newObject) {
                    return newObject;
                };
            },
            "addToMenu": function(grid) {
                grid.api.core.addToGridMenu(grid, [ {
                    "title": i18nService.getSafeText("gridMenu.importerTitle"),
                    "order": 150
                }, {
                    "templateUrl": "ui-grid/importerMenuItemContainer",
                    "action": function($event) {
                        this.grid.api.importer.importAFile(grid);
                    },
                    "order": 151
                } ]);
            },
            "importThisFile": function(grid, fileObject) {
                if (!fileObject) {
                    gridUtil.logError("No file object provided to importThisFile, should be impossible, aborting");
                    return;
                }
                var reader = new FileReader();
                switch (fileObject.type) {
                  case "application/json":
                    reader.onload = service.importJsonClosure(grid);
                    break;

                  default:
                    reader.onload = service.importCsvClosure(grid);
                    break;
                }
                reader.readAsText(fileObject);
            },
            "importJsonClosure": function(grid) {
                return function(importFile) {
                    var newObjects = [];
                    var newObject;
                    var importArray = service.parseJson(grid, importFile);
                    if (importArray === null) {
                        return;
                    }
                    importArray.forEach(function(value, index) {
                        newObject = service.newObject(grid);
                        angular.extend(newObject, value);
                        newObject = grid.options.importerObjectCallback(grid, newObject);
                        newObjects.push(newObject);
                    });
                    service.addObjects(grid, newObjects);
                };
            },
            "parseJson": function(grid, importFile) {
                var loadedObjects;
                try {
                    loadedObjects = JSON.parse(importFile.target.result);
                } catch (e) {
                    service.alertError(grid, "importer.invalidJson", "File could not be processed, is it valid json? Content was: ", importFile.target.result);
                    return;
                }
                if (!Array.isArray(loadedObjects)) {
                    service.alertError(grid, "importer.jsonNotarray", "Import failed, file is not an array, file was: ", importFile.target.result);
                    return [];
                } else {
                    return loadedObjects;
                }
            },
            "importCsvClosure": function(grid) {
                return function(importFile) {
                    var importArray = service.parseCsv(importFile);
                    if (!importArray || importArray.length < 1) {
                        service.alertError(grid, "importer.invalidCsv", "File could not be processed, is it valid csv? Content was: ", importFile.target.result);
                        return;
                    }
                    var newObjects = service.createCsvObjects(grid, importArray);
                    if (!newObjects || newObjects.length === 0) {
                        service.alertError(grid, "importer.noObjects", "Objects were not able to be derived, content was: ", importFile.target.result);
                        return;
                    }
                    service.addObjects(grid, newObjects);
                };
            },
            "parseCsv": function(importFile) {
                var csv = importFile.target.result;
                return CSV.parse(csv);
            },
            "createCsvObjects": function(grid, importArray) {
                var headerMapping = grid.options.importerProcessHeaders(grid, importArray.shift());
                if (!headerMapping || headerMapping.length === 0) {
                    service.alertError(grid, "importer.noHeaders", "Column names could not be derived, content was: ", importArray);
                    return [];
                }
                var newObjects = [];
                var newObject;
                importArray.forEach(function(row, index) {
                    newObject = service.newObject(grid);
                    if (row !== null) {
                        row.forEach(function(field, index) {
                            if (headerMapping[index] !== null) {
                                newObject[headerMapping[index]] = field;
                            }
                        });
                    }
                    newObject = grid.options.importerObjectCallback(grid, newObject);
                    newObjects.push(newObject);
                });
                return newObjects;
            },
            "processHeaders": function(grid, headerRow) {
                var headers = [];
                if (!grid.options.columnDefs || grid.options.columnDefs.length === 0) {
                    headerRow.forEach(function(value, index) {
                        headers.push(value.replace(/[^0-9a-zA-Z\-_]/g, "_"));
                    });
                    return headers;
                } else {
                    var lookupHash = service.flattenColumnDefs(grid, grid.options.columnDefs);
                    headerRow.forEach(function(value, index) {
                        if (lookupHash[value]) {
                            headers.push(lookupHash[value]);
                        } else if (lookupHash[value.toLowerCase()]) {
                            headers.push(lookupHash[value.toLowerCase()]);
                        } else {
                            headers.push(null);
                        }
                    });
                    return headers;
                }
            },
            "flattenColumnDefs": function(grid, columnDefs) {
                var flattenedHash = {};
                columnDefs.forEach(function(columnDef, index) {
                    if (columnDef.name) {
                        flattenedHash[columnDef.name] = columnDef.field || columnDef.name;
                        flattenedHash[columnDef.name.toLowerCase()] = columnDef.field || columnDef.name;
                    }
                    if (columnDef.field) {
                        flattenedHash[columnDef.field] = columnDef.field || columnDef.name;
                        flattenedHash[columnDef.field.toLowerCase()] = columnDef.field || columnDef.name;
                    }
                    if (columnDef.displayName) {
                        flattenedHash[columnDef.displayName] = columnDef.field || columnDef.name;
                        flattenedHash[columnDef.displayName.toLowerCase()] = columnDef.field || columnDef.name;
                    }
                    if (columnDef.displayName && grid.options.importerHeaderFilter) {
                        flattenedHash[grid.options.importerHeaderFilter(columnDef.displayName)] = columnDef.field || columnDef.name;
                        flattenedHash[grid.options.importerHeaderFilter(columnDef.displayName).toLowerCase()] = columnDef.field || columnDef.name;
                    }
                });
                return flattenedHash;
            },
            "addObjects": function(grid, newObjects, $scope) {
                if (grid.api.rowEdit) {
                    var dataChangeDereg = grid.registerDataChangeCallback(function() {
                        grid.api.rowEdit.setRowsDirty(newObjects);
                        dataChangeDereg();
                    }, [ uiGridConstants.dataChange.ROW ]);
                    grid.importer.$scope.$on("$destroy", dataChangeDereg);
                }
                grid.importer.$scope.$apply(grid.options.importerDataAddCallback(grid, newObjects));
            },
            "newObject": function(grid) {
                if (typeof grid.options !== "undefined" && typeof grid.options.importerNewObject !== "undefined") {
                    return new grid.options.importerNewObject();
                } else {
                    return {};
                }
            },
            "alertError": function(grid, alertI18nToken, consoleMessage, context) {
                if (grid.options.importerErrorCallback) {
                    grid.options.importerErrorCallback(grid, alertI18nToken, consoleMessage, context);
                } else {
                    $window.alert(i18nService.getSafeText(alertI18nToken));
                    gridUtil.logError(consoleMessage + context);
                }
            }
        };
        return service;
    } ]);
    module.directive("uiGridImporter", [ "uiGridImporterConstants", "uiGridImporterService", "gridUtil", "$compile", function(uiGridImporterConstants, uiGridImporterService, gridUtil, $compile) {
        return {
            "replace": true,
            "priority": 0,
            "require": "^uiGrid",
            "scope": false,
            "link": function($scope, $elm, $attrs, uiGridCtrl) {
                uiGridImporterService.initializeGrid($scope, uiGridCtrl.grid);
            }
        };
    } ]);
    module.directive("uiGridImporterMenuItem", [ "uiGridImporterConstants", "uiGridImporterService", "gridUtil", "$compile", function(uiGridImporterConstants, uiGridImporterService, gridUtil, $compile) {
        return {
            "replace": true,
            "priority": 0,
            "require": "^uiGrid",
            "scope": false,
            "templateUrl": "ui-grid/importerMenuItem",
            "link": function($scope, $elm, $attrs, uiGridCtrl) {
                var handleFileSelect = function(event) {
                    var target = event.srcElement || event.target;
                    if (target && target.files && target.files.length === 1) {
                        var fileObject = target.files[0];
                        uiGridImporterService.importThisFile(grid, fileObject);
                        target.form.reset();
                    }
                };
                var fileChooser = $elm[0].querySelectorAll(".ui-grid-importer-file-chooser");
                var grid = uiGridCtrl.grid;
                if (fileChooser.length !== 1) {
                    gridUtil.logError("Found > 1 or < 1 file choosers within the menu item, error, cannot continue");
                } else {
                    fileChooser[0].addEventListener("change", handleFileSelect, false);
                }
            }
        };
    } ]);
})();

(function() {
    "use strict";
    var module = angular.module("ui.grid.infiniteScroll", [ "ui.grid" ]);
    module.service("uiGridInfiniteScrollService", [ "gridUtil", "$compile", "$timeout", "uiGridConstants", "ScrollEvent", "$q", function(gridUtil, $compile, $timeout, uiGridConstants, ScrollEvent, $q) {
        var service = {
            "initializeGrid": function(grid, $scope) {
                service.defaultGridOptions(grid.options);
                if (!grid.options.enableInfiniteScroll) {
                    return;
                }
                grid.infiniteScroll = {
                    "dataLoading": false
                };
                service.setScrollDirections(grid, grid.options.infiniteScrollUp, grid.options.infiniteScrollDown);
                grid.api.core.on.scrollEnd($scope, service.handleScroll);
                var publicApi = {
                    "events": {
                        "infiniteScroll": {
                            "needLoadMoreData": function($scope, fn) {},
                            "needLoadMoreDataTop": function($scope, fn) {}
                        }
                    },
                    "methods": {
                        "infiniteScroll": {
                            "dataLoaded": function(scrollUp, scrollDown) {
                                service.setScrollDirections(grid, scrollUp, scrollDown);
                                var promise = service.adjustScroll(grid).then(function() {
                                    grid.infiniteScroll.dataLoading = false;
                                });
                                return promise;
                            },
                            "resetScroll": function(scrollUp, scrollDown) {
                                service.setScrollDirections(grid, scrollUp, scrollDown);
                                return service.adjustInfiniteScrollPosition(grid, 0);
                            },
                            "saveScrollPercentage": function() {
                                grid.infiniteScroll.prevScrollTop = grid.renderContainers.body.prevScrollTop;
                                grid.infiniteScroll.previousVisibleRows = grid.getVisibleRowCount();
                            },
                            "dataRemovedTop": function(scrollUp, scrollDown) {
                                service.dataRemovedTop(grid, scrollUp, scrollDown);
                            },
                            "dataRemovedBottom": function(scrollUp, scrollDown) {
                                service.dataRemovedBottom(grid, scrollUp, scrollDown);
                            },
                            "setScrollDirections": function(scrollUp, scrollDown) {
                                service.setScrollDirections(grid, scrollUp, scrollDown);
                            }
                        }
                    }
                };
                grid.api.registerEventsFromObject(publicApi.events);
                grid.api.registerMethodsFromObject(publicApi.methods);
            },
            "defaultGridOptions": function(gridOptions) {
                gridOptions.enableInfiniteScroll = gridOptions.enableInfiniteScroll !== false;
                gridOptions.infiniteScrollRowsFromEnd = gridOptions.infiniteScrollRowsFromEnd || 20;
                gridOptions.infiniteScrollUp = gridOptions.infiniteScrollUp === true;
                gridOptions.infiniteScrollDown = gridOptions.infiniteScrollDown !== false;
            },
            "setScrollDirections": function(grid, scrollUp, scrollDown) {
                grid.infiniteScroll.scrollUp = scrollUp === true;
                grid.suppressParentScrollUp = scrollUp === true;
                grid.infiniteScroll.scrollDown = scrollDown !== false;
                grid.suppressParentScrollDown = scrollDown !== false;
            },
            "handleScroll": function(args) {
                if (args.grid.infiniteScroll && args.grid.infiniteScroll.dataLoading || args.source === "ui.grid.adjustInfiniteScrollPosition") {
                    return;
                }
                if (args.y) {
                    var percentage;
                    var targetPercentage = args.grid.options.infiniteScrollRowsFromEnd / args.grid.renderContainers.body.visibleRowCache.length;
                    if (args.grid.scrollDirection === uiGridConstants.scrollDirection.UP) {
                        percentage = args.y.percentage;
                        if (percentage <= targetPercentage) {
                            service.loadData(args.grid);
                        }
                    } else if (args.grid.scrollDirection === uiGridConstants.scrollDirection.DOWN) {
                        percentage = 1 - args.y.percentage;
                        if (percentage <= targetPercentage) {
                            service.loadData(args.grid);
                        }
                    }
                }
            },
            "loadData": function(grid) {
                grid.infiniteScroll.previousVisibleRows = grid.renderContainers.body.visibleRowCache.length;
                grid.infiniteScroll.direction = grid.scrollDirection;
                delete grid.infiniteScroll.prevScrollTop;
                if (grid.scrollDirection === uiGridConstants.scrollDirection.UP && grid.infiniteScroll.scrollUp) {
                    grid.infiniteScroll.dataLoading = true;
                    grid.api.infiniteScroll.raise.needLoadMoreDataTop();
                } else if (grid.scrollDirection === uiGridConstants.scrollDirection.DOWN && grid.infiniteScroll.scrollDown) {
                    grid.infiniteScroll.dataLoading = true;
                    grid.api.infiniteScroll.raise.needLoadMoreData();
                }
            },
            "adjustScroll": function(grid) {
                var promise = $q.defer();
                $timeout(function() {
                    var newPercentage, viewportHeight, rowHeight, newVisibleRows, oldTop, newTop;
                    viewportHeight = grid.getViewportHeight() + grid.headerHeight - grid.renderContainers.body.headerHeight - grid.scrollbarHeight;
                    rowHeight = grid.options.rowHeight;
                    if (grid.infiniteScroll.direction === undefined) {
                        service.adjustInfiniteScrollPosition(grid, 0);
                    }
                    newVisibleRows = grid.getVisibleRowCount();
                    var canvasHeight = rowHeight * newVisibleRows;
                    if (grid.infiniteScroll.scrollDown && viewportHeight > canvasHeight) {
                        grid.api.infiniteScroll.raise.needLoadMoreData();
                    }
                    if (grid.infiniteScroll.direction === uiGridConstants.scrollDirection.UP) {
                        oldTop = grid.infiniteScroll.prevScrollTop || 0;
                        newTop = oldTop + (newVisibleRows - grid.infiniteScroll.previousVisibleRows) * rowHeight;
                        service.adjustInfiniteScrollPosition(grid, newTop);
                        $timeout(function() {
                            promise.resolve();
                        });
                    }
                    if (grid.infiniteScroll.direction === uiGridConstants.scrollDirection.DOWN) {
                        newTop = grid.infiniteScroll.prevScrollTop || grid.infiniteScroll.previousVisibleRows * rowHeight - viewportHeight;
                        service.adjustInfiniteScrollPosition(grid, newTop);
                        $timeout(function() {
                            promise.resolve();
                        });
                    }
                }, 0);
                return promise.promise;
            },
            "adjustInfiniteScrollPosition": function(grid, scrollTop) {
                var scrollEvent = new ScrollEvent(grid, null, null, "ui.grid.adjustInfiniteScrollPosition"), visibleRows = grid.getVisibleRowCount(), viewportHeight = grid.getViewportHeight() + grid.headerHeight - grid.renderContainers.body.headerHeight - grid.scrollbarHeight, rowHeight = grid.options.rowHeight, scrollHeight = visibleRows * rowHeight - viewportHeight;
                if (scrollTop === 0 && grid.infiniteScroll.scrollUp) {
                    scrollEvent.y = {
                        "percentage": 1 / scrollHeight
                    };
                } else {
                    scrollEvent.y = {
                        "percentage": scrollTop / scrollHeight
                    };
                }
                grid.scrollContainers("", scrollEvent);
            },
            "dataRemovedTop": function(grid, scrollUp, scrollDown) {
                var newVisibleRows, oldTop, newTop, rowHeight;
                service.setScrollDirections(grid, scrollUp, scrollDown);
                newVisibleRows = grid.renderContainers.body.visibleRowCache.length;
                oldTop = grid.infiniteScroll.prevScrollTop;
                rowHeight = grid.options.rowHeight;
                newTop = oldTop - (grid.infiniteScroll.previousVisibleRows - newVisibleRows) * rowHeight;
                return service.adjustInfiniteScrollPosition(grid, newTop);
            },
            "dataRemovedBottom": function(grid, scrollUp, scrollDown) {
                var newTop;
                service.setScrollDirections(grid, scrollUp, scrollDown);
                newTop = grid.infiniteScroll.prevScrollTop;
                return service.adjustInfiniteScrollPosition(grid, newTop);
            }
        };
        return service;
    } ]);
    module.directive("uiGridInfiniteScroll", [ "uiGridInfiniteScrollService", function(uiGridInfiniteScrollService) {
        return {
            "priority": -200,
            "scope": false,
            "require": "^uiGrid",
            "compile": function($scope, $elm, $attr) {
                return {
                    "pre": function($scope, $elm, $attr, uiGridCtrl) {
                        uiGridInfiniteScrollService.initializeGrid(uiGridCtrl.grid, $scope);
                    },
                    "post": function($scope, $elm, $attr) {}
                };
            }
        };
    } ]);
})();

(function() {
    "use strict";
    var module = angular.module("ui.grid.moveColumns", [ "ui.grid" ]);
    module.service("uiGridMoveColumnService", [ "$q", "$timeout", "$log", "ScrollEvent", "uiGridConstants", "gridUtil", function($q, $timeout, $log, ScrollEvent, uiGridConstants, gridUtil) {
        var service = {
            "initializeGrid": function(grid) {
                var self = this;
                this.registerPublicApi(grid);
                this.defaultGridOptions(grid.options);
                grid.moveColumns = {
                    "orderCache": []
                };
                grid.registerColumnBuilder(self.movableColumnBuilder);
                grid.registerDataChangeCallback(self.verifyColumnOrder, [ uiGridConstants.dataChange.COLUMN ]);
            },
            "registerPublicApi": function(grid) {
                var self = this;
                var publicApi = {
                    "events": {
                        "colMovable": {
                            "columnPositionChanged": function(colDef, originalPosition, newPosition) {}
                        }
                    },
                    "methods": {
                        "colMovable": {
                            "moveColumn": function(originalPosition, finalPosition) {
                                var columns = grid.columns;
                                if (!angular.isNumber(originalPosition) || !angular.isNumber(finalPosition)) {
                                    gridUtil.logError("MoveColumn: Please provide valid values for originalPosition and finalPosition");
                                    return;
                                }
                                var nonMovableColumns = 0;
                                for (var i = 0; i < columns.length; i++) {
                                    if (angular.isDefined(columns[i].colDef.visible) && columns[i].colDef.visible === false || columns[i].isRowHeader === true) {
                                        nonMovableColumns++;
                                    }
                                }
                                if (originalPosition >= columns.length - nonMovableColumns || finalPosition >= columns.length - nonMovableColumns) {
                                    gridUtil.logError("MoveColumn: Invalid values for originalPosition, finalPosition");
                                    return;
                                }
                                var findPositionForRenderIndex = function(index) {
                                    var position = index;
                                    for (var i = 0; i <= position; i++) {
                                        if (angular.isDefined(columns[i]) && (angular.isDefined(columns[i].colDef.visible) && columns[i].colDef.visible === false || columns[i].isRowHeader === true)) {
                                            position++;
                                        }
                                    }
                                    return position;
                                };
                                self.redrawColumnAtPosition(grid, findPositionForRenderIndex(originalPosition), findPositionForRenderIndex(finalPosition));
                            }
                        }
                    }
                };
                grid.api.registerEventsFromObject(publicApi.events);
                grid.api.registerMethodsFromObject(publicApi.methods);
            },
            "defaultGridOptions": function(gridOptions) {
                gridOptions.enableColumnMoving = gridOptions.enableColumnMoving !== false;
            },
            "movableColumnBuilder": function(colDef, col, gridOptions) {
                var promises = [];
                colDef.enableColumnMoving = colDef.enableColumnMoving === undefined ? gridOptions.enableColumnMoving : colDef.enableColumnMoving;
                return $q.all(promises);
            },
            "updateColumnCache": function(grid) {
                grid.moveColumns.orderCache = grid.getOnlyDataColumns();
            },
            "verifyColumnOrder": function(grid) {
                var headerRowOffset = grid.rowHeaderColumns.length;
                var newIndex;
                angular.forEach(grid.moveColumns.orderCache, function(cacheCol, cacheIndex) {
                    newIndex = grid.columns.indexOf(cacheCol);
                    if (newIndex !== -1 && newIndex - headerRowOffset !== cacheIndex) {
                        var column = grid.columns.splice(newIndex, 1)[0];
                        grid.columns.splice(cacheIndex + headerRowOffset, 0, column);
                    }
                });
            },
            "redrawColumnAtPosition": function(grid, originalPosition, newPosition) {
                if (originalPosition === newPosition) {
                    return;
                }
                var columns = grid.columns;
                var originalColumn = columns[originalPosition];
                if (originalColumn.colDef.enableColumnMoving) {
                    if (originalPosition > newPosition) {
                        for (var i1 = originalPosition; i1 > newPosition; i1--) {
                            columns[i1] = columns[i1 - 1];
                        }
                    } else if (newPosition > originalPosition) {
                        for (var i2 = originalPosition; i2 < newPosition; i2++) {
                            columns[i2] = columns[i2 + 1];
                        }
                    }
                    columns[newPosition] = originalColumn;
                    service.updateColumnCache(grid);
                    grid.queueGridRefresh();
                    $timeout(function() {
                        grid.api.core.notifyDataChange(uiGridConstants.dataChange.COLUMN);
                        grid.api.colMovable.raise.columnPositionChanged(originalColumn.colDef, originalPosition, newPosition);
                    });
                }
            }
        };
        return service;
    } ]);
    module.directive("uiGridMoveColumns", [ "uiGridMoveColumnService", function(uiGridMoveColumnService) {
        return {
            "replace": true,
            "priority": 0,
            "require": "^uiGrid",
            "scope": false,
            "compile": function() {
                return {
                    "pre": function($scope, $elm, $attrs, uiGridCtrl) {
                        uiGridMoveColumnService.initializeGrid(uiGridCtrl.grid);
                    },
                    "post": function($scope, $elm, $attrs, uiGridCtrl) {}
                };
            }
        };
    } ]);
    module.directive("uiGridHeaderCell", [ "$q", "gridUtil", "uiGridMoveColumnService", "$document", "$log", "uiGridConstants", "ScrollEvent", function($q, gridUtil, uiGridMoveColumnService, $document, $log, uiGridConstants, ScrollEvent) {
        return {
            "priority": -10,
            "require": "^uiGrid",
            "compile": function() {
                return {
                    "post": function($scope, $elm, $attrs, uiGridCtrl) {
                        if ($scope.col.colDef.enableColumnMoving) {
                            var $contentsElm = angular.element($elm[0].querySelectorAll(".ui-grid-cell-contents"));
                            var gridLeft;
                            var previousMouseX;
                            var totalMouseMovement;
                            var rightMoveLimit;
                            var elmCloned = false;
                            var movingElm;
                            var reducedWidth;
                            var moveOccurred = false;
                            var downFn = function(event) {
                                gridLeft = $scope.grid.element[0].getBoundingClientRect().left;
                                if ($scope.grid.hasLeftContainer()) {
                                    gridLeft += $scope.grid.renderContainers.left.header[0].getBoundingClientRect().width;
                                }
                                previousMouseX = event.pageX;
                                totalMouseMovement = 0;
                                rightMoveLimit = gridLeft + $scope.grid.getViewportWidth();
                                if (event.type === "mousedown") {
                                    $document.on("mousemove", moveFn);
                                    $document.on("mouseup", upFn);
                                } else if (event.type === "touchstart") {
                                    $document.on("touchmove", moveFn);
                                    $document.on("touchend", upFn);
                                }
                            };
                            var moveFn = function(event) {
                                var changeValue = event.pageX - previousMouseX;
                                if (changeValue === 0) {
                                    return;
                                }
                                document.onselectstart = function() {
                                    return false;
                                };
                                moveOccurred = true;
                                if (!elmCloned) {
                                    cloneElement();
                                } else if (elmCloned) {
                                    moveElement(changeValue);
                                    previousMouseX = event.pageX;
                                }
                            };
                            var upFn = function(event) {
                                document.onselectstart = null;
                                if (movingElm) {
                                    movingElm.remove();
                                    elmCloned = false;
                                }
                                offAllEvents();
                                onDownEvents();
                                if (!moveOccurred) {
                                    return;
                                }
                                var columns = $scope.grid.columns;
                                var columnIndex = 0;
                                for (var i = 0; i < columns.length; i++) {
                                    if (columns[i].colDef.name !== $scope.col.colDef.name) {
                                        columnIndex++;
                                    } else {
                                        break;
                                    }
                                }
                                var targetIndex;
                                if (totalMouseMovement < 0) {
                                    var totalColumnsLeftWidth = 0;
                                    var il;
                                    if ($scope.grid.isRTL()) {
                                        for (il = columnIndex + 1; il < columns.length; il++) {
                                            if (angular.isUndefined(columns[il].colDef.visible) || columns[il].colDef.visible === true) {
                                                totalColumnsLeftWidth += columns[il].drawnWidth || columns[il].width || columns[il].colDef.width;
                                                if (totalColumnsLeftWidth > Math.abs(totalMouseMovement)) {
                                                    uiGridMoveColumnService.redrawColumnAtPosition($scope.grid, columnIndex, il - 1);
                                                    break;
                                                }
                                            }
                                        }
                                    } else {
                                        for (il = columnIndex - 1; il >= 0; il--) {
                                            if (angular.isUndefined(columns[il].colDef.visible) || columns[il].colDef.visible === true) {
                                                totalColumnsLeftWidth += columns[il].drawnWidth || columns[il].width || columns[il].colDef.width;
                                                if (totalColumnsLeftWidth > Math.abs(totalMouseMovement)) {
                                                    uiGridMoveColumnService.redrawColumnAtPosition($scope.grid, columnIndex, il + 1);
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                    if (totalColumnsLeftWidth < Math.abs(totalMouseMovement)) {
                                        targetIndex = 0;
                                        if ($scope.grid.isRTL()) {
                                            targetIndex = columns.length - 1;
                                        }
                                        uiGridMoveColumnService.redrawColumnAtPosition($scope.grid, columnIndex, targetIndex);
                                    }
                                } else if (totalMouseMovement > 0) {
                                    var totalColumnsRightWidth = 0;
                                    var ir;
                                    if ($scope.grid.isRTL()) {
                                        for (ir = columnIndex - 1; ir > 0; ir--) {
                                            if (angular.isUndefined(columns[ir].colDef.visible) || columns[ir].colDef.visible === true) {
                                                totalColumnsRightWidth += columns[ir].drawnWidth || columns[ir].width || columns[ir].colDef.width;
                                                if (totalColumnsRightWidth > totalMouseMovement) {
                                                    uiGridMoveColumnService.redrawColumnAtPosition($scope.grid, columnIndex, ir);
                                                    break;
                                                }
                                            }
                                        }
                                    } else {
                                        for (ir = columnIndex + 1; ir < columns.length; ir++) {
                                            if (angular.isUndefined(columns[ir].colDef.visible) || columns[ir].colDef.visible === true) {
                                                totalColumnsRightWidth += columns[ir].drawnWidth || columns[ir].width || columns[ir].colDef.width;
                                                if (totalColumnsRightWidth > totalMouseMovement) {
                                                    uiGridMoveColumnService.redrawColumnAtPosition($scope.grid, columnIndex, ir - 1);
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                    if (totalColumnsRightWidth < totalMouseMovement) {
                                        targetIndex = columns.length - 1;
                                        if ($scope.grid.isRTL()) {
                                            targetIndex = 0;
                                        }
                                        uiGridMoveColumnService.redrawColumnAtPosition($scope.grid, columnIndex, targetIndex);
                                    }
                                }
                            };
                            var onDownEvents = function() {
                                $contentsElm.on("touchstart", downFn);
                                $contentsElm.on("mousedown", downFn);
                            };
                            var offAllEvents = function() {
                                $contentsElm.off("touchstart", downFn);
                                $contentsElm.off("mousedown", downFn);
                                $document.off("mousemove", moveFn);
                                $document.off("touchmove", moveFn);
                                $document.off("mouseup", upFn);
                                $document.off("touchend", upFn);
                            };
                            onDownEvents();
                            var cloneElement = function() {
                                elmCloned = true;
                                movingElm = $elm.clone();
                                $elm.parent().append(movingElm);
                                movingElm.addClass("movingColumn");
                                var movingElementStyles = {};
                                movingElementStyles.left = $elm[0].offsetLeft + "px";
                                var gridRight = $scope.grid.element[0].getBoundingClientRect().right;
                                var elmRight = $elm[0].getBoundingClientRect().right;
                                if (elmRight > gridRight) {
                                    reducedWidth = $scope.col.drawnWidth + (gridRight - elmRight);
                                    movingElementStyles.width = reducedWidth + "px";
                                }
                                movingElm.css(movingElementStyles);
                            };
                            var moveElement = function(changeValue) {
                                var columns = $scope.grid.columns;
                                var totalColumnWidth = 0;
                                for (var i = 0; i < columns.length; i++) {
                                    if (angular.isUndefined(columns[i].colDef.visible) || columns[i].colDef.visible === true) {
                                        totalColumnWidth += columns[i].drawnWidth || columns[i].width || columns[i].colDef.width;
                                    }
                                }
                                var currentElmLeft = movingElm[0].getBoundingClientRect().left - 1;
                                var currentElmRight = movingElm[0].getBoundingClientRect().right;
                                var newElementLeft;
                                newElementLeft = currentElmLeft - gridLeft + changeValue;
                                newElementLeft = newElementLeft < rightMoveLimit ? newElementLeft : rightMoveLimit;
                                if ((currentElmLeft >= gridLeft || changeValue > 0) && (currentElmRight <= rightMoveLimit || changeValue < 0)) {
                                    movingElm.css({
                                        "visibility": "visible",
                                        "left": movingElm[0].offsetLeft + (newElementLeft < rightMoveLimit ? changeValue : rightMoveLimit - currentElmLeft) + "px"
                                    });
                                } else if (totalColumnWidth > Math.ceil(uiGridCtrl.grid.gridWidth)) {
                                    changeValue *= 8;
                                    var scrollEvent = new ScrollEvent($scope.col.grid, null, null, "uiGridHeaderCell.moveElement");
                                    scrollEvent.x = {
                                        "pixels": changeValue
                                    };
                                    scrollEvent.grid.scrollContainers("", scrollEvent);
                                }
                                var totalColumnsLeftWidth = 0;
                                for (var il = 0; il < columns.length; il++) {
                                    if (angular.isUndefined(columns[il].colDef.visible) || columns[il].colDef.visible === true) {
                                        if (columns[il].colDef.name !== $scope.col.colDef.name) {
                                            totalColumnsLeftWidth += columns[il].drawnWidth || columns[il].width || columns[il].colDef.width;
                                        } else {
                                            break;
                                        }
                                    }
                                }
                                if ($scope.newScrollLeft === undefined) {
                                    totalMouseMovement += changeValue;
                                } else {
                                    totalMouseMovement = $scope.newScrollLeft + newElementLeft - totalColumnsLeftWidth;
                                }
                                if (reducedWidth < $scope.col.drawnWidth) {
                                    reducedWidth += Math.abs(changeValue);
                                    movingElm.css({
                                        "width": reducedWidth + "px"
                                    });
                                }
                            };
                        }
                    }
                };
            }
        };
    } ]);
})();

(function() {
    "use strict";
    var module = angular.module("ui.grid.pagination", [ "ng", "ui.grid" ]);
    module.service("uiGridPaginationService", [ "gridUtil", function(gridUtil) {
        var service = {
            "initializeGrid": function(grid) {
                service.defaultGridOptions(grid.options);
                var publicApi = {
                    "events": {
                        "pagination": {
                            "paginationChanged": function(currentPage, pageSize) {}
                        }
                    },
                    "methods": {
                        "pagination": {
                            "getPage": function() {
                                return grid.options.enablePagination ? grid.options.paginationCurrentPage : null;
                            },
                            "getTotalPages": function() {
                                if (!grid.options.enablePagination) {
                                    return null;
                                }
                                return grid.options.totalItems === 0 ? 1 : Math.ceil(grid.options.totalItems / grid.options.paginationPageSize);
                            },
                            "nextPage": function() {
                                if (!grid.options.enablePagination) {
                                    return;
                                }
                                if (grid.options.totalItems > 0) {
                                    grid.options.paginationCurrentPage = Math.min(grid.options.paginationCurrentPage + 1, publicApi.methods.pagination.getTotalPages());
                                } else {
                                    grid.options.paginationCurrentPage++;
                                }
                            },
                            "previousPage": function() {
                                if (!grid.options.enablePagination) {
                                    return;
                                }
                                grid.options.paginationCurrentPage = Math.max(grid.options.paginationCurrentPage - 1, 1);
                            },
                            "seek": function(page) {
                                if (!grid.options.enablePagination) {
                                    return;
                                }
                                if (!angular.isNumber(page) || page < 1) {
                                    throw "Invalid page number: " + page;
                                }
                                grid.options.paginationCurrentPage = Math.min(page, publicApi.methods.pagination.getTotalPages());
                            }
                        }
                    }
                };
                grid.api.registerEventsFromObject(publicApi.events);
                grid.api.registerMethodsFromObject(publicApi.methods);
                var processPagination = function(renderableRows) {
                    if (grid.options.useExternalPagination || !grid.options.enablePagination) {
                        return renderableRows;
                    }
                    var pageSize = parseInt(grid.options.paginationPageSize, 10);
                    var currentPage = parseInt(grid.options.paginationCurrentPage, 10);
                    var visibleRows = renderableRows.filter(function(row) {
                        return row.visible;
                    });
                    grid.options.totalItems = visibleRows.length;
                    var firstRow = (currentPage - 1) * pageSize;
                    if (firstRow > visibleRows.length) {
                        currentPage = grid.options.paginationCurrentPage = 1;
                        firstRow = (currentPage - 1) * pageSize;
                    }
                    return visibleRows.slice(firstRow, firstRow + pageSize);
                };
                grid.registerRowsProcessor(processPagination, 900);
            },
            "defaultGridOptions": function(gridOptions) {
                gridOptions.enablePagination = gridOptions.enablePagination !== false;
                gridOptions.enablePaginationControls = gridOptions.enablePaginationControls !== false;
                gridOptions.useExternalPagination = gridOptions.useExternalPagination === true;
                if (gridUtil.isNullOrUndefined(gridOptions.totalItems)) {
                    gridOptions.totalItems = 0;
                }
                if (gridUtil.isNullOrUndefined(gridOptions.paginationPageSizes)) {
                    gridOptions.paginationPageSizes = [ 250, 500, 1e3 ];
                }
                if (gridUtil.isNullOrUndefined(gridOptions.paginationPageSize)) {
                    if (gridOptions.paginationPageSizes.length > 0) {
                        gridOptions.paginationPageSize = gridOptions.paginationPageSizes[0];
                    } else {
                        gridOptions.paginationPageSize = 0;
                    }
                }
                if (gridUtil.isNullOrUndefined(gridOptions.paginationCurrentPage)) {
                    gridOptions.paginationCurrentPage = 1;
                }
                if (gridUtil.isNullOrUndefined(gridOptions.paginationTemplate)) {
                    gridOptions.paginationTemplate = "ui-grid/pagination";
                }
            },
            "onPaginationChanged": function(grid, currentPage, pageSize) {
                grid.api.pagination.raise.paginationChanged(currentPage, pageSize);
                if (!grid.options.useExternalPagination) {
                    grid.queueGridRefresh();
                }
            }
        };
        return service;
    } ]);
    module.directive("uiGridPagination", [ "gridUtil", "uiGridPaginationService", function(gridUtil, uiGridPaginationService) {
        return {
            "priority": -200,
            "scope": false,
            "require": "uiGrid",
            "link": {
                "pre": function($scope, $elm, $attr, uiGridCtrl) {
                    uiGridPaginationService.initializeGrid(uiGridCtrl.grid);
                    gridUtil.getTemplate(uiGridCtrl.grid.options.paginationTemplate).then(function(contents) {
                        var template = angular.element(contents);
                        $elm.append(template);
                        uiGridCtrl.innerCompile(template);
                    });
                }
            }
        };
    } ]);
    module.directive("uiGridPager", [ "uiGridPaginationService", "uiGridConstants", "gridUtil", "i18nService", function(uiGridPaginationService, uiGridConstants, gridUtil, i18nService) {
        return {
            "priority": -200,
            "scope": true,
            "require": "^uiGrid",
            "link": function($scope, $elm, $attr, uiGridCtrl) {
                var defaultFocusElementSelector = ".ui-grid-pager-control-input";
                $scope.aria = i18nService.getSafeText("pagination.aria");
                $scope.paginationApi = uiGridCtrl.grid.api.pagination;
                $scope.sizesLabel = i18nService.getSafeText("pagination.sizes");
                $scope.totalItemsLabel = i18nService.getSafeText("pagination.totalItems");
                $scope.paginationOf = i18nService.getSafeText("pagination.of");
                $scope.paginationThrough = i18nService.getSafeText("pagination.through");
                var options = uiGridCtrl.grid.options;
                uiGridCtrl.grid.renderContainers.body.registerViewportAdjuster(function(adjustment) {
                    adjustment.height = adjustment.height - gridUtil.elementHeight($elm, "padding");
                    return adjustment;
                });
                var dataChangeDereg = uiGridCtrl.grid.registerDataChangeCallback(function(grid) {
                    if (!grid.options.useExternalPagination) {
                        grid.options.totalItems = grid.rows.length;
                    }
                }, [ uiGridConstants.dataChange.ROW ]);
                $scope.$on("$destroy", dataChangeDereg);
                var setShowing = function() {
                    $scope.showingLow = (options.paginationCurrentPage - 1) * options.paginationPageSize + 1;
                    $scope.showingHigh = Math.min(options.paginationCurrentPage * options.paginationPageSize, options.totalItems);
                };
                var deregT = $scope.$watch("grid.options.totalItems + grid.options.paginationPageSize", setShowing);
                var deregP = $scope.$watch("grid.options.paginationCurrentPage + grid.options.paginationPageSize", function(newValues, oldValues) {
                    if (newValues === oldValues || oldValues === undefined) {
                        return;
                    }
                    if (!angular.isNumber(options.paginationCurrentPage) || options.paginationCurrentPage < 1) {
                        options.paginationCurrentPage = 1;
                        return;
                    }
                    if (options.totalItems > 0 && options.paginationCurrentPage > $scope.paginationApi.getTotalPages()) {
                        options.paginationCurrentPage = $scope.paginationApi.getTotalPages();
                        return;
                    }
                    setShowing();
                    uiGridPaginationService.onPaginationChanged($scope.grid, options.paginationCurrentPage, options.paginationPageSize);
                });
                $scope.$on("$destroy", function() {
                    deregT();
                    deregP();
                });
                $scope.cantPageForward = function() {
                    if (options.totalItems > 0) {
                        return options.paginationCurrentPage >= $scope.paginationApi.getTotalPages();
                    } else {
                        return options.data.length < 1;
                    }
                };
                $scope.cantPageToLast = function() {
                    if (options.totalItems > 0) {
                        return $scope.cantPageForward();
                    } else {
                        return true;
                    }
                };
                $scope.cantPageBackward = function() {
                    return options.paginationCurrentPage <= 1;
                };
                var focusToInputIf = function(condition) {
                    if (condition) {
                        gridUtil.focus.bySelector($elm, defaultFocusElementSelector);
                    }
                };
                $scope.pageFirstPageClick = function() {
                    $scope.paginationApi.seek(1);
                    focusToInputIf($scope.cantPageBackward());
                };
                $scope.pagePreviousPageClick = function() {
                    $scope.paginationApi.previousPage();
                    focusToInputIf($scope.cantPageBackward());
                };
                $scope.pageNextPageClick = function() {
                    $scope.paginationApi.nextPage();
                    focusToInputIf($scope.cantPageForward());
                };
                $scope.pageLastPageClick = function() {
                    $scope.paginationApi.seek($scope.paginationApi.getTotalPages());
                    focusToInputIf($scope.cantPageToLast());
                };
            }
        };
    } ]);
})();

(function() {
    "use strict";
    var module = angular.module("ui.grid.pinning", [ "ui.grid" ]);
    module.constant("uiGridPinningConstants", {
        "container": {
            "LEFT": "left",
            "RIGHT": "right",
            "NONE": ""
        }
    });
    module.service("uiGridPinningService", [ "gridUtil", "GridRenderContainer", "i18nService", "uiGridPinningConstants", function(gridUtil, GridRenderContainer, i18nService, uiGridPinningConstants) {
        var service = {
            "initializeGrid": function(grid) {
                service.defaultGridOptions(grid.options);
                grid.registerColumnBuilder(service.pinningColumnBuilder);
                var publicApi = {
                    "events": {
                        "pinning": {
                            "columnPinned": function(colDef, container) {}
                        }
                    },
                    "methods": {
                        "pinning": {
                            "pinColumn": function(col, container) {
                                service.pinColumn(grid, col, container);
                            }
                        }
                    }
                };
                grid.api.registerEventsFromObject(publicApi.events);
                grid.api.registerMethodsFromObject(publicApi.methods);
            },
            "defaultGridOptions": function(gridOptions) {
                gridOptions.enablePinning = gridOptions.enablePinning !== false;
            },
            "pinningColumnBuilder": function(colDef, col, gridOptions) {
                colDef.enablePinning = colDef.enablePinning === undefined ? gridOptions.enablePinning : colDef.enablePinning;
                if (colDef.pinnedLeft) {
                    col.renderContainer = "left";
                    col.grid.createLeftContainer();
                } else if (colDef.pinnedRight) {
                    col.renderContainer = "right";
                    col.grid.createRightContainer();
                }
                if (!colDef.enablePinning) {
                    return;
                }
                var pinColumnLeftAction = {
                    "name": "ui.grid.pinning.pinLeft",
                    "title": i18nService.get().pinning.pinLeft,
                    "icon": "ui-grid-icon-left-open",
                    "shown": function() {
                        return typeof this.context.col.renderContainer === "undefined" || !this.context.col.renderContainer || this.context.col.renderContainer !== "left";
                    },
                    "action": function() {
                        service.pinColumn(this.context.col.grid, this.context.col, uiGridPinningConstants.container.LEFT);
                    }
                };
                var pinColumnRightAction = {
                    "name": "ui.grid.pinning.pinRight",
                    "title": i18nService.get().pinning.pinRight,
                    "icon": "ui-grid-icon-right-open",
                    "shown": function() {
                        return typeof this.context.col.renderContainer === "undefined" || !this.context.col.renderContainer || this.context.col.renderContainer !== "right";
                    },
                    "action": function() {
                        service.pinColumn(this.context.col.grid, this.context.col, uiGridPinningConstants.container.RIGHT);
                    }
                };
                var removePinAction = {
                    "name": "ui.grid.pinning.unpin",
                    "title": i18nService.get().pinning.unpin,
                    "icon": "ui-grid-icon-cancel",
                    "shown": function() {
                        return typeof this.context.col.renderContainer !== "undefined" && this.context.col.renderContainer !== null && this.context.col.renderContainer !== "body";
                    },
                    "action": function() {
                        service.pinColumn(this.context.col.grid, this.context.col, uiGridPinningConstants.container.NONE);
                    }
                };
                if (!gridUtil.arrayContainsObjectWithProperty(col.menuItems, "name", "ui.grid.pinning.pinLeft")) {
                    col.menuItems.push(pinColumnLeftAction);
                }
                if (!gridUtil.arrayContainsObjectWithProperty(col.menuItems, "name", "ui.grid.pinning.pinRight")) {
                    col.menuItems.push(pinColumnRightAction);
                }
                if (!gridUtil.arrayContainsObjectWithProperty(col.menuItems, "name", "ui.grid.pinning.unpin")) {
                    col.menuItems.push(removePinAction);
                }
            },
            "pinColumn": function(grid, col, container) {
                if (container === uiGridPinningConstants.container.NONE) {
                    col.renderContainer = null;
                    col.colDef.pinnedLeft = col.colDef.pinnedRight = false;
                } else {
                    col.renderContainer = container;
                    if (container === uiGridPinningConstants.container.LEFT) {
                        grid.createLeftContainer();
                    } else if (container === uiGridPinningConstants.container.RIGHT) {
                        grid.createRightContainer();
                    }
                }
                grid.refresh().then(function() {
                    grid.api.pinning.raise.columnPinned(col.colDef, container);
                });
            }
        };
        return service;
    } ]);
    module.directive("uiGridPinning", [ "gridUtil", "uiGridPinningService", function(gridUtil, uiGridPinningService) {
        return {
            "require": "uiGrid",
            "scope": false,
            "compile": function() {
                return {
                    "pre": function($scope, $elm, $attrs, uiGridCtrl) {
                        uiGridPinningService.initializeGrid(uiGridCtrl.grid);
                    },
                    "post": function($scope, $elm, $attrs, uiGridCtrl) {}
                };
            }
        };
    } ]);
})();

(function() {
    "use strict";
    var module = angular.module("ui.grid.resizeColumns", [ "ui.grid" ]);
    module.service("uiGridResizeColumnsService", [ "gridUtil", "$q", "$timeout", function(gridUtil, $q, $timeout) {
        var service = {
            "defaultGridOptions": function(gridOptions) {
                gridOptions.enableColumnResizing = gridOptions.enableColumnResizing !== false;
                if (gridOptions.enableColumnResize === false) {
                    gridOptions.enableColumnResizing = false;
                }
            },
            "colResizerColumnBuilder": function(colDef, col, gridOptions) {
                var promises = [];
                colDef.enableColumnResizing = colDef.enableColumnResizing === undefined ? gridOptions.enableColumnResizing : colDef.enableColumnResizing;
                if (colDef.enableColumnResize === false) {
                    colDef.enableColumnResizing = false;
                }
                return $q.all(promises);
            },
            "registerPublicApi": function(grid) {
                var publicApi = {
                    "events": {
                        "colResizable": {
                            "columnSizeChanged": function(colDef, deltaChange) {}
                        }
                    }
                };
                grid.api.registerEventsFromObject(publicApi.events);
            },
            "fireColumnSizeChanged": function(grid, colDef, deltaChange) {
                $timeout(function() {
                    if (grid.api.colResizable) {
                        grid.api.colResizable.raise.columnSizeChanged(colDef, deltaChange);
                    } else {
                        gridUtil.logError("The resizeable api is not registered, this may indicate that you've included the module but not added the 'ui-grid-resize-columns' directive to your grid definition.  Cannot raise any events.");
                    }
                });
            },
            "findTargetCol": function(col, position, rtlMultiplier) {
                var renderContainer = col.getRenderContainer();
                if (position === "left") {
                    var colIndex = renderContainer.visibleColumnCache.indexOf(col);
                    return renderContainer.visibleColumnCache[colIndex - 1 * rtlMultiplier];
                } else {
                    return col;
                }
            }
        };
        return service;
    } ]);
    module.directive("uiGridResizeColumns", [ "gridUtil", "uiGridResizeColumnsService", function(gridUtil, uiGridResizeColumnsService) {
        return {
            "replace": true,
            "priority": 0,
            "require": "^uiGrid",
            "scope": false,
            "compile": function() {
                return {
                    "pre": function($scope, $elm, $attrs, uiGridCtrl) {
                        uiGridResizeColumnsService.defaultGridOptions(uiGridCtrl.grid.options);
                        uiGridCtrl.grid.registerColumnBuilder(uiGridResizeColumnsService.colResizerColumnBuilder);
                        uiGridResizeColumnsService.registerPublicApi(uiGridCtrl.grid);
                    },
                    "post": function($scope, $elm, $attrs, uiGridCtrl) {}
                };
            }
        };
    } ]);
    module.directive("uiGridHeaderCell", [ "gridUtil", "$templateCache", "$compile", "$q", "uiGridResizeColumnsService", "uiGridConstants", "$timeout", function(gridUtil, $templateCache, $compile, $q, uiGridResizeColumnsService, uiGridConstants, $timeout) {
        return {
            "priority": -10,
            "require": "^uiGrid",
            "compile": function() {
                return {
                    "post": function($scope, $elm, $attrs, uiGridCtrl) {
                        var grid = uiGridCtrl.grid;
                        if (grid.options.enableColumnResizing) {
                            var columnResizerElm = $templateCache.get("ui-grid/columnResizer");
                            var rtlMultiplier = 1;
                            if (grid.isRTL()) {
                                $scope.position = "left";
                                rtlMultiplier = -1;
                            }
                            var displayResizers = function() {
                                var resizers = $elm[0].getElementsByClassName("ui-grid-column-resizer");
                                for (var i = 0; i < resizers.length; i++) {
                                    angular.element(resizers[i]).remove();
                                }
                                var otherCol = uiGridResizeColumnsService.findTargetCol($scope.col, "left", rtlMultiplier);
                                var renderContainer = $scope.col.getRenderContainer();
                                if (otherCol && renderContainer.visibleColumnCache.indexOf($scope.col) !== 0 && otherCol.colDef.enableColumnResizing !== false) {
                                    var resizerLeft = angular.element(columnResizerElm).clone();
                                    resizerLeft.attr("position", "left");
                                    $elm.prepend(resizerLeft);
                                    $compile(resizerLeft)($scope);
                                }
                                if ($scope.col.colDef.enableColumnResizing !== false) {
                                    var resizerRight = angular.element(columnResizerElm).clone();
                                    resizerRight.attr("position", "right");
                                    $elm.append(resizerRight);
                                    $compile(resizerRight)($scope);
                                }
                            };
                            displayResizers();
                            var waitDisplay = function() {
                                $timeout(displayResizers);
                            };
                            var dataChangeDereg = grid.registerDataChangeCallback(waitDisplay, [ uiGridConstants.dataChange.COLUMN ]);
                            $scope.$on("$destroy", dataChangeDereg);
                        }
                    }
                };
            }
        };
    } ]);
    module.directive("uiGridColumnResizer", [ "$document", "gridUtil", "uiGridConstants", "uiGridResizeColumnsService", function($document, gridUtil, uiGridConstants, uiGridResizeColumnsService) {
        var resizeOverlay = angular.element('<div class="ui-grid-resize-overlay"></div>');
        var resizer = {
            "priority": 0,
            "scope": {
                "col": "=",
                "position": "@",
                "renderIndex": "="
            },
            "require": "?^uiGrid",
            "link": function($scope, $elm, $attrs, uiGridCtrl) {
                var startX = 0, x = 0, gridLeft = 0, rtlMultiplier = 1;
                if (uiGridCtrl.grid.isRTL()) {
                    $scope.position = "left";
                    rtlMultiplier = -1;
                }
                if ($scope.position === "left") {
                    $elm.addClass("left");
                } else if ($scope.position === "right") {
                    $elm.addClass("right");
                }
                function refreshCanvas(xDiff) {
                    uiGridCtrl.grid.refreshCanvas(true).then(function() {
                        uiGridCtrl.grid.queueGridRefresh();
                    });
                }
                function constrainWidth(col, width) {
                    var newWidth = width;
                    if (col.minWidth && newWidth < col.minWidth) {
                        newWidth = col.minWidth;
                    } else if (col.maxWidth && newWidth > col.maxWidth) {
                        newWidth = col.maxWidth;
                    }
                    return newWidth;
                }
                function moveFunction(event, args) {
                    if (event.originalEvent) {
                        event = event.originalEvent;
                    }
                    event.preventDefault();
                    x = (event.targetTouches ? event.targetTouches[0] : event).clientX - gridLeft;
                    if (x < 0) {
                        x = 0;
                    } else if (x > uiGridCtrl.grid.gridWidth) {
                        x = uiGridCtrl.grid.gridWidth;
                    }
                    var col = uiGridResizeColumnsService.findTargetCol($scope.col, $scope.position, rtlMultiplier);
                    if (col.colDef.enableColumnResizing === false) {
                        return;
                    }
                    if (!uiGridCtrl.grid.element.hasClass("column-resizing")) {
                        uiGridCtrl.grid.element.addClass("column-resizing");
                    }
                    var xDiff = x - startX;
                    var newWidth = parseInt(col.drawnWidth + xDiff * rtlMultiplier, 10);
                    x = x + (constrainWidth(col, newWidth) - newWidth) * rtlMultiplier;
                    resizeOverlay.css({
                        "left": x + "px"
                    });
                    uiGridCtrl.fireEvent(uiGridConstants.events.ITEM_DRAGGING);
                }
                function upFunction(event, args) {
                    if (event.originalEvent) {
                        event = event.originalEvent;
                    }
                    event.preventDefault();
                    uiGridCtrl.grid.element.removeClass("column-resizing");
                    resizeOverlay.remove();
                    x = (event.changedTouches ? event.changedTouches[0] : event).clientX - gridLeft;
                    var xDiff = x - startX;
                    if (xDiff === 0) {
                        offAllEvents();
                        onDownEvents();
                        return;
                    }
                    var col = uiGridResizeColumnsService.findTargetCol($scope.col, $scope.position, rtlMultiplier);
                    if (col.colDef.enableColumnResizing === false) {
                        return;
                    }
                    var newWidth = parseInt(col.drawnWidth + xDiff * rtlMultiplier, 10);
                    col.width = constrainWidth(col, newWidth);
                    col.hasCustomWidth = true;
                    refreshCanvas(xDiff);
                    uiGridResizeColumnsService.fireColumnSizeChanged(uiGridCtrl.grid, col.colDef, xDiff);
                    offAllEvents();
                    onDownEvents();
                }
                var downFunction = function(event, args) {
                    if (event.originalEvent) {
                        event = event.originalEvent;
                    }
                    event.stopPropagation();
                    gridLeft = uiGridCtrl.grid.element[0].getBoundingClientRect().left;
                    startX = (event.targetTouches ? event.targetTouches[0] : event).clientX - gridLeft;
                    uiGridCtrl.grid.element.append(resizeOverlay);
                    resizeOverlay.css({
                        "left": startX
                    });
                    if (event.type === "touchstart") {
                        $document.on("touchend", upFunction);
                        $document.on("touchmove", moveFunction);
                        $elm.off("mousedown", downFunction);
                    } else {
                        $document.on("mouseup", upFunction);
                        $document.on("mousemove", moveFunction);
                        $elm.off("touchstart", downFunction);
                    }
                };
                var onDownEvents = function() {
                    $elm.on("mousedown", downFunction);
                    $elm.on("touchstart", downFunction);
                };
                var offAllEvents = function() {
                    $document.off("mouseup", upFunction);
                    $document.off("touchend", upFunction);
                    $document.off("mousemove", moveFunction);
                    $document.off("touchmove", moveFunction);
                    $elm.off("mousedown", downFunction);
                    $elm.off("touchstart", downFunction);
                };
                onDownEvents();
                var dblClickFn = function(event, args) {
                    event.stopPropagation();
                    var col = uiGridResizeColumnsService.findTargetCol($scope.col, $scope.position, rtlMultiplier);
                    if (col.colDef.enableColumnResizing === false) {
                        return;
                    }
                    var maxWidth = 0;
                    var xDiff = 0;
                    var renderContainerElm = gridUtil.closestElm($elm, ".ui-grid-render-container");
                    var cells = renderContainerElm.querySelectorAll("." + uiGridConstants.COL_CLASS_PREFIX + col.uid + " .ui-grid-cell-contents");
                    Array.prototype.forEach.call(cells, function(cell) {
                        var menuButton;
                        if (angular.element(cell).parent().hasClass("ui-grid-header-cell")) {
                            menuButton = angular.element(cell).parent()[0].querySelectorAll(".ui-grid-column-menu-button");
                        }
                        gridUtil.fakeElement(cell, {}, function(newElm) {
                            var e = angular.element(newElm);
                            e.attr("style", "float: left");
                            var width = gridUtil.elementWidth(e);
                            if (menuButton) {
                                var menuButtonWidth = gridUtil.elementWidth(menuButton);
                                width = width + menuButtonWidth;
                            }
                            if (width > maxWidth) {
                                maxWidth = width;
                                xDiff = maxWidth - width;
                            }
                        });
                    });
                    col.width = constrainWidth(col, maxWidth);
                    col.hasCustomWidth = true;
                    refreshCanvas(xDiff);
                    uiGridResizeColumnsService.fireColumnSizeChanged(uiGridCtrl.grid, col.colDef, xDiff);
                };
                $elm.on("dblclick", dblClickFn);
                $elm.on("$destroy", function() {
                    $elm.off("dblclick", dblClickFn);
                    offAllEvents();
                });
            }
        };
        return resizer;
    } ]);
})();

(function() {
    "use strict";
    var module = angular.module("ui.grid.rowEdit", [ "ui.grid", "ui.grid.edit", "ui.grid.cellNav" ]);
    module.constant("uiGridRowEditConstants", {});
    module.service("uiGridRowEditService", [ "$interval", "$q", "uiGridConstants", "uiGridRowEditConstants", "gridUtil", function($interval, $q, uiGridConstants, uiGridRowEditConstants, gridUtil) {
        var service = {
            "initializeGrid": function(scope, grid) {
                grid.rowEdit = {};
                var publicApi = {
                    "events": {
                        "rowEdit": {
                            "saveRow": function(rowEntity) {}
                        }
                    },
                    "methods": {
                        "rowEdit": {
                            "setSavePromise": function(rowEntity, savePromise) {
                                service.setSavePromise(grid, rowEntity, savePromise);
                            },
                            "getDirtyRows": function() {
                                return grid.rowEdit.dirtyRows ? grid.rowEdit.dirtyRows : [];
                            },
                            "getErrorRows": function() {
                                return grid.rowEdit.errorRows ? grid.rowEdit.errorRows : [];
                            },
                            "flushDirtyRows": function() {
                                return service.flushDirtyRows(grid);
                            },
                            "setRowsDirty": function(dataRows) {
                                service.setRowsDirty(grid, dataRows);
                            },
                            "setRowsClean": function(dataRows) {
                                service.setRowsClean(grid, dataRows);
                            }
                        }
                    }
                };
                grid.api.registerEventsFromObject(publicApi.events);
                grid.api.registerMethodsFromObject(publicApi.methods);
                grid.api.core.on.renderingComplete(scope, function(gridApi) {
                    grid.api.edit.on.afterCellEdit(scope, service.endEditCell);
                    grid.api.edit.on.beginCellEdit(scope, service.beginEditCell);
                    grid.api.edit.on.cancelCellEdit(scope, service.cancelEditCell);
                    if (grid.api.cellNav) {
                        grid.api.cellNav.on.navigate(scope, service.navigate);
                    }
                });
            },
            "defaultGridOptions": function(gridOptions) {},
            "saveRow": function(grid, gridRow) {
                var self = this;
                return function() {
                    gridRow.isSaving = true;
                    if (gridRow.rowEditSavePromise) {
                        return gridRow.rowEditSavePromise;
                    }
                    var promise = grid.api.rowEdit.raise.saveRow(gridRow.entity);
                    if (gridRow.rowEditSavePromise) {
                        gridRow.rowEditSavePromise.then(self.processSuccessPromise(grid, gridRow), self.processErrorPromise(grid, gridRow));
                    } else {
                        gridUtil.logError("A promise was not returned when saveRow event was raised, either nobody is listening to event, or event handler did not return a promise");
                    }
                    return promise;
                };
            },
            "setSavePromise": function(grid, rowEntity, savePromise) {
                var gridRow = grid.getRow(rowEntity);
                gridRow.rowEditSavePromise = savePromise;
            },
            "processSuccessPromise": function(grid, gridRow) {
                var self = this;
                return function() {
                    delete gridRow.isSaving;
                    delete gridRow.isDirty;
                    delete gridRow.isError;
                    delete gridRow.rowEditSaveTimer;
                    delete gridRow.rowEditSavePromise;
                    self.removeRow(grid.rowEdit.errorRows, gridRow);
                    self.removeRow(grid.rowEdit.dirtyRows, gridRow);
                };
            },
            "processErrorPromise": function(grid, gridRow) {
                return function() {
                    delete gridRow.isSaving;
                    delete gridRow.rowEditSaveTimer;
                    delete gridRow.rowEditSavePromise;
                    gridRow.isError = true;
                    if (!grid.rowEdit.errorRows) {
                        grid.rowEdit.errorRows = [];
                    }
                    if (!service.isRowPresent(grid.rowEdit.errorRows, gridRow)) {
                        grid.rowEdit.errorRows.push(gridRow);
                    }
                };
            },
            "removeRow": function(rowArray, removeGridRow) {
                if (typeof rowArray === "undefined" || rowArray === null) {
                    return;
                }
                rowArray.forEach(function(gridRow, index) {
                    if (gridRow.uid === removeGridRow.uid) {
                        rowArray.splice(index, 1);
                    }
                });
            },
            "isRowPresent": function(rowArray, removeGridRow) {
                var present = false;
                rowArray.forEach(function(gridRow, index) {
                    if (gridRow.uid === removeGridRow.uid) {
                        present = true;
                    }
                });
                return present;
            },
            "flushDirtyRows": function(grid) {
                var promises = [];
                grid.api.rowEdit.getDirtyRows().forEach(function(gridRow) {
                    service.saveRow(grid, gridRow)();
                    promises.push(gridRow.rowEditSavePromise);
                });
                return $q.all(promises);
            },
            "endEditCell": function(rowEntity, colDef, newValue, previousValue) {
                var grid = this.grid;
                var gridRow = grid.getRow(rowEntity);
                if (!gridRow) {
                    gridUtil.logError("Unable to find rowEntity in grid data, dirty flag cannot be set");
                    return;
                }
                if (newValue !== previousValue || gridRow.isDirty) {
                    if (!grid.rowEdit.dirtyRows) {
                        grid.rowEdit.dirtyRows = [];
                    }
                    if (!gridRow.isDirty) {
                        gridRow.isDirty = true;
                        grid.rowEdit.dirtyRows.push(gridRow);
                    }
                    delete gridRow.isError;
                    service.considerSetTimer(grid, gridRow);
                }
            },
            "beginEditCell": function(rowEntity, colDef) {
                var grid = this.grid;
                var gridRow = grid.getRow(rowEntity);
                if (!gridRow) {
                    gridUtil.logError("Unable to find rowEntity in grid data, timer cannot be cancelled");
                    return;
                }
                service.cancelTimer(grid, gridRow);
            },
            "cancelEditCell": function(rowEntity, colDef) {
                var grid = this.grid;
                var gridRow = grid.getRow(rowEntity);
                if (!gridRow) {
                    gridUtil.logError("Unable to find rowEntity in grid data, timer cannot be set");
                    return;
                }
                service.considerSetTimer(grid, gridRow);
            },
            "navigate": function(newRowCol, oldRowCol) {
                var grid = this.grid;
                if (newRowCol.row.rowEditSaveTimer) {
                    service.cancelTimer(grid, newRowCol.row);
                }
                if (oldRowCol && oldRowCol.row && oldRowCol.row !== newRowCol.row) {
                    service.considerSetTimer(grid, oldRowCol.row);
                }
            },
            "considerSetTimer": function(grid, gridRow) {
                service.cancelTimer(grid, gridRow);
                if (gridRow.isDirty && !gridRow.isSaving) {
                    if (grid.options.rowEditWaitInterval !== -1) {
                        var waitTime = grid.options.rowEditWaitInterval ? grid.options.rowEditWaitInterval : 2e3;
                        gridRow.rowEditSaveTimer = $interval(service.saveRow(grid, gridRow), waitTime, 1);
                    }
                }
            },
            "cancelTimer": function(grid, gridRow) {
                if (gridRow.rowEditSaveTimer && !gridRow.isSaving) {
                    $interval.cancel(gridRow.rowEditSaveTimer);
                    delete gridRow.rowEditSaveTimer;
                }
            },
            "setRowsDirty": function(grid, myDataRows) {
                var gridRow;
                myDataRows.forEach(function(value, index) {
                    gridRow = grid.getRow(value);
                    if (gridRow) {
                        if (!grid.rowEdit.dirtyRows) {
                            grid.rowEdit.dirtyRows = [];
                        }
                        if (!gridRow.isDirty) {
                            gridRow.isDirty = true;
                            grid.rowEdit.dirtyRows.push(gridRow);
                        }
                        delete gridRow.isError;
                        service.considerSetTimer(grid, gridRow);
                    } else {
                        gridUtil.logError("requested row not found in rowEdit.setRowsDirty, row was: " + value);
                    }
                });
            },
            "setRowsClean": function(grid, myDataRows) {
                var gridRow;
                myDataRows.forEach(function(value, index) {
                    gridRow = grid.getRow(value);
                    if (gridRow) {
                        delete gridRow.isDirty;
                        service.removeRow(grid.rowEdit.dirtyRows, gridRow);
                        service.cancelTimer(grid, gridRow);
                        delete gridRow.isError;
                        service.removeRow(grid.rowEdit.errorRows, gridRow);
                    } else {
                        gridUtil.logError("requested row not found in rowEdit.setRowsClean, row was: " + value);
                    }
                });
            }
        };
        return service;
    } ]);
    module.directive("uiGridRowEdit", [ "gridUtil", "uiGridRowEditService", "uiGridEditConstants", function(gridUtil, uiGridRowEditService, uiGridEditConstants) {
        return {
            "replace": true,
            "priority": 0,
            "require": "^uiGrid",
            "scope": false,
            "compile": function() {
                return {
                    "pre": function($scope, $elm, $attrs, uiGridCtrl) {
                        uiGridRowEditService.initializeGrid($scope, uiGridCtrl.grid);
                    },
                    "post": function($scope, $elm, $attrs, uiGridCtrl) {}
                };
            }
        };
    } ]);
    module.directive("uiGridViewport", [ "$compile", "uiGridConstants", "gridUtil", "$parse", function($compile, uiGridConstants, gridUtil, $parse) {
        return {
            "priority": -200,
            "scope": false,
            "compile": function($elm, $attrs) {
                var rowRepeatDiv = angular.element($elm.children().children()[0]);
                var existingNgClass = rowRepeatDiv.attr("ng-class");
                var newNgClass = "";
                if (existingNgClass) {
                    newNgClass = existingNgClass.slice(0, -1) + ", 'ui-grid-row-dirty': row.isDirty, 'ui-grid-row-saving': row.isSaving, 'ui-grid-row-error': row.isError}";
                } else {
                    newNgClass = "{'ui-grid-row-dirty': row.isDirty, 'ui-grid-row-saving': row.isSaving, 'ui-grid-row-error': row.isError}";
                }
                rowRepeatDiv.attr("ng-class", newNgClass);
                return {
                    "pre": function($scope, $elm, $attrs, controllers) {},
                    "post": function($scope, $elm, $attrs, controllers) {}
                };
            }
        };
    } ]);
})();

(function() {
    "use strict";
    var module = angular.module("ui.grid.saveState", [ "ui.grid", "ui.grid.selection", "ui.grid.cellNav", "ui.grid.grouping", "ui.grid.pinning", "ui.grid.treeView" ]);
    module.constant("uiGridSaveStateConstants", {
        "featureName": "saveState"
    });
    module.service("uiGridSaveStateService", [ "$q", "uiGridSaveStateConstants", "gridUtil", "$compile", "$interval", "uiGridConstants", function($q, uiGridSaveStateConstants, gridUtil, $compile, $interval, uiGridConstants) {
        var service = {
            "initializeGrid": function(grid) {
                grid.saveState = {};
                this.defaultGridOptions(grid.options);
                var publicApi = {
                    "events": {
                        "saveState": {}
                    },
                    "methods": {
                        "saveState": {
                            "save": function() {
                                return service.save(grid);
                            },
                            "restore": function($scope, state) {
                                service.restore(grid, $scope, state);
                            }
                        }
                    }
                };
                grid.api.registerEventsFromObject(publicApi.events);
                grid.api.registerMethodsFromObject(publicApi.methods);
            },
            "defaultGridOptions": function(gridOptions) {
                gridOptions.saveWidths = gridOptions.saveWidths !== false;
                gridOptions.saveOrder = gridOptions.saveOrder !== false;
                gridOptions.saveScroll = gridOptions.saveScroll === true;
                gridOptions.saveFocus = gridOptions.saveScroll !== true && gridOptions.saveFocus !== false;
                gridOptions.saveVisible = gridOptions.saveVisible !== false;
                gridOptions.saveSort = gridOptions.saveSort !== false;
                gridOptions.saveFilter = gridOptions.saveFilter !== false;
                gridOptions.saveSelection = gridOptions.saveSelection !== false;
                gridOptions.saveGrouping = gridOptions.saveGrouping !== false;
                gridOptions.saveGroupingExpandedStates = gridOptions.saveGroupingExpandedStates === true;
                gridOptions.savePinning = gridOptions.savePinning !== false;
                gridOptions.saveTreeView = gridOptions.saveTreeView !== false;
            },
            "save": function(grid) {
                var savedState = {};
                savedState.columns = service.saveColumns(grid);
                savedState.scrollFocus = service.saveScrollFocus(grid);
                savedState.selection = service.saveSelection(grid);
                savedState.grouping = service.saveGrouping(grid);
                savedState.treeView = service.saveTreeView(grid);
                savedState.pagination = service.savePagination(grid);
                return savedState;
            },
            "restore": function(grid, $scope, state) {
                if (state.columns) {
                    service.restoreColumns(grid, state.columns);
                }
                if (state.scrollFocus) {
                    service.restoreScrollFocus(grid, $scope, state.scrollFocus);
                }
                if (state.selection) {
                    service.restoreSelection(grid, state.selection);
                }
                if (state.grouping) {
                    service.restoreGrouping(grid, state.grouping);
                }
                if (state.treeView) {
                    service.restoreTreeView(grid, state.treeView);
                }
                if (state.pagination) {
                    service.restorePagination(grid, state.pagination);
                }
                grid.refresh();
            },
            "saveColumns": function(grid) {
                var columns = [];
                grid.getOnlyDataColumns().forEach(function(column) {
                    var savedColumn = {};
                    savedColumn.name = column.name;
                    if (grid.options.saveVisible) {
                        savedColumn.visible = column.visible;
                    }
                    if (grid.options.saveWidths) {
                        savedColumn.width = column.width;
                    }
                    if (grid.options.saveSort) {
                        savedColumn.sort = angular.copy(column.sort);
                    }
                    if (grid.options.saveFilter) {
                        savedColumn.filters = [];
                        column.filters.forEach(function(filter) {
                            var copiedFilter = {};
                            angular.forEach(filter, function(value, key) {
                                if (key !== "condition" && key !== "$$hashKey" && key !== "placeholder") {
                                    copiedFilter[key] = value;
                                }
                            });
                            savedColumn.filters.push(copiedFilter);
                        });
                    }
                    if (!!grid.api.pinning && grid.options.savePinning) {
                        savedColumn.pinned = column.renderContainer ? column.renderContainer : "";
                    }
                    columns.push(savedColumn);
                });
                return columns;
            },
            "saveScrollFocus": function(grid) {
                if (!grid.api.cellNav) {
                    return {};
                }
                var scrollFocus = {};
                if (grid.options.saveFocus) {
                    scrollFocus.focus = true;
                    var rowCol = grid.api.cellNav.getFocusedCell();
                    if (rowCol !== null) {
                        if (rowCol.col !== null) {
                            scrollFocus.colName = rowCol.col.colDef.name;
                        }
                        if (rowCol.row !== null) {
                            scrollFocus.rowVal = service.getRowVal(grid, rowCol.row);
                        }
                    }
                }
                if (grid.options.saveScroll || grid.options.saveFocus && !scrollFocus.colName && !scrollFocus.rowVal) {
                    scrollFocus.focus = false;
                    if (grid.renderContainers.body.prevRowScrollIndex) {
                        scrollFocus.rowVal = service.getRowVal(grid, grid.renderContainers.body.visibleRowCache[grid.renderContainers.body.prevRowScrollIndex]);
                    }
                    if (grid.renderContainers.body.prevColScrollIndex) {
                        scrollFocus.colName = grid.renderContainers.body.visibleColumnCache[grid.renderContainers.body.prevColScrollIndex].name;
                    }
                }
                return scrollFocus;
            },
            "saveSelection": function(grid) {
                if (!grid.api.selection || !grid.options.saveSelection) {
                    return [];
                }
                var selection = grid.api.selection.getSelectedGridRows().map(function(gridRow) {
                    return service.getRowVal(grid, gridRow);
                });
                return selection;
            },
            "saveGrouping": function(grid) {
                if (!grid.api.grouping || !grid.options.saveGrouping) {
                    return {};
                }
                return grid.api.grouping.getGrouping(grid.options.saveGroupingExpandedStates);
            },
            "savePagination": function(grid) {
                if (!grid.api.pagination || !grid.options.paginationPageSize) {
                    return {};
                }
                return {
                    "paginationCurrentPage": grid.options.paginationCurrentPage,
                    "paginationPageSize": grid.options.paginationPageSize
                };
            },
            "saveTreeView": function(grid) {
                if (!grid.api.treeView || !grid.options.saveTreeView) {
                    return {};
                }
                return grid.api.treeView.getTreeView();
            },
            "getRowVal": function(grid, gridRow) {
                if (!gridRow) {
                    return null;
                }
                var rowVal = {};
                if (grid.options.saveRowIdentity) {
                    rowVal.identity = true;
                    rowVal.row = grid.options.saveRowIdentity(gridRow.entity);
                } else {
                    rowVal.identity = false;
                    rowVal.row = grid.renderContainers.body.visibleRowCache.indexOf(gridRow);
                }
                return rowVal;
            },
            "restoreColumns": function(grid, columnsState) {
                var isSortChanged = false;
                columnsState.forEach(function(columnState, index) {
                    var currentCol = grid.getColumn(columnState.name);
                    if (currentCol && !grid.isRowHeaderColumn(currentCol)) {
                        if (grid.options.saveVisible && (currentCol.visible !== columnState.visible || currentCol.colDef.visible !== columnState.visible)) {
                            currentCol.visible = columnState.visible;
                            currentCol.colDef.visible = columnState.visible;
                            grid.api.core.raise.columnVisibilityChanged(currentCol);
                        }
                        if (grid.options.saveWidths && currentCol.width !== columnState.width) {
                            currentCol.width = columnState.width;
                            currentCol.hasCustomWidth = true;
                        }
                        if (grid.options.saveSort && !angular.equals(currentCol.sort, columnState.sort) && !(currentCol.sort === undefined && angular.isEmpty(columnState.sort))) {
                            currentCol.sort = angular.copy(columnState.sort);
                            isSortChanged = true;
                        }
                        if (grid.options.saveFilter && !angular.equals(currentCol.filters, columnState.filters)) {
                            columnState.filters.forEach(function(filter, index) {
                                angular.extend(currentCol.filters[index], filter);
                                if (typeof filter.term === "undefined" || filter.term === null) {
                                    delete currentCol.filters[index].term;
                                }
                            });
                            grid.api.core.raise.filterChanged();
                        }
                        if (!!grid.api.pinning && grid.options.savePinning && currentCol.renderContainer !== columnState.pinned) {
                            grid.api.pinning.pinColumn(currentCol, columnState.pinned);
                        }
                        var currentIndex = grid.getOnlyDataColumns().indexOf(currentCol);
                        if (currentIndex !== -1) {
                            if (grid.options.saveOrder && currentIndex !== index) {
                                var column = grid.columns.splice(currentIndex + grid.rowHeaderColumns.length, 1)[0];
                                grid.columns.splice(index + grid.rowHeaderColumns.length, 0, column);
                            }
                        }
                    }
                });
                if (isSortChanged) {
                    grid.api.core.raise.sortChanged(grid, grid.getColumnSorting());
                }
            },
            "restoreScrollFocus": function(grid, $scope, scrollFocusState) {
                if (!grid.api.cellNav) {
                    return;
                }
                var colDef, row;
                if (scrollFocusState.colName) {
                    var colDefs = grid.options.columnDefs.filter(function(colDef) {
                        return colDef.name === scrollFocusState.colName;
                    });
                    if (colDefs.length > 0) {
                        colDef = colDefs[0];
                    }
                }
                if (scrollFocusState.rowVal && scrollFocusState.rowVal.row) {
                    if (scrollFocusState.rowVal.identity) {
                        row = service.findRowByIdentity(grid, scrollFocusState.rowVal);
                    } else {
                        row = grid.renderContainers.body.visibleRowCache[scrollFocusState.rowVal.row];
                    }
                }
                var entity = row && row.entity ? row.entity : null;
                if (colDef || entity) {
                    if (scrollFocusState.focus) {
                        grid.api.cellNav.scrollToFocus(entity, colDef);
                    } else {
                        grid.scrollTo(entity, colDef);
                    }
                }
            },
            "restoreSelection": function(grid, selectionState) {
                if (!grid.api.selection) {
                    return;
                }
                grid.api.selection.clearSelectedRows();
                selectionState.forEach(function(rowVal) {
                    if (rowVal.identity) {
                        var foundRow = service.findRowByIdentity(grid, rowVal);
                        if (foundRow) {
                            grid.api.selection.selectRow(foundRow.entity);
                        }
                    } else {
                        grid.api.selection.selectRowByVisibleIndex(rowVal.row);
                    }
                });
            },
            "restoreGrouping": function(grid, groupingState) {
                if (!grid.api.grouping || typeof groupingState === "undefined" || groupingState === null || angular.equals(groupingState, {})) {
                    return;
                }
                grid.api.grouping.setGrouping(groupingState);
            },
            "restoreTreeView": function(grid, treeViewState) {
                if (!grid.api.treeView || typeof treeViewState === "undefined" || treeViewState === null || angular.equals(treeViewState, {})) {
                    return;
                }
                grid.api.treeView.setTreeView(treeViewState);
            },
            "restorePagination": function(grid, pagination) {
                if (!grid.api.pagination || !grid.options.paginationPageSize) {
                    return;
                }
                grid.options.paginationCurrentPage = pagination.paginationCurrentPage;
                grid.options.paginationPageSize = pagination.paginationPageSize;
            },
            "findRowByIdentity": function(grid, rowVal) {
                if (!grid.options.saveRowIdentity) {
                    return null;
                }
                var filteredRows = grid.rows.filter(function(gridRow) {
                    if (grid.options.saveRowIdentity(gridRow.entity) === rowVal.row) {
                        return true;
                    } else {
                        return false;
                    }
                });
                if (filteredRows.length > 0) {
                    return filteredRows[0];
                } else {
                    return null;
                }
            }
        };
        return service;
    } ]);
    module.directive("uiGridSaveState", [ "uiGridSaveStateConstants", "uiGridSaveStateService", "gridUtil", "$compile", function(uiGridSaveStateConstants, uiGridSaveStateService, gridUtil, $compile) {
        return {
            "replace": true,
            "priority": 0,
            "require": "^uiGrid",
            "scope": false,
            "link": function($scope, $elm, $attrs, uiGridCtrl) {
                uiGridSaveStateService.initializeGrid(uiGridCtrl.grid);
            }
        };
    } ]);
})();

(function() {
    "use strict";
    var module = angular.module("ui.grid.selection", [ "ui.grid" ]);
    module.constant("uiGridSelectionConstants", {
        "featureName": "selection",
        "selectionRowHeaderColName": "selectionRowHeaderCol"
    });
    angular.module("ui.grid").config([ "$provide", function($provide) {
        $provide.decorator("GridRow", [ "$delegate", function($delegate) {
            $delegate.prototype.setSelected = function(selected) {
                this.isSelected = selected;
                if (selected) {
                    this.grid.selection.selectedCount++;
                } else {
                    this.grid.selection.selectedCount--;
                }
            };
            return $delegate;
        } ]);
    } ]);
    module.service("uiGridSelectionService", [ "$q", "$templateCache", "uiGridSelectionConstants", "gridUtil", function($q, $templateCache, uiGridSelectionConstants, gridUtil) {
        var service = {
            "initializeGrid": function(grid) {
                grid.selection = {};
                grid.selection.lastSelectedRow = null;
                grid.selection.selectAll = false;
                grid.selection.selectedCount = 0;
                service.defaultGridOptions(grid.options);
                var publicApi = {
                    "events": {
                        "selection": {
                            "rowSelectionChanged": function(scope, row, evt) {},
                            "rowSelectionChangedBatch": function(scope, rows, evt) {}
                        }
                    },
                    "methods": {
                        "selection": {
                            "toggleRowSelection": function(rowEntity, evt) {
                                var row = grid.getRow(rowEntity);
                                if (row !== null) {
                                    service.toggleRowSelection(grid, row, evt, grid.options.multiSelect, grid.options.noUnselect);
                                }
                            },
                            "selectRow": function(rowEntity, evt) {
                                var row = grid.getRow(rowEntity);
                                if (row !== null && !row.isSelected) {
                                    service.toggleRowSelection(grid, row, evt, grid.options.multiSelect, grid.options.noUnselect);
                                }
                            },
                            "selectRowByVisibleIndex": function(rowNum, evt) {
                                var row = grid.renderContainers.body.visibleRowCache[rowNum];
                                if (row !== null && typeof row !== "undefined" && !row.isSelected) {
                                    service.toggleRowSelection(grid, row, evt, grid.options.multiSelect, grid.options.noUnselect);
                                }
                            },
                            "unSelectRow": function(rowEntity, evt) {
                                var row = grid.getRow(rowEntity);
                                if (row !== null && row.isSelected) {
                                    service.toggleRowSelection(grid, row, evt, grid.options.multiSelect, grid.options.noUnselect);
                                }
                            },
                            "selectAllRows": function(evt) {
                                if (grid.options.multiSelect === false) {
                                    return;
                                }
                                var changedRows = [];
                                grid.rows.forEach(function(row) {
                                    if (!row.isSelected && row.enableSelection !== false) {
                                        row.setSelected(true);
                                        service.decideRaiseSelectionEvent(grid, row, changedRows, evt);
                                    }
                                });
                                service.decideRaiseSelectionBatchEvent(grid, changedRows, evt);
                                grid.selection.selectAll = true;
                            },
                            "selectAllVisibleRows": function(evt) {
                                if (grid.options.multiSelect === false) {
                                    return;
                                }
                                var changedRows = [];
                                grid.rows.forEach(function(row) {
                                    if (row.visible) {
                                        if (!row.isSelected && row.enableSelection !== false) {
                                            row.setSelected(true);
                                            service.decideRaiseSelectionEvent(grid, row, changedRows, evt);
                                        }
                                    } else {
                                        if (row.isSelected) {
                                            row.setSelected(false);
                                            service.decideRaiseSelectionEvent(grid, row, changedRows, evt);
                                        }
                                    }
                                });
                                service.decideRaiseSelectionBatchEvent(grid, changedRows, evt);
                                grid.selection.selectAll = true;
                            },
                            "clearSelectedRows": function(evt) {
                                service.clearSelectedRows(grid, evt);
                            },
                            "getSelectedRows": function() {
                                return service.getSelectedRows(grid).map(function(gridRow) {
                                    return gridRow.entity;
                                });
                            },
                            "getSelectedGridRows": function() {
                                return service.getSelectedRows(grid);
                            },
                            "getSelectedCount": function() {
                                return grid.selection.selectedCount;
                            },
                            "setMultiSelect": function(multiSelect) {
                                grid.options.multiSelect = multiSelect;
                            },
                            "setModifierKeysToMultiSelect": function(modifierKeysToMultiSelect) {
                                grid.options.modifierKeysToMultiSelect = modifierKeysToMultiSelect;
                            },
                            "getSelectAllState": function() {
                                return grid.selection.selectAll;
                            }
                        }
                    }
                };
                grid.api.registerEventsFromObject(publicApi.events);
                grid.api.registerMethodsFromObject(publicApi.methods);
            },
            "defaultGridOptions": function(gridOptions) {
                gridOptions.enableRowSelection = gridOptions.enableRowSelection !== false;
                gridOptions.multiSelect = gridOptions.multiSelect !== false;
                gridOptions.noUnselect = gridOptions.noUnselect === true;
                gridOptions.modifierKeysToMultiSelect = gridOptions.modifierKeysToMultiSelect === true;
                gridOptions.enableRowHeaderSelection = gridOptions.enableRowHeaderSelection !== false;
                if (typeof gridOptions.enableFullRowSelection === "undefined") {
                    gridOptions.enableFullRowSelection = !gridOptions.enableRowHeaderSelection;
                }
                gridOptions.enableSelectAll = gridOptions.enableSelectAll !== false;
                gridOptions.enableSelectionBatchEvent = gridOptions.enableSelectionBatchEvent !== false;
                gridOptions.selectionRowHeaderWidth = angular.isDefined(gridOptions.selectionRowHeaderWidth) ? gridOptions.selectionRowHeaderWidth : 30;
                gridOptions.enableFooterTotalSelected = gridOptions.enableFooterTotalSelected !== false;
                gridOptions.isRowSelectable = angular.isDefined(gridOptions.isRowSelectable) ? gridOptions.isRowSelectable : angular.noop;
            },
            "toggleRowSelection": function(grid, row, evt, multiSelect, noUnselect) {
                var selected = row.isSelected;
                if (row.enableSelection === false && !selected) {
                    return;
                }
                var selectedRows;
                if (!multiSelect && !selected) {
                    service.clearSelectedRows(grid, evt);
                } else if (!multiSelect && selected) {
                    selectedRows = service.getSelectedRows(grid);
                    if (selectedRows.length > 1) {
                        selected = false;
                        service.clearSelectedRows(grid, evt);
                    }
                }
                if (selected && noUnselect) {} else {
                    row.setSelected(!selected);
                    if (row.isSelected === true) {
                        grid.selection.lastSelectedRow = row;
                    }
                    selectedRows = service.getSelectedRows(grid);
                    grid.selection.selectAll = grid.rows.length === selectedRows.length;
                    grid.api.selection.raise.rowSelectionChanged(row, evt);
                }
            },
            "shiftSelect": function(grid, row, evt, multiSelect) {
                if (!multiSelect) {
                    return;
                }
                var selectedRows = service.getSelectedRows(grid);
                var fromRow = selectedRows.length > 0 ? grid.renderContainers.body.visibleRowCache.indexOf(grid.selection.lastSelectedRow) : 0;
                var toRow = grid.renderContainers.body.visibleRowCache.indexOf(row);
                if (fromRow > toRow) {
                    var tmp = fromRow;
                    fromRow = toRow;
                    toRow = tmp;
                }
                var changedRows = [];
                for (var i = fromRow; i <= toRow; i++) {
                    var rowToSelect = grid.renderContainers.body.visibleRowCache[i];
                    if (rowToSelect) {
                        if (!rowToSelect.isSelected && rowToSelect.enableSelection !== false) {
                            rowToSelect.setSelected(true);
                            grid.selection.lastSelectedRow = rowToSelect;
                            service.decideRaiseSelectionEvent(grid, rowToSelect, changedRows, evt);
                        }
                    }
                }
                service.decideRaiseSelectionBatchEvent(grid, changedRows, evt);
            },
            "getSelectedRows": function(grid) {
                return grid.rows.filter(function(row) {
                    return row.isSelected;
                });
            },
            "clearSelectedRows": function(grid, evt) {
                var changedRows = [];
                service.getSelectedRows(grid).forEach(function(row) {
                    if (row.isSelected) {
                        row.setSelected(false);
                        service.decideRaiseSelectionEvent(grid, row, changedRows, evt);
                    }
                });
                service.decideRaiseSelectionBatchEvent(grid, changedRows, evt);
                grid.selection.selectAll = false;
                grid.selection.selectedCount = 0;
            },
            "decideRaiseSelectionEvent": function(grid, row, changedRows, evt) {
                if (!grid.options.enableSelectionBatchEvent) {
                    grid.api.selection.raise.rowSelectionChanged(row, evt);
                } else {
                    changedRows.push(row);
                }
            },
            "decideRaiseSelectionBatchEvent": function(grid, changedRows, evt) {
                if (changedRows.length > 0) {
                    grid.api.selection.raise.rowSelectionChangedBatch(changedRows, evt);
                }
            }
        };
        return service;
    } ]);
    module.directive("uiGridSelection", [ "uiGridSelectionConstants", "uiGridSelectionService", "$templateCache", "uiGridConstants", function(uiGridSelectionConstants, uiGridSelectionService, $templateCache, uiGridConstants) {
        return {
            "replace": true,
            "priority": 0,
            "require": "^uiGrid",
            "scope": false,
            "compile": function() {
                return {
                    "pre": function($scope, $elm, $attrs, uiGridCtrl) {
                        uiGridSelectionService.initializeGrid(uiGridCtrl.grid);
                        if (uiGridCtrl.grid.options.enableRowHeaderSelection) {
                            var selectionRowHeaderDef = {
                                "name": uiGridSelectionConstants.selectionRowHeaderColName,
                                "displayName": "",
                                "width": uiGridCtrl.grid.options.selectionRowHeaderWidth,
                                "minWidth": 10,
                                "cellTemplate": "ui-grid/selectionRowHeader",
                                "headerCellTemplate": "ui-grid/selectionHeaderCell",
                                "enableColumnResizing": false,
                                "enableColumnMenu": false,
                                "exporterSuppressExport": true,
                                "allowCellFocus": true
                            };
                            uiGridCtrl.grid.addRowHeaderColumn(selectionRowHeaderDef);
                        }
                        var processorSet = false;
                        var processSelectableRows = function(rows) {
                            rows.forEach(function(row) {
                                row.enableSelection = uiGridCtrl.grid.options.isRowSelectable(row);
                            });
                            return rows;
                        };
                        var updateOptions = function() {
                            if (uiGridCtrl.grid.options.isRowSelectable !== angular.noop && processorSet !== true) {
                                uiGridCtrl.grid.registerRowsProcessor(processSelectableRows, 500);
                                processorSet = true;
                            }
                        };
                        updateOptions();
                        var dataChangeDereg = uiGridCtrl.grid.registerDataChangeCallback(updateOptions, [ uiGridConstants.dataChange.OPTIONS ]);
                        $scope.$on("$destroy", dataChangeDereg);
                    },
                    "post": function($scope, $elm, $attrs, uiGridCtrl) {}
                };
            }
        };
    } ]);
    module.directive("uiGridSelectionRowHeaderButtons", [ "$templateCache", "uiGridSelectionService", "gridUtil", function($templateCache, uiGridSelectionService, gridUtil) {
        return {
            "replace": true,
            "restrict": "E",
            "template": $templateCache.get("ui-grid/selectionRowHeaderButtons"),
            "scope": true,
            "require": "^uiGrid",
            "link": function($scope, $elm, $attrs, uiGridCtrl) {
                var self = uiGridCtrl.grid;
                $scope.selectButtonClick = selectButtonClick;
                if (gridUtil.detectBrowser() === "ie") {
                    $elm.on("mousedown", selectButtonMouseDown);
                }
                function selectButtonClick(row, evt) {
                    evt.stopPropagation();
                    if (evt.shiftKey) {
                        uiGridSelectionService.shiftSelect(self, row, evt, self.options.multiSelect);
                    } else if (evt.ctrlKey || evt.metaKey) {
                        uiGridSelectionService.toggleRowSelection(self, row, evt, self.options.multiSelect, self.options.noUnselect);
                    } else {
                        uiGridSelectionService.toggleRowSelection(self, row, evt, self.options.multiSelect && !self.options.modifierKeysToMultiSelect, self.options.noUnselect);
                    }
                }
                function selectButtonMouseDown(evt) {
                    if (evt.ctrlKey || evt.shiftKey) {
                        evt.target.onselectstart = function() {
                            return false;
                        };
                        window.setTimeout(function() {
                            evt.target.onselectstart = null;
                        }, 0);
                    }
                }
            }
        };
    } ]);
    module.directive("uiGridSelectionSelectAllButtons", [ "$templateCache", "uiGridSelectionService", function($templateCache, uiGridSelectionService) {
        return {
            "replace": true,
            "restrict": "E",
            "template": $templateCache.get("ui-grid/selectionSelectAllButtons"),
            "scope": false,
            "link": function($scope, $elm, $attrs, uiGridCtrl) {
                var self = $scope.col.grid;
                $scope.headerButtonClick = function(row, evt) {
                    if (self.selection.selectAll) {
                        uiGridSelectionService.clearSelectedRows(self, evt);
                        if (self.options.noUnselect) {
                            self.api.selection.selectRowByVisibleIndex(0, evt);
                        }
                        self.selection.selectAll = false;
                    } else {
                        if (self.options.multiSelect) {
                            self.api.selection.selectAllVisibleRows(evt);
                            self.selection.selectAll = true;
                        }
                    }
                };
            }
        };
    } ]);
    module.directive("uiGridViewport", [ "$compile", "uiGridConstants", "uiGridSelectionConstants", "gridUtil", "$parse", "uiGridSelectionService", function($compile, uiGridConstants, uiGridSelectionConstants, gridUtil, $parse, uiGridSelectionService) {
        return {
            "priority": -200,
            "scope": false,
            "compile": function($elm, $attrs) {
                var rowRepeatDiv = angular.element($elm.children().children()[0]);
                var existingNgClass = rowRepeatDiv.attr("ng-class");
                var newNgClass = "";
                if (existingNgClass) {
                    newNgClass = existingNgClass.slice(0, -1) + ",'ui-grid-row-selected': row.isSelected}";
                } else {
                    newNgClass = "{'ui-grid-row-selected': row.isSelected}";
                }
                rowRepeatDiv.attr("ng-class", newNgClass);
                return {
                    "pre": function($scope, $elm, $attrs, controllers) {},
                    "post": function($scope, $elm, $attrs, controllers) {}
                };
            }
        };
    } ]);
    module.directive("uiGridCell", [ "$compile", "uiGridConstants", "uiGridSelectionConstants", "gridUtil", "$parse", "uiGridSelectionService", "$timeout", function($compile, uiGridConstants, uiGridSelectionConstants, gridUtil, $parse, uiGridSelectionService, $timeout) {
        return {
            "priority": -200,
            "restrict": "A",
            "require": "?^uiGrid",
            "scope": false,
            "link": function($scope, $elm, $attrs, uiGridCtrl) {
                var touchStartTime = 0;
                var touchTimeout = 300;
                if (uiGridCtrl.grid.api.cellNav) {
                    uiGridCtrl.grid.api.cellNav.on.viewPortKeyDown($scope, function(evt, rowCol) {
                        if (rowCol === null || rowCol.row !== $scope.row || rowCol.col !== $scope.col) {
                            return;
                        }
                        if (evt.keyCode === 32 && $scope.col.colDef.name === "selectionRowHeaderCol") {
                            uiGridSelectionService.toggleRowSelection($scope.grid, $scope.row, evt, $scope.grid.options.multiSelect && !$scope.grid.options.modifierKeysToMultiSelect, $scope.grid.options.noUnselect);
                            $scope.$apply();
                        }
                    });
                }
                var selectCells = function(evt) {
                    $elm.off("touchend", touchEnd);
                    if (evt.shiftKey) {
                        uiGridSelectionService.shiftSelect($scope.grid, $scope.row, evt, $scope.grid.options.multiSelect);
                    } else if (evt.ctrlKey || evt.metaKey) {
                        uiGridSelectionService.toggleRowSelection($scope.grid, $scope.row, evt, $scope.grid.options.multiSelect, $scope.grid.options.noUnselect);
                    } else {
                        uiGridSelectionService.toggleRowSelection($scope.grid, $scope.row, evt, $scope.grid.options.multiSelect && !$scope.grid.options.modifierKeysToMultiSelect, $scope.grid.options.noUnselect);
                    }
                    $scope.$apply();
                    $timeout(function() {
                        $elm.on("touchend", touchEnd);
                    }, touchTimeout);
                };
                var touchStart = function(evt) {
                    touchStartTime = new Date().getTime();
                    $elm.off("click", selectCells);
                };
                var touchEnd = function(evt) {
                    var touchEndTime = new Date().getTime();
                    var touchTime = touchEndTime - touchStartTime;
                    if (touchTime < touchTimeout) {
                        selectCells(evt);
                    }
                    $timeout(function() {
                        $elm.on("click", selectCells);
                    }, touchTimeout);
                };
                function registerRowSelectionEvents() {
                    if ($scope.grid.options.enableRowSelection && $scope.grid.options.enableFullRowSelection) {
                        $elm.addClass("ui-grid-disable-selection");
                        $elm.on("touchstart", touchStart);
                        $elm.on("touchend", touchEnd);
                        $elm.on("click", selectCells);
                        $scope.registered = true;
                    }
                }
                function deregisterRowSelectionEvents() {
                    if ($scope.registered) {
                        $elm.removeClass("ui-grid-disable-selection");
                        $elm.off("touchstart", touchStart);
                        $elm.off("touchend", touchEnd);
                        $elm.off("click", selectCells);
                        $scope.registered = false;
                    }
                }
                registerRowSelectionEvents();
                var dataChangeDereg = $scope.grid.registerDataChangeCallback(function() {
                    if ($scope.grid.options.enableRowSelection && $scope.grid.options.enableFullRowSelection && !$scope.registered) {
                        registerRowSelectionEvents();
                    } else if ((!$scope.grid.options.enableRowSelection || !$scope.grid.options.enableFullRowSelection) && $scope.registered) {
                        deregisterRowSelectionEvents();
                    }
                }, [ uiGridConstants.dataChange.OPTIONS ]);
                $elm.on("$destroy", dataChangeDereg);
            }
        };
    } ]);
    module.directive("uiGridGridFooter", [ "$compile", "uiGridConstants", "gridUtil", function($compile, uiGridConstants, gridUtil) {
        return {
            "restrict": "EA",
            "replace": true,
            "priority": -1e3,
            "require": "^uiGrid",
            "scope": true,
            "compile": function($elm, $attrs) {
                return {
                    "pre": function($scope, $elm, $attrs, uiGridCtrl) {
                        if (!uiGridCtrl.grid.options.showGridFooter) {
                            return;
                        }
                        gridUtil.getTemplate("ui-grid/gridFooterSelectedItems").then(function(contents) {
                            var template = angular.element(contents);
                            var newElm = $compile(template)($scope);
                            angular.element($elm[0].getElementsByClassName("ui-grid-grid-footer")[0]).append(newElm);
                        });
                    },
                    "post": function($scope, $elm, $attrs, controllers) {}
                };
            }
        };
    } ]);
})();

(function() {
    "use strict";
    var module = angular.module("ui.grid.treeBase", [ "ui.grid" ]);
    module.constant("uiGridTreeBaseConstants", {
        "featureName": "treeBase",
        "rowHeaderColName": "treeBaseRowHeaderCol",
        "EXPANDED": "expanded",
        "COLLAPSED": "collapsed",
        "aggregation": {
            "COUNT": "count",
            "SUM": "sum",
            "MAX": "max",
            "MIN": "min",
            "AVG": "avg"
        }
    });
    module.service("uiGridTreeBaseService", [ "$q", "uiGridTreeBaseConstants", "gridUtil", "GridRow", "gridClassFactory", "i18nService", "uiGridConstants", "rowSorter", function($q, uiGridTreeBaseConstants, gridUtil, GridRow, gridClassFactory, i18nService, uiGridConstants, rowSorter) {
        var service = {
            "initializeGrid": function(grid, $scope) {
                grid.treeBase = {};
                grid.treeBase.numberLevels = 0;
                grid.treeBase.expandAll = false;
                grid.treeBase.tree = [];
                service.defaultGridOptions(grid.options);
                grid.registerRowsProcessor(service.treeRows, 410);
                grid.registerColumnBuilder(service.treeBaseColumnBuilder);
                service.createRowHeader(grid);
                var publicApi = {
                    "events": {
                        "treeBase": {
                            "rowExpanded": {},
                            "rowCollapsed": {}
                        }
                    },
                    "methods": {
                        "treeBase": {
                            "expandAllRows": function() {
                                service.expandAllRows(grid);
                            },
                            "collapseAllRows": function() {
                                service.collapseAllRows(grid);
                            },
                            "toggleRowTreeState": function(row) {
                                service.toggleRowTreeState(grid, row);
                            },
                            "expandRow": function(row) {
                                service.expandRow(grid, row);
                            },
                            "expandRowChildren": function(row) {
                                service.expandRowChildren(grid, row);
                            },
                            "collapseRow": function(row) {
                                service.collapseRow(grid, row);
                            },
                            "collapseRowChildren": function(row) {
                                service.collapseRowChildren(grid, row);
                            },
                            "getTreeExpandedState": function() {
                                return {
                                    "expandedState": service.getTreeState(grid)
                                };
                            },
                            "setTreeState": function(config) {
                                service.setTreeState(grid, config);
                            },
                            "getRowChildren": function(row) {
                                return row.treeNode.children.map(function(childNode) {
                                    return childNode.row;
                                });
                            }
                        }
                    }
                };
                grid.api.registerEventsFromObject(publicApi.events);
                grid.api.registerMethodsFromObject(publicApi.methods);
            },
            "defaultGridOptions": function(gridOptions) {
                gridOptions.treeRowHeaderBaseWidth = gridOptions.treeRowHeaderBaseWidth || 30;
                gridOptions.treeIndent = gridOptions.treeIndent || 10;
                gridOptions.showTreeRowHeader = gridOptions.showTreeRowHeader !== false;
                gridOptions.showTreeExpandNoChildren = gridOptions.showTreeExpandNoChildren !== false;
                gridOptions.treeRowHeaderAlwaysVisible = gridOptions.treeRowHeaderAlwaysVisible !== false;
                gridOptions.treeCustomAggregations = gridOptions.treeCustomAggregations || {};
                gridOptions.enableExpandAll = gridOptions.enableExpandAll !== false;
            },
            "treeBaseColumnBuilder": function(colDef, col, gridOptions) {
                if (typeof colDef.customTreeAggregationFn !== "undefined") {
                    col.treeAggregationFn = colDef.customTreeAggregationFn;
                }
                if (typeof colDef.treeAggregationType !== "undefined") {
                    col.treeAggregation = {
                        "type": colDef.treeAggregationType
                    };
                    if (typeof gridOptions.treeCustomAggregations[colDef.treeAggregationType] !== "undefined") {
                        col.treeAggregationFn = gridOptions.treeCustomAggregations[colDef.treeAggregationType].aggregationFn;
                        col.treeAggregationFinalizerFn = gridOptions.treeCustomAggregations[colDef.treeAggregationType].finalizerFn;
                        col.treeAggregation.label = gridOptions.treeCustomAggregations[colDef.treeAggregationType].label;
                    } else if (typeof service.nativeAggregations()[colDef.treeAggregationType] !== "undefined") {
                        col.treeAggregationFn = service.nativeAggregations()[colDef.treeAggregationType].aggregationFn;
                        col.treeAggregation.label = service.nativeAggregations()[colDef.treeAggregationType].label;
                    }
                }
                if (typeof colDef.treeAggregationLabel !== "undefined") {
                    if (typeof col.treeAggregation === "undefined") {
                        col.treeAggregation = {};
                    }
                    col.treeAggregation.label = colDef.treeAggregationLabel;
                }
                col.treeAggregationUpdateEntity = colDef.treeAggregationUpdateEntity !== false;
                if (typeof col.customTreeAggregationFinalizerFn === "undefined") {
                    col.customTreeAggregationFinalizerFn = colDef.customTreeAggregationFinalizerFn;
                }
            },
            "createRowHeader": function(grid) {
                var rowHeaderColumnDef = {
                    "name": uiGridTreeBaseConstants.rowHeaderColName,
                    "displayName": "",
                    "width": grid.options.treeRowHeaderBaseWidth,
                    "minWidth": 10,
                    "cellTemplate": "ui-grid/treeBaseRowHeader",
                    "headerCellTemplate": "ui-grid/treeBaseHeaderCell",
                    "enableColumnResizing": false,
                    "enableColumnMenu": false,
                    "exporterSuppressExport": true,
                    "allowCellFocus": true
                };
                rowHeaderColumnDef.visible = grid.options.treeRowHeaderAlwaysVisible;
                grid.addRowHeaderColumn(rowHeaderColumnDef);
            },
            "expandAllRows": function(grid) {
                grid.treeBase.tree.forEach(function(node) {
                    service.setAllNodes(grid, node, uiGridTreeBaseConstants.EXPANDED);
                });
                grid.treeBase.expandAll = true;
                grid.queueGridRefresh();
            },
            "collapseAllRows": function(grid) {
                grid.treeBase.tree.forEach(function(node) {
                    service.setAllNodes(grid, node, uiGridTreeBaseConstants.COLLAPSED);
                });
                grid.treeBase.expandAll = false;
                grid.queueGridRefresh();
            },
            "setAllNodes": function(grid, treeNode, targetState) {
                if (typeof treeNode.state !== "undefined" && treeNode.state !== targetState) {
                    treeNode.state = targetState;
                    if (targetState === uiGridTreeBaseConstants.EXPANDED) {
                        grid.api.treeBase.raise.rowExpanded(treeNode.row);
                    } else {
                        grid.api.treeBase.raise.rowCollapsed(treeNode.row);
                    }
                }
                if (treeNode.children) {
                    treeNode.children.forEach(function(childNode) {
                        service.setAllNodes(grid, childNode, targetState);
                    });
                }
            },
            "toggleRowTreeState": function(grid, row) {
                if (typeof row.treeLevel === "undefined" || row.treeLevel === null || row.treeLevel < 0) {
                    return;
                }
                if (row.treeNode.state === uiGridTreeBaseConstants.EXPANDED) {
                    service.collapseRow(grid, row);
                } else {
                    service.expandRow(grid, row);
                }
                grid.queueGridRefresh();
            },
            "expandRow": function(grid, row) {
                if (typeof row.treeLevel === "undefined" || row.treeLevel === null || row.treeLevel < 0) {
                    return;
                }
                if (row.treeNode.state !== uiGridTreeBaseConstants.EXPANDED) {
                    row.treeNode.state = uiGridTreeBaseConstants.EXPANDED;
                    grid.api.treeBase.raise.rowExpanded(row);
                    grid.treeBase.expandAll = service.allExpanded(grid.treeBase.tree);
                    grid.queueGridRefresh();
                }
            },
            "expandRowChildren": function(grid, row) {
                if (typeof row.treeLevel === "undefined" || row.treeLevel === null || row.treeLevel < 0) {
                    return;
                }
                service.setAllNodes(grid, row.treeNode, uiGridTreeBaseConstants.EXPANDED);
                grid.treeBase.expandAll = service.allExpanded(grid.treeBase.tree);
                grid.queueGridRefresh();
            },
            "collapseRow": function(grid, row) {
                if (typeof row.treeLevel === "undefined" || row.treeLevel === null || row.treeLevel < 0) {
                    return;
                }
                if (row.treeNode.state !== uiGridTreeBaseConstants.COLLAPSED) {
                    row.treeNode.state = uiGridTreeBaseConstants.COLLAPSED;
                    grid.treeBase.expandAll = false;
                    grid.api.treeBase.raise.rowCollapsed(row);
                    grid.queueGridRefresh();
                }
            },
            "collapseRowChildren": function(grid, row) {
                if (typeof row.treeLevel === "undefined" || row.treeLevel === null || row.treeLevel < 0) {
                    return;
                }
                service.setAllNodes(grid, row.treeNode, uiGridTreeBaseConstants.COLLAPSED);
                grid.treeBase.expandAll = false;
                grid.queueGridRefresh();
            },
            "allExpanded": function(tree) {
                var allExpanded = true;
                tree.forEach(function(node) {
                    if (!service.allExpandedInternal(node)) {
                        allExpanded = false;
                    }
                });
                return allExpanded;
            },
            "allExpandedInternal": function(treeNode) {
                if (treeNode.children && treeNode.children.length > 0) {
                    if (treeNode.state === uiGridTreeBaseConstants.COLLAPSED) {
                        return false;
                    }
                    var allExpanded = true;
                    treeNode.children.forEach(function(node) {
                        if (!service.allExpandedInternal(node)) {
                            allExpanded = false;
                        }
                    });
                    return allExpanded;
                } else {
                    return true;
                }
            },
            "treeRows": function(renderableRows) {
                if (renderableRows.length === 0) {
                    return renderableRows;
                }
                var grid = this;
                var currentLevel = 0;
                var currentState = uiGridTreeBaseConstants.EXPANDED;
                var parents = [];
                grid.treeBase.tree = service.createTree(grid, renderableRows);
                service.updateRowHeaderWidth(grid);
                service.sortTree(grid);
                service.fixFilter(grid);
                return service.renderTree(grid.treeBase.tree);
            },
            "updateRowHeaderWidth": function(grid) {
                var rowHeader = grid.getColumn(uiGridTreeBaseConstants.rowHeaderColName);
                var newWidth = grid.options.treeRowHeaderBaseWidth + grid.options.treeIndent * Math.max(grid.treeBase.numberLevels - 1, 0);
                if (rowHeader && newWidth !== rowHeader.width) {
                    rowHeader.width = newWidth;
                    grid.queueRefresh();
                }
                var newVisibility = true;
                if (grid.options.showTreeRowHeader === false) {
                    newVisibility = false;
                }
                if (grid.options.treeRowHeaderAlwaysVisible === false && grid.treeBase.numberLevels <= 0) {
                    newVisibility = false;
                }
                if (rowHeader.visible !== newVisibility) {
                    rowHeader.visible = newVisibility;
                    rowHeader.colDef.visible = newVisibility;
                    grid.queueGridRefresh();
                }
            },
            "renderTree": function(nodeList) {
                var renderableRows = [];
                nodeList.forEach(function(node) {
                    if (node.row.visible) {
                        renderableRows.push(node.row);
                    }
                    if (node.state === uiGridTreeBaseConstants.EXPANDED && node.children && node.children.length > 0) {
                        renderableRows = renderableRows.concat(service.renderTree(node.children));
                    }
                });
                return renderableRows;
            },
            "createTree": function(grid, renderableRows) {
                var currentLevel = -1;
                var parents = [];
                var currentState;
                grid.treeBase.tree = [];
                grid.treeBase.numberLevels = 0;
                var aggregations = service.getAggregations(grid);
                var createNode = function(row) {
                    if (typeof row.entity.$$treeLevel !== "undefined" && row.treeLevel !== row.entity.$$treeLevel) {
                        row.treeLevel = row.entity.$$treeLevel;
                    }
                    if (row.treeLevel <= currentLevel) {
                        while (row.treeLevel <= currentLevel) {
                            var lastParent = parents.pop();
                            service.finaliseAggregations(lastParent);
                            currentLevel--;
                        }
                        if (parents.length > 0) {
                            currentState = service.setCurrentState(parents);
                        } else {
                            currentState = uiGridTreeBaseConstants.EXPANDED;
                        }
                    }
                    if ((typeof row.treeLevel === "undefined" || row.treeLevel === null || row.treeLevel < 0) && row.visible) {
                        service.aggregate(grid, row, parents);
                    }
                    service.addOrUseNode(grid, row, parents, aggregations);
                    if (typeof row.treeLevel !== "undefined" && row.treeLevel !== null && row.treeLevel >= 0) {
                        parents.push(row);
                        currentLevel++;
                        currentState = service.setCurrentState(parents);
                    }
                    if (grid.treeBase.numberLevels < row.treeLevel + 1) {
                        grid.treeBase.numberLevels = row.treeLevel + 1;
                    }
                };
                renderableRows.forEach(createNode);
                while (parents.length > 0) {
                    var lastParent = parents.pop();
                    service.finaliseAggregations(lastParent);
                }
                return grid.treeBase.tree;
            },
            "addOrUseNode": function(grid, row, parents, aggregationBase) {
                var newAggregations = [];
                aggregationBase.forEach(function(aggregation) {
                    newAggregations.push(service.buildAggregationObject(aggregation.col));
                });
                var newNode = {
                    "state": uiGridTreeBaseConstants.COLLAPSED,
                    "row": row,
                    "parentRow": null,
                    "aggregations": newAggregations,
                    "children": []
                };
                if (row.treeNode) {
                    newNode.state = row.treeNode.state;
                }
                if (parents.length > 0) {
                    newNode.parentRow = parents[parents.length - 1];
                }
                row.treeNode = newNode;
                if (parents.length === 0) {
                    grid.treeBase.tree.push(newNode);
                } else {
                    parents[parents.length - 1].treeNode.children.push(newNode);
                }
            },
            "setCurrentState": function(parents) {
                var currentState = uiGridTreeBaseConstants.EXPANDED;
                parents.forEach(function(parent) {
                    if (parent.treeNode.state === uiGridTreeBaseConstants.COLLAPSED) {
                        currentState = uiGridTreeBaseConstants.COLLAPSED;
                    }
                });
                return currentState;
            },
            "sortTree": function(grid) {
                grid.columns.forEach(function(column) {
                    if (column.sort && column.sort.ignoreSort) {
                        delete column.sort.ignoreSort;
                    }
                });
                grid.treeBase.tree = service.sortInternal(grid, grid.treeBase.tree);
            },
            "sortInternal": function(grid, treeList) {
                var rows = treeList.map(function(node) {
                    return node.row;
                });
                rows = rowSorter.sort(grid, rows, grid.columns);
                var treeNodes = rows.map(function(row) {
                    return row.treeNode;
                });
                treeNodes.forEach(function(node) {
                    if (node.state === uiGridTreeBaseConstants.EXPANDED && node.children && node.children.length > 0) {
                        node.children = service.sortInternal(grid, node.children);
                    }
                });
                return treeNodes;
            },
            "fixFilter": function(grid) {
                var parentsVisible;
                grid.treeBase.tree.forEach(function(node) {
                    if (node.children && node.children.length > 0) {
                        parentsVisible = node.row.visible;
                        service.fixFilterInternal(node.children, parentsVisible);
                    }
                });
            },
            "fixFilterInternal": function(nodes, parentsVisible) {
                nodes.forEach(function(node) {
                    if (node.row.visible && !parentsVisible) {
                        service.setParentsVisible(node);
                        parentsVisible = true;
                    }
                    if (node.children && node.children.length > 0) {
                        if (service.fixFilterInternal(node.children, parentsVisible && node.row.visible)) {
                            parentsVisible = true;
                        }
                    }
                });
                return parentsVisible;
            },
            "setParentsVisible": function(node) {
                while (node.parentRow) {
                    node.parentRow.visible = true;
                    node = node.parentRow.treeNode;
                }
            },
            "buildAggregationObject": function(column) {
                var newAggregation = {
                    "col": column
                };
                if (column.treeAggregation && column.treeAggregation.type) {
                    newAggregation.type = column.treeAggregation.type;
                }
                if (column.treeAggregation && column.treeAggregation.label) {
                    newAggregation.label = column.treeAggregation.label;
                }
                return newAggregation;
            },
            "getAggregations": function(grid) {
                var aggregateArray = [];
                grid.columns.forEach(function(column) {
                    if (typeof column.treeAggregationFn !== "undefined") {
                        aggregateArray.push(service.buildAggregationObject(column));
                        if (grid.options.showColumnFooter && typeof column.colDef.aggregationType === "undefined" && column.treeAggregation) {
                            column.treeFooterAggregation = service.buildAggregationObject(column);
                            column.aggregationType = service.treeFooterAggregationType;
                        }
                    }
                });
                return aggregateArray;
            },
            "aggregate": function(grid, row, parents) {
                if (parents.length === 0 && row.treeNode && row.treeNode.aggregations) {
                    row.treeNode.aggregations.forEach(function(aggregation) {
                        if (typeof aggregation.col.treeFooterAggregation !== "undefined") {
                            var fieldValue = grid.getCellValue(row, aggregation.col);
                            var numValue = Number(fieldValue);
                            aggregation.col.treeAggregationFn(aggregation.col.treeFooterAggregation, fieldValue, numValue, row);
                        }
                    });
                }
                parents.forEach(function(parent, index) {
                    if (parent.treeNode.aggregations) {
                        parent.treeNode.aggregations.forEach(function(aggregation) {
                            var fieldValue = grid.getCellValue(row, aggregation.col);
                            var numValue = Number(fieldValue);
                            aggregation.col.treeAggregationFn(aggregation, fieldValue, numValue, row);
                            if (index === 0 && typeof aggregation.col.treeFooterAggregation !== "undefined") {
                                aggregation.col.treeAggregationFn(aggregation.col.treeFooterAggregation, fieldValue, numValue, row);
                            }
                        });
                    }
                });
            },
            "nativeAggregations": function() {
                var nativeAggregations = {
                    "count": {
                        "label": i18nService.get().aggregation.count,
                        "menuTitle": i18nService.get().grouping.aggregate_count,
                        "aggregationFn": function(aggregation, fieldValue, numValue) {
                            if (typeof aggregation.value === "undefined") {
                                aggregation.value = 1;
                            } else {
                                aggregation.value++;
                            }
                        }
                    },
                    "sum": {
                        "label": i18nService.get().aggregation.sum,
                        "menuTitle": i18nService.get().grouping.aggregate_sum,
                        "aggregationFn": function(aggregation, fieldValue, numValue) {
                            if (!isNaN(numValue)) {
                                if (typeof aggregation.value === "undefined") {
                                    aggregation.value = numValue;
                                } else {
                                    aggregation.value += numValue;
                                }
                            }
                        }
                    },
                    "min": {
                        "label": i18nService.get().aggregation.min,
                        "menuTitle": i18nService.get().grouping.aggregate_min,
                        "aggregationFn": function(aggregation, fieldValue, numValue) {
                            if (typeof aggregation.value === "undefined") {
                                aggregation.value = fieldValue;
                            } else {
                                if (typeof fieldValue !== "undefined" && fieldValue !== null && (fieldValue < aggregation.value || aggregation.value === null)) {
                                    aggregation.value = fieldValue;
                                }
                            }
                        }
                    },
                    "max": {
                        "label": i18nService.get().aggregation.max,
                        "menuTitle": i18nService.get().grouping.aggregate_max,
                        "aggregationFn": function(aggregation, fieldValue, numValue) {
                            if (typeof aggregation.value === "undefined") {
                                aggregation.value = fieldValue;
                            } else {
                                if (typeof fieldValue !== "undefined" && fieldValue !== null && (fieldValue > aggregation.value || aggregation.value === null)) {
                                    aggregation.value = fieldValue;
                                }
                            }
                        }
                    },
                    "avg": {
                        "label": i18nService.get().aggregation.avg,
                        "menuTitle": i18nService.get().grouping.aggregate_avg,
                        "aggregationFn": function(aggregation, fieldValue, numValue) {
                            if (typeof aggregation.count === "undefined") {
                                aggregation.count = 1;
                            } else {
                                aggregation.count++;
                            }
                            if (isNaN(numValue)) {
                                return;
                            }
                            if (typeof aggregation.value === "undefined" || typeof aggregation.sum === "undefined") {
                                aggregation.value = numValue;
                                aggregation.sum = numValue;
                            } else {
                                aggregation.sum += numValue;
                                aggregation.value = aggregation.sum / aggregation.count;
                            }
                        }
                    }
                };
                return nativeAggregations;
            },
            "finaliseAggregation": function(row, aggregation) {
                if (aggregation.col.treeAggregationUpdateEntity && typeof row !== "undefined" && typeof row.entity["$$" + aggregation.col.uid] !== "undefined") {
                    angular.extend(aggregation, row.entity["$$" + aggregation.col.uid]);
                }
                if (typeof aggregation.col.treeAggregationFinalizerFn === "function") {
                    aggregation.col.treeAggregationFinalizerFn(aggregation);
                }
                if (typeof aggregation.col.customTreeAggregationFinalizerFn === "function") {
                    aggregation.col.customTreeAggregationFinalizerFn(aggregation);
                }
                if (typeof aggregation.rendered === "undefined") {
                    aggregation.rendered = aggregation.label ? aggregation.label + aggregation.value : aggregation.value;
                }
            },
            "finaliseAggregations": function(row) {
                if (typeof row.treeNode.aggregations === "undefined") {
                    return;
                }
                row.treeNode.aggregations.forEach(function(aggregation) {
                    service.finaliseAggregation(row, aggregation);
                    if (aggregation.col.treeAggregationUpdateEntity) {
                        var aggregationCopy = {};
                        angular.forEach(aggregation, function(value, key) {
                            if (aggregation.hasOwnProperty(key) && key !== "col") {
                                aggregationCopy[key] = value;
                            }
                        });
                        row.entity["$$" + aggregation.col.uid] = aggregationCopy;
                    }
                });
            },
            "treeFooterAggregationType": function(rows, column) {
                service.finaliseAggregation(undefined, column.treeFooterAggregation);
                if (typeof column.treeFooterAggregation.value === "undefined" || column.treeFooterAggregation.rendered === null) {
                    return "";
                }
                return column.treeFooterAggregation.rendered;
            }
        };
        return service;
    } ]);
    module.directive("uiGridTreeBaseRowHeaderButtons", [ "$templateCache", "uiGridTreeBaseService", function($templateCache, uiGridTreeBaseService) {
        return {
            "replace": true,
            "restrict": "E",
            "template": $templateCache.get("ui-grid/treeBaseRowHeaderButtons"),
            "scope": true,
            "require": "^uiGrid",
            "link": function($scope, $elm, $attrs, uiGridCtrl) {
                var self = uiGridCtrl.grid;
                $scope.treeButtonClick = function(row, evt) {
                    uiGridTreeBaseService.toggleRowTreeState(self, row, evt);
                };
            }
        };
    } ]);
    module.directive("uiGridTreeBaseExpandAllButtons", [ "$templateCache", "uiGridTreeBaseService", function($templateCache, uiGridTreeBaseService) {
        return {
            "replace": true,
            "restrict": "E",
            "template": $templateCache.get("ui-grid/treeBaseExpandAllButtons"),
            "scope": false,
            "link": function($scope, $elm, $attrs, uiGridCtrl) {
                var self = $scope.col.grid;
                $scope.headerButtonClick = function(row, evt) {
                    if (self.treeBase.expandAll) {
                        uiGridTreeBaseService.collapseAllRows(self, evt);
                    } else {
                        uiGridTreeBaseService.expandAllRows(self, evt);
                    }
                };
            }
        };
    } ]);
    module.directive("uiGridViewport", [ "$compile", "uiGridConstants", "gridUtil", "$parse", function($compile, uiGridConstants, gridUtil, $parse) {
        return {
            "priority": -200,
            "scope": false,
            "compile": function($elm, $attrs) {
                var rowRepeatDiv = angular.element($elm.children().children()[0]);
                var existingNgClass = rowRepeatDiv.attr("ng-class");
                var newNgClass = "";
                if (existingNgClass) {
                    newNgClass = existingNgClass.slice(0, -1) + ",'ui-grid-tree-header-row': row.treeLevel > -1}";
                } else {
                    newNgClass = "{'ui-grid-tree-header-row': row.treeLevel > -1}";
                }
                rowRepeatDiv.attr("ng-class", newNgClass);
                return {
                    "pre": function($scope, $elm, $attrs, controllers) {},
                    "post": function($scope, $elm, $attrs, controllers) {}
                };
            }
        };
    } ]);
})();

(function() {
    "use strict";
    var module = angular.module("ui.grid.treeView", [ "ui.grid", "ui.grid.treeBase" ]);
    module.constant("uiGridTreeViewConstants", {
        "featureName": "treeView",
        "rowHeaderColName": "treeBaseRowHeaderCol",
        "EXPANDED": "expanded",
        "COLLAPSED": "collapsed",
        "aggregation": {
            "COUNT": "count",
            "SUM": "sum",
            "MAX": "max",
            "MIN": "min",
            "AVG": "avg"
        }
    });
    module.service("uiGridTreeViewService", [ "$q", "uiGridTreeViewConstants", "uiGridTreeBaseConstants", "uiGridTreeBaseService", "gridUtil", "GridRow", "gridClassFactory", "i18nService", "uiGridConstants", function($q, uiGridTreeViewConstants, uiGridTreeBaseConstants, uiGridTreeBaseService, gridUtil, GridRow, gridClassFactory, i18nService, uiGridConstants) {
        var service = {
            "initializeGrid": function(grid, $scope) {
                uiGridTreeBaseService.initializeGrid(grid, $scope);
                grid.treeView = {};
                grid.registerRowsProcessor(service.adjustSorting, 60);
                var publicApi = {
                    "events": {
                        "treeView": {}
                    },
                    "methods": {
                        "treeView": {}
                    }
                };
                grid.api.registerEventsFromObject(publicApi.events);
                grid.api.registerMethodsFromObject(publicApi.methods);
            },
            "defaultGridOptions": function(gridOptions) {
                gridOptions.enableTreeView = gridOptions.enableTreeView !== false;
            },
            "adjustSorting": function(renderableRows) {
                var grid = this;
                grid.columns.forEach(function(column) {
                    if (column.sort) {
                        column.sort.ignoreSort = true;
                    }
                });
                return renderableRows;
            }
        };
        return service;
    } ]);
    module.directive("uiGridTreeView", [ "uiGridTreeViewConstants", "uiGridTreeViewService", "$templateCache", function(uiGridTreeViewConstants, uiGridTreeViewService, $templateCache) {
        return {
            "replace": true,
            "priority": 0,
            "require": "^uiGrid",
            "scope": false,
            "compile": function() {
                return {
                    "pre": function($scope, $elm, $attrs, uiGridCtrl) {
                        if (uiGridCtrl.grid.options.enableTreeView !== false) {
                            uiGridTreeViewService.initializeGrid(uiGridCtrl.grid, $scope);
                        }
                    },
                    "post": function($scope, $elm, $attrs, uiGridCtrl) {}
                };
            }
        };
    } ]);
})();

(function() {
    "use strict";
    var module = angular.module("ui.grid.validate", [ "ui.grid" ]);
    module.service("uiGridValidateService", [ "$sce", "$q", "$http", "i18nService", "uiGridConstants", function($sce, $q, $http, i18nService, uiGridConstants) {
        var service = {
            "validatorFactories": {},
            "setExternalFactoryFunction": function(externalFactoryFunction) {
                service.externalFactoryFunction = externalFactoryFunction;
            },
            "clearExternalFactory": function() {
                delete service.externalFactoryFunction;
            },
            "getValidatorFromExternalFactory": function(name, argument) {
                return service.externalFactoryFunction(name, argument).validatorFactory(argument);
            },
            "getMessageFromExternalFactory": function(name, argument) {
                return service.externalFactoryFunction(name, argument).messageFunction(argument);
            },
            "setValidator": function(name, validatorFactory, messageFunction) {
                service.validatorFactories[name] = {
                    "validatorFactory": validatorFactory,
                    "messageFunction": messageFunction
                };
            },
            "getValidator": function(name, argument) {
                if (service.externalFactoryFunction) {
                    var validator = service.getValidatorFromExternalFactory(name, argument);
                    if (validator) {
                        return validator;
                    }
                }
                if (!service.validatorFactories[name]) {
                    throw "Invalid validator name: " + name;
                }
                return service.validatorFactories[name].validatorFactory(argument);
            },
            "getMessage": function(name, argument) {
                if (service.externalFactoryFunction) {
                    var message = service.getMessageFromExternalFactory(name, argument);
                    if (message) {
                        return message;
                    }
                }
                return service.validatorFactories[name].messageFunction(argument);
            },
            "isInvalid": function(rowEntity, colDef) {
                return rowEntity["$$invalid" + colDef.name];
            },
            "setInvalid": function(rowEntity, colDef) {
                rowEntity["$$invalid" + colDef.name] = true;
            },
            "setValid": function(rowEntity, colDef) {
                delete rowEntity["$$invalid" + colDef.name];
            },
            "setError": function(rowEntity, colDef, validatorName) {
                if (!rowEntity["$$errors" + colDef.name]) {
                    rowEntity["$$errors" + colDef.name] = {};
                }
                rowEntity["$$errors" + colDef.name][validatorName] = true;
            },
            "clearError": function(rowEntity, colDef, validatorName) {
                if (!rowEntity["$$errors" + colDef.name]) {
                    return;
                }
                if (validatorName in rowEntity["$$errors" + colDef.name]) {
                    delete rowEntity["$$errors" + colDef.name][validatorName];
                }
            },
            "getErrorMessages": function(rowEntity, colDef) {
                var errors = [];
                if (!rowEntity["$$errors" + colDef.name] || Object.keys(rowEntity["$$errors" + colDef.name]).length === 0) {
                    return errors;
                }
                Object.keys(rowEntity["$$errors" + colDef.name]).sort().forEach(function(validatorName) {
                    errors.push(service.getMessage(validatorName, colDef.validators[validatorName]));
                });
                return errors;
            },
            "getFormattedErrors": function(rowEntity, colDef) {
                var msgString = "";
                var errors = service.getErrorMessages(rowEntity, colDef);
                if (!errors.length) {
                    return;
                }
                errors.forEach(function(errorMsg) {
                    msgString += errorMsg + "<br/>";
                });
                return $sce.trustAsHtml("<p><b>" + i18nService.getSafeText("validate.error") + "</b></p>" + msgString);
            },
            "getTitleFormattedErrors": function(rowEntity, colDef) {
                var newLine = "\n";
                var msgString = "";
                var errors = service.getErrorMessages(rowEntity, colDef);
                if (!errors.length) {
                    return;
                }
                errors.forEach(function(errorMsg) {
                    msgString += errorMsg + newLine;
                });
                return $sce.trustAsHtml(i18nService.getSafeText("validate.error") + newLine + msgString);
            },
            "runValidators": function(rowEntity, colDef, newValue, oldValue, grid) {
                if (newValue === oldValue) {
                    return;
                }
                if (typeof colDef.name === "undefined" || !colDef.name) {
                    throw new Error("colDef.name is required to perform validation");
                }
                service.setValid(rowEntity, colDef);
                var validateClosureFactory = function(rowEntity, colDef, validatorName) {
                    return function(value) {
                        if (!value) {
                            service.setInvalid(rowEntity, colDef);
                            service.setError(rowEntity, colDef, validatorName);
                            if (grid) {
                                grid.api.validate.raise.validationFailed(rowEntity, colDef, newValue, oldValue);
                            }
                        }
                    };
                };
                for (var validatorName in colDef.validators) {
                    service.clearError(rowEntity, colDef, validatorName);
                    var msg;
                    var validatorFunction = service.getValidator(validatorName, colDef.validators[validatorName]);
                    $q.when(validatorFunction(oldValue, newValue, rowEntity, colDef)).then(validateClosureFactory(rowEntity, colDef, validatorName));
                }
            },
            "createDefaultValidators": function() {
                service.setValidator("minLength", function(argument) {
                    return function(oldValue, newValue, rowEntity, colDef) {
                        if (newValue === undefined || newValue === null || newValue === "") {
                            return true;
                        }
                        return newValue.length >= argument;
                    };
                }, function(argument) {
                    return i18nService.getSafeText("validate.minLength").replace("THRESHOLD", argument);
                });
                service.setValidator("maxLength", function(argument) {
                    return function(oldValue, newValue, rowEntity, colDef) {
                        if (newValue === undefined || newValue === null || newValue === "") {
                            return true;
                        }
                        return newValue.length <= argument;
                    };
                }, function(threshold) {
                    return i18nService.getSafeText("validate.maxLength").replace("THRESHOLD", threshold);
                });
                service.setValidator("required", function(argument) {
                    return function(oldValue, newValue, rowEntity, colDef) {
                        if (argument) {
                            return !(newValue === undefined || newValue === null || newValue === "");
                        }
                        return true;
                    };
                }, function(argument) {
                    return i18nService.getSafeText("validate.required");
                });
            },
            "initializeGrid": function(scope, grid) {
                grid.validate = {
                    "isInvalid": service.isInvalid,
                    "getFormattedErrors": service.getFormattedErrors,
                    "getTitleFormattedErrors": service.getTitleFormattedErrors,
                    "runValidators": service.runValidators
                };
                var publicApi = {
                    "events": {
                        "validate": {
                            "validationFailed": function(rowEntity, colDef, newValue, oldValue) {}
                        }
                    },
                    "methods": {
                        "validate": {
                            "isInvalid": function(rowEntity, colDef) {
                                return grid.validate.isInvalid(rowEntity, colDef);
                            },
                            "getErrorMessages": function(rowEntity, colDef) {
                                return grid.validate.getErrorMessages(rowEntity, colDef);
                            },
                            "getFormattedErrors": function(rowEntity, colDef) {
                                return grid.validate.getFormattedErrors(rowEntity, colDef);
                            },
                            "getTitleFormattedErrors": function(rowEntity, colDef) {
                                return grid.validate.getTitleFormattedErrors(rowEntity, colDef);
                            }
                        }
                    }
                };
                grid.api.registerEventsFromObject(publicApi.events);
                grid.api.registerMethodsFromObject(publicApi.methods);
                if (grid.edit) {
                    grid.api.edit.on.afterCellEdit(scope, function(rowEntity, colDef, newValue, oldValue) {
                        grid.validate.runValidators(rowEntity, colDef, newValue, oldValue, grid);
                    });
                }
                service.createDefaultValidators();
            }
        };
        return service;
    } ]);
    module.directive("uiGridValidate", [ "gridUtil", "uiGridValidateService", function(gridUtil, uiGridValidateService) {
        return {
            "priority": 0,
            "replace": true,
            "require": "^uiGrid",
            "scope": false,
            "compile": function() {
                return {
                    "pre": function($scope, $elm, $attrs, uiGridCtrl) {
                        uiGridValidateService.initializeGrid($scope, uiGridCtrl.grid);
                    },
                    "post": function($scope, $elm, $attrs, uiGridCtrl) {}
                };
            }
        };
    } ]);
})();

angular.module("ui.grid").run([ "$templateCache", function($templateCache) {
    "use strict";
    $templateCache.put("ui-grid/ui-grid-filter", '<div class="ui-grid-filter-container" ng-repeat="colFilter in col.filters" ng-class="{\'ui-grid-filter-cancel-button-hidden\' : colFilter.disableCancelFilterButton === true }"><div ng-if="colFilter.type !== \'select\'"><input type="text" class="ui-grid-filter-input ui-grid-filter-input-{{$index}}" ng-model="colFilter.term" ng-attr-placeholder="{{colFilter.placeholder || \'\'}}" aria-label="{{colFilter.ariaLabel || aria.defaultFilterLabel}}"><div role="button" class="ui-grid-filter-button" ng-click="removeFilter(colFilter, $index)" ng-if="!colFilter.disableCancelFilterButton" ng-disabled="colFilter.term === undefined || colFilter.term === null || colFilter.term === \'\'" ng-show="colFilter.term !== undefined && colFilter.term !== null && colFilter.term !== \'\'"><i class="ui-grid-icon-cancel" ui-grid-one-bind-aria-label="aria.removeFilter">&nbsp;</i></div></div><div ng-if="colFilter.type === \'select\'"><select class="ui-grid-filter-select ui-grid-filter-input-{{$index}}" ng-model="colFilter.term" ng-attr-placeholder="{{colFilter.placeholder || aria.defaultFilterLabel}}" aria-label="{{colFilter.ariaLabel || \'\'}}" ng-options="option.value as option.label for option in colFilter.selectOptions"><option value=""></option></select><div role="button" class="ui-grid-filter-button-select" ng-click="removeFilter(colFilter, $index)" ng-if="!colFilter.disableCancelFilterButton" ng-disabled="colFilter.term === undefined || colFilter.term === null || colFilter.term === \'\'" ng-show="colFilter.term !== undefined && colFilter.term != null"><i class="ui-grid-icon-cancel" ui-grid-one-bind-aria-label="aria.removeFilter">&nbsp;</i></div></div></div>');
    $templateCache.put("ui-grid/ui-grid-footer", '<div class="ui-grid-footer-panel ui-grid-footer-aggregates-row"><!-- tfooter --><div class="ui-grid-footer ui-grid-footer-viewport"><div class="ui-grid-footer-canvas"><div class="ui-grid-footer-cell-wrapper" ng-style="colContainer.headerCellWrapperStyle()"><div role="row" class="ui-grid-footer-cell-row"><div ui-grid-footer-cell role="gridcell" ng-repeat="col in colContainer.renderedColumns track by col.uid" col="col" render-index="$index" class="ui-grid-footer-cell ui-grid-clearfix"></div></div></div></div></div></div>');
    $templateCache.put("ui-grid/ui-grid-grid-footer", '<div class="ui-grid-footer-info ui-grid-grid-footer"><span>{{\'search.totalItems\' | t}} {{grid.rows.length}}</span> <span ng-if="grid.renderContainers.body.visibleRowCache.length !== grid.rows.length" class="ngLabel">({{"search.showingItems" | t}} {{grid.renderContainers.body.visibleRowCache.length}})</span></div>');
    $templateCache.put("ui-grid/ui-grid-group-panel", '<div class="ui-grid-group-panel"><div ui-t="groupPanel.description" class="description" ng-show="groupings.length == 0"></div><ul ng-show="groupings.length > 0" class="ngGroupList"><li class="ngGroupItem" ng-repeat="group in configGroups"><span class="ngGroupElement"><span class="ngGroupName">{{group.displayName}} <span ng-click="removeGroup($index)" class="ngRemoveGroup">x</span></span> <span ng-hide="$last" class="ngGroupArrow"></span></span></li></ul></div>');
    $templateCache.put("ui-grid/ui-grid-header", '<div role="rowgroup" class="ui-grid-header"><!-- theader --><div class="ui-grid-top-panel"><div class="ui-grid-header-viewport"><div class="ui-grid-header-canvas"><div class="ui-grid-header-cell-wrapper" ng-style="colContainer.headerCellWrapperStyle()"><div role="row" class="ui-grid-header-cell-row"><div class="ui-grid-header-cell ui-grid-clearfix" ng-repeat="col in colContainer.renderedColumns track by col.uid" ui-grid-header-cell col="col" render-index="$index"></div></div></div></div></div></div></div>');
    $templateCache.put("ui-grid/ui-grid-menu-button", '<div class="ui-grid-menu-button"><div role="button" ui-grid-one-bind-id-grid="\'grid-menu\'" class="ui-grid-icon-container" ng-click="toggleMenu()" aria-haspopup="true"><i class="ui-grid-icon-menu" ui-grid-one-bind-aria-label="i18n.aria.buttonLabel">&nbsp;</i></div><div ui-grid-menu menu-items="menuItems"></div></div>');
    $templateCache.put("ui-grid/ui-grid-no-header", '<div class="ui-grid-top-panel"></div>');
    $templateCache.put("ui-grid/ui-grid-row", "<div ng-repeat=\"(colRenderIndex, col) in colContainer.renderedColumns track by col.uid\" ui-grid-one-bind-id-grid=\"rowRenderIndex + '-' + col.uid + '-cell'\" class=\"ui-grid-cell\" ng-class=\"{ 'ui-grid-row-header-cell': col.isRowHeader }\" role=\"{{col.isRowHeader ? 'rowheader' : 'gridcell'}}\" ui-grid-cell></div>");
    $templateCache.put("ui-grid/ui-grid", '<div ui-i18n="en" class="ui-grid"><!-- TODO (c0bra): add "scoped" attr here, eventually? --><style ui-grid-style>.grid{{ grid.id }} {\n' + "      /* Styles for the grid */\n" + "    }\n" + "\n" + "    .grid{{ grid.id }} .ui-grid-row, .grid{{ grid.id }} .ui-grid-cell, .grid{{ grid.id }} .ui-grid-cell .ui-grid-vertical-bar {\n" + "      height: {{ grid.options.rowHeight }}px;\n" + "    }\n" + "\n" + "    .grid{{ grid.id }} .ui-grid-row:last-child .ui-grid-cell {\n" + "      border-bottom-width: {{ ((grid.getTotalRowHeight() < grid.getViewportHeight()) && '1') || '0' }}px;\n" + "    }\n" + "\n" + "    {{ grid.verticalScrollbarStyles }}\n" + "    {{ grid.horizontalScrollbarStyles }}\n" + "\n" + "    /*\n" + "    .ui-grid[dir=rtl] .ui-grid-viewport {\n" + "      padding-left: {{ grid.verticalScrollbarWidth }}px;\n" + "    }\n" + "    */\n" + "\n" + '    {{ grid.customStyles }}</style><div class="ui-grid-contents-wrapper"><div ui-grid-menu-button ng-if="grid.options.enableGridMenu"></div><div ng-if="grid.hasLeftContainer()" style="width: 0" ui-grid-pinned-container="\'left\'"></div><div ui-grid-render-container container-id="\'body\'" col-container-name="\'body\'" row-container-name="\'body\'" bind-scroll-horizontal="true" bind-scroll-vertical="true" enable-horizontal-scrollbar="grid.options.enableHorizontalScrollbar" enable-vertical-scrollbar="grid.options.enableVerticalScrollbar"></div><div ng-if="grid.hasRightContainer()" style="width: 0" ui-grid-pinned-container="\'right\'"></div><div ui-grid-grid-footer ng-if="grid.options.showGridFooter"></div><div ui-grid-column-menu ng-if="grid.options.enableColumnMenus"></div><div ng-transclude></div></div></div>');
    $templateCache.put("ui-grid/uiGridCell", '<div class="ui-grid-cell-contents" title="TOOLTIP">{{COL_FIELD CUSTOM_FILTERS}}</div>');
    $templateCache.put("ui-grid/uiGridColumnMenu", '<div class="ui-grid-column-menu"><div ui-grid-menu menu-items="menuItems"><!-- <div class="ui-grid-column-menu">\n' + '    <div class="inner" ng-show="menuShown">\n' + "      <ul>\n" + '        <div ng-show="grid.options.enableSorting">\n' + '          <li ng-click="sortColumn($event, asc)" ng-class="{ \'selected\' : col.sort.direction == asc }"><i class="ui-grid-icon-sort-alt-up"></i> Sort Ascending</li>\n' + '          <li ng-click="sortColumn($event, desc)" ng-class="{ \'selected\' : col.sort.direction == desc }"><i class="ui-grid-icon-sort-alt-down"></i> Sort Descending</li>\n' + '          <li ng-show="col.sort.direction" ng-click="unsortColumn()"><i class="ui-grid-icon-cancel"></i> Remove Sort</li>\n' + "        </div>\n" + "      </ul>\n" + "    </div>\n" + "  </div> --></div></div>");
    $templateCache.put("ui-grid/uiGridFooterCell", '<div class="ui-grid-cell-contents" col-index="renderIndex"><div>{{ col.getAggregationText() + ( col.getAggregationValue() CUSTOM_FILTERS ) }}</div></div>');
    $templateCache.put("ui-grid/uiGridHeaderCell", '<div role="columnheader" ng-class="{ \'sortable\': sortable }" ui-grid-one-bind-aria-labelledby-grid="col.uid + \'-header-text \' + col.uid + \'-sortdir-text\'" aria-sort="{{col.sort.direction == asc ? \'ascending\' : ( col.sort.direction == desc ? \'descending\' : (!col.sort.direction ? \'none\' : \'other\'))}}"><div role="button" tabindex="0" class="ui-grid-cell-contents ui-grid-header-cell-primary-focus" col-index="renderIndex" title="TOOLTIP"><span class="ui-grid-header-cell-label" ui-grid-one-bind-id-grid="col.uid + \'-header-text\'">{{ col.displayName CUSTOM_FILTERS }}</span> <span ui-grid-one-bind-id-grid="col.uid + \'-sortdir-text\'" ui-grid-visible="col.sort.direction" aria-label="{{getSortDirectionAriaLabel()}}"><i ng-class="{ \'ui-grid-icon-up-dir\': col.sort.direction == asc, \'ui-grid-icon-down-dir\': col.sort.direction == desc, \'ui-grid-icon-blank\': !col.sort.direction }" title="{{isSortPriorityVisible() ? i18n.headerCell.priority + \' \' + ( col.sort.priority + 1 )  : null}}" aria-hidden="true"></i> <sub ui-grid-visible="isSortPriorityVisible()" class="ui-grid-sort-priority-number">{{col.sort.priority + 1}}</sub></span></div><div role="button" tabindex="0" ui-grid-one-bind-id-grid="col.uid + \'-menu-button\'" class="ui-grid-column-menu-button" ng-if="grid.options.enableColumnMenus && !col.isRowHeader  && col.colDef.enableColumnMenu !== false" ng-click="toggleMenu($event)" ng-class="{\'ui-grid-column-menu-button-last-col\': isLastCol}" ui-grid-one-bind-aria-label="i18n.headerCell.aria.columnMenuButtonLabel" aria-haspopup="true"><i class="ui-grid-icon-angle-down" aria-hidden="true">&nbsp;</i></div><div ui-grid-filter></div></div>');
    $templateCache.put("ui-grid/uiGridMenu", '<div class="ui-grid-menu" ng-if="shown"><style ui-grid-style>{{dynamicStyles}}</style><div class="ui-grid-menu-mid" ng-show="shownMid"><div class="ui-grid-menu-inner"><ul role="menu" class="ui-grid-menu-items"><li ng-repeat="item in menuItems" role="menuitem" ui-grid-menu-item ui-grid-one-bind-id="\'menuitem-\'+$index" action="item.action" name="item.title" active="item.active" icon="item.icon" shown="item.shown" context="item.context" template-url="item.templateUrl" leave-open="item.leaveOpen" screen-reader-only="item.screenReaderOnly"></li></ul></div></div></div>');
    $templateCache.put("ui-grid/uiGridMenuItem", '<button type="button" class="ui-grid-menu-item" ng-click="itemAction($event, title)" ng-show="itemShown()" ng-class="{ \'ui-grid-menu-item-active\': active(), \'ui-grid-sr-only\': (!focus && screenReaderOnly) }" aria-pressed="{{active()}}" tabindex="0" ng-focus="focus=true" ng-blur="focus=false"><i ng-class="icon" aria-hidden="true">&nbsp;</i> {{ name }}</button>');
    $templateCache.put("ui-grid/uiGridRenderContainer", "<div role=\"grid\" ui-grid-one-bind-id-grid=\"'grid-container'\" class=\"ui-grid-render-container\" ng-style=\"{ 'margin-left': colContainer.getMargin('left') + 'px', 'margin-right': colContainer.getMargin('right') + 'px' }\"><!-- All of these dom elements are replaced in place --><div ui-grid-header></div><div ui-grid-viewport></div><div ng-if=\"colContainer.needsHScrollbarPlaceholder()\" class=\"ui-grid-scrollbar-placeholder\" ng-style=\"{height:colContainer.grid.scrollbarHeight + 'px'}\"></div><ui-grid-footer ng-if=\"grid.options.showColumnFooter\"></ui-grid-footer></div>");
    $templateCache.put("ui-grid/uiGridViewport", '<div role="rowgroup" class="ui-grid-viewport" ng-style="colContainer.getViewportStyle()"><!-- tbody --><div class="ui-grid-canvas"><div ng-repeat="(rowRenderIndex, row) in rowContainer.renderedRows track by $index" class="ui-grid-row" ng-style="Viewport.rowStyle(rowRenderIndex)"><div role="row" ui-grid-row="row" row-render-index="rowRenderIndex"></div></div></div></div>');
    $templateCache.put("ui-grid/cellEditor", '<div><form name="inputForm"><input type="INPUT_TYPE" ng-class="\'colt\' + col.uid" ui-grid-editor ng-model="MODEL_COL_FIELD"></form></div>');
    $templateCache.put("ui-grid/dropdownEditor", '<div><form name="inputForm"><select ng-class="\'colt\' + col.uid" ui-grid-edit-dropdown ng-model="MODEL_COL_FIELD" ng-options="field[editDropdownIdLabel] as field[editDropdownValueLabel] CUSTOM_FILTERS for field in editDropdownOptionsArray"></select></form></div>');
    $templateCache.put("ui-grid/fileChooserEditor", '<div><form name="inputForm"><input ng-class="\'colt\' + col.uid" ui-grid-edit-file-chooser type="file" id="files" name="files[]" ng-model="MODEL_COL_FIELD"></form></div>');
    $templateCache.put("ui-grid/expandableRow", '<div ui-grid-expandable-row ng-if="expandableRow.shouldRenderExpand()" class="expandableRow" style="float:left; margin-top: 1px; margin-bottom: 1px" ng-style="{width: (grid.renderContainers.body.getCanvasWidth()) + \'px\', height: row.expandedRowHeight + \'px\'}"></div>');
    $templateCache.put("ui-grid/expandableRowHeader", '<div class="ui-grid-row-header-cell ui-grid-expandable-buttons-cell"><div class="ui-grid-cell-contents"><i ng-class="{ \'ui-grid-icon-plus-squared\' : !row.isExpanded, \'ui-grid-icon-minus-squared\' : row.isExpanded }" ng-click="grid.api.expandable.toggleRowExpansion(row.entity)"></i></div></div>');
    $templateCache.put("ui-grid/expandableScrollFiller", "<div ng-if=\"expandableRow.shouldRenderFiller()\" ng-class=\"{scrollFiller:true, scrollFillerClass:(colContainer.name === 'body')}\" ng-style=\"{ width: (grid.getViewportWidth()) + 'px', height: row.expandedRowHeight + 2 + 'px', 'margin-left': grid.options.rowHeader.rowHeaderWidth + 'px' }\"><i class=\"ui-grid-icon-spin5 ui-grid-animate-spin\" ng-style=\"{'margin-top': ( row.expandedRowHeight/2 - 5) + 'px', 'margin-left' : ((grid.getViewportWidth() - grid.options.rowHeader.rowHeaderWidth)/2 - 5) + 'px'}\"></i></div>");
    $templateCache.put("ui-grid/expandableTopRowHeader", '<div class="ui-grid-row-header-cell ui-grid-expandable-buttons-cell"><div class="ui-grid-cell-contents"><i ng-class="{ \'ui-grid-icon-plus-squared\' : !grid.expandable.expandedAll, \'ui-grid-icon-minus-squared\' : grid.expandable.expandedAll }" ng-click="grid.api.expandable.toggleAllRows()"></i></div></div>');
    $templateCache.put("ui-grid/csvLink", '<span class="ui-grid-exporter-csv-link-span"><a href="data:text/csv;charset=UTF-8,CSV_CONTENT" download="FILE_NAME">LINK_LABEL</a></span>');
    $templateCache.put("ui-grid/importerMenuItem", '<li class="ui-grid-menu-item"><form><input class="ui-grid-importer-file-chooser" type="file" id="files" name="files[]"></form></li>');
    $templateCache.put("ui-grid/importerMenuItemContainer", "<div ui-grid-importer-menu-item></div>");
    $templateCache.put("ui-grid/pagination", '<div role="contentinfo" class="ui-grid-pager-panel" ui-grid-pager ng-show="grid.options.enablePaginationControls"><div role="navigation" class="ui-grid-pager-container"><div role="menubar" class="ui-grid-pager-control"><button type="button" role="menuitem" class="ui-grid-pager-first" ui-grid-one-bind-title="aria.pageToFirst" ui-grid-one-bind-aria-label="aria.pageToFirst" ng-click="pageFirstPageClick()" ng-disabled="cantPageBackward()"><div ng-class="grid.isRTL() ? \'last-triangle\' : \'first-triangle\'"><div ng-class="grid.isRTL() ? \'last-bar-rtl\' : \'first-bar\'"></div></div></button> <button type="button" role="menuitem" class="ui-grid-pager-previous" ui-grid-one-bind-title="aria.pageBack" ui-grid-one-bind-aria-label="aria.pageBack" ng-click="pagePreviousPageClick()" ng-disabled="cantPageBackward()"><div ng-class="grid.isRTL() ? \'last-triangle prev-triangle\' : \'first-triangle prev-triangle\'"></div></button> <input type="number" ui-grid-one-bind-title="aria.pageSelected" ui-grid-one-bind-aria-label="aria.pageSelected" class="ui-grid-pager-control-input" ng-model="grid.options.paginationCurrentPage" min="1" max="{{ paginationApi.getTotalPages() }}" required> <span class="ui-grid-pager-max-pages-number" ng-show="paginationApi.getTotalPages() > 0"><abbr ui-grid-one-bind-title="paginationOf">/</abbr> {{ paginationApi.getTotalPages() }}</span> <button type="button" role="menuitem" class="ui-grid-pager-next" ui-grid-one-bind-title="aria.pageForward" ui-grid-one-bind-aria-label="aria.pageForward" ng-click="pageNextPageClick()" ng-disabled="cantPageForward()"><div ng-class="grid.isRTL() ? \'first-triangle next-triangle\' : \'last-triangle next-triangle\'"></div></button> <button type="button" role="menuitem" class="ui-grid-pager-last" ui-grid-one-bind-title="aria.pageToLast" ui-grid-one-bind-aria-label="aria.pageToLast" ng-click="pageLastPageClick()" ng-disabled="cantPageToLast()"><div ng-class="grid.isRTL() ? \'first-triangle\' : \'last-triangle\'"><div ng-class="grid.isRTL() ? \'first-bar-rtl\' : \'last-bar\'"></div></div></button></div><div class="ui-grid-pager-row-count-picker" ng-if="grid.options.paginationPageSizes.length > 1"><select ui-grid-one-bind-aria-labelledby-grid="\'items-per-page-label\'" ng-model="grid.options.paginationPageSize" ng-options="o as o for o in grid.options.paginationPageSizes"></select><span ui-grid-one-bind-id-grid="\'items-per-page-label\'" class="ui-grid-pager-row-count-label">&nbsp;{{sizesLabel}}</span></div><span ng-if="grid.options.paginationPageSizes.length <= 1" class="ui-grid-pager-row-count-label">{{grid.options.paginationPageSize}}&nbsp;{{sizesLabel}}</span></div><div class="ui-grid-pager-count-container"><div class="ui-grid-pager-count"><span ng-show="grid.options.totalItems > 0">{{showingLow}} <abbr ui-grid-one-bind-title="paginationThrough">-</abbr> {{showingHigh}} {{paginationOf}} {{grid.options.totalItems}} {{totalItemsLabel}}</span></div></div></div>');
    $templateCache.put("ui-grid/columnResizer", '<div ui-grid-column-resizer ng-if="grid.options.enableColumnResizing" class="ui-grid-column-resizer" col="col" position="right" render-index="renderIndex" unselectable="on"></div>');
    $templateCache.put("ui-grid/gridFooterSelectedItems", '<span ng-if="grid.selection.selectedCount !== 0 && grid.options.enableFooterTotalSelected">({{"search.selectedItems" | t}} {{grid.selection.selectedCount}})</span>');
    $templateCache.put("ui-grid/selectionHeaderCell", '<div><!-- <div class="ui-grid-vertical-bar">&nbsp;</div> --><div class="ui-grid-cell-contents" col-index="renderIndex"><ui-grid-selection-select-all-buttons ng-if="grid.options.enableSelectAll"></ui-grid-selection-select-all-buttons></div></div>');
    $templateCache.put("ui-grid/selectionRowHeader", '<div class="ui-grid-disable-selection"><div class="ui-grid-cell-contents"><ui-grid-selection-row-header-buttons></ui-grid-selection-row-header-buttons></div></div>');
    $templateCache.put("ui-grid/selectionRowHeaderButtons", '<div class="ui-grid-selection-row-header-buttons ui-grid-icon-ok" ng-class="{\'ui-grid-row-selected\': row.isSelected}" ng-click="selectButtonClick(row, $event)">&nbsp;</div>');
    $templateCache.put("ui-grid/selectionSelectAllButtons", '<div class="ui-grid-selection-row-header-buttons ui-grid-icon-ok" ng-class="{\'ui-grid-all-selected\': grid.selection.selectAll}" ng-click="headerButtonClick($event)"></div>');
    $templateCache.put("ui-grid/treeBaseExpandAllButtons", '<div class="ui-grid-tree-base-row-header-buttons" ng-class="{\'ui-grid-icon-minus-squared\': grid.treeBase.numberLevels > 0 && grid.treeBase.expandAll, \'ui-grid-icon-plus-squared\': grid.treeBase.numberLevels > 0 && !grid.treeBase.expandAll}" ng-click="headerButtonClick($event)"></div>');
    $templateCache.put("ui-grid/treeBaseHeaderCell", '<div><div class="ui-grid-cell-contents" col-index="renderIndex"><ui-grid-tree-base-expand-all-buttons ng-if="grid.options.enableExpandAll"></ui-grid-tree-base-expand-all-buttons></div></div>');
    $templateCache.put("ui-grid/treeBaseRowHeader", '<div class="ui-grid-cell-contents"><ui-grid-tree-base-row-header-buttons></ui-grid-tree-base-row-header-buttons></div>');
    $templateCache.put("ui-grid/treeBaseRowHeaderButtons", "<div class=\"ui-grid-tree-base-row-header-buttons\" ng-class=\"{'ui-grid-tree-base-header': row.treeLevel > -1 }\" ng-click=\"treeButtonClick(row, $event)\"><i ng-class=\"{'ui-grid-icon-minus-squared': ( ( grid.options.showTreeExpandNoChildren && row.treeLevel > -1 ) || ( row.treeNode.children && row.treeNode.children.length > 0 ) ) && row.treeNode.state === 'expanded', 'ui-grid-icon-plus-squared': ( ( grid.options.showTreeExpandNoChildren && row.treeLevel > -1 ) || ( row.treeNode.children && row.treeNode.children.length > 0 ) ) && row.treeNode.state === 'collapsed'}\" ng-style=\"{'padding-left': grid.options.treeIndent * row.treeLevel + 'px'}\"></i> &nbsp;</div>");
    $templateCache.put("ui-grid/cellTitleValidator", '<div class="ui-grid-cell-contents" ng-class="{invalid:grid.validate.isInvalid(row.entity,col.colDef)}" title="{{grid.validate.getTitleFormattedErrors(row.entity,col.colDef)}}">{{COL_FIELD CUSTOM_FILTERS}}</div>');
    $templateCache.put("ui-grid/cellTooltipValidator", '<div class="ui-grid-cell-contents" ng-class="{invalid:grid.validate.isInvalid(row.entity,col.colDef)}" tooltip-html-unsafe="{{grid.validate.getFormattedErrors(row.entity,col.colDef)}}" tooltip-enable="grid.validate.isInvalid(row.entity,col.colDef)" tooltip-append-to-body="true" tooltip-placement="top" title="TOOLTIP">{{COL_FIELD CUSTOM_FILTERS}}</div>');
} ]);