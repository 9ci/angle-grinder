angular.module("xeditable", []).value("editableOptions", {
    "theme": "default",
    "buttons": "right",
    "blurElem": "cancel",
    "blurForm": "ignore",
    "activate": "focus"
});

angular.module("xeditable").directive("editableBsdate", [ "editableDirectiveFactory", function(editableDirectiveFactory) {
    return editableDirectiveFactory({
        "directiveName": "editableBsdate",
        "inputTpl": '<input type="text">'
    });
} ]);

angular.module("xeditable").directive("editableBstime", [ "editableDirectiveFactory", function(editableDirectiveFactory) {
    return editableDirectiveFactory({
        "directiveName": "editableBstime",
        "inputTpl": "<timepicker></timepicker>",
        "render": function() {
            this.parent.render.call(this);
            var div = angular.element('<div class="well well-small" style="display:inline-block;"></div>');
            div.attr("ng-model", this.inputEl.attr("ng-model"));
            this.inputEl.removeAttr("ng-model");
            if (this.attrs.eNgChange) {
                div.attr("ng-change", this.inputEl.attr("ng-change"));
                this.inputEl.removeAttr("ng-change");
            }
            this.inputEl.wrap(div);
        }
    });
} ]);

angular.module("xeditable").directive("editableCheckbox", [ "editableDirectiveFactory", function(editableDirectiveFactory) {
    return editableDirectiveFactory({
        "directiveName": "editableCheckbox",
        "inputTpl": '<input type="checkbox">',
        "render": function() {
            this.parent.render.call(this);
            if (this.attrs.eTitle) {
                this.inputEl.wrap("<label></label>");
                this.inputEl.after(angular.element("<span></span>").text(this.attrs.eTitle));
            }
        },
        "autosubmit": function() {
            var self = this;
            self.inputEl.bind("change", function() {
                setTimeout(function() {
                    self.scope.$apply(function() {
                        self.scope.$form.$submit();
                    });
                }, 500);
            });
        }
    });
} ]);

angular.module("xeditable").directive("editableChecklist", [ "editableDirectiveFactory", "editableNgOptionsParser", function(editableDirectiveFactory, editableNgOptionsParser) {
    return editableDirectiveFactory({
        "directiveName": "editableChecklist",
        "inputTpl": "<span></span>",
        "useCopy": true,
        "render": function() {
            this.parent.render.call(this);
            var parsed = editableNgOptionsParser(this.attrs.eNgOptions);
            var html = '<label ng-repeat="' + parsed.ngRepeat + '">' + '<input type="checkbox" checklist-model="$parent.$data" checklist-value="' + parsed.locals.valueFn + '">' + '<span ng-bind="' + parsed.locals.displayFn + '"></span></label>';
            this.inputEl.removeAttr("ng-model");
            this.inputEl.removeAttr("ng-options");
            this.inputEl.html(html);
        }
    });
} ]);

(function() {
    var types = "text|email|tel|number|url|search|color|date|datetime|time|month|week".split("|");
    angular.forEach(types, function(type) {
        var directiveName = "editable" + type.charAt(0).toUpperCase() + type.slice(1);
        angular.module("xeditable").directive(directiveName, [ "editableDirectiveFactory", function(editableDirectiveFactory) {
            return editableDirectiveFactory({
                "directiveName": directiveName,
                "inputTpl": '<input type="' + type + '">'
            });
        } ]);
    });
    angular.module("xeditable").directive("editableRange", [ "editableDirectiveFactory", function(editableDirectiveFactory) {
        return editableDirectiveFactory({
            "directiveName": "editableRange",
            "inputTpl": '<input type="range" id="range" name="range">',
            "render": function() {
                this.parent.render.call(this);
                this.inputEl.after("<output>{{$data}}</output>");
            }
        });
    } ]);
})();

angular.module("xeditable").directive("editableRadiolist", [ "editableDirectiveFactory", "editableNgOptionsParser", function(editableDirectiveFactory, editableNgOptionsParser) {
    return editableDirectiveFactory({
        "directiveName": "editableRadiolist",
        "inputTpl": "<span></span>",
        "render": function() {
            this.parent.render.call(this);
            var parsed = editableNgOptionsParser(this.attrs.eNgOptions);
            var html = '<label ng-repeat="' + parsed.ngRepeat + '">' + '<input type="radio" ng-model="$parent.$data" value="{{' + parsed.locals.valueFn + '}}">' + '<span ng-bind="' + parsed.locals.displayFn + '"></span></label>';
            this.inputEl.removeAttr("ng-model");
            this.inputEl.removeAttr("ng-options");
            this.inputEl.html(html);
        },
        "autosubmit": function() {
            var self = this;
            self.inputEl.bind("change", function() {
                setTimeout(function() {
                    self.scope.$apply(function() {
                        self.scope.$form.$submit();
                    });
                }, 500);
            });
        }
    });
} ]);

angular.module("xeditable").directive("editableSelect", [ "editableDirectiveFactory", function(editableDirectiveFactory) {
    return editableDirectiveFactory({
        "directiveName": "editableSelect",
        "inputTpl": "<select></select>",
        "autosubmit": function() {
            var self = this;
            self.inputEl.bind("change", function() {
                self.scope.$apply(function() {
                    self.scope.$form.$submit();
                });
            });
        }
    });
} ]);

angular.module("xeditable").directive("editableTextarea", [ "editableDirectiveFactory", function(editableDirectiveFactory) {
    return editableDirectiveFactory({
        "directiveName": "editableTextarea",
        "inputTpl": "<textarea></textarea>",
        "addListeners": function() {
            var self = this;
            self.parent.addListeners.call(self);
            if (self.single && self.buttons !== "no") {
                self.autosubmit();
            }
        },
        "autosubmit": function() {
            var self = this;
            self.inputEl.bind("keydown", function(e) {
                if ((e.ctrlKey || e.metaKey) && e.keyCode === 13) {
                    self.scope.$apply(function() {
                        self.scope.$form.$submit();
                    });
                }
            });
        }
    });
} ]);

angular.module("xeditable").factory("editableController", [ "$q", "editableUtils", function($q, editableUtils) {
    EditableController.$inject = [ "$scope", "$attrs", "$element", "$parse", "editableThemes", "editableOptions", "$rootScope", "$compile", "$q" ];
    function EditableController($scope, $attrs, $element, $parse, editableThemes, editableOptions, $rootScope, $compile, $q) {
        var valueGetter;
        var inWaiting;
        var self = this;
        self.scope = $scope;
        self.elem = $element;
        self.attrs = $attrs;
        self.inputEl = null;
        self.editorEl = null;
        self.single = true;
        self.error = "";
        self.theme = editableThemes[editableOptions.theme] || editableThemes["default"];
        self.parent = {};
        self.inputTpl = "";
        self.directiveName = "";
        self.useCopy = false;
        self.single = null;
        self.buttons = "right";
        self.init = function(single) {
            self.single = single;
            self.name = $attrs.eName || $attrs[self.directiveName];
            if ($attrs[self.directiveName]) {
                valueGetter = $parse($attrs[self.directiveName]);
            } else {
                throw "You should provide value for `" + self.directiveName + "` in editable element!";
            }
            if (!self.single) {
                self.buttons = "no";
            } else {
                self.buttons = self.attrs.buttons || editableOptions.buttons;
            }
            if ($attrs.eName) {
                self.scope.$watch("$data", function(newVal) {
                    self.scope.$form.$data[$attrs.eName] = newVal;
                });
            }
            if ($attrs.onshow) {
                self.onshow = function() {
                    return self.catchError($parse($attrs.onshow)($scope));
                };
            }
            if ($attrs.onhide) {
                self.onhide = function() {
                    return $parse($attrs.onhide)($scope);
                };
            }
            if ($attrs.oncancel) {
                self.oncancel = function() {
                    return $parse($attrs.oncancel)($scope);
                };
            }
            if ($attrs.onbeforesave) {
                self.onbeforesave = function() {
                    return self.catchError($parse($attrs.onbeforesave)($scope));
                };
            }
            if ($attrs.onaftersave) {
                self.onaftersave = function() {
                    return self.catchError($parse($attrs.onaftersave)($scope));
                };
            }
            $scope.$parent.$watch($attrs[self.directiveName], function(newVal, oldVal) {
                self.handleEmpty();
            });
        };
        self.render = function() {
            var theme = self.theme;
            self.inputEl = angular.element(self.inputTpl);
            self.controlsEl = angular.element(theme.controlsTpl);
            self.controlsEl.append(self.inputEl);
            if (self.buttons !== "no") {
                self.buttonsEl = angular.element(theme.buttonsTpl);
                self.submitEl = angular.element(theme.submitTpl);
                self.cancelEl = angular.element(theme.cancelTpl);
                self.buttonsEl.append(self.submitEl).append(self.cancelEl);
                self.controlsEl.append(self.buttonsEl);
                self.inputEl.addClass("editable-has-buttons");
            }
            self.errorEl = angular.element(theme.errorTpl);
            self.controlsEl.append(self.errorEl);
            self.editorEl = angular.element(self.single ? theme.formTpl : theme.noformTpl);
            self.editorEl.append(self.controlsEl);
            for (var k in $attrs.$attr) {
                if (k.length <= 1) {
                    continue;
                }
                var transferAttr = false;
                var nextLetter = k.substring(1, 2);
                if (k.substring(0, 1) === "e" && nextLetter === nextLetter.toUpperCase()) {
                    transferAttr = k.substring(1);
                } else {
                    continue;
                }
                if (transferAttr === "Form" || transferAttr === "NgSubmit") {
                    continue;
                }
                transferAttr = transferAttr.substring(0, 1).toLowerCase() + editableUtils.camelToDash(transferAttr.substring(1));
                var attrValue = $attrs[k] === "" ? transferAttr : $attrs[k];
                self.inputEl.attr(transferAttr, attrValue);
            }
            self.inputEl.addClass("editable-input");
            self.inputEl.attr("ng-model", "$data");
            self.editorEl.addClass(editableUtils.camelToDash(self.directiveName));
            if (self.single) {
                self.editorEl.attr("editable-form", "$form");
                self.editorEl.attr("blur", self.attrs.blur || (self.buttons === "no" ? "cancel" : editableOptions.blurElem));
            }
            if (angular.isFunction(theme.postrender)) {
                theme.postrender.call(self);
            }
        };
        self.setLocalValue = function() {
            self.scope.$data = self.useCopy ? angular.copy(valueGetter($scope.$parent)) : valueGetter($scope.$parent);
        };
        self.show = function() {
            self.setLocalValue();
            self.render();
            $element.after(self.editorEl);
            $compile(self.editorEl)($scope);
            self.addListeners();
            $element.addClass("editable-hide");
            return self.onshow();
        };
        self.hide = function() {
            self.editorEl.remove();
            $element.removeClass("editable-hide");
            return self.onhide();
        };
        self.cancel = function() {
            self.oncancel();
        };
        self.addListeners = function() {
            self.inputEl.bind("keyup", function(e) {
                if (!self.single) {
                    return;
                }
                switch (e.keyCode) {
                  case 27:
                    self.scope.$apply(function() {
                        self.scope.$form.$cancel();
                    });
                    break;
                }
            });
            if (self.single && self.buttons === "no") {
                self.autosubmit();
            }
            self.editorEl.bind("click", function(e) {
                if (e.which !== 1) {
                    return;
                }
                if (self.scope.$form.$visible) {
                    self.scope.$form._clicked = true;
                }
            });
        };
        self.setWaiting = function(value) {
            if (value) {
                inWaiting = !self.inputEl.attr("disabled") && !self.inputEl.attr("ng-disabled") && !self.inputEl.attr("ng-enabled");
                if (inWaiting) {
                    self.inputEl.attr("disabled", "disabled");
                    if (self.buttonsEl) {
                        self.buttonsEl.find("button").attr("disabled", "disabled");
                    }
                }
            } else {
                if (inWaiting) {
                    self.inputEl.removeAttr("disabled");
                    if (self.buttonsEl) {
                        self.buttonsEl.find("button").removeAttr("disabled");
                    }
                }
            }
        };
        self.activate = function() {
            setTimeout(function() {
                var el = self.inputEl[0];
                if (editableOptions.activate === "focus" && el.focus) {
                    el.focus();
                }
                if (editableOptions.activate === "select" && el.select) {
                    el.select();
                }
            }, 0);
        };
        self.setError = function(msg) {
            if (!angular.isObject(msg)) {
                $scope.$error = msg;
                self.error = msg;
            }
        };
        self.catchError = function(result, noPromise) {
            if (angular.isObject(result) && noPromise !== true) {
                $q.when(result).then(angular.bind(this, function(r) {
                    this.catchError(r, true);
                }), angular.bind(this, function(r) {
                    this.catchError(r, true);
                }));
            } else if (noPromise && angular.isObject(result) && result.status && result.status !== 200 && result.data && angular.isString(result.data)) {
                this.setError(result.data);
                result = result.data;
            } else if (angular.isString(result)) {
                this.setError(result);
            }
            return result;
        };
        self.save = function() {
            valueGetter.assign($scope.$parent, angular.copy(self.scope.$data));
        };
        self.handleEmpty = function() {
            var val = valueGetter($scope.$parent);
            var isEmpty = val === null || val === undefined || val === "" || angular.isArray(val) && val.length === 0;
            $element.toggleClass("editable-empty", isEmpty);
        };
        self.autosubmit = angular.noop;
        self.onshow = angular.noop;
        self.onhide = angular.noop;
        self.oncancel = angular.noop;
        self.onbeforesave = angular.noop;
        self.onaftersave = angular.noop;
    }
    return EditableController;
} ]);

angular.module("xeditable").factory("editableDirectiveFactory", [ "$parse", "$compile", "editableThemes", "$rootScope", "$document", "editableController", "editableFormController", function($parse, $compile, editableThemes, $rootScope, $document, editableController, editableFormController) {
    return function(overwrites) {
        return {
            "restrict": "A",
            "scope": true,
            "require": [ overwrites.directiveName, "?^form" ],
            "controller": editableController,
            "link": function(scope, elem, attrs, ctrl) {
                var eCtrl = ctrl[0];
                var eFormCtrl;
                var hasForm = false;
                if (ctrl[1]) {
                    eFormCtrl = ctrl[1];
                    hasForm = true;
                } else if (attrs.eForm) {
                    var getter = $parse(attrs.eForm)(scope);
                    if (getter) {
                        eFormCtrl = getter;
                        hasForm = true;
                    } else {
                        for (var i = 0; i < $document[0].forms.length; i++) {
                            if ($document[0].forms[i].name === attrs.eForm) {
                                eFormCtrl = null;
                                hasForm = true;
                                break;
                            }
                        }
                    }
                }
                angular.forEach(overwrites, function(v, k) {
                    if (eCtrl[k] !== undefined) {
                        eCtrl.parent[k] = eCtrl[k];
                    }
                });
                angular.extend(eCtrl, overwrites);
                eCtrl.init(!hasForm);
                scope.$editable = eCtrl;
                elem.addClass("editable");
                if (hasForm) {
                    if (eFormCtrl) {
                        scope.$form = eFormCtrl;
                        if (!scope.$form.$addEditable) {
                            throw "Form with editable elements should have `editable-form` attribute.";
                        }
                        scope.$form.$addEditable(eCtrl);
                    } else {
                        $rootScope.$$editableBuffer = $rootScope.$$editableBuffer || {};
                        $rootScope.$$editableBuffer[attrs.eForm] = $rootScope.$$editableBuffer[attrs.eForm] || [];
                        $rootScope.$$editableBuffer[attrs.eForm].push(eCtrl);
                        scope.$form = null;
                    }
                } else {
                    scope.$form = editableFormController();
                    scope.$form.$addEditable(eCtrl);
                    if (attrs.eForm) {
                        scope.$parent[attrs.eForm] = scope.$form;
                    }
                    if (!attrs.eForm) {
                        elem.addClass("editable-click");
                        elem.bind("click", function(e) {
                            e.preventDefault();
                            e.editable = eCtrl;
                            scope.$apply(function() {
                                scope.$form.$show();
                            });
                        });
                    }
                }
            }
        };
    };
} ]);

angular.module("xeditable").factory("editableFormController", [ "$parse", "$document", "$rootScope", "editablePromiseCollection", "editableUtils", function($parse, $document, $rootScope, editablePromiseCollection, editableUtils) {
    var shown = [];
    $document.bind("click", function(e) {
        if (e.which !== 1) {
            return;
        }
        var toCancel = [];
        var toSubmit = [];
        for (var i = 0; i < shown.length; i++) {
            if (shown[i]._clicked) {
                shown[i]._clicked = false;
                continue;
            }
            if (shown[i].$waiting) {
                continue;
            }
            if (shown[i]._blur === "cancel") {
                toCancel.push(shown[i]);
            }
            if (shown[i]._blur === "submit") {
                toSubmit.push(shown[i]);
            }
        }
        if (toCancel.length || toSubmit.length) {
            $rootScope.$apply(function() {
                angular.forEach(toCancel, function(v) {
                    v.$cancel();
                });
                angular.forEach(toSubmit, function(v) {
                    v.$submit();
                });
            });
        }
    });
    var base = {
        "$addEditable": function(editable) {
            this.$editables.push(editable);
            editable.elem.bind("$destroy", angular.bind(this, this.$removeEditable, editable));
            if (!editable.scope.$form) {
                editable.scope.$form = this;
            }
            if (this.$visible) {
                editable.catchError(editable.show());
            }
        },
        "$removeEditable": function(editable) {
            for (var i = 0; i < this.$editables.length; i++) {
                if (this.$editables[i] === editable) {
                    this.$editables.splice(i, 1);
                    return;
                }
            }
        },
        "$show": function() {
            if (this.$visible) {
                return;
            }
            this.$visible = true;
            var pc = editablePromiseCollection();
            pc.when(this.$onshow());
            this.$setError(null, "");
            angular.forEach(this.$editables, function(editable) {
                pc.when(editable.show());
            });
            pc.then({
                "onWait": angular.bind(this, this.$setWaiting),
                "onTrue": angular.bind(this, this.$activate),
                "onFalse": angular.bind(this, this.$activate),
                "onString": angular.bind(this, this.$activate)
            });
            setTimeout(angular.bind(this, function() {
                this._clicked = false;
                if (editableUtils.indexOf(shown, this) === -1) {
                    shown.push(this);
                }
            }), 0);
        },
        "$activate": function(name) {
            var i;
            if (this.$editables.length) {
                if (angular.isString(name)) {
                    for (i = 0; i < this.$editables.length; i++) {
                        if (this.$editables[i].name === name) {
                            this.$editables[i].activate();
                            return;
                        }
                    }
                }
                for (i = 0; i < this.$editables.length; i++) {
                    if (this.$editables[i].error) {
                        this.$editables[i].activate();
                        return;
                    }
                }
                this.$editables[0].activate();
            }
        },
        "$hide": function() {
            if (!this.$visible) {
                return;
            }
            this.$visible = false;
            this.$onhide();
            angular.forEach(this.$editables, function(editable) {
                editable.hide();
            });
            editableUtils.arrayRemove(shown, this);
        },
        "$cancel": function() {
            if (!this.$visible) {
                return;
            }
            this.$oncancel();
            angular.forEach(this.$editables, function(editable) {
                editable.cancel();
            });
            this.$hide();
        },
        "$setWaiting": function(value) {
            this.$waiting = !!value;
            angular.forEach(this.$editables, function(editable) {
                editable.setWaiting(!!value);
            });
        },
        "$setError": function(name, msg) {
            angular.forEach(this.$editables, function(editable) {
                if (!name || editable.name === name) {
                    editable.setError(msg);
                }
            });
        },
        "$submit": function() {
            if (this.$waiting) {
                return;
            }
            this.$setError(null, "");
            var pc = editablePromiseCollection();
            angular.forEach(this.$editables, function(editable) {
                pc.when(editable.onbeforesave());
            });
            pc.then({
                "onWait": angular.bind(this, this.$setWaiting),
                "onTrue": angular.bind(this, checkSelf, true),
                "onFalse": angular.bind(this, checkSelf, false),
                "onString": angular.bind(this, this.$activate)
            });
            function checkSelf(childrenTrue) {
                var pc = editablePromiseCollection();
                pc.when(this.$onbeforesave());
                pc.then({
                    "onWait": angular.bind(this, this.$setWaiting),
                    "onTrue": childrenTrue ? angular.bind(this, this.$save) : angular.bind(this, this.$hide),
                    "onFalse": angular.bind(this, this.$hide),
                    "onString": angular.bind(this, this.$activate)
                });
            }
        },
        "$save": function() {
            angular.forEach(this.$editables, function(editable) {
                editable.save();
            });
            var pc = editablePromiseCollection();
            pc.when(this.$onaftersave());
            angular.forEach(this.$editables, function(editable) {
                pc.when(editable.onaftersave());
            });
            pc.then({
                "onWait": angular.bind(this, this.$setWaiting),
                "onTrue": angular.bind(this, this.$hide),
                "onFalse": angular.bind(this, this.$hide),
                "onString": angular.bind(this, this.$activate)
            });
        },
        "$onshow": angular.noop,
        "$oncancel": angular.noop,
        "$onhide": angular.noop,
        "$onbeforesave": angular.noop,
        "$onaftersave": angular.noop
    };
    return function() {
        return angular.extend({
            "$editables": [],
            "$visible": false,
            "$waiting": false,
            "$data": {},
            "_clicked": false,
            "_blur": null
        }, base);
    };
} ]);

angular.module("xeditable").directive("editableForm", [ "$rootScope", "$parse", "editableFormController", "editableOptions", function($rootScope, $parse, editableFormController, editableOptions) {
    return {
        "restrict": "A",
        "require": [ "form" ],
        "compile": function() {
            return {
                "pre": function(scope, elem, attrs, ctrl) {
                    var form = ctrl[0];
                    var eForm;
                    if (attrs.editableForm) {
                        if (scope[attrs.editableForm] && scope[attrs.editableForm].$show) {
                            eForm = scope[attrs.editableForm];
                            angular.extend(form, eForm);
                        } else {
                            eForm = editableFormController();
                            scope[attrs.editableForm] = eForm;
                            angular.extend(eForm, form);
                        }
                    } else {
                        eForm = editableFormController();
                        angular.extend(form, eForm);
                    }
                    var buf = $rootScope.$$editableBuffer;
                    var name = form.$name;
                    if (name && buf && buf[name]) {
                        angular.forEach(buf[name], function(editable) {
                            eForm.$addEditable(editable);
                        });
                        delete buf[name];
                    }
                },
                "post": function(scope, elem, attrs, ctrl) {
                    var eForm;
                    if (attrs.editableForm && scope[attrs.editableForm] && scope[attrs.editableForm].$show) {
                        eForm = scope[attrs.editableForm];
                    } else {
                        eForm = ctrl[0];
                    }
                    if (attrs.onshow) {
                        eForm.$onshow = angular.bind(eForm, $parse(attrs.onshow), scope);
                    }
                    if (attrs.onhide) {
                        eForm.$onhide = angular.bind(eForm, $parse(attrs.onhide), scope);
                    }
                    if (attrs.oncancel) {
                        eForm.$oncancel = angular.bind(eForm, $parse(attrs.oncancel), scope);
                    }
                    if (attrs.shown && $parse(attrs.shown)(scope)) {
                        eForm.$show();
                    }
                    eForm._blur = attrs.blur || editableOptions.blurForm;
                    if (!attrs.ngSubmit && !attrs.submit) {
                        if (attrs.onbeforesave) {
                            eForm.$onbeforesave = function() {
                                return $parse(attrs.onbeforesave)(scope, {
                                    "$data": eForm.$data
                                });
                            };
                        }
                        if (attrs.onaftersave) {
                            eForm.$onaftersave = function() {
                                return $parse(attrs.onaftersave)(scope, {
                                    "$data": eForm.$data
                                });
                            };
                        }
                        elem.bind("submit", function(event) {
                            event.preventDefault();
                            scope.$apply(function() {
                                eForm.$submit();
                            });
                        });
                    }
                    elem.bind("click", function(e) {
                        if (e.which !== 1) {
                            return;
                        }
                        if (eForm.$visible) {
                            eForm._clicked = true;
                        }
                    });
                }
            };
        }
    };
} ]);

angular.module("xeditable").factory("editablePromiseCollection", [ "$q", function($q) {
    function promiseCollection() {
        return {
            "promises": [],
            "hasFalse": false,
            "hasString": false,
            "when": function(result, noPromise) {
                if (result === false) {
                    this.hasFalse = true;
                } else if (!noPromise && angular.isObject(result)) {
                    this.promises.push($q.when(result));
                } else if (angular.isString(result)) {
                    this.hasString = true;
                } else {
                    return;
                }
            },
            "then": function(callbacks) {
                callbacks = callbacks || {};
                var onTrue = callbacks.onTrue || angular.noop;
                var onFalse = callbacks.onFalse || angular.noop;
                var onString = callbacks.onString || angular.noop;
                var onWait = callbacks.onWait || angular.noop;
                var self = this;
                if (this.promises.length) {
                    onWait(true);
                    $q.all(this.promises).then(function(results) {
                        onWait(false);
                        angular.forEach(results, function(result) {
                            self.when(result, true);
                        });
                        applyCallback();
                    }, function(error) {
                        onWait(false);
                        onString();
                    });
                } else {
                    applyCallback();
                }
                function applyCallback() {
                    if (!self.hasString && !self.hasFalse) {
                        onTrue();
                    } else if (!self.hasString && self.hasFalse) {
                        onFalse();
                    } else {
                        onString();
                    }
                }
            }
        };
    }
    return promiseCollection;
} ]);

angular.module("xeditable").factory("editableUtils", [ function() {
    return {
        "indexOf": function(array, obj) {
            if (array.indexOf) return array.indexOf(obj);
            for (var i = 0; i < array.length; i++) {
                if (obj === array[i]) return i;
            }
            return -1;
        },
        "arrayRemove": function(array, value) {
            var index = this.indexOf(array, value);
            if (index >= 0) {
                array.splice(index, 1);
            }
            return value;
        },
        "camelToDash": function(str) {
            var SNAKE_CASE_REGEXP = /[A-Z]/g;
            return str.replace(SNAKE_CASE_REGEXP, function(letter, pos) {
                return (pos ? "-" : "") + letter.toLowerCase();
            });
        },
        "dashToCamel": function(str) {
            var SPECIAL_CHARS_REGEXP = /([\:\-\_]+(.))/g;
            var MOZ_HACK_REGEXP = /^moz([A-Z])/;
            return str.replace(SPECIAL_CHARS_REGEXP, function(_, separator, letter, offset) {
                return offset ? letter.toUpperCase() : letter;
            }).replace(MOZ_HACK_REGEXP, "Moz$1");
        }
    };
} ]);

angular.module("xeditable").factory("editableNgOptionsParser", [ function() {
    var NG_OPTIONS_REGEXP = /^\s*(.*?)(?:\s+as\s+(.*?))?(?:\s+group\s+by\s+(.*))?\s+for\s+(?:([\$\w][\$\w]*)|(?:\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)))\s+in\s+(.*?)(?:\s+track\s+by\s+(.*?))?$/;
    function parser(optionsExp) {
        var match;
        if (!(match = optionsExp.match(NG_OPTIONS_REGEXP))) {
            throw "ng-options parse error";
        }
        var displayFn = match[2] || match[1], valueName = match[4] || match[6], keyName = match[5], groupByFn = match[3] || "", valueFn = match[2] ? match[1] : valueName, valuesFn = match[7], track = match[8], trackFn = track ? match[8] : null;
        var ngRepeat;
        if (keyName === undefined) {
            ngRepeat = valueName + " in " + valuesFn;
            if (track !== undefined) {
                ngRepeat += " track by " + trackFn;
            }
        } else {
            ngRepeat = "(" + keyName + ", " + valueName + ") in " + valuesFn;
        }
        return {
            "ngRepeat": ngRepeat,
            "locals": {
                "valueName": valueName,
                "keyName": keyName,
                "valueFn": valueFn,
                "displayFn": displayFn
            }
        };
    }
    return parser;
} ]);

angular.module("xeditable").factory("editableThemes", function() {
    var themes = {
        "default": {
            "formTpl": '<form class="editable-wrap"></form>',
            "noformTpl": '<span class="editable-wrap"></span>',
            "controlsTpl": '<span class="editable-controls"></span>',
            "inputTpl": "",
            "errorTpl": '<div class="editable-error" ng-show="$error" ng-bind="$error"></div>',
            "buttonsTpl": '<span class="editable-buttons"></span>',
            "submitTpl": '<button type="submit">save</button>',
            "cancelTpl": '<button type="button" ng-click="$form.$cancel()">cancel</button>'
        },
        "bs2": {
            "formTpl": '<form class="form-inline editable-wrap" role="form"></form>',
            "noformTpl": '<span class="editable-wrap"></span>',
            "controlsTpl": '<div class="editable-controls controls control-group" ng-class="{\'error\': $error}"></div>',
            "inputTpl": "",
            "errorTpl": '<div class="editable-error help-block" ng-show="$error" ng-bind="$error"></div>',
            "buttonsTpl": '<span class="editable-buttons"></span>',
            "submitTpl": '<button type="submit" class="btn btn-primary"><span class="icon-ok icon-white"></span></button>',
            "cancelTpl": '<button type="button" class="btn" ng-click="$form.$cancel()">' + '<span class="icon-remove"></span>' + "</button>"
        },
        "bs3": {
            "formTpl": '<form class="form-inline editable-wrap" role="form"></form>',
            "noformTpl": '<span class="editable-wrap"></span>',
            "controlsTpl": '<div class="editable-controls form-group" ng-class="{\'has-error\': $error}"></div>',
            "inputTpl": "",
            "errorTpl": '<div class="editable-error help-block" ng-show="$error" ng-bind="$error"></div>',
            "buttonsTpl": '<span class="editable-buttons"></span>',
            "submitTpl": '<button type="submit" class="btn btn-primary"><span class="glyphicon glyphicon-ok"></span></button>',
            "cancelTpl": '<button type="button" class="btn btn-default" ng-click="$form.$cancel()">' + '<span class="glyphicon glyphicon-remove"></span>' + "</button>",
            "buttonsClass": "",
            "inputClass": "",
            "postrender": function() {
                switch (this.directiveName) {
                  case "editableText":
                  case "editableSelect":
                  case "editableTextarea":
                  case "editableEmail":
                  case "editableTel":
                  case "editableNumber":
                  case "editableUrl":
                  case "editableSearch":
                  case "editableDate":
                  case "editableDatetime":
                  case "editableTime":
                  case "editableMonth":
                  case "editableWeek":
                    this.inputEl.addClass("form-control");
                    if (this.theme.inputClass) {
                        if (this.inputEl.attr("multiple") && (this.theme.inputClass === "input-sm" || this.theme.inputClass === "input-lg")) {
                            break;
                        }
                        this.inputEl.addClass(this.theme.inputClass);
                    }
                    break;
                }
                if (this.buttonsEl && this.theme.buttonsClass) {
                    this.buttonsEl.find("button").addClass(this.theme.buttonsClass);
                }
            }
        }
    };
    return themes;
});