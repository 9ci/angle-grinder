= demo app for tutorial "Grails with REST"


= example application for tutorail "Grails with REST"

REST (REpresentational State Transfer) is an architectural style that uses HTTP requests to GET, PUT, POST and DELETE data.

Grails provides several nice features to implement REST.

First is resource anotation `@Resource`, that creates controller with basic CRUD operations for you. So when you have next
domain class
```
@Resource(uri='/orgs', formats=['xml', 'json'])
class Org {
	String name
}
```
and no implemented controllers, `http://localhost:8080/orgs` will return you a list of all your orgs:
```
<list>
	<org id="1">
		<name>Org_18</name>
	</org>
	<org id="2">
		<name>Org_14</name>
	</org>
</list>
```
and `http://localhost:8080/orgs/3` will return data for Org with id = 3.
//TODO: probably add examples for all CRUD operations
__Note __ It returns xml because it is on the first place for `formats=['xml', 'json']` property, if one changes
to `formats=['json', 'xml']` then JSON will be returned by default. But it accept both format on POST/PUT for example
```
curl -i -X POST -H "Content-Type: application/json" -d '{"name":"New Org Name"}' localhost:8080/orgs
```
will give the same result as
```
curl -i -X POST -H "Content-Type: text/xml" -d '<org><name>New Org Name</name></org>' localhost:8080/orgs
```

The next feature is to handle relations between domains. Let's take a look how we can `Locations` for specific 'Org'.
The first thing that we shall do is to change `UrlMappings.groovy`:
```
class UrlMappings {

    static mappings = {
        "/$controller/$action?/$id?(.$format)?"{
            constraints {
                // apply constraints here
            }
        }

        "/"(view:"/index")
        "500"(view:'/error')
        "404"(view:'/notFound')
        "/orgs"(resources: "org") {
            "/locations"(resources: "location")
        }
    }
}
```
In such a way we show that for url `http://localhost:8080/orgs/1/locations` we want to get locations, but it will show
locations not for Org with id = 1, but all of them, to make it work how we expect we should implement our own RestController.

Here is very basic example for it:
```
class LocationController extends RestfulController {
    static responseFormats = ['json', 'xml']
    LocationController(){
        super(Location)
    }
}
```
So, now we can even remove `@Resource` for Location domain and it will work in the same way.

__Note __ we moved format property to controller `static responseFormats = ['json', 'xml']`

The first thing one should understand is that when `http://localhost:8080/orgs/1/locations` is called we call `index`
action with `params = [orgId: 1]` of the LocationController, and not `location` action for `OrgController`, and now
it's clear how controller should be look like:
```
class LocationController extends RestfulController {
    static responseFormats = ['json', 'xml']
    LocationController(){
        super(Location)
    }

    @Override
    protected List listAllResources(Map params) {
        def crit = resource.createCriteria()
        def datalist = crit.list(params) {
            if (params.orgId){
                eq "org.id", params.orgId as Long
            }
        }
        return datalist
    }
}
```
To uderstand the better I addvise to review `RestfulController` https://github.com/grails/grails-core/blob/master/grails-plugin-rest/src/main/groovy/grails/rest/RestfulController.groovy[source]

To make the code DRY let's use https://github.com/9ci/grails-dao[grails-dao] plugin and implement RestDaoController that uses it:
```
abstract class RestDaoController<T> extends RestfulController<T> {
  static namespace = "api"
  //Responce formats, json - by default
  static responseFormats = ['json', 'xml']

  RestDaoController(Class<T> domainClass) {
    this(domainClass, false)
  }

  RestDaoController(Class<T> domainClass, boolean readOnly) {
    super(domainClass, readOnly)
  }

  Class getDomainClass() {
    resource
  }

  protected def getDao() {
    resource.dao
  }


  def index(Integer max) {
    params.max = Math.min(max ?: 10, 100)
    respond pagedList(listAllResources(params)).jsonData, model: [("${resourceName}Count".toString()): countResources()]
  }

  @Override
  protected List<T> listAllResources(Map params) {
    listCriteria(params)
  }

  @Override
  def save() {
    if (handleReadOnly()) {
      return
    }
    def p = BeanPathTools.flattenMap(request, request.JSON)
    def result = insertDomain(p)
    formatResponse(result.entity)
  }

  @Override
  def update() {
    if (handleReadOnly()) {
      return
    }
    def p = BeanPathTools.flattenMap(request, request.JSON)
    def result = updateDomain(p)
    formatResponse(result.entity)
  }

  /**
   * Deletes a resource for the given id
   * @param id The id
   */
  def delete() {
    if(handleReadOnly()) {
      return
    }

    def instance = queryForResource(params.id)
    if (instance == null) {
      transactionStatus.setRollbackOnly()
      notFound()
      return
    }

    deleteDomain(params)

    request.withFormat {
      form multipartForm {
        flash.message = message(code: 'default.deleted.message', args: [message(code: "${resourceClassName}.label".toString(), default: resourceClassName), instance.id])
        redirect action:"index", method:"GET"
      }
      '*'{ render status: NO_CONTENT } // NO CONTENT STATUS CODE
    }
  }

  protected def updateDomain(p, opts = null) {
    log.debug "updateDomain with ${p}"
    def res = dao.update(p)
    if (opts?.flush) DaoUtil.flush()
    return res
  }

  protected def formatResponse(def instance) {
    request.withFormat {
      form multipartForm {
        flash.message = message(code: 'default.created.message', args: [message(code: "${resourceName}.label".toString(), default: resourceClassName), instance.id])
        redirect instance
      }
      '*' {
        response.addHeader(HttpHeaders.LOCATION,
          g.createLink(
            resource: this.controllerName, action: 'show', id: instance.id, absolute: true,
            namespace: hasProperty('namespace') ? this.namespace : null))
        respond instance, [status: CREATED]
      }
    }
  }

  /**
   * Called from the saves and saveOrUpdateJson,
   * providing a place to override functionality
   */
  protected def insertDomain(p) {
    log.info("insertDomain(${p})")
    return dao.insert(p)
  }

  protected def deleteDomain(p){
    return dao.remove(p)
  }

  /**
   * returns the list of domain obects for the scaffolded contro
   */
  protected def listCriteria(params) {
    def crit = domainClass.createCriteria()
    def pager = new Pager(params)
    def datalist = crit.list(max: pager.max, offset: pager.offset) {
      if (params.sort)
        order(params.sort, params.order)
    }
    return datalist
  }

  protected def pagedList(dlist) {
    def pageData = new Pager(params)
    def fieldList
    if(hasProperty('listFields')){
      fieldList = listFields
    }
    else if(hasProperty('showFields')){
      fieldList = showFields
    }
    else if(hasProperty('selectFields')){
      fieldList = selectFields
    }
    pageData.setupData(dlist, fieldList)
    return pageData
  }

}
```

