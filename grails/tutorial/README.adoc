= Creating Grails applications using Angle-Grinder's Angular and restful DAO services
:toc:
:numbered:

== Getting started

For this tutorial you will need:

* JDK (I advise 8, but you can take 7 as well).

* Git.

* Grails 3.2.0 (you can install it with http://sdkman.io/[sdkman] on most Unix based systems.)

After all is installed clone the repo:

----
git clone https://github.com/9ci/angle-grinder
----

and switch to branch `rest_tutorial` branch, and go to `angle-grinder/grails/restTutorial/step1`, the final result is in
the `result` folder for each step

So first let's create new grails app:

----
$ grails create-app -profile rest-api -features hibernate4 resttutorail
Application created at angle-grinder/grails/restTutorial/step1/resttutorail
----

Grails3 provides several different profiles you can read about them in http://docs.grails.org/3.2.0/guide/profiles.html[docs]

== Creating a Basic Grails REST API

To avoid writting `nullable: true` a billion times we will set the default to allow nulls for fields
Add the following to `grails-app/config/application.groovy`
[source,groovy]
----
grails.gorm.default.constraints = {
  '*' (nullable: true, blank: true)
}
----

And then lets create a domain class for our proof of concept:

----
grails create-domain-class Contact
----

And we'll set it up like so:

[source,groovy]
----
class Contact {
  String firstName
  String lastName
  String email
  Boolean inactive

  static constraints = {
    firstName nullable: false
    inactive bindable:false
  }
}
----

We will load 100 rows of mock test data from a file `Contacts.json` in src/resources.
The mock data was generated from a great tool https://www.mockaroo.com[Mockaroo]. Check it out

[source,groovy]
----
class BootStrap {
    def grailsApplication
    def init = { servletContext ->
        def res = grailsApplication.mainContext.getResource("classpath:Contacts.json")
        def data = new JsonSlurper().parse(res.getInputStream())
        data.each{
          Contact contact = new Contact(it)
          contact.save(failOnError:true,flush: true)
        }
    }
    def destroy = {
    }
}
----

=== Resource annotation on Contact Domain

So now we can start working on creating REST Api for our app. The most easiest way is to use http://docs.grails.org/latest/guide/webServices.html#domainResources[domain resources]
So as we see from docs we just need to update our domain a bit (just add `@Resource` anotation) in such a way:

[source,groovy]
----
@Resource(uri = '/contacts', formats = ["json"])
class Contact {
  ...
}
----

=== url-mappings-report

To see all available endpoints that Grails create for us run:

----
$ grails url-mappings-report

 |    *     | ERROR: 500                            | View:   /error
 |    *     | ERROR: 404                            | View:   /notFound
 |   GET    | /${controller}(.${format)?            | Action: index
 |   POST   | /${controller}(.${format)?            | Action: save
 |  DELETE  | /${controller}/${id}(.${format)?      | Action: delete
 |   GET    | /${controller}/${id}(.${format)?      | Action: show
 |   PUT    | /${controller}/${id}(.${format)?      | Action: update
 |  PATCH   | /${controller}/${id}(.${format)?      | Action: patch

Controller: application
 |    *     | /                                     | Action: index

Controller: org
 |   GET    | /contacts/create                          | Action: create
 |   GET    | /contacts/${id}/edit                      | Action: edit
 |   POST   | /contacts                                 | Action: save
 |   GET    | /contacts                                 | Action: index
 |  DELETE  | /contacts/${id}                           | Action: delete
 |  PATCH   | /contacts/${id}                           | Action: patch
 |   PUT    | /contacts/${id}                           | Action: update
 |   GET    | /contacts/${id}                           | Action: show
----

=== Using CURL to test CRUD and List

Fire up the app with `run-app`

===== GET (list):
----
curl -i -X GET -H "Content-Type: application/json"  localhost:8080/contacts
HTTP/1.1 200
X-Application-Context: application:development
Content-Type: application/json;charset=UTF-8
Transfer-Encoding: chunked
Date: Fri, 04 Nov 2016 14:48:14 GMT

[{"id":1,"email":"mscott0@ameblo.jp","firstName":"Marie","lastName":"Scott"},{"id":2,"email":"jrodriguez1@scribd.com" ...
----

===== POST:
----
curl -i -X POST -H "Content-Type: application/json" -d '{"firstName":"Joe", "lastName": "Cool"}' localhost:8080/contacts
HTTP/1.1 201
X-Application-Context: application:development
Location: http://localhost:8080/contacts/101
Content-Type: application/json;charset=UTF-8
Transfer-Encoding: chunked
Date: Fri, 04 Nov 2016 15:00:49 GMT

{"id":101,"firstName":"Joe","lastName":"Cool"}
----
===== GET (by id):
----
curl -i -X GET -H "Content-Type: application/json"  localhost:8080/contacts/101
HTTP/1.1 200
X-Application-Context: application:development
Content-Type: application/json;charset=UTF-8
Transfer-Encoding: chunked
Date: Fri, 04 Nov 2016 15:02:09 GMT

{"id":101,"firstName":"Joe","lastName":"Cool"}
----

===== PUT:
----
curl -i -X PUT -H "Content-Type: application/json" -d '{"firstName": "New Name", "lastName": "New Last name"}' localhost:8080/contacts/101
HTTP/1.1 200
X-Application-Context: application:development
Location: http://localhost:8080/contacts/101
Content-Type: application/json;charset=UTF-8
Transfer-Encoding: chunked
Date: Fri, 04 Nov 2016 15:03:48 GMT

{"id":101,"firstName":"New Name","lastName":"New Last name"}
----

===== DELETE:
----
curl -i -X GET -H "Content-Type: application/json"  localhost:8080/contacts/50
HTTP/1.1 200
X-Application-Context: application:development
Content-Type: application/json;charset=UTF-8
Transfer-Encoding: chunked
Date: Mon, 21 Nov 2016 12:43:48 GMT

{"id":50,"email":"aramirez1d@amazon.de","firstName":"Arthur","lastName":"Ramirez"}
----

=== Functional
The next step is to add functional tests for our app

For testing we also need http://grails.org/plugin/rest-client-builder[Rest Client Builder plugin], it is already in the
dependencies list so we do not need any changes.

Here is an example of `POST` request (creating of a new contact).
RestBuilder we use to emulate request from external source. Note, in Grails3 integration tests run on the random port,
so you cant call `http://localhost:8080/contacts` , but we can use `serverPort` variable instead. See example:

[source,groovy]
----
package resttutorial

import grails.plugins.rest.client.RestBuilder
import grails.plugins.rest.client.RestResponse
import grails.test.mixin.integration.Integration
import org.grails.web.json.JSONElement
import spock.lang.Shared
import spock.lang.Specification

@Integration
class ContactSpec extends Specification {

    @Shared
    RestBuilder rest = new RestBuilder()

    void "check POST request"() {
        when:
        RestResponse response = rest.post("http://localhost:${serverPort}/contacts"){
          json([
            firstName: "Test contact",
            email:"foo@bar.com",
            inactive:true //is bindable: false - see domain, so it wont be set to contact
          ])
        }

        then:
        response.status == 201
        response.json != null
        JSONElement json = response.json
        json.id == 101
        json.firstName == "Test contact"
        json.lastName == null
        json.email == "foo@bar.com"
        json.inactive == null
    }
}
----

More tests examples are in the are in the snapshot's `ContactSpec.groovy`

=== Snapshot 1 of tutorial app is at this point

== The DAO plugin with REST support

=== Introduction

The DAO plugin adds a new Service artifact to sit in between the controller interface and the restful logic.
At it core its just a specialized transactional service to deal with CRUD, searching and other functionality relating to a domain.
The mains goals are to reduce boiler plate in the controller, centralizing transactional domain logic out of the controller,
make it easier to reuse the crud across the application without the controller and simplify testing.

Add in the dependency for the plugin
----
compile "org.grails.plugin:dao:2.0.1"
----

=== RestDaoController

Dao plugin will setup a default DAO for every domain and it has RestDaoController that overrides some methods of the
default Grails `RestfullController` to make it use DAOs.

The `@Resource` has a property `superClass` that allows us to use another controller as basic for building rest endpoints,
so lets set `RestDaoController` as super class for our Contact:

[source,groovy]
----
@Resource(uri = '/contacts', superClass = RestDaoController)
class Contact {
  ...
}
----

Now you can check that our functional tests still pass with the defaults.

For the next stage please move to next snapshot folder.

=== Implement the ContactDao

Lets say we want to customize the insert to allow a user to pass in a name and have it be split into first and last names.

The test for this case will look like:

[source,groovy]
----
  given:
  RestBuilder rest = new RestBuilder()

  when: "name is passed"
  def response = rest.post("http://localhost:${serverPort}/contacts"){
    json([
      name: "Joe Cool",
      email: "foo@bar.com"
    ])
  }

  then:
  response.status == 201
  JSONElement json = response.json
  json.firstName == "Joe"
  json.lastName == "Cool"
  }
}
----

And we will setup a concrete implementation of a dao for the contact.
The plugin will recognize that we want to use this base on the naming convention SomeDomainNameDao
In either the the grails-app/services or grails-app/dao directory add the ContactDao.groovy

[source,groovy]
.ContactDao.groovy
----
package resttutorial

import grails.plugin.dao.GormDaoSupport

class ContactDao extends GormDaoSupport {
	Class domainClass = Contact

  @Override
  Map insert(Map params) {
    String name = params.remove("name")
    if(name){
      def (fname, lname) = name.split()
      params.firstName = fname
      params.lastName = lname
    }
    super.insert(params)
  }
}
----

Now you can run tests to be sure that new functionality works, and didn't break old.

=== Snapshot 2 of tutorial app is at this point

=== Implementing a RestDaoController

RestDaoController gives us ability to customise actions using DAOs, but what if we need to specify custom endpoint.

Use Case: A user can not update the inactive field since its bindable false:
Add a new end point so a user can inactivate the contact instead of a delete

Remove the `@Resource` annotation from the contacts domain and add the ContactController.groovy


[source,groovy]
.ContactController.groovy
----
package restapp

class ContactController extends RestDaoController {
    static responseFormats = ['json']

    ContactController() {
        super(Contact)
    }

    def inactivate(Long id) {
      try{
        make this clean and with the pattern we use for others in the RestDaoController
        Map result or entity = dao.inactivate(Long id)
        respond result.entity
      }catch(e){
        set apporpriate status for error
        repond with the errors
      }
    }

}
----

Add logic to the dao

[source,groovy]
----
class ContactDao extends RestDaoController {
    ...

    Contact inactivate(Long id) {
      Contact.get(id) etc....
      return the contact when success
    }
    ....
}
----

Update our rest sanity tests

[source,groovy]
----
```groovy
def "inactivate a contact"(){
  when:
  some rest call inactivate 1
  then:

}
```
----

Update our dao tests

[source,groovy]
----
```groovy
def "inactivate a contact"(){
  when:
  def resp = dao.inactivate(1)
  then:

}
```
----

=== Snapshot 3 of tutorial app is at this point

== Creating the Angular UI

. show how to create a basic CRUD and List screen

Add fields to domain so we can show more of the widgets in angle-grinder

```groovy
import java.time.*

class Contact {
  Salutations salutation
  String firstName
  String lastName
  String email

  String street
  String city
  String state
  String postalCode
  String country

  LocalDate dateOfBirth
  TimeZone timeZone
  LocalDateTime activateOnDate

  Date dateCreated
  Date lastUpdated

  static constraints = {
    firstName nullable: false
    activateOnDate nullable: false
  }

  enum Salutations {
    Ninja,
    Mr,
    Mrs,
    Ms,
    Dr,
    Rev
  }
}
```

=== customize the searching

=== paging

=== Add Contacts
. now add in your examples with Contacts instead of Location
. create tests
. create UI

== Spring Security

Based on this excellent tutorial http://alvarosanchez.github.io/grails-angularjs-springsecurity-workshop/
we can do it like x

=== Adding simple login screen

==== our CRUD screens should still work and be scured now

== Other Tools
=== Using postman for testing
=== Using Intellij for testing




































== example application for tutorail "Grails with REST"

REST (REpresentational State Transfer) is an architectural style that uses HTTP requests to GET, PUT, POST and DELETE data.

Grails provides several nice features to implement REST.

First is resource anotation `@Resource`, that creates controller with basic CRUD operations for you. So when you have next
domain class

[source,groovy]
.Org.groovy
----
@Resource(uri='/orgs', formats=['xml', 'json'])
class Org {
	String name
}
----

using just the @Resource annotation and no controllers, `http://localhost:8080/orgs` will return you a list of all your orgs:

[source,json]
----
/*TODO change this to JSON and lets just stick with JSON thoughout the tutorial*/
<list>
	<org id="1">
		<name>Org_18</name>
	</org>
	<org id="2">
		<name>Org_14</name>
	</org>
</list>
----

and `http://localhost:8080/orgs/3` will return data for Org with id = 3.
//TODO: probably add examples for all CRUD operations
__Note __ It returns xml because it is on the first place for `formats=['xml', 'json']` property, if one changes
to `formats=['json', 'xml']` then JSON will be returned by default. But it accept both format on POST/PUT for example

```
curl -i -X POST -H "Content-Type: application/json" -d '{"name":"New Org Name"}' localhost:8080/orgs
```

will give the same result as

```
curl -i -X POST -H "Content-Type: text/xml" -d '<org><name>New Org Name</name></org>' localhost:8080/orgs
```

The next feature is to handle relations between domains. Let's take a look how we can `Locations` for specific 'Org'.
The first thing that we shall do is to change `UrlMappings.groovy`:

TODO first just use Org as an example go all the way through it.

[source,groovy]
.UrlMappings.groovy
```
class UrlMappings {

    static mappings = {
        "/$controller/$action?/$id?(.$format)?"{
            constraints {
                // apply constraints here
            }
        }

        "/"(view:"/index")
        "500"(view:'/error')
        "404"(view:'/notFound')
        "/orgs"(resources: "org") {
            "/locations"(resources: "location")
        }
    }
}
```
In such a way we show that for url `http://localhost:8080/orgs/1/locations` we want to get locations, but it will show
locations not for Org with id = 1, but all of them, to make it work how we expect we should implement our own RestController.

Here is very basic example for it:
```
class LocationController extends RestfulController {
    static responseFormats = ['json', 'xml']
    LocationController(){
        super(Location)
    }
}
```
So, now we can even remove `@Resource` for Location domain and it will work in the same way.

__Note__ we moved `format` property to controller `static responseFormats = ['json', 'xml']`

The first thing one should understand is that when `http://localhost:8080/orgs/1/locations` is called we call `index`
action with `params = [orgId: 1]` of the LocationController, and not `location` action for `OrgController`, and now
it's clear how controller should be look like:
```
class LocationController extends RestfulController {
    static responseFormats = ['json', 'xml']
    LocationController(){
        super(Location)
    }

    @Override
    protected List listAllResources(Map params) {
        def crit = resource.createCriteria()
        def datalist = crit.list(params) {
            if (params.orgId){
                eq "org.id", params.orgId as Long
            }
        }
        return datalist
    }
}
```
To understand it better I advise to review `RestfulController` https://github.com/grails/grails-core/blob/master/grails-plugin-rest/src/main/groovy/grails/rest/RestfulController.groovy[source]

Sure we can add totally custom action for controller, for example `random`:
First we need to add it to `UrlMappings.groovy`:
```
 "/orgs"(resources: "org") {
            "/locations"(resources: "location")
        }
        "/orgs/random"(controller: "org", action:"random", method: "GET")
        "/locations"(resources: "location")
```
And then add to `OrgController`
```
def random() {
        respond Org.get(new Random().nextInt(Org.count()))
    }
```
Then on `http://localhost:8080/orgs/random` a random `Org` will be returned.

__Note__ to view a list of url mapping use `url-mappings-report` command for grails console, for org it would look like:
```
Controller: org
 |   GET    | /orgs/random               | Action: random
 |   GET    | /orgs/create               | Action: create
 |   GET    | /orgs/${id}/edit           | Action: edit
 |   POST   | /orgs                      | Action: save
 |   GET    | /orgs                      | Action: index
 |  DELETE  | /orgs/${id}                | Action: delete
 |  PATCH   | /orgs/${id}                | Action: patch
 |   PUT    | /orgs/${id}                | Action: update
 |   GET    | /orgs/${id}                | Action: show
```

and

To make the code more DRY let's use https://github.com/9ci/grails-dao[grails-dao] plugin.

Add
```
compile "org.grails.plugin:dao:2.0"
```
to dependencies section of `build.gradle` file.

To apply dao features for all controllers at once we can create new `RestDaoController` which will extend `RestfulController`
TODO you only need to show a link to this, not the entire source

```
abstract class RestDaoController<T> extends RestfulController<T> {
    //Responce formats, json - by default
    static responseFormats = ['json', 'xml']

    RestDaoController(Class<T> domainClass) {
        this(domainClass, false)
    }

    RestDaoController(Class<T> domainClass, boolean readOnly) {
        super(domainClass, readOnly)
    }

    Class getDomainClass() {
        resource
    }

    protected def getDao() {
        resource.dao
    }


    def index(Integer max) {
        params.max = Math.min(max ?: 10, 100)
        respond listAllResources(params), model: [("${resourceName}Count".toString()): countResources()]
    }

    @Override
    protected List<T> listAllResources(Map params) {
        listCriteria(params)
    }

    @Override
    def save() {
        if (handleReadOnly()) {
            return
        }
        def result = insertDomain(request.JSON)
        formatResponse(result.entity)
    }

    @Override
    def update() {
        if (handleReadOnly()) {
            return
        }
        def result = updateDomain(request.JSON)
        formatResponse(result.entity)
    }

    /**
     * Deletes a resource for the given id
     * @param id The id
     */
    def delete() {
        if(handleReadOnly()) {
            return
        }

        def instance = queryForResource(params.id)
        if (instance == null) {
            transactionStatus.setRollbackOnly()
            notFound()
            return
        }

        deleteDomain(params)

        request.withFormat {
            form multipartForm {
                flash.message = message(code: 'default.deleted.message', args: [message(code: "${resourceClassName}.label".toString(), default: resourceClassName), instance.id])
                redirect action:"index", method:"GET"
            }
            '*'{ render status: NO_CONTENT } // NO CONTENT STATUS CODE
        }
    }

    protected def updateDomain(p, opts = null) {
        log.debug "updateDomain with ${p}"
        def res = dao.update(p)
        if (opts?.flush) DaoUtil.flush()
        return res
    }

    protected def formatResponse(def instance) {
        request.withFormat {
            form multipartForm {
                flash.message = message(code: 'default.created.message', args: [message(code: "${resourceName}.label".toString(), default: resourceClassName), instance.id])
                redirect instance
            }
            '*' {
                response.addHeader(HttpHeaders.LOCATION,
                        g.createLink(
                                resource: this.controllerName, action: 'show', id: instance.id, absolute: true,
                                namespace: hasProperty('namespace') ? this.namespace : null))
                respond instance, [status: CREATED]
            }
        }
    }

    /**
     * Called from the saves and saveOrUpdateJson,
     * providing a place to override functionality
     */
    protected def insertDomain(p) {
        log.info("insertDomain(${p})")
        return dao.insert(p)
    }

    protected def deleteDomain(p){
        return dao.remove(p)
    }

    /**
     * returns the list of domain obects for the scaffolded contro
     */
    protected def listCriteria(params) {
        def crit = domainClass.createCriteria()
        def datalist = crit.list(max: params.max, offset: params.offset) {
            if (params.sort)
                order(params.sort, params.order)
        }
        return datalist
    }


}
```
and for Org domain we should add `@Resource(superClass = RestDaoController)`

As a result on `curl -i -X POST -H "Content-Type: application/json" -d '{"name": "test"}' localhost:8080/orgs`
we will get
```
HTTP/1.1 201
X-Application-Context: application:development
Location: http://localhost:8080/org/show/6
Content-Type: application/json;charset=UTF-8
Transfer-Encoding: chunked
Date: Thu, 27 Oct 2016 11:32:52 GMT

{"id":6,"name":"test","registrationDate":null}
```
You can say that it is the same we've had for default `RestfullController`, and on current state it is so. To improve
we need to add `OrgDao.groovy` to dao folder(in grails-app) or to service folder.
```
class OrgDao extends GormDaoSupport{
	Class domainClass = Org

	Map insert(params){
		def madeNameDefault = "default Org"
		if(!params.name){
			params.name = madeNameDefault
		}
		if (params.name){
			params.name += " from Dao"
		}
		super.insert(params)
	}
}
```
After that for `curl -i -X POST -H "Content-Type: application/json" -d '{}' localhost:8080/orgs`, next response will be returned
```
HTTP/1.1 201
X-Application-Context: application:development
Location: http://localhost:8080/org/show/6
Content-Type: application/json;charset=UTF-8
Transfer-Encoding: chunked
Date: Thu, 27 Oct 2016 11:38:57 GMT

{"id":6,"name":"default Org from Dao","registrationDate":null}
```

The next step will be to add UI interface. For this we will use Angle-Grinder plugin.
`compile "nine:angle-grinder:2.0.0"` should be added to `build.gradle`

Due to the fact that Ag-grinder plugin uses not pure angular, but Grails gsp pages to, the right way will be to split
controllers that renders pages and REST Api controllers. And it is really easy to do with help off `RestDaoController` we
just need to add `static namespace = "api"`, and update `UrlMappings.groovy`:
//TODO: design the ways how to make it more DRY
```
"/api/orgs"(resources: "org", namespace:"api") {
    "/locations"(resources: "location", namespace:"api")
}
"/api/locations"(resources: "location", namespace:"api")
```

Also, Ag-Grinder plugin provides nice tools such as pager, so let's update our RestDaoController with pagination for lists:
```
protected def listCriteria(params) {
        def crit = domainClass.createCriteria()
        def pager = new Pager(params)
        def datalist = crit.list(max: pager.max, offset: pager.offset) {
            if (params.sort)
                order(params.sort, params.order)
        }
        return datalist
    }

    protected def pagedList(dlist) {
        def pageData = new Pager(params)
        def fieldList
        if(hasProperty('listFields')){
            fieldList = listFields
        }
        else if(hasProperty('showFields')){
            fieldList = showFields
        }
        else if(hasProperty('selectFields')){
            fieldList = selectFields
        }
        pageData.setupData(dlist, fieldList)
        return pageData
    }
```
So now we can add UI for our app. AG-Grinder designed in the way to have not "One Page" app, but to separate it on a smaller
chunks.
We will have common `app` folder in `assets/javascript` and our small Angular apps there.

We still need a way to render grails templates, so we create "OrgController" that will be responsible for rendering templates
for Org:

```
package tutorial

class OrgController {

    def index() { }

    def template() {
        render template: params.name
    }
}
```

And for JS part we can implement out Resources in the next way:
```
org = angular.module "orgApp", ["angleGrinder"]

org.config [
  "$routeProvider", "ResourceTemplateServ", ($routeProvider, ResourceTemplateServ) ->
    orgTemplate = (path) -> ResourceTemplateServ("/org", path)
    templateUrl = (name) -> "#{orgTemplate("template")}?name=#{name}"

    $routeProvider
      .when "/",
        templateUrl: templateUrl "list"
        controller: "org.ListCtrl"

      .when "/create",
        templateUrl: templateUrl "form"
        controller: "org.FormCtrl"
        resolve: org: ["Resource", (Resource) -> new Resource()]

      .when "/:id",
        templateUrl: templateUrl "show"
        controller: "org.ShowCtrl"
        resolve: org: [
          "$route", "resourceResolver", ($route, resourceResolver) ->
            resourceResolver($route.current.params.id)
        ]

      .when "/:id/edit",
        templateUrl: templateUrl "form"
        controller: "org.FormCtrl"
        resolve: org: [
          "$route", "resourceResolver", ($route, resourceResolver) ->
            resourceResolver($route.current.params.id)
        ]

      .otherwise redirectTo: "/"
]
```

Ag-Grinder has really handy implementation of `Resource` and `ResourceResolver` wich really helps to
keep the code DRY, but by default it is implemented not for REST approach. So I've updated it to make it work with REST too.
To "Turn REST on" one needs to add  `app.constant('RestContext', 'api')` where `'api'` - REST controller namespace. // TODO we can move namespace from grails ctrl and Angular to config

//TODO: not sure do we need step by step instructions for creting angular app

As a Last step let's add Spring security to our app.
Please read http://alvarosanchez.github.io/grails-spring-security-rest/latest/docs/index.html[docs] to understand better
what we need to implement.

First we need to setup Security REST API, just add `compile "org.grails.plugins:spring-security-rest:2.0.0.M2"` in your
`build.graddle`

After that we need to create domain classes (User, Role and UserRole) we can make it by command:
`grails s2-quickstart tutorial User Role`
Where tutorial - package name where classes should be placed

On the output you will get
```
| Creating User class 'User' and Role class 'Role' in package 'tutorial'
| Rendered template Person.groovy.template to destination grails-app/domain/tutorial/User.groovy
| Rendered template Authority.groovy.template to destination grails-app/domain/tutorial/Role.groovy
| Rendered template PersonAuthority.groovy.template to destination grails-app/domain/tutorial/UserRole.groovy
|
************************************************************
* Created security-related domain classes. Your            *
* grails-app/conf/application.groovy has been updated with *
* the class names of the configured domain classes;        *
* please verify that the values are correct.               *
************************************************************
```

The executed command will also update `grails-app/conf/application.groovy` or create it if you didn't have it.

We need to replace the chain with pattern /** with the next one:

```
[pattern: '/api/**',  filters: 'JOINED_FILTERS,-anonymousAuthenticationFilter,-exceptionTranslationFilter,-authenticationProcessingFilter,-securityContextPersistenceFilter,-rememberMeAuthenticationFilter']
```

For testing add to `Bootstrap.groovy`
```
Role admin = new Role("ROLE_ADMIN").save()
User user = new User("user", "pass").save()
UserRole.create(user, admin, true)
```
To restrict the API to be accessed only for ROLE_ADMIN users:
```
@Secured(['ROLE_ADMIN'])
class OrgController extends RestDaoController {

    OrgController(){
        super(Org)
    }
}
```

Now when you try to get data from Api you'll get
```
curl -i -X GET -H "Content-Type: application/json"  localhost:8080/api/orgs
HTTP/1.1 401
WWW-Authenticate: Bearer
Content-Type: application/json;charset=UTF-8
Transfer-Encoding: chunked
Date: Fri, 28 Oct 2016 15:01:30 GMT

{"timestamp":1477666890707,"status":401,"error":"Unauthorized","message":"No message available","path":"/api/orgs"}
```
To get a token we need:
```
curl -i -H "Content-Type: e":"user","password":"pass"}' localhost:8080/api/login
HTTP/1.1 200
Cache-Control: no-store
Pragma: no-cache
Content-Type: application/json;charset=UTF-8
Content-Length: 2144
Date: Fri, 28 Oct 2016 15:03:08 GMT

{"username":"user","roles":["ROLE_ADMIN"],"token_type":"Bearer","access_token":"eyJhbGciOiJIUzI1NiJ9..
```
And to get accsess to our Api we need to pass token as header with our request.

So now we should implement frontend part.
The approach is to create `LoginCtrl` which will be parent for all of the others controllers.
```
class LoginCtrl
  @$inject = ["$scope", "pathWithContext", "$window", "$http", "$rootScope"]
  constructor: ($scope, pathWithContext, $window, $http, $rootScope) ->
    $rootScope.authenticated = $window.sessionStorage.token?
    $scope.user ={}
    $scope.login = ->
      $http.post((pathWithContext '/api/login'), {username: $scope.user.username,password: $scope.user.password}).then (response)->
        $rootScope.authenticated = true
        $window.sessionStorage.token = response.data.access_token
        $window.location = pathWithContext "/org"

    $scope.logout = ->
      $window.sessionStorage.token = undefined


auth.controller("LoginCtrl", LoginCtrl)
```

To add a header for each request we will add an Interseptor:
```
auth.factory('authInterceptor', ($rootScope, $window) ->
  { request: (config) ->
    config.headers = config.headers or {}
    if $window.sessionStorage.token?
      config.headers.Authorization = 'Bearer ' + $window.sessionStorage.token
    config
  }
).config ($httpProvider) ->
  $httpProvider.interceptors.push 'authInterceptor'
  return
```

And in layout:
```
<div ng-if="authenticated == true">
        <div id="page" class="container">
            <g:layoutBody/>
        </div>
    </div>
    <div ng-if="authenticated == false">
        <table>
            <tbody>
            <tr>
                <td>
                    Username:
                </td>
                <td>
                    <input type="text" name="username" ng-model="user.username" />
                </td>
            </tr>
            <tr>
                <td>
                    Password:
                </td>
                <td>
                    <input type="password" name="password" ng-model="user.password" />
                </td>
            </tr>
            <tr>
                <td colspan="2">
                    <button type="button" ng-click="login()">Login</button>
                </td>
            </tr>
            </tbody>
        </table>
    </div>
</div>
```
