(function($) {
    "use strict";
    var loadImage = function(file, callback, options) {
        var img = document.createElement("img"), url, oUrl;
        img.onerror = callback;
        img.onload = function() {
            if (oUrl && !(options && options.noRevoke)) {
                loadImage.revokeObjectURL(oUrl);
            }
            if (callback) {
                callback(loadImage.scale(img, options));
            }
        };
        if (loadImage.isInstanceOf("Blob", file) || loadImage.isInstanceOf("File", file)) {
            url = oUrl = loadImage.createObjectURL(file);
            img._type = file.type;
        } else if (typeof file === "string") {
            url = file;
            if (options && options.crossOrigin) {
                img.crossOrigin = options.crossOrigin;
            }
        } else {
            return false;
        }
        if (url) {
            img.src = url;
            return img;
        }
        return loadImage.readFile(file, function(e) {
            var target = e.target;
            if (target && target.result) {
                img.src = target.result;
            } else {
                if (callback) {
                    callback(e);
                }
            }
        });
    }, urlAPI = window.createObjectURL && window || window.URL && URL.revokeObjectURL && URL || window.webkitURL && webkitURL;
    loadImage.isInstanceOf = function(type, obj) {
        return Object.prototype.toString.call(obj) === "[object " + type + "]";
    };
    loadImage.transformCoordinates = function() {
        return;
    };
    loadImage.getTransformedOptions = function(options) {
        return options;
    };
    loadImage.renderImageToCanvas = function(canvas, img, sourceX, sourceY, sourceWidth, sourceHeight, destX, destY, destWidth, destHeight) {
        canvas.getContext("2d").drawImage(img, sourceX, sourceY, sourceWidth, sourceHeight, destX, destY, destWidth, destHeight);
        return canvas;
    };
    loadImage.hasCanvasOption = function(options) {
        return options.canvas || options.crop;
    };
    loadImage.scale = function(img, options) {
        options = options || {};
        var canvas = document.createElement("canvas"), useCanvas = img.getContext || loadImage.hasCanvasOption(options) && canvas.getContext, width = img.naturalWidth || img.width, height = img.naturalHeight || img.height, destWidth = width, destHeight = height, maxWidth, maxHeight, minWidth, minHeight, sourceWidth, sourceHeight, sourceX, sourceY, tmp, scaleUp = function() {
            var scale = Math.max((minWidth || destWidth) / destWidth, (minHeight || destHeight) / destHeight);
            if (scale > 1) {
                destWidth = destWidth * scale;
                destHeight = destHeight * scale;
            }
        }, scaleDown = function() {
            var scale = Math.min((maxWidth || destWidth) / destWidth, (maxHeight || destHeight) / destHeight);
            if (scale < 1) {
                destWidth = destWidth * scale;
                destHeight = destHeight * scale;
            }
        };
        if (useCanvas) {
            options = loadImage.getTransformedOptions(options);
            sourceX = options.left || 0;
            sourceY = options.top || 0;
            if (options.sourceWidth) {
                sourceWidth = options.sourceWidth;
                if (options.right !== undefined && options.left === undefined) {
                    sourceX = width - sourceWidth - options.right;
                }
            } else {
                sourceWidth = width - sourceX - (options.right || 0);
            }
            if (options.sourceHeight) {
                sourceHeight = options.sourceHeight;
                if (options.bottom !== undefined && options.top === undefined) {
                    sourceY = height - sourceHeight - options.bottom;
                }
            } else {
                sourceHeight = height - sourceY - (options.bottom || 0);
            }
            destWidth = sourceWidth;
            destHeight = sourceHeight;
        }
        maxWidth = options.maxWidth;
        maxHeight = options.maxHeight;
        minWidth = options.minWidth;
        minHeight = options.minHeight;
        if (useCanvas && maxWidth && maxHeight && options.crop) {
            destWidth = maxWidth;
            destHeight = maxHeight;
            tmp = sourceWidth / sourceHeight - maxWidth / maxHeight;
            if (tmp < 0) {
                sourceHeight = maxHeight * sourceWidth / maxWidth;
                if (options.top === undefined && options.bottom === undefined) {
                    sourceY = (height - sourceHeight) / 2;
                }
            } else if (tmp > 0) {
                sourceWidth = maxWidth * sourceHeight / maxHeight;
                if (options.left === undefined && options.right === undefined) {
                    sourceX = (width - sourceWidth) / 2;
                }
            }
        } else {
            if (options.contain || options.cover) {
                minWidth = maxWidth = maxWidth || minWidth;
                minHeight = maxHeight = maxHeight || minHeight;
            }
            if (options.cover) {
                scaleDown();
                scaleUp();
            } else {
                scaleUp();
                scaleDown();
            }
        }
        if (useCanvas) {
            canvas.width = destWidth;
            canvas.height = destHeight;
            loadImage.transformCoordinates(canvas, options);
            return loadImage.renderImageToCanvas(canvas, img, sourceX, sourceY, sourceWidth, sourceHeight, 0, 0, destWidth, destHeight);
        }
        img.width = destWidth;
        img.height = destHeight;
        return img;
    };
    loadImage.createObjectURL = function(file) {
        return urlAPI ? urlAPI.createObjectURL(file) : false;
    };
    loadImage.revokeObjectURL = function(url) {
        return urlAPI ? urlAPI.revokeObjectURL(url) : false;
    };
    loadImage.readFile = function(file, callback, method) {
        if (window.FileReader) {
            var fileReader = new FileReader();
            fileReader.onload = fileReader.onerror = callback;
            method = method || "readAsDataURL";
            if (fileReader[method]) {
                fileReader[method](file);
                return fileReader;
            }
        }
        return false;
    };
    if (typeof define === "function" && define.amd) {
        define(function() {
            return loadImage;
        });
    } else {
        $.loadImage = loadImage;
    }
})(this);

(function(factory) {
    "use strict";
    if (typeof define === "function" && define.amd) {
        define([ "load-image" ], factory);
    } else {
        factory(window.loadImage);
    }
})(function(loadImage) {
    "use strict";
    var hasblobSlice = window.Blob && (Blob.prototype.slice || Blob.prototype.webkitSlice || Blob.prototype.mozSlice);
    loadImage.blobSlice = hasblobSlice && function() {
        var slice = this.slice || this.webkitSlice || this.mozSlice;
        return slice.apply(this, arguments);
    };
    loadImage.metaDataParsers = {
        "jpeg": {
            "65505": []
        }
    };
    loadImage.parseMetaData = function(file, callback, options) {
        options = options || {};
        var that = this, maxMetaDataSize = options.maxMetaDataSize || 262144, data = {}, noMetaData = !(window.DataView && file && file.size >= 12 && file.type === "image/jpeg" && loadImage.blobSlice);
        if (noMetaData || !loadImage.readFile(loadImage.blobSlice.call(file, 0, maxMetaDataSize), function(e) {
            if (e.target.error) {
                console.log(e.target.error);
                callback(data);
                return;
            }
            var buffer = e.target.result, dataView = new DataView(buffer), offset = 2, maxOffset = dataView.byteLength - 4, headLength = offset, markerBytes, markerLength, parsers, i;
            if (dataView.getUint16(0) === 65496) {
                while (offset < maxOffset) {
                    markerBytes = dataView.getUint16(offset);
                    if (markerBytes >= 65504 && markerBytes <= 65519 || markerBytes === 65534) {
                        markerLength = dataView.getUint16(offset + 2) + 2;
                        if (offset + markerLength > dataView.byteLength) {
                            console.log("Invalid meta data: Invalid segment size.");
                            break;
                        }
                        parsers = loadImage.metaDataParsers.jpeg[markerBytes];
                        if (parsers) {
                            for (i = 0; i < parsers.length; i += 1) {
                                parsers[i].call(that, dataView, offset, markerLength, data, options);
                            }
                        }
                        offset += markerLength;
                        headLength = offset;
                    } else {
                        break;
                    }
                }
                if (!options.disableImageHead && headLength > 6) {
                    if (buffer.slice) {
                        data.imageHead = buffer.slice(0, headLength);
                    } else {
                        data.imageHead = new Uint8Array(buffer).subarray(0, headLength);
                    }
                }
            } else {
                console.log("Invalid JPEG file: Missing JPEG marker.");
            }
            callback(data);
        }, "readAsArrayBuffer")) {
            callback(data);
        }
    };
});